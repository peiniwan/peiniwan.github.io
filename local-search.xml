<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6.AsyncTask</title>
    <link href="/2025/12/e01ee5fe9518.html"/>
    <url>/2025/12/e01ee5fe9518.html</url>
    
    <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>AsyncTask的特点是<em>任务在主线程之外运行，而回调方法是在主线程中执行</em>，AsyncTask其实使用handler来实现异步任务的，它是一个抽象类，AsyncTask的execute在主线程中首先调用了onPreExecute做预备工作，在子线程中调用了doInBackground方法去做耗时操作，返回的数据通过Message.obtain(handler, ON_POST_MSG, result).sendToTarget()发送在主线程里</li><li>handle的handleMessage方法调用了onPostExecute，更新ui</li><li>AsyncTask定义了三种泛型类型 Params，Progress和Result。 Params 启动任务执行的输入参数，比如HTTP请求的URL。 Progress 后台任务执行的百分比。 Result 后台执行任务最终返回的结果，比如String。 子类必须实现抽象方法doInBackground(Params… p) ，在此方法中实现任务的执行工作，比如连接网络获取数据等。通常还应 该实现onPostExecute(Result r)方法，因为应用程序关心的结果在此方法中返回。需要注意的是AsyncTask一定要在主线程中创 建实例。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAsynTask</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ON_POST_MSG</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> MyHandler handler;<br><br><br>    <span class="hljs-comment">// 运行在主线程中，做准备工作</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPreExecute</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 运行在子线程中，做耗时操作</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">doInBackground</span><span class="hljs-params">(String s)</span>;<br><br>    <span class="hljs-comment">// 运行在主线程中，耗时操作完成，更新ui</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPostExecute</span><span class="hljs-params">(String s)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAsynTask</span><span class="hljs-params">()</span> &#123;<br>        handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHandler</span>();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String... strs)</span> &#123; <br>        onPreExecute();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> doInBackground(strs[<span class="hljs-number">0</span>]);<br>                Message.obtain(handler, ON_POST_MSG, result).sendToTarget();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> ON_POST_MSG:<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) msg.obj;<br>                onPostExecute(result);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">super</span>.handleMessage(msg);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>MainActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAsynTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPreExecute</span><span class="hljs-params">()</span> &#123;<br>                printLog(<span class="hljs-string">&quot;我在做准备操作&quot;</span>);<br>                Toast.makeText(getApplication(), <span class="hljs-string">&quot;我在做准备操作&quot;</span>, <span class="hljs-number">0</span>).show();<br>            &#125;<br><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPostExecute</span><span class="hljs-params">(String s)</span> &#123;<br>                printLog(<span class="hljs-string">&quot;我接收到了结果：&quot;</span> + s);<br>                Toast.makeText(getApplication(), <span class="hljs-string">&quot;我接收到了结果&quot;</span>, <span class="hljs-number">0</span>).show();<br>            &#125;<br><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">doInBackground</span><span class="hljs-params">(String s)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                printLog(<span class="hljs-string">&quot;我在访问网络,参数是：&quot;</span> + s);<br>                <span class="hljs-keyword">return</span> s + <span class="hljs-string">&quot;返回&quot;</span>;<br>            &#125;<br>        &#125;.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span> &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLog</span><span class="hljs-params">(String log)</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:说:&quot;</span> + log);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="AsyncTask的优缺点"><a href="#AsyncTask的优缺点" class="headerlink" title="AsyncTask的优缺点"></a>AsyncTask的优缺点</h4><p>使用的优点:简单、快捷、过程可控      <br>使用的缺点:</p><ul><li>AsyncTask的缺陷:可以分为两个部分说，在3.0以前，最大支持128个线程的并发，每次开启10个，5个同时运行，当开第129就会奔溃。在3.0以后，无论有多少任务，<em>都会在其内部单线程执行</em>。在执行多个异步操作时，一个运行其他的就得等待，需要自己开启线程池，比较麻烦，</li><li>每次当一个任务执行完毕后，下一个任务才会得到执行，SerialExecutor模仿的是单一线程池的效果，如果我们快速地启动了很多任务，同一时刻只会有一个线程正在执行，其余的均处于等待状态。</li><li>在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来.</li><li>AsynTask为什么要设计为只能够一次任务？最核心的还是线程安全问题，多个子线程同时运行，会产生状态不一致的问题。所以要务必保证只能够执行一次<br>  <strong>新版不对</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">2</span>,  Math.min(CPU_COUNT - <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">//最大2</span><br><br><span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,<br>                sPoolWorkQueue, sThreadFactory);<br>        threadPoolExecutor.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>        THREAD_POOL_EXECUTOR = threadPoolExecutor;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>Handler的优缺点<br>使用的优点：<br>结构清晰，功能定义明确<br>对于多个后台任务时，简单，清晰<br>使用的缺点：<br>在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p><strong>SerialExecutor模仿的是单一线程池的效果，如果我们快速地启动了很多任务，同一时刻只会有一个线程正在执行，其余的均处于等待状态</strong>。</p><p>那么假设一下,如果用户开启某个页面,而此页面有Task在执行,再打开另外一个页面,这个页面还有Task需要执行,这个时候很可能会出现卡一个的情况,不是硬件配置差,而是软件质量差导致的~那么如何修复呢?</p><p>解决： <strong>cancel + isCancelled ,强烈推荐</strong><br>真正决定任务取消的是需要手动调用isCancelled方法check task状态,因此推荐的修复方案是在手动调用cancel方法的同时,能调用inCancelled方法检测task状态:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Override  <br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">Integer</span> doInBackground(<span class="hljs-literal">Void</span><span class="hljs-params">...</span> mgs) &#123;  <br><span class="hljs-comment">// Task被取消了，马上退出  </span><br><span class="hljs-keyword">if</span>(isCancelled()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">null</span>;  <br><span class="hljs-params">...</span><span class="hljs-params">...</span>.  <br><span class="hljs-comment">// Task被取消了，马上退出</span><br><br><span class="hljs-keyword">if</span>(isCancelled()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">null</span>;  <br>&#125;  <br><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p><strong>2:建议在修复方案1的基础上将AsyncTask作为静态内部类存在(与Handler处理方式相似),避免内部类的this$0持有外部类的引用</strong></p><p><strong>但不推荐只修改AsyncTask为静态内部类的方案,虽然不是泄露了,但没有根本上解决问题~</strong></p><p><strong>3:如果AsyncTask中需要使用Context,建议使用weakreference</strong></p><p>4:如果确实需要做相对耗时的操作,建议用service去做,而不要用AsyncTask,推荐</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.ThreadLocal</title>
    <link href="/2025/12/ddf77f0e17a8.html"/>
    <url>/2025/12/ddf77f0e17a8.html</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>默认成员变量是共享的</strong></p><ul><li><p>ThreadLocal 是一种以空间换时间的做法，在每个 Thread 里面维护了一个 ThreadLocalMap</p></li><li><p><strong>Map 和 Thread 绑定，所以虽然访问的是同一个 ThreadLocal 对象，但是访问的 Map 却不是同一个，所以取得值也不一样。</strong></p></li><li><p>也不会影响其他线程。在这个线程是独享的，也没有线程安全方面的问题。</p></li><li><p>用途：通过它可以在指定的线程里存储数据，数据存储以后，只有在指定的线程中可以获取存储的数据，对于其他线程说则无法获取到数据。</p></li><li><p>先是获取当前线程对象, 然后从当前线程中获取线程的 Thread LocalMap, 值是添加到这个 ThreadLocalMap 中的, key 就是当前 Threadlocal 的对象。从使用的 AP 看上去像是把值存储在了 Threadlocal 中, 其实值是存储在线程内部, 然后关联了对应的 ThreadLocal, 这样通过 ThreadLocal. get 时就能获取到对应的值。</p></li><li><p>很明显这种做法更科学，这也就是 ThreadLocal 的做法，因为铅笔（数据）本身就是同学（thread）自己在用，所以一开始就把铅笔交给同学自己保管是最好的，每个同学之间进行隔离。</p></li></ul><h2 id="说明一"><a href="#说明一" class="headerlink" title="说明一"></a>说明一</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.resources/2023/09/15/17-54-50-f72547b88900383d14234931b69e6610-unknown_filename.3-5f00f5.png" alt="unknown_filename.3|800"></p><h2 id="说明二"><a href="#说明二" class="headerlink" title="说明二"></a>说明二</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.resources/2023/09/15/17-54-50-3616a9baa0fedd0ec53ae5ef2db1dbbc-unknown_filename.4-05cc07.png" alt="unknown_filename.4|800"></p><h2 id="在-Android-中的应用"><a href="#在-Android-中的应用" class="headerlink" title="在 Android 中的应用"></a>在 Android 中的应用</h2><ul><li>messengeQueue-Looper 模型中，我们平常直接在 UI 线程中 new Handler ()就可以了，里面就是 mainLooper，但是 Android 怎么确定的 UIx 线程中 new Handler ()里面是 mainLooper 呢，答案就是通过将 Looper 作为 ThreadLocal 变量。</li><li>Choreographer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Choreographer</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =  <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;  <br>                <span class="hljs-meta">@Override</span>  <br>                <span class="hljs-keyword">protected</span> Choreographer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>                    <span class="hljs-type">Looper</span> <span class="hljs-variable">looper</span> <span class="hljs-operator">=</span> Looper.myLooper();  <br>                    <span class="hljs-keyword">if</span> (looper == <span class="hljs-literal">null</span>) &#123;  <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The current thread must have a looper!&quot;</span>);  <br>                    &#125;  <br>                    <span class="hljs-type">Choreographer</span> <span class="hljs-variable">choreographer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);  <br>                    <span class="hljs-keyword">if</span> (looper == Looper.getMainLooper()) &#123;  <br>                        mMainInstance = choreographer;  <br>                    &#125;  <br>                    <span class="hljs-keyword">return</span> choreographer;  <br>                &#125;  <br>            &#125;;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Choreographer mMainInstance;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>Choreographer 主要是主线程用的，用于配合 VSYNC 中断信号。<br>所以这里使用 ThreadLocal 更多的意义在于完成线程单例的功能。</p><h2 id="手写-ThreadLocal"><a href="#手写-ThreadLocal" class="headerlink" title="手写 ThreadLocal"></a>手写 ThreadLocal</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadLoacl</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-comment">// 存放变量副本的map容器，以 Thread 为 key，变量副本为 value</span><br>    <span class="hljs-keyword">private</span> Map&lt;Thread, T&gt; theadMap = <span class="hljs-keyword">new</span> HashMap&lt;Thread, T&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> syncorhized T <span class="hljs-title">get</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> theadMap.<span class="hljs-keyword">get</span>(Thread.currentThread());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synchroized <span class="hljs-title">set</span>(<span class="hljs-params">T t</span>)</span> &#123;<br>        theadMap.<span class="hljs-keyword">set</span>(Thread.currentThread(), t);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://juejin.cn/post/6958991265933295624">【源码篇】ThreadLocal的奇思妙想（万字图文） - 掘金</a></p><p><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">理解Java中的ThreadLocal - 技术小黑屋</a></p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.IdleHandler</title>
    <link href="/2025/12/66ad799b2a01.html"/>
    <url>/2025/12/66ad799b2a01.html</url>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>当 MessageQueue 没有消息的时候，就会阻塞在 next 方法中，其实在<em>阻塞之前，MessageQueue 还会做一件事，就是检查是否存在 IdleHandler，如果有，就会去执行它的 queueIdle</em> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> IdleHandler[] mPendingIdleHandlers;  <br>    Message <span class="hljs-title function_">next</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span> (; ; ) &#123;  <br>            ......<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br><span class="hljs-comment">//当消息执行完毕，就设置 pendingIdleHandlerCount  </span><br>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span>  <br>                        &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages. when)) &#123;  <br>                    pendingIdleHandlerCount = mIdleHandlers.size ();  <br>                &#125;  <br><span class="hljs-comment">//初始化 mPendingIdleHandlers  </span><br>                <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;  <br>                    mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max (pendingIdleHandlerCount, <span class="hljs-number">4</span>)];  <br>                &#125;  <br><span class="hljs-comment">//mIdleHandlers 转为数组  </span><br>                mPendingIdleHandlers = mIdleHandlers.toArray (mPendingIdleHandlers);  <br>            &#125;  <br>  <br><span class="hljs-comment">// 遍历数组，处理每个 IdleHandler  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;  <br>                <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];  <br>                mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler  </span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    keep = idler.queueIdle ();  <br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;  <br>                    Log.wtf (TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);  <br>                &#125;  <br>  <br><span class="hljs-comment">//如果 queueIdle 方法返回 false，则处理完就删除这个 IdleHandler  </span><br>                <span class="hljs-keyword">if</span> (! keep) &#123;  <br>                    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                        mIdleHandlers.remove (idler);  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br><span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.  </span><br>            pendingIdleHandlerCount = <span class="hljs-number">0</span>;  <br>        &#125;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>当没有消息处理的时候，就会去处理这个 mIdleHandlers 集合里面的每个 IdleHandler 对象，并调用其 queueIdle 方法。最后根据 queueIdle 返回值判断是否用完删除当前的 IdleHandler。</p><p>然后看看 IdleHandler 是怎么加进去的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Looper.myQueue (). addIdleHandler (<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span> () &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span> <span class="hljs-params">()</span> &#123;  <br><span class="hljs-comment">//做事情  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        &#125;  <br>    &#125;);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addIdleHandler</span> <span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span> (<span class="hljs-string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>            mIdleHandlers.add (handler);  <br>        &#125;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>ok，综上所述，IdleHandler 就是当消息队列里面没有当前要处理的消息了，需要堵塞之前，可以做一些空闲任务的处理。</p><h2 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h2><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>GcIdler 方法理解起来很简单、就是获取上次 GC 的时间，判断是否需要 GC 操作。如果需要则进行 GC 操作。</p><p>何时会收到 GC_WHEN_IDLE 消息？当 AMS(ActivityManagerService) 中的这两个方法被调用之后：</p><ul><li>doLowMemReportIfNeededLocked，这个方法看名字就知道是不够内存的时候调用的了，内存不足时，强行 GC</li><li>当 ActivityThread 的 handleResumeActivity 方法被调用时。</li></ul><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h3><p>[[3-Activity 生命周期#为什么 Activity.finish() 之后 10s 才 onDestroy ？]]</p><p> onResume 方法执行完，界面已经显示这些更重要的事情已经处理完了，空闲的时候开始处理这些事情。也就是说系统的设计逻辑是保障最重要的逻辑先执行完，再去处理其他次要的事情。</p><p>但是如果 MessageQueue 队列中一直有消息，那么 IdleHandler 就一直没有机会被执行，那么原本该销毁的界面的 onStop，onDestory 就得不到执行吗？<br>不是这样的，在 resumeTopActivityInnerLocked () -&gt; completeResumeLocked () -&gt; scheduleIdleTimeoutLocked () 方法中会发送一个会发送一个延迟消息（10s），如果界面很久没有关闭，耗时 (如果界面需要关闭)，那么 10s 后该消息被触发就会关闭界面，执行 onStop 等方法。</p><h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h2><p><strong>LeakCanary</strong><br> ensureGone () 中会进行 GC 回收和一些分析等操作，所以通过这些分析后，<strong>我们可以知道 LeakCanary 进行内存泄漏检测并不是 onDestry 方法执行完成后就进行垃圾回收和一些分析的，而是利用 IdleHandler 在空闲的时候进行这些操作的，尽量不去影响主线程的操作</strong>。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>常见的使用场景有：启动优化。</p><p>我们一般会把一些事件（比如界面 view 的绘制、赋值）放到 onCreate 方法或者 onResume 方法中。但是这两个方法其实都是在界面绘制之前调用的，也就是说一定程度上这两个方法的耗时会影响到启动时间。</p><p>所以我们可以把一些操作放到 IdleHandler 中，也就是界面绘制完成之后才去调用，这样就能减少启动时间了。</p><p>但是，这里需要注意下可能会有坑。<em>可以用，如果没执行，需要优化代码</em></p><p>如果使用不当，IdleHandler 会一直不执行，比如在 View 的 onDraw 方法里面无限制的直接或者间接调用 View 的 invalidate 方法。</p><p>其原因就在于 <em>onDraw 方法中执行 invalidate</em>，会添加一个同步屏障消息，在等到异步消息之前，会阻塞在 next 方法，而等到 FrameDisplayEventReceiver 异步任务之后又会执行 onDraw 方法，从而无限循环。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0/%E6%89%93%E7%A0%B4Handler%E9%97%AE%E5%88%B0%E5%BA%95.resources/2023/09/15/18-19-06-cbb6dd3234c97851d86a78dc1596942e-F332FEFC-81FE-466B-8716-67CF7A1A846B-f9fa57.png" alt="F332FEFC-81FE-466B-8716-67CF7A1A846B.png|900"></p><p>其他使用场景：</p><ul><li>想要在一个 View 绘制完成之后添加其他依赖于这个 View 的 View，当然这个用 View # post () 也能实现，区别就是前者会在消息队列空闲时执行</li><li>发送一个返回 true 的 IdleHandler，在里面让某个 View 不停闪烁，这样当用户发呆时就可以诱导用户点击这个 View，这也是种很酷的操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.Handler 里的各种消息</title>
    <link href="/2025/12/bfe220353bca.html"/>
    <url>/2025/12/bfe220353bca.html</url>
    
    <content type="html"><![CDATA[<h2 id="同步屏障和异步消息"><a href="#同步屏障和异步消息" class="headerlink" title="同步屏障和异步消息"></a>同步屏障和异步消息</h2><p>其实在 Handler 机制中，有三种消息类型：</p><ul><li>同步消息。也就是普通的消息。</li><li>异步消息。通过 setAsynchronous (true) 设置的消息。</li><li>同步屏障消息。通过 postSyncBarrier 方法添加的消息，<em>特点是 target 为空</em>，也就是没有对应的 handler。也是通过屏障的时间，确定屏障消息插入的位置<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161425009.png" alt="Pasted image 20250820142310"></li></ul><p>这三者之间的关系如何呢？</p><ul><li>正常情况下，同步消息和异步消息都是正常被处理，也就是根据时间 when 来取消息，处理消息。</li><li>如果当前消息是一个同步屏障，那么就会从当前消息之后的消息开始寻找，并将找到的下一个异步消息赋给 msg，直到找到异步消息或遍历完整个消息队列。</li></ul><p>取消息，next () 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br><span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">do</span> &#123;<br>prevMsg = msg;<br>msg = msg.next;<br>&#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说同步屏障消息不会被返回，他只是一个标志，一个工具，遇到它就代表要去先行处理异步消息了，提高优先级。<br>所以同步屏障和异步消息的存在的意义就在于有些消息需要“<em>加急处理</em>”。<br>同步障碍会阻碍同步消息，只允许通过异步消息</p><h2 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h2><p><strong>Choreographer 本质上是 Android 的“帧调度器”。</strong></p><p>它的作用是：<br><strong>在每一次屏幕刷新（VSYNC）到来时，统一调度一帧中必须完成的三件事——输入、动画、绘制，保证 UI 和屏幕刷新节奏严格同步，避免掉帧。</strong></p><p>它解决的核心问题<br>手机屏幕是按固定频率刷新的（比如 60Hz &#x2F; 120Hz），<br>而 App 的 UI 更新如果不和这个节奏对齐，就会出现：</p><ul><li>一帧画不完 → 掉帧</li><li>多次无意义绘制 → 浪费性能</li><li>动画和触摸不同步 → 卡顿、抖动</li></ul><p><strong>Choreographer 就是用来“对齐 App 和屏幕节奏”的。</strong></p><p>它是怎么工作的</p><blockquote><p><strong>每次 VSYNC 到来，Choreographer 就会触发一次 UI 帧回调，按顺序执行输入 → 动画 → 绘制，然后把这一帧准时提交给屏幕。</strong></p></blockquote><p>它在一帧里主要干三件事（重点）</p><ol><li><p><strong>处理输入（Input）</strong></p><ul><li>比如触摸、滑动事件</li></ul></li><li><p><strong>执行动画（Animation）</strong></p><ul><li>属性动画、View 动画的进度计算</li></ul></li><li><p><strong>绘制 UI（Traversal &#x2F; Draw）</strong></p><ul><li>measure → layout → draw<br>👉 <strong>一帧中只有这三类事情，且顺序是固定的。</strong></li></ul></li></ol><p>和开发者最直接的关系</p><ul><li>当你调用 <code>View.invalidate()</code> &#x2F; <code>requestLayout()</code> 时</li><li>并不会立刻绘制</li><li>而是告诉 Choreographer：<br>  <strong>“下一个 VSYNC 来了记得叫我画一帧”</strong></li></ul><p>所以：</p><blockquote><p>UI 更新永远是“等 VSYNC 再统一执行”，而不是随调随画。</p></blockquote><p>为什么会掉帧<br>在 60Hz 屏幕下，一帧只有 <strong>16.6ms</strong>：</p><ul><li>如果你在这一帧里：<ul><li>做了重计算</li><li>主线程 IO     </li><li>复杂布局</li></ul></li><li>导致三件事没在 16.6ms 内完成<br>👉 <strong>Choreographer 就会错过这个 VSYNC，直接掉一帧。</strong></li></ul><p>监听掉帧卡顿是否流畅，看两帧之间的时间间隔（即<strong>每帧的实际耗时</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Choreographer</span>.FrameCallback &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">mLastFrameTimeNanos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrame</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTimeNanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mLastFrameTimeNanos != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">frameCostMs</span> <span class="hljs-operator">=</span> (frameTimeNanos - mLastFrameTimeNanos) / <span class="hljs-number">1_000_000</span>;<br>            <span class="hljs-keyword">if</span> (frameCostMs &gt; <span class="hljs-number">16</span>) &#123;<br>                Log.w(<span class="hljs-string">&quot;FrameMonitor&quot;</span>, <span class="hljs-string">&quot;一帧耗时: &quot;</span> + frameCostMs + <span class="hljs-string">&quot;ms， 已掉帧！&quot;</span>);<br>            &#125;<br>        &#125;<br>        mLastFrameTimeNanos = frameTimeNanos;<br>        Choreographer.getInstance().postFrameCallback(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 继续监听下一帧</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 启动监听: Choreographer.getInstance().postFrameCallback(new FrameMonitor());</span><br></code></pre></td></tr></table></figure><p>Handler 包装 dispatchMessage<br>能帮助定位原因：是因为处理这个消息花了太长时间，导致了卡顿。</p><p><strong>Choreographer 调度一帧的流程</strong> 👇</p><ol><li><strong>Vsync 信号到来</strong> → Choreographer 收到回调，开始这一帧。</li><li><strong>Input Handling</strong> → 处理输入事件（触摸&#x2F;按键）。</li><li><strong>Animation</strong> → 执行动画数值更新。</li><li><strong>Measure&#x2F;Layout&#x2F;Draw</strong> → 视图树测量、布局、绘制。</li><li><strong>Render</strong> → 把绘制结果提交给 GPU。</li><li><strong>Display</strong> → SurfaceFlinger 合成并最终显示到屏幕。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161425010.png" alt="Pasted image 20250820153519"></li></ol><h2 id="同步屏障和异步消息的使用场景"><a href="#同步屏障和异步消息的使用场景" class="headerlink" title="同步屏障和异步消息的使用场景"></a>同步屏障和异步消息的使用场景</h2><p>系统把插入屏障和构造异步 Handler 这些东西标记为 @UnsupportedAppUsage，意思就是<em>这些 API 是系统自己用的，不想让开发者调用</em>。那系统是什么时候用的呢？</p><p>View 绘制的起点是 ViewRootImpl 的 requestLayout () 开始的，这个方法会去执行上面的三大绘制任务：测量、布局、绘制。调用 requestLayout () 方法之后，<em>并不会马上开始进行绘制任务，而是会给主线程设置一个同步屏幕</em>，并设置 Vsync 信号监听。当 Vsync 信号的到来，会发送一个异步消息到主线程 Handler，执行我们上一步设置的绘制监听任务，并移除同步屏障。</p><p>requestLayout 调用 scheduleTraversals<br>绘制方法 scheduleTraversals，刷新帧率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTraversals</span><span class="hljs-params">()</span> &#123;  <br>      <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;  <br>          mTraversalScheduled = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// 同步屏障，阻塞所有的同步消息  </span><br>          mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();  <br><span class="hljs-comment">//监听Vsync信号，然后发送异步消息 -&gt; 执行绘制任务</span><br>          mChoreographer.postCallback(  <br>                  Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);  <br>      &#125;  <br>  &#125;  <br><br></code></pre></td></tr></table></figure><p>postCallback 方法里执行  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);  <br>msg.arg1 =callbackType;  <br>msg.setAsynchronous(<span class="hljs-literal">true</span>);  <br>mHandler.sendMessageAtTime(msg,dueTime);<br></code></pre></td></tr></table></figure><p>在该方法中加入了同步屏障，后续加入一个异步消息 MSG_DO_SCHEDULE_CALLBACK，最后会执行到 FrameDisplayEventReceiver，<em>用于申请 VSYNC 信号</em>。</p><p>在等待 Vsync 信号的时候主线程什么事都没干，这样的好处是保证在 Vsync 信号到来时，绘制任务可以被及时执行，不会造成界面卡顿。<br>这样的话，我们发送的普通消息可能会被延迟处理，<em>在 Vsync 信号到了</em>之后，移除屏障，才得以处理普通消息。</p><p><strong>同步屏障的移除</strong><br>在 MessageQueue. java 的 removeSyncBarrier () 方法。<br>删除屏障消息的方法很简单，就是不断遍历消息队列，知道找到屏障消息，退出循环的条件有两个，一是 p.target &#x3D;&#x3D; null，说明是屏障消息，二是 p.arg1 &#x3D;&#x3D; token，也说明 p 是屏障消息，因为在屏障消息入队的时候，设置过 msg. arg1 &#x3D; token。找到屏障消息后，把它从消息队列中删除并回收。</p><blockquote><p>postSyncBarrier () 和 removeSyncBarrier () 必须成对出现，否则会导致消息队列出现假死情况。</p></blockquote><p>如果不异常同步屏障消息，队列中已经没有了异步消息，但是存在普通消息，所以会一直等异步消息，普通消息得不到执行机会</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161425011.png" alt="deepseek_mermaid_20250905_cc1d26"></p><h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>在 WMS 中会为这个 Window 分配 Surface，并确定显示层级，可见负责显示界面的是画布 Surface，而不是窗口本身，WMS 将他管理的 Surface 交由 SurfaceFlinger 处理，SurfaceFlinger <em>将这些 Surface 合并后放入到 buffer 中</em>，屏幕会定时从 buffer 中获取显示数据，显示到屏幕上。<br>[[6-系统源码#SurfaceView]]</p><h2 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h2><p>在 Android 系统中，屏幕定时从 buffer 中获取显示数据的时间通常是以屏幕刷新率（刷新频率）来衡量的。常见的屏幕刷新率包括60Hz 和120Hz，表示屏幕每秒刷新60次或120次。</p><p>具体的刷新时间取决于屏幕刷新率和 VSync 信号的触发。VSync（垂直同步信号）是一个由硬件生成的信号，用于同步屏幕刷新和显示数据的传输。<strong>在每个 VSync 信号触发时，GPU会从 buffer 中获取最新的显示数据，并将其显示在屏幕上</strong>。</p><p>以60Hz 的屏幕刷新率为例，每秒刷新60次，因此每次刷新的时间间隔约为16.67毫秒（1秒&#x2F;60 &#x3D; 0.0167秒 ≈ 16.67毫秒）。这意味着，<em>屏幕会大约每16.67毫秒获取一次 buffer 中的显示数据，并更新到屏幕上</em>。</p><p>需要注意的是，具体的屏幕刷新率和 VSync 触发时间可能因设备而异。某些设备可能具有不同的刷新率（例如90Hz 或120Hz），因此屏幕获取显示数据的时间间隔也会相应变化。此外，硬件和系统的性能也可能影响刷新时间的准确性。</p><h2 id="VSYNC"><a href="#VSYNC" class="headerlink" title="VSYNC"></a>VSYNC</h2><p> Android 系统每隔16ms 发出 VSYNC 信号，触发对 UI 进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms 内完成。如果你的某个操作花费时间是24ms，系统在得到 VSYNC 信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms 内看到的会是同一帧画面。</p><p>用户容易在 UI 执行动画或者滑动 ListView 的时候感知到卡顿不流畅，是因为这里的操作相对复杂，容易发生丢帧的现象，从而感觉卡顿。<strong>有很多原因可以导致丢帧，也许是因为你的 layout 太过复杂，无法在16ms 内完成渲染，有可能是因为你的 UI 上有层叠太多的绘制单元，还有可能是因为动画执行的次数过多</strong>。这些都会导致 CPU 或者 GPU 负载过重。<br>vsync 信号是由底层发出的</p><h2 id="cpu、gpu功能"><a href="#cpu、gpu功能" class="headerlink" title="cpu、gpu功能"></a>cpu、gpu功能</h2><ul><li>cpu 负责计算 measure layout draw </li><li>gpu 负责渲染 display &#x3D;&gt;位图</li><li>每个16ms 会发送一次垂直同步信号 vsync</li><li>每次信号发送的时候都会从 <em>gpu 的 buffer 中取出渲染好的位图显示在屏幕上</em>，同时如果有需要还会进行下一次的 cpu 计算, 计算好后放入 buffer 中</li><li>如果计算时间超过了两次 vsync 之间的时间即16ms 则 vsync 信号会把上一次 gpu buffer 中的信息展示出来这时候就是卡顿</li><li>另外如果页面没有变化屏幕还是一样会去 buffer 中取出上一次的刷新, 只不过 cpu 不再去计算而已</li></ul>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.Handler消息机制</title>
    <link href="/2025/12/32fa1f4007bf.html"/>
    <url>/2025/12/32fa1f4007bf.html</url>
    
    <content type="html"><![CDATA[<h2 id="Handler-被设计出来的原因？有什么用？"><a href="#Handler-被设计出来的原因？有什么用？" class="headerlink" title="Handler 被设计出来的原因？有什么用？"></a>Handler 被设计出来的原因？有什么用？</h2><p> Handler 的意义就是切换线程</p><p>作为 Android 消息机制的主要成员，它管理着所有与界面有关的消息事件，常见的使用场景有：</p><ul><li>跨进程之后的界面消息处理。   Binder 线程到主线程<br>比如 Activity 的启动，就是 AMS 在进行进程间通信的时候，通过 Binder 线程将消息发送给 ApplicationThread 的消息处理者 Handler，然后再将消息分发给主线程中去执行。</li><li>网络交互后切换到主线程进行 UI 更新<br>总之一句话，Hanlder 的存在就是为了解决在子线程中无法访问 UI 的问题。</li></ul><p>Android 在主线程是不能加载网络数据或图片、数据库查询、复杂业务逻辑处理以及费时任务操作，因为 Android 的 UI 操作并不是线程安全的，并且所有涉及 UI 的操作必须在 UI 线程中完成。Android 应用在5s 内无响应的话会导致 ANR (Application Not Response)</p><p>Java 指定某个线程执行？不行。必须写循环</p><h2 id="Android-的-Handler-机制"><a href="#Android-的-Handler-机制" class="headerlink" title="Android 的 Handler 机制"></a>Android 的 Handler 机制</h2><p>本质：在某个指定的运行中的线程上执行代码<br>思路：在接受任务的线程上执行循环判断<br>Looper：负责循环、条件判断和任务执行<br>Handler：负责任务的定制和线程间传递</p><p><strong>Executor、AsyncTask、HandlerThead、IntentService 的选择</strong></p><p>原则：哪个简单用哪个</p><ul><li>能用 Executor 就用 Executor</li><li>需要用到「后台线程推送任务到 UI 线程」时，再考虑 AsyncTask 或者 Handler</li><li>HandlerThread 的使用场景：原本它设计的使用场景是「在已经运行的指定线程上执行代码」，但现实开发中，除了主线程之外，几乎没有这种需求，因为 HandlerThread 和 Executor 相比在实际应用中并没什么优势，<em>反而用起来会麻烦一点</em>。不过，这二者喜欢用谁就用谁吧。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-04-16-09-f457ff1fd65a0c78c2b0f964d4cafb27-09-57-37-f457ff1fd65a0c78c2b0f964d4cafb27-unknown_filename.1-96b6f1-931dc0.png" alt="unknown_filename.1|600"></p><h2 id="Handler-流程"><a href="#Handler-流程" class="headerlink" title="Handler 流程"></a>Handler 流程</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-04-16-10-c20ab3939e02e0cc66175e64f3ccca83-09-57-37-c20ab3939e02e0cc66175e64f3ccca83-Image-f61a65-224a4d.png" alt="Image|600|1000"></p><ul><li>一般会在子线程中创建 message 对象，通过 handler 的 sendmessage 方法把消息发送到 messageQueue 队列（<em>单链表</em>）里，队列是先进先出的</li><li>在队列里通过 enqueueMessage 方法对所有的 message 按时间为顺序从小到大排列 (通过 msg. next)，如果发现刚才发送的 message 排在队列的最前头，就唤醒主线程，让主线程去取 (looper)</li><li>在主线程的 activityThraead 类默认已经创建 looper 对象，在 new looper 的时候构造方法里创建了 messagequeue 对象。</li><li>looper 调用  loop 方法（一直是主线程里），里面又不停的调用 mQueue 的  next 方法，从 messagequeue 里取消息（for (;;) ），这是个阻塞式方法（死循环）</li><li>取到消息后通过 msg. tagre（也就是 Handler）. dispatchMessage 方法分发消息，里面又调用了 handlermessage 方法将消息交给 handler 处理，刷新 ui</li></ul><h2 id="如何从子线程切换到主线程的？"><a href="#如何从子线程切换到主线程的？" class="headerlink" title="如何从子线程切换到主线程的？"></a>如何从子线程切换到主线程的？</h2><p>线程间是共享资源的</p><ul><li>handler 将自己的引用间接被 Looper 持有，handler 的构造函数里有 looper，是主线程的 looper。就算没有，也会创建一个 mLooper：当前线程中的 Looper 对象。</li><li>构造的时候就是主线程的 handler</li><li>所以 handler. sendMessage ()，这里 handler 在主线程。</li><li>当 Looper 在主线程调用 loop ()方法时，该方法会取出 handler 并调用其 handleMessage ()方法，这样就切换到了主线程。</li><li>handler 的创建的时候采用的是当前线程的 Looper 来构造消息系统，Looper 在哪个线程创建, 就在哪个线程绑定, 并且 handler 是在他关联的消息系统来处理的。</li></ul><h2 id="为什么建议子线程不访问（更新）UI"><a href="#为什么建议子线程不访问（更新）UI" class="headerlink" title="为什么建议子线程不访问（更新）UI"></a>为什么建议子线程不访问（更新）UI</h2><p>因为 Android 中的 UI 控件不是线程安全的，如果多线程访问 UI 控件那还不乱套了。那为什么不加锁呢？</p><ul><li>会降低 UI 访问的效率。本身 UI 控件就是离用户比较近的一个组件，加锁之后自然会发生阻塞，那么 UI 访问的效率会降低，最终反应到用户端就是这个手机有点卡。</li><li>太复杂了。本身 UI 访问时一个比较简单的操作逻辑，直接创建 UI，修改 UI 即可。如果加锁之后就让这个 UI 访问的逻辑变得很复杂，没必要。</li></ul><p>所以，Android 设计出了单线程模型来处理 UI 操作，再搭配上 Handler，是一个比较合适的解决方案。</p><h2 id="子线程访问-UI-的崩溃原因和解决办法"><a href="#子线程访问-UI-的崩溃原因和解决办法" class="headerlink" title="子线程访问 UI 的崩溃原因和解决办法"></a>子线程访问 UI 的崩溃原因和解决办法</h2><p>崩溃发生在 ViewRootImpl 类的 checkThread 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewRootImpl</span><span class="hljs-params">(Context context, Display display)</span> &#123;  <br>    mContext = context;  <br>    ...  <br>    mThread = Thread.currentThread();  <br>    ...  <br>&#125;  <br>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">checkThread</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">if</span> (mThread != Thread.currentThread()) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalledFromWrongThreadException</span>(  <br>                <span class="hljs-string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是判断了<em>当前线程是否是 ViewRootImpl 创建时候的线程</em>，如果不是，就会崩溃。<br>而 ViewRootImpl 创建的时机就是界面被绘制的时候，也就是 onResume 之后，所以如果在子线程进行 UI 更新，就会发现当前线程（子线程）和 View 创建的线程（主线程）不是同一个线程，就会抛异常。</p><p>解决办法有三种：</p><ul><li>在新建视图的线程进行这个视图的 UI 更新，主线程创建 View，主线程更新 View。</li><li>子线程切换到主线程进行 UI 更新，比如 Handler、view. post 方法。</li><li>Android 中有⼀个控件 SurfaceView ，它可以通过 holder 获得 canvas 对象，可以直接在⼦线程中更新 UI。</li></ul><p>只有创建了 view 树的线程，才能访问它的子 view。并没有说子线程一定不能访问 UI。那可以猜想到，button 的确实是在子线程被添加到 window 中的，子线程确实可以直接访问。</p><ul><li>在⼦线程中创建 ViewRootImpl，自己创建，最好不要这么做<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-04-16-06-07df94d5805778519106c874b9bea70f-09-57-37-07df94d5805778519106c874b9bea70f-unknown_filename.2-444aa1-c61ad7.png" alt="unknown_filename.2|600"></li></ul><p>子线程可以 showToast, 只要在前后调 Looper. prepare ()和 Looper. loop ()即可。<em>show 的过程就是添加 Window 的过程</em>。<br> 只有调用了 Looper. prepare ()方法，才会构造一个 Looper 对象并在 ThreadLocal 存储当前线程的 Looper 对象。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    Looper.prepare();<span class="hljs-comment">//Looper初始化</span><br>                    <span class="hljs-comment">//Handler初始化 需要注意, Handler初始化传入Looper对象是子线程中缓存的Looper对象</span><br>                    mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.myLooper());<br>                    Looper.loop();<span class="hljs-comment">//死循环</span><br>                    <span class="hljs-comment">//注意: Looper.loop()之后的位置代码在Looper退出之前不会执行,(并非永远不执行)</span><br>                &#125;<br>            &#125;).start();<br></code></pre></td></tr></table></figure><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-04-16-06-565116f8521b84be2c0d9d78e7e10e90-09-57-37-565116f8521b84be2c0d9d78e7e10e90-unknown_filename.4-4bd720-e20fec.png" alt="unknown_filename.4|600"></p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>用的什么数据结构来存储数据？</p><p>看名字应该是个队列结构，队列的特点是什么？先进先出，一般在队尾增加数据，在队首进行取数据或者删除数据。<br>那 Hanlder 中的消息似乎也满足这样的特点，先发的消息肯定就会先被处理。但是，Handler 中还有比较特殊的情况，比如延时消息。<br>延时消息的存在就让这个队列有些特殊性了，并不能完全保证先进先出，而是需要根据时间来判断，所以 Android 中采用了链表的形式来实现这个队列，也方便了数据的插入。</p><p>创建是 native，核心内容就是初始化一个 NativeMessageQueue 对象，并将其地址返回给 Java 层。</p><p>来一起看看消息的发送过程，无论是哪种方法发送消息，都会走到 sendMessageDelayed 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br><span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>delayMillis = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br><span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br><span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>sendMessageDelayed 方法主要计算了消息需要被处理的时间，如果 delayMillis 为0，那么消息的处理时间就是当前时间。<br>然后就是关键方法 MessageQueue 的方法 enqueueMessage。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br><br>                Log.w(TAG, e.getMessage(), e);<br>                msg.recycle();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            msg.markInUse();<br>            msg.when = when;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br><br>            <span class="hljs-type">boolean</span> needWake;<br>            <span class="hljs-comment">//下面</span><br>     <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>            <span class="hljs-keyword">if</span> (needWake) &#123;<br>                nativeWake(mPtr);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>    <br>不懂得地方先不看，只看我们想看的：</p><ul><li>首先设置了 Message 的 when 字段，也就是代表了这个消息的处理时间</li><li>然后判断当前队列是不是为空，是不是即时消息，是不是执行时间 when 大于表头的消息时间，满足任意一个，就<em>把当前消息 msg 插入到表头</em>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>                <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>                msg.next = p;<br>                mMessages = msg;<br>                needWake = mBlocked;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>否则，就需要遍历这个队列，也就是链表，找出 when 小于某个节点的 when，找到后插入。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span>  &#123;  <br>    needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();  <br>    Message prev;  <br>    <span class="hljs-keyword">for</span> (; ; ) &#123;  <br>        prev = p;  <br>        p = p.next;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;  <br>            needWake = <span class="hljs-literal">false</span>;  <br>        &#125;  <br>    &#125;  <br>    msg.next = p; <br>    prev.next = msg;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>插入消息就是通过消息的执行时间，也就是 when 字段（当前时间+延迟时间），<em>来找到合适的位置插入链表</em>。</p><p>具体方法就是通过死循环，使用快慢指针 p 和 prev，每次向后移动一格，直到找到某个节点 p 的 when 大于我们要插入消息（msg）的 when 字段，则插入到 p 和 prev 之间。或者遍历到链表结束，插入到链表结尾。</p><p>所以，MessageQueue 就是一个用于存储消息、用链表实现的特殊队列结构。   </p><h2 id="延迟消息是怎么实现的"><a href="#延迟消息是怎么实现的" class="headerlink" title="延迟消息是怎么实现的"></a>延迟消息是怎么实现的</h2><p>无论是即时消息还是延迟消息，都是计算出具体的时间，然后作为消息的 when 字段进程赋值。<br>然后在 MessageQueue 中找到合适的位置（安排 when 小到大排列），并将消息插入到 MessageQueue 中。<br>这样，MessageQueue 就是一个<em>按照消息时间排列</em>的一个链表结构。</p><h2 id="MessageQueue-的消息怎么被取出来的"><a href="#MessageQueue-的消息怎么被取出来的" class="headerlink" title="MessageQueue 的消息怎么被取出来的"></a>MessageQueue 的消息怎么被取出来的</h2><p>刚才说过了消息的存储，接下来看看消息的取出，Looper.loop ——loopOnce</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>        <span class="hljs-comment">//调用MessageQueue的next()方法取消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//消息为空，会退出消息队列</span><br>            <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;<br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span><br>                    + msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>        &#125;<br>        ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            msg.target.dispatchMessage(msg);<span class="hljs-comment">//msg.target是绑定的Handler</span><br>            <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>                observer.messageDispatched(token, msg);<br>            &#125;<br>            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>        &#125; <br>        ...<br>        msg.recycleUnchecked();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p> queue. next 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        nativePollOnce(ptr, nextPollTimeoutMillis);  <br>  <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();  <br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;  <br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">do</span> &#123;  <br>                    prevMsg = msg;  <br>                    msg = msg.next;  <br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;  <br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.  </span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// Got a message.  </span><br>                    mBlocked = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;  <br>                        prevMsg.next = msg.next;  <br>                    &#125; <span class="hljs-keyword">else</span> &#123;  <br>                        mMessages = msg.next;  <br>                    &#125;  <br>                    msg.next = <span class="hljs-literal">null</span>;  <br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);  <br>                    msg.markInUse();  <br>                    <span class="hljs-keyword">return</span> msg;  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// No more messages.  </span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;  <br>            &#125;     <br>             <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span>  <br>                    &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;  <br>                pendingIdleHandlerCount = mIdleHandlers.size();  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.  </span><br>                mBlocked = <span class="hljs-literal">true</span>;  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>  <br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;  <br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];  <br>            &#125;  <br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// Run the idle handlers.  </span><br>        <span class="hljs-comment">// We only ever reach this code block during the first iteration.        </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];  <br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler  </span><br>  <br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                keep = idler.queueIdle();  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;  <br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);  <br>            &#125;  <br>  <br>            <span class="hljs-keyword">if</span> (!keep) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                    mIdleHandlers.remove(idler);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.  </span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;  <br><br>        <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered  </span><br>        <span class="hljs-comment">// so go back and look again for a pending message without waiting.      </span><br>          nextPollTimeoutMillis = <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么取消息也是用的死循环呢？<br>其实死循环就是为了保证一定要返回一条消息，如果没有可用消息，那么就阻塞在这里，一直到有新消息的到来。<br>其中，nativePollOnce 方法就是阻塞方法，nextPollTimeoutMillis 参数就是阻塞的时间。那什么时候会阻塞呢？两种情况：</p><ul><li>1、有消息，但是当前时间小于消息执行时间，也就是代码中的这一句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>   nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候阻塞时间&#x3D;消息时间减去当前时间，然后进入下一次循环，阻塞。</p><ul><li>2、没有消息的时候，也就是上述代码的最后一句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>-1就代表一直阻塞。</p><h2 id="阻塞之后怎么唤醒"><a href="#阻塞之后怎么唤醒" class="headerlink" title="阻塞之后怎么唤醒"></a>阻塞之后怎么唤醒</h2><p>说说 pipe&#x2F;epoll 机制</p><p>接着上文的逻辑，当消息不可用或者没有消息的时候就会阻塞在 <em>next 方法</em>，而阻塞的办法是通过 pipe&#x2F;epoll 机制</p><p><em>epoll 原理</em><br>[[Linux相关#IO 多路复用]]</p><p>epoll 机制是一种 IO 多路复用的机制，具体逻辑就是一个进程可以监视多个描述符，当某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，这个读写操作是阻塞的。在 Android 中，会创建一个 Linux 管道（Pipe）来处理阻塞和唤醒。</p><ul><li>当消息队列为空，管道的读端等待管道中有新内容可读，就会通过 epoll 机制进入阻塞状态。</li><li>当有消息要处理，就会通过管道的写端写入内容，唤醒主线程。</li></ul><p>那什么时候会怎么唤醒消息队列线程呢？</p><p>还记得刚才插入消息的 enqueueMessage 方法中有个 needWake 字段吗，很明显，这个就是表示是否唤醒的字段。<br>其中还有个字段是 mBlocked，看字面意思是阻塞的意思，去代码里面找找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (; ; ) &#123;  <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;  <br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    mBlocked = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span> msg;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;  <br>                mBlocked = <span class="hljs-literal">true</span>;  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在获取消息的方法 next 中，有两个地方对 mBlocked 赋值：</p><ul><li>当获取到消息的时候，mBlocked 赋值为 false，表示不阻塞。</li><li>当没有消息要处理，也没有 idleHandler 要处理的时候，mBlocked 赋值为 true，表示阻塞。</li></ul><p>好了，确实这个字段就表示是否阻塞的意思，再去看看 enqueueMessage 方法中，唤醒机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;  <br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>        <span class="hljs-type">boolean</span> needWake;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;  <br>            msg.next = p;  <br>            mMessages = msg;  <br>            needWake = mBlocked;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();  <br>            Message prev;  <br>            <span class="hljs-keyword">for</span> (; ; ) &#123;  <br>                prev = p;  <br>                p = p.next;  <br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;  <br>                    needWake = <span class="hljs-literal">false</span>;  <br>                &#125;  <br>            &#125;  <br>            msg.next = p;  <br>            prev.next = msg;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">if</span> (needWake) &#123;  <br>            nativeWake(mPtr);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>当链表为空或者时间小于表头消息时间，那么就插入表头，并且设置是否唤醒为 mBlocked。<br>再结合上述的例子，也就是当有新消息要插入表头了，这时候如果之前是阻塞状态（mBlocked&#x3D;true），那么就要唤醒线程了。</p></li><li><p>否则，就需要取链表中找到某个节点并插入消息，在这之前需要赋值 needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg. isAsynchronous ()(是否是异步消息)</p></li></ul><p>也就是在插入消息之前，需要判断是否阻塞，并且表头是不是屏障消息（ p.target &#x3D;&#x3D; null），并且当前消息是不是异步消息。也就是如果现在是同步屏障模式下，那么要插入的消息又刚好是异步消息，那就不用管插入消息问题了，直接唤醒线程，因为异步消息需要先执行。</p><ul><li>最后一点，是在循环里，如果发现之前就存在异步消息，那就还是设置是否唤醒为 false。意思就是，如果之前有异步消息了，那肯定之前就唤醒过了，这时候就不需要再次唤醒了。</li></ul><p>最后根据 needWake 的值，决定是否调用 nativeWake 方法唤醒 next()方法。</p><h2 id="Handler-里的各种消息"><a href="#Handler-里的各种消息" class="headerlink" title="Handler 里的各种消息"></a>Handler 里的各种消息</h2><p>[[2.Handler 里的各种消息]]</p><h2 id="Message-消息分发之后的处理"><a href="#Message-消息分发之后的处理" class="headerlink" title="Message 消息分发之后的处理"></a>Message 消息分发之后的处理</h2><p>消息怎么复用的？</p><p>再看看 loop 方法，在消息被分发之后，也就是执行了 dispatchMessage 方法之后，还偷偷做了一个操作——recycleUnchecked。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span> (; ; ) &#123;  <br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block  </span><br>            <span class="hljs-keyword">try</span> &#123;  <br>                msg.target.dispatchMessage(msg);  <br>            &#125;  <br>            msg.recycleUnchecked();  <br>        &#125;  <br>    &#125;  <br>  <br><span class="hljs-comment">//Message.java  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;  <br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleUnchecked</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;  <br>            <span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;  <br>                next = sPool;  <br>                sPool = <span class="hljs-built_in">this</span>;  <br>                sPoolSize++;  <br>            &#125;  <br>        &#125;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>在 recycleUnchecked 方法中，释放了所有资源，然后将当前的空消息插入到 sPool 表头。<br>这里的 sPool 就是一个消息对象池，它也是一个链表结构的消息，最大长度为50。</p><h2 id="享元模式-Message-obtain"><a href="#享元模式-Message-obtain" class="headerlink" title="享元模式 Message. obtain"></a>享元模式 Message. obtain</h2><p>在使用 handler 的时候发现，创建 message 对象有两种方式，一种是直接 new，一种是使用 Message. obtain ()，这个 message 的静态方法是这样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">sPoolSync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">gCheckRecycle</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>            <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>                sPool = m.next;<br>                m.next = <span class="hljs-literal">null</span>;<br>                m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>                sPoolSize--;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>解释：<br>首先，它会检查 sPool 是否为 null。如果 sPool 不为 null，说明之前已经创建过 Message 对象并放入了对象池中。然后直接复用消息池 sPool 中的第一条消息，然后 sPool 指向下一个节点，消息池数量减一。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper是干嘛呢？怎么获取当前线程的 Looper？为什么不直接用 Map 存储线程和对象呢？</p><p>在 Handler 发送消息之后，消息就被存储到 MessageQueue 中，而 Looper 就是一个管理消息队列的角色。 Looper 会从 MessageQueue 中不断的查找消息，也就是 loop 方法，并将消息交回给 Handler 进行处理。而 Looper 的获取就是通过 ThreadLocal 机制:<br>[[5.ThreadLocal]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Looper&gt;();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br><span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>&#125;<br>sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> Looper <span class="hljs-title function_">myLooper</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过 prepare 方法创建 Looper 并且加入到 sThreadLocal 中，通过 myLooper 方法从 sThreadLocal 中获取 Looper。</p><h3 id="Looper-中的-quitAllowed-字段"><a href="#Looper-中的-quitAllowed-字段" class="headerlink" title="Looper 中的 quitAllowed 字段"></a>Looper 中的 quitAllowed 字段</h3><p>按照字面意思就是是否允许退出，那么这个 quit 方法一般是什么时候使用呢？</p><ul><li>主线程中，一般情况下肯定不能退出，因为退出后主线程就停止了。所以是当 APP 需要退出的时候，就会调用 quit 方法</li><li>子线程中，如果消息都处理完了，就需要调用 quit 方法停止消息循环。</li></ul><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>Looper. loop 方法是死循环，为什么不会卡死（ANR）</p><ul><li>1、<em>主线程本身就是需要一只运行的，因为要处理各个 View，界面变化。所以需要这个死循环来保证主线程一直执行下去，不会被退出</em>。可执行代码是能一直执行下去的，死循环便能保证主线程不会被退出</li><li>2、真正会卡死的操作是在某个消息处理的时候操作时间过长，导致掉帧、ANR，而不是 loop 方法本身。</li><li>3、在主线程以外，会有其他的线程来处理接受其他进程的事件，比如 Binder 线程（ApplicationThread），会接受 AMS 发送来的事件，比如屏幕刷新16ms 一个消息，你的<em>各种点击事件</em>，都会唤醒</li><li>4、在收到跨进程消息后，会交给主线程的 Hanlder 再进行消息分发。所以 Activity 的生命周期都是依靠主线程的 Looper. loop，当收到不同 Message 时则采用相应措施，比如收到 msg&#x3D;H.LAUNCH_ACTIVITY，则调用 ActivityThread.handleLaunchActivity ()方法，最终执行到 onCreate 方法。</li><li>5、当没有消息的时候，会阻塞在 loop 的 queue.next ()中的 nativePollOnce ()方法里，此时<em>主线程会释放 CPU 资源进入休眠状态</em>，直到下个消息到达或者有事务发生。所以死循环也不会特别消耗 CPU 资源。</li></ul><p>对于线程来说，既然是一段可执行的代码，当可执行的代码执行完后，线程的生命周期就该终止了，线程也就退出。而对于主线程，我们是绝不希望运行一段时间自己就退出的。<br>那么如何保证能一直存活呢？简单的做法就是让可执行的代码一直执行下去，死循环就可以保证不被退出。例如：loop () 方法中就是采用 for (;;) 死循环的方式。</p><h2 id="Message-分发消息"><a href="#Message-分发消息" class="headerlink" title="Message 分发消息"></a>Message 分发消息</h2><p>在 loop 方法中，找到要处理的 Message，然后调用了这么一句代码处理消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">msg.target.dispatchMessage (msg);<br></code></pre></td></tr></table></figure><p>所以是将消息交给了 msg. target 来处理，那么这个 target 是啥呢？</p><p>找找它的来头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Handler</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span> <span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>msg. target = <span class="hljs-built_in">this</span>;<br><span class="hljs-keyword">return</span> queue.enqueueMessage (msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用 Hanlder 发送消息的时候，会设置 msg. target &#x3D; this，所以 target 就是当初把消息加到消息队列的那个 Handler。</p><h2 id="post-Runnable-与-sendMessage"><a href="#post-Runnable-与-sendMessage" class="headerlink" title="post (Runnable) 与 sendMessage"></a>post (Runnable) 与 sendMessage</h2><p>Hanlder 中主要的发送消息可以分为两种：</p><ul><li>post (Runnable)</li><li>sendMessage</li></ul><p>post 这个方法是把任务 r 转成一个 message 放进了 handler 所在的线程中的 messageQueue 消息队列中，并且是立刻发送的消息，这样它既不是异步的也不是延时的</p><p>handler. post 和 handler. sendMessage 本质上是没有区别的，都是发送一个消息到消息队列中，只是实际用法中有一点差别, <em>post 也没有独特的作用，post 本质上还是用 sendMessage 实现的</em>，post 只是一中更方便的用法而已</p><p>通过 post 的源码可知，其实 post 和 sendMessage 的区别就在于：post 方法给 Message 设置了一个 callback。</p><p>那么这个 callback 有什么用呢？我们再转到消息处理的方法 dispatchMessage 中看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span> <span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg. callback != <span class="hljs-literal">null</span>) &#123;<br>            handleCallback (msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (mCallback.handleMessage (msg)) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            handleMessage (msg);<br>        &#125;<br>    &#125;<br>  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCallback</span> <span class="hljs-params">(Message message)</span> &#123;<br>        message.callback.run ();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这段代码可以分为三部分看：</p><ul><li>1、如果 msg. callback 不为空，也就是通过 post 方法发送消息的时候，会把消息交给这个 msg. callback 进行处理，然后就没有后续了。</li><li>2、如果 msg. callback 为空，也就是通过 sendMessage 发送消息的时候，会判断 Handler 当前的 mCallback 是否为空，如果不为空就交给 Handler. Callback. handleMessage 处理。</li><li>3、如果 mCallback. handleMessage 返回 true，则无后续了。</li><li>4、如果 mCallback. handleMessage 返回 false，则调用 handler 类重写的 handleMessage 方法。</li></ul><p>所以 post (Runnable) 与 sendMessage 的区别就在于后续消息的处理方式，是交给 msg. callback 还是 Handler. Callback 或者 Handler. handleMessage。</p><h2 id="postdelay"><a href="#postdelay" class="headerlink" title="postdelay"></a>postdelay</h2><ul><li>把消息放到过几秒再放到消息队列里，遍历循环链表找到最后一个时间比当前要插入的消息的时间小的消息。</li><li>postDelay 本质还是交给 MessageQueue 去处理的, 然后在 next 方法里面, 调用 nativePollOnce 进行阻塞, <em>nativePollOnce 类似 Object 的 wait 方法, 只不过用了 native 方法对线程精确时间的唤醒</em>。</li></ul><h2 id="Handler-Callback-handleMessage-和-Handler-handleMessage"><a href="#Handler-Callback-handleMessage-和-Handler-handleMessage" class="headerlink" title="Handler. Callback. handleMessage 和 Handler. handleMessage"></a>Handler. Callback. handleMessage 和 Handler. handleMessage</h2><p>有什么不一样？为什么这么设计</p><p>接着上面的代码说，这两个处理方法的区别在于 Handler. Callback. handleMessage 方法是否返回 true：</p><ul><li>如果为 true，则不再执行 Handler. handleMessage </li><li>如果为 false，则两个方法都要执行。</li></ul><p>那么什么时候有 Callback，什么时候没有呢？这涉及到两种 Hanlder 的创建方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> handler1= <span class="hljs-keyword">object</span> : Handler ()&#123;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span> <span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> &#123;<br><span class="hljs-keyword">super</span>.handleMessage (msg)<br>&#125;<br>&#125;<br><br>  <br><span class="hljs-keyword">val</span> handler2 = Handler (<span class="hljs-keyword">object</span> : Handler. Callback &#123;<br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span> <span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br>&#125;)<br><br></code></pre></td></tr></table></figure><p>常用的方法就是第1种，派生一个 Handler 的子类并重写 handleMessage 方法。而第2种就是系统给我们提供了一种不需要派生子类的使用方法，只需要传入一个 Callback 即可。</p><h2 id="Handler、Looper、MessageQueue、线程"><a href="#Handler、Looper、MessageQueue、线程" class="headerlink" title="Handler、Looper、MessageQueue、线程"></a>Handler、Looper、MessageQueue、线程</h2><ul><li>一个线程只会有一个 Looper 对象，所以线程和 Looper 是一一对应的。</li><li>MessageQueue 对象是在 new Looper 的时候创建的，所以 Looper 和 MessageQueue 是一一对应的。</li><li>Handler 的作用只是将消息加到 MessageQueue 中，并后续取出消息后，根据消息的 target 字段分发给当初的那个 handler，所以 Handler 对于 Looper 是可以多对一的，也就是多个 Hanlder 对象都可以用同一个线程、同一个 Looper、同一个 MessageQueue。</li></ul><p>总结：Looper、MessageQueue、线程是一一对应关系，而他们与 Handler 是可以一对多的。</p><h2 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h2><p>[[4.IdleHandler]]</p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>为了让我们在<em>子线程里面更方便的使用 Handler</em></p><p>HandlerThread 其实就是一个单线程，和 new singinthreadExecutor 效果一样。<br>HandlerThread 自己做了 prepare 和 loop<br>IntentService 就是用的 HandlerThread</p><p>用法：</p><ol><li>先创建一个 HandlerThread，然后 start</li><li>创建 handler，构造函数是 HandlerThread 的 looper</li><li>handler sendMessage</li><li><em>handleMessage 里运行在子线程里了</em>，做完操作可以用主线程 handler 发送消息给主线程</li><li>用完 HandlerThread. quit ();</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 步骤1：创建 HandlerThread 实例对象</span><br><span class="hljs-comment">// 传入参数 = 线程名字，作用 = 标记该线程</span><br><span class="hljs-type">HandlerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span> (<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-comment">// 步骤2：启动线程</span><br>thread.start ();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span>. Callback &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span> <span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-comment">//在子线程中进行相应的网络请求，这在子线程</span><br>            <span class="hljs-comment">//然后通知主线程的 handler 去更新 UI</span><br>            mUIHandler.sendMessage (msg1);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br> <br> <span class="hljs-comment">// 步骤3：创建子线程 Handler &amp; 复写 handleMessage（）</span><br><span class="hljs-type">Handler</span> <span class="hljs-variable">childHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span> (handlerThread.getLooper (), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildCallback</span> ());<br><br><span class="hljs-comment">// 步骤4：使用子线程 Handler 向子线程的消息队列发送消息</span><br>  <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain ();<br>  msg. what = <span class="hljs-number">2</span>; <span class="hljs-comment">//消息的标识</span><br>  msg. obj = <span class="hljs-string">&quot;B&quot;</span>; <span class="hljs-comment">// 消息的存放</span><br>  childHandler.sendMessage (msg);<br>  <br>  <br>  <span class="hljs-comment">// 步骤5：结束线程，即停止线程的消息循环</span><br>  mHandlerThread.quit ();<br></code></pre></td></tr></table></figure><p><code>HandlerThread</code> 类的简化版源码，用于理解其基本原理和实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Looper mLooper;<br>    <span class="hljs-type">int</span> mTid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HandlerThread</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建 Looper，将其关联到当前线程</span><br>        Looper.prepare();<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            mLooper = Looper.myLooper();<br>            mTid = Process.myTid();<br>            notifyAll();<br>        &#125;<br>        <span class="hljs-comment">// 进入消息循环，处理消息队列中的消息</span><br>        Looper.loop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitForStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Looper <span class="hljs-title function_">getLooper</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mLooper;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>HandlerThread 使用场景</strong></p><ul><li>执行多个耗时任务，并且这些任务需要按顺序执行（串行执行），简单的单线程池</li><li>需要将任务从主线程切换到后台线程执行，避免阻塞UI线程。</li></ul><p>其他用法</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">HandlerThread mWorker = <span class="hljs-keyword">new</span> HandlerThread(TAG);  <br>mWorker.start();<br>mWorker.getThreadHandler<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">post</span><span class="hljs-params">(() -&gt; mRenderer.updateOffsets(xOffset, yOffset))</span>;</span><br></code></pre></td></tr></table></figure><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntentService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Looper mServiceLooper;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ServiceHandler mServiceHandler;<br>    <span class="hljs-keyword">private</span> String mName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> mRedelivery;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceHandler</span> <span class="hljs-params">(Looper looper)</span> &#123;<br>            <span class="hljs-built_in">super</span> (looper);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span> <span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-comment">//重写的方法，子线程需要做的事情</span><br>            onHandleIntent ((Intent) msg. obj);<br>            <span class="hljs-comment">//做完事，自动停止</span><br>            stopSelf (msg. arg1);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntentService</span> <span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span> ();<br>        <span class="hljs-comment">//IntentService 的线程名</span><br>        mName = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIntentRedelivery</span> <span class="hljs-params">(<span class="hljs-type">boolean</span> enabled)</span> &#123;<br>        mRedelivery = enabled;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate ();<br>        <span class="hljs-type">HandlerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span> (<span class="hljs-string">&quot;IntentService[&quot;</span> + mName + <span class="hljs-string">&quot;]&quot;</span>);<br>        thread.start ();<br><br>        <span class="hljs-comment">//构造子线程 Handler</span><br>        mServiceLooper = thread.getLooper ();<br>        mServiceHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceHandler</span> (mServiceLooper);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span> <span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Intent intent, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mServiceHandler.obtainMessage ();<br>        msg. arg1 = startId;<br>        msg. obj = intent;<br>        <span class="hljs-comment">//在 Service 启动的时候发送消息，子线程开始工作</span><br>        mServiceHandler.sendMessage (msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onStartCommand</span> <span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Intent intent, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <span class="hljs-comment">//调用上面的那个方法，促使子线程开始工作</span><br>        onStart (intent, startId);<br>        <span class="hljs-keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span> <span class="hljs-params">()</span> &#123;<br>        mServiceLooper.quit ();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span> <span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@WorkerThread</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onHandleIntent</span> <span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Intent intent)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>理一下这个源码：</p><ul><li>首先，这是一个 Service</li><li>并且内部维护了一个 HandlerThread，也就是有完整的 Looper 在运行。</li><li>还维护了一个子线程的 ServiceHandler。</li><li>启动 Service 后，会通过 Handler 执行 onHandleIntent 方法。</li><li>完成任务后，会自动执行 stopSelf 停止当前 Service。</li></ul><p>所以，这就是一个可以在子线程进行耗时任务，并且在任务执行后自动停止的 Service。</p><h2 id="利用-Handler-机制设计一个不崩溃的-App"><a href="#利用-Handler-机制设计一个不崩溃的-App" class="headerlink" title="利用 Handler 机制设计一个不崩溃的 App"></a>利用 Handler 机制设计一个不崩溃的 App</h2><p>主线程崩溃，其实都是发生在消息的处理内，包括生命周期、界面绘制。<br>所以如果我们能控制这个过程，并且在发生崩溃后重新开启消息循环，那么主线程就能继续运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Handler (Looper.getMainLooper ()). post &#123;  <br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <span class="hljs-comment">//主线程异常拦截  </span><br>           <span class="hljs-keyword">try</span> &#123;  <br>               Looper.loop ()  <br>           &#125; <span class="hljs-keyword">catch</span> (e:Throwable)&#123;  <br>           &#125;  <br>       &#125;  <br>   &#125;<br></code></pre></td></tr></table></figure><p>还有一些特殊情况处理，比如 onCreate 内发生崩溃，具体可以看看文章<br>《能否让 APP 永不崩溃》 <a href="https://juejin.cn/post/6904283635856179214">juejin.cn&#x2F;post&#x2F;690428…</a></p><h2 id="post-一个-Runnable-，在下一帧就可以拿到了"><a href="#post-一个-Runnable-，在下一帧就可以拿到了" class="headerlink" title="post 一个 Runnable ，在下一帧就可以拿到了?"></a>post 一个 Runnable ，在下一帧就可以拿到了?</h2><ul><li>这个说不准，如果上一条 Message 在 <em>callback 中 sleep 了5秒，那就在5秒之后才会取出了</em>。。。</li><li>说到屏幕刷新（也就是这个“下一帧”），在 View 中倒是有个方法可以让 Runnable 在下一次屏幕刷新时执行，它就是：postOnAnimation (Runnable action)！</li><li>相信很多同学在看 View 类源码的时候都会看到过它的身影，比如 RecyclerView 在处理惯性滚动时就会反复调用这个方法（在每一次屏幕刷新时才计算滚动后的坐标值，而不是开子线程去不停计算，以节省资源）</li></ul><h2 id="runOnUiThread"><a href="#runOnUiThread" class="headerlink" title="runOnUiThread"></a>runOnUiThread</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> void runOnUiThread (Runnable <span class="hljs-keyword">action</span>) &#123;<br><span class="hljs-keyword">if</span> (Thread.currentThread () <span class="hljs-comment">!= mUiThread) &#123;</span><br>mHandler.post (<span class="hljs-keyword">action</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">action</span>.run ();<br>&#125;<br>&#125;   <br></code></pre></td></tr></table></figure><h2 id="new-Handler-与-new-Handler-Looper-getMainLooper"><a href="#new-Handler-与-new-Handler-Looper-getMainLooper" class="headerlink" title="new Handler ()与 new Handler (Looper. getMainLooper ())"></a>new Handler ()与 new Handler (Looper. getMainLooper ())</h2><p>要刷新 UI，handler 要用到主线程的 Looper 对象。那么在主线程 Handler handler&#x3D;new Handler () 如果在其他非主线程也要满足这个功能的话，要 Handler handler&#x3D;new Handler (Looper.getMainLooper ());</p><h2 id="如何确保线程安全的"><a href="#如何确保线程安全的" class="headerlink" title="如何确保线程安全的"></a>如何确保线程安全的</h2><p><strong>既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个 Handler 可能处于不同线程），那它内部是如何确保线程安全的？</strong><br>这里主要关注 MessageQueue 的消息存取即可，看源码内部的话，在往消息队列里面存储消息时，会拿当前的 MessageQueue 对象作为锁对象，这样通过加锁就可以确保操作的原子性和可见性了。<br>消息的读取也是同理，也会拿当前的 MessageQueue 对象作为锁对象，来保证多线程读写的一个安全性。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Handler%E3%80%81AsyncTask.resources/2023/09/18/09-57-37-316c10eb3157921780472e15034a081f-unknown_filename.6-268a33.png" alt="unknown_filename.6"></p><h2 id="自定义简单-Handler"><a href="#自定义简单-Handler" class="headerlink" title="自定义简单 Handler"></a>自定义简单 Handler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizableThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CustomizableThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizableThread</span> ();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runTest</span> <span class="hljs-params">()</span> &#123;<br>        thread.start ();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep (<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace ();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizableThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-type">Looper</span> <span class="hljs-variable">looper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span> ();<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>            looper.loop ();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Looper</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> quit;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTask</span> <span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>. task = task;<br>        &#125;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span> <span class="hljs-params">()</span> &#123;<br>            quit = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span> <span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (! quit) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        task.run ();<br>                        task = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9-Android构建流程</title>
    <link href="/2025/12/4c89bc4ee6b8.html"/>
    <url>/2025/12/4c89bc4ee6b8.html</url>
    
    <content type="html"><![CDATA[<h3 id="Android-构建流程"><a href="#Android-构建流程" class="headerlink" title="Android 构建流程"></a>Android 构建流程</h3><p>AAPT ( <em>Android 资源打包工具</em>， Android Asset Packaging Tool) 是一种编译工具, 供 Android studio 和 Android Gradle plugin 用于编译和打包应用资源。而 AAPT2是在 AAPT 上做了优化。 Android Gradle Plugin0.0或者更高版本默认开启AAPT2。AAPT2会解析资源、为资源编索引并资源编译为针对 Android平台进行过优化的二进制格式。</p><p>其实里面都是用的命令生成的</p><ol><li>编译资源，使⽤ aapt2 ⼯具对资源进⾏编译，产出：资源⼆进制⽂件压缩包 zip</li><li>链接资源使⽤。 aapt2 ⼯具将资源整合，产出：资源⽂件及 R.java ⽂件，arsc</li><li>编译 Java ⽂件。使⽤ javac ⼯具编译 Java ⽂件，产出：class 字节码⽂件</li><li>使⽤ dex ⼯具编译 class 代码，产出：dex ⽂件</li><li>合并 dex ⽂件和资源⽂件，产出：还未签名的 apk ⽂件</li><li>使⽤ apksigner ⼯具对 apk 签名，产出：已签名的 apk ⽂件</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-c1adb4339eaf5f47c9e8e6d708018e0a-unknown_filename.4-78e973.png" alt="unknown_filename.4"></p><h3 id="⼿动⽣成⼀个安装包的过程"><a href="#⼿动⽣成⼀个安装包的过程" class="headerlink" title="⼿动⽣成⼀个安装包的过程"></a>⼿动⽣成⼀个安装包的过程</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-7d24a82d422bff3f63009b58e4c05bb7-unknown_filename.1-72cfbe.png" alt="unknown_filename.1"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-d6e8fce6d1a1c9ba5d4a71376167ec0f-unknown_filename.5-d75aa4.png" alt="unknown_filename.5"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-47dc6a421ed9f5b3c9edfefce35c1c26-unknown_filename-1ffe40.png" alt="unknown_filename"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-bd2ed2f3484aefe2db5fd032c936839b-unknown_filename.3-ea9e4b.png" alt="unknown_filename.3"></p><p>配置 buildCofig 里的参数<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-9e9f7de761231fb48f291244b7fde38a-unknown_filename.2-f107b6.png" alt="unknown_filename.2"></p><h3 id="apk-目录"><a href="#apk-目录" class="headerlink" title="apk 目录"></a>apk 目录</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-829bdefc57223f78d17ba16e1452515b-unknown_filename.7-045de7.png" alt="unknown_filename.7"></p><h3 id="arsc-文件"><a href="#arsc-文件" class="headerlink" title="arsc 文件"></a>arsc 文件</h3><ul><li><p>编译后的二进制资源文件，主要作用是 App 的资源索引表，可以从二进制的文件中查找到资源的相关信息，或者根据资源的 id 可以定位到二进制文件中的位置</p></li><li><p>除了 assets、图片、布局资源之外，其它的资源都会被赋予一个资源 ID。打包工具负责编译和打包资源，编译完成之后，<em>会生成一个 resources. arsc 文件和一个R.java，前者保存的是一个资源索引表，后者定义了各个资源 ID 常量，供在代码中索引资源</em>。id 都是16进制 0X1212，<strong>字符串没了</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-50-34-57476b5cfcb37c1c0e39dc2772823951-unknown_filename.6-b7c27f.png" alt="unknown_filename.6"></p></li></ul><h3 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h3><p>进入目录，发现会有3个文件：CERT. RSA，CERT. SF，MANIFEST. MF。<br>MANIFEST：版本号以及对每一个文件的哈希值（BASE64）。包括资源文件。这个是对每个文件的整体进行 SHA1 hash。<br>CERT. SF 文件：看到跟 manifest. mf 中的很类似，也是 BASE64编码的哈希值，这个是对每个文件的头3行进行 SHA1 hash。这两个文件中的内容仅仅是个摘要，也就是仅仅对文件做个 hash。<br>CERT. RSA：最后一个文件是 CERT. RSA，这个文件中放的是 apk 包的签名，同时还有证书的公钥。</p><h3 id="Android-的签名机制"><a href="#Android-的签名机制" class="headerlink" title="Android 的签名机制"></a>Android 的签名机制</h3><p>对 APK 中所有文件内容分别进行 Hash 计算，并将结果以 BASE64编码格式保存在 MANIFEST. MF。使用开发者的私钥对 MANIFEST. MF 进行加密，将加密结果保存在 CERT. SF。最后 CERT.RSA (证书信息包括公钥）和上面的两个文件，放入 APK 的<strong>META-INF</strong>目录下。</p><p><strong>如何判断证书是否有效</strong></p><p>因为签名的时候是使用私钥对 MANIFEST. MF 进行加密保存在 CERT. SF 中，之后只需要用证书中的公钥对 CERT. SF 进行解密，将结果和 MANIFEST. MF 进行比较即可<br>注意，在证书正确的情况下如果更改的 APK 里面文件内容，此时以上判断还是不会通过。<em>因为 MANIFEST. MF 保存的是 APK 里面所有文件的 Hash 值，只要改变了 APK 里文件内容，Hash 值就会变化</em></p><p><em>v2 签名机制</em>是在 Android 7.0 以及以上版本才支持。因此对于 Android 7.0 以及以上版本，在安装过程中，如果发现有 v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制。v1 和 v2 签名机制是可以同时存在的</p><ul><li><strong>V1</strong>：逐文件校验，慢，安全性低，但兼容老系统。</li><li><strong>V2</strong>：整体校验，快，安全性高，但只支持 7.0+。</li></ul><h3 id="使用-python-实现多渠道打包"><a href="#使用-python-实现多渠道打包" class="headerlink" title="使用 python 实现多渠道打包"></a>使用 python 实现多渠道打包</h3><p>实现思路：<br>如果能直接修改 apk 的渠道号，而不需要再重新签名能节省不少打包的时间。解压 apk，解压后的根目录会有一个 META-INF 目录。如果在 META-INF 目录内添加空文件，可以不用重新签名应用。因此，通过为不同渠道的应用添加不同的空文件，可以唯一标识一个渠道。</p><p>思路已经很清晰了，在 META-INF 目录添加一个空文件，文件名即渠道号，如 channel_wandoujia。然后在 java 代码中对文件进行遍历，找到该渠道文件，读出文件名，即获取到了渠道号。</p><h3 id="加快编译速度"><a href="#加快编译速度" class="headerlink" title="加快编译速度"></a>加快编译速度</h3><ul><li>你可以把编译简单理解为，将高级语言转化为机器或者虚拟机所能识别的低级语言的过程。对于 Android 来说，这个过程就是把 Java 或者 Kotlin 转变为 Android 虚拟机运行的<strong>Dalvik 字节码</strong></li><li>关闭 JITandroid:vmSafeMode&#x3D;“true”，关闭虚拟机的 JIT 优化</li></ul><blockquote><p>Android Q 大幅改进了 ART 运行时。所谓运行时改进就是对编译器 (JIT) 的改进, 开发者无需进行任何操作，便可有效缩短应用的启动时间，减少内存消耗，并提高应用的运行流畅度。<br>ART 配置文件，允许 ART 在应用开始运行之前就预编译一部分代码。基于云的编译文件适用于所有应用，而且运行 Android P 或更高版本系统的设备目前已提供相关支持。</p></blockquote><ul><li>r8&#x2F;d8</li></ul><blockquote><p>d8Dex 编译时间更短，dex 文件大小更小，D8编译的. dex 文件将拥有相同或者是更好的运行时性能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8-Launcher学习</title>
    <link href="/2025/12/33bb23a10f32.html"/>
    <url>/2025/12/33bb23a10f32.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7389902952649424959?searchId=20250714204245A4F5525ABB7DFF0C01A7#heading-5">android12.0(S) Launcher3 导入 AndroidStudio 调试编译验证环境 aosp 12.0 - 掘金</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>launcher其实就是一个app，从功能上说，是对手机上其他app的一个管理和启动，从代码上说比其他app多了一个属性，就是在AndroidManifest.xml文件中多了一个“android:name&#x3D;”android.intent.category.HOME”属性，这个属性就是在启动系统或者按Home键时会过滤这个属性，如果系统中只要一个应用具有这个属性，就会直接跳转到这个界面，也就是这个launcher，如果有多个，会弹出选择框让用户选择并且提示用户是否选择默认设置。</p><h2 id="Launcher启动流程"><a href="#Launcher启动流程" class="headerlink" title="Launcher启动流程"></a>Launcher启动流程</h2><ul><li>Launcher是一个应用程序，这个应用程序用来显示系统中已经安装的应用程序</li><li>SyetemServer进程在启动的过程中会启动PackageManagerService将所有应用程序安装完毕</li><li>ActivityManager 向PackageManagerService查询CATEGOR_HOME的Activity启动作为桌面Activity，将Launcher启动起来</li><li>Launcher显示所有应用图标，<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-28-15-25-4791251b872f274a13ed2b606ac1abaf-2023-09-28-15-20-4791251b872f274a13ed2b606ac1abaf-20230928152033-6a3a35-2bb0ff.png" alt="image.png"></li></ul><p>启动Launcher后，通过LauncherModel控制加载逻辑，LoaderTask开启线程加载数据，LoaderResults进行数据绑定的处理，最后将数据返回给Launcher处理</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>下面介绍一下桌面的基本结构。首先看下图：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-26-18-40-8208dbfa7c5f0389dd3e4bb03231aba4-20230926184023-b84670.png" alt="image.png"></p><p>最外层，也就是手机显示层是一个叫做Workspace的控件，其实在Workspace外层还有一个DragLayer层，在他的里面的最上面，是一个叫做SearchDropTargetView的控件，该控件就是搜索或者删除应用的控件。中间最大的一块是CellLayout，一个Workspace包含一个或者多个CellLayout，多个CellLayout横向并排排列，每个CellLayout在宽度上占用一屏，如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-26-18-40-b8bda8642af75c7b12fbae46c9da51a9-20230926184047-eec37c.png" alt="image.png"></p><p>当用户左右滑动时会切换中间的CellLayout部分，如下图所示：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-26-18-41-61c85ee4f2c17c5e38b49a6d92031203-20230926184101-e9488f.png" alt="image.png"></p><p>CellLayout主要的作用是装在快捷方式或者小部件等。用户通过点击这些快捷方式打开应用。中间的指示点叫做PageIndicator，用来指示你当前处于第几个屏幕上面，也就是第几个CellLayout。最下面的四个图标所占的位置叫做Hotseat，主要是放置短信，拨号等最常用的应用图标。用户左右滑动屏幕时，该控件不做滑动处理。</p><p>当用户长按桌面时，中间的CellLayout会缩小，下面的Hotseat和上面的SearchDropTargetView会隐藏，从而显示出隐藏的三个菜单按钮。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-26-18-41-7076b1d024b05dd13b32e45ce5aa95da-20230926184116-ab8124.png" alt="image.png"></p><p><strong>hotseat</strong><br>受欢迎的位置</p><p>原生Launcher3经典的四种UI模式：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-28-15-24-b7784ae5768397c16d28a5c20745d4da-20230928152445-1814dc.png" alt="image.png"><br>Launcher3的实质其实就是一个Activity包含N个自定义层级的View，不同模式隐藏显示不同的View而已。</p><h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><p>Launcher：主界面Activity，最核心且唯一的Activity。</p><p>LauncherAppState：单例对象，构造方法中初始化对象、注册应用安装、卸载、更新，配置变化等广播。这些广播用来实时更新桌面图标等，其receiver的实现在LauncherModel类中，LauncherModel也在这里初始化。</p><p>LauncherModel：数据处理类，保存桌面状态，提供读写数据库的API，内部类LoaderTask用来初始化桌面。</p><p>InvariantDeviceProfile：一些不变的设备相关参数管理类，其内部包涵了横竖屏模式的DeviceProfile。</p><p>WidgetPreviewLoader：存储Widget信息的数据库，内部创建了数据库widgetpreviews.db。</p><p>LauncherAppsCompat：获取已安装App列表信息的兼容抽象基类，子类依据不同版本API进行兼容性处理。</p><p>AppWidgetManagerCompat：获取AppWidget列表的兼容抽象基类，子类依据不同版本API进行兼容性处理。</p><p>LauncherStateTransitionAnimation：各类动画总管处理执行类，负责各种情况下的各种动画效果处理。</p><p>IconCache：图标缓存类，应用程序icon和title的缓存，内部类创建了数据库app_icons.db。</p><p>LauncherProvider：核心数据库类，负责launcher.db的创建与维护。</p><p>LauncherAppWidgetHost：AppWidgetHost子类，是桌面插件宿主，为了方便托拽等才继承处理的。</p><p>LauncherAppWidgetHostView：AppWidgetHostView子类，配合LauncherAppWidgetHost得到HostView。</p><p>LauncherRootView：竖屏模式下根布局，继承了InsettableFrameLayout，控制是否显示在状态栏等下面。</p><p>DragLayer：一个用来负责分发事件的ViewGroup。</p><p>DragController：DragLayer只是一个ViewGroup，具体的拖拽的处理都放到了DragController中。</p><p>BubblTextView：图标都基于他，继承自TextView。</p><p>DragView：拖动图标时跟随手指移动的View。</p><p>Folder：打开文件夹展示的View。</p><p>FolderIcon：文件夹图标。</p><p>DragSource&#x2F;DropTarget：拖拽接口，DragSource表示图标从哪开始拖，DropTarget表示图标被拖到哪去。</p><p>ItemInfo：桌面上每个Item的信息[[1-数据结构]]，包括在第几屏、第几行、第几列、宽高等信息；该对象与数据库中记录一一对应；该类有多个子类，譬如FolderIcon的FolderInfo、BubbleTextView的ShortcutInfo等。</p><h2 id="启动主流程"><a href="#启动主流程" class="headerlink" title="启动主流程"></a>启动主流程</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-28-15-29-29397159e9140a366d28b47c0efa6020-20230928152958-05353b.png" alt="image.png"></p><p>需要特别注意上图中红色的两步。在setContentView之后我们其实又进行了一次依据设备属性的layout操作，接着才进行异步数据加载的，所以我们的重点会放在LauncherModel的loader方法中。</p><p>在启动Launcher时数据加载绑定其实分了两大类，workspace与allApps（widgets）的加载，他们都是通过异步加载回调UI绑定数据的，下面我们先看下workspace的加载绑定流程，如下：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-28-15-31-d95c250ef10bc0896a0f52b7636e2e80-20230928153148-8cb68b.png" alt="image.png"><br>可以发现，到此其实UI和数据都已经显示OK了，我们接着关注一下AllApps和Widget的加载流程，如下：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-28-15-35-0184083daf2a40622f73eb1b6264885a-20230928153511-12cb60.png" alt="image.png"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-10-09-16-05-62a4379a552c28cabd1f621767bc0de0-20231009160552-cfdde4.png" alt="image.png"></p><h3 id="新应用安装后自动显示到桌面"><a href="#新应用安装后自动显示到桌面" class="headerlink" title="新应用安装后自动显示到桌面"></a>新应用安装后自动显示到桌面</h3><p>在LauncherAppState的构造方法中，LauncherModel被注册到了LauncherApps中，<em>LauncherApps是一个系统服务</em>，可以用来查询和监听系统内应用的安装卸载等变化。 LauncherModel类继承了LauncherApps.Callback并实现了其回调方法。 所以当有新应用安装成功后，会回调此方法。</p><h2 id="将launch3代码导出"><a href="#将launch3代码导出" class="headerlink" title="将launch3代码导出"></a>将launch3代码导出</h2><h2 id="不同api是怎么适配的？"><a href="#不同api是怎么适配的？" class="headerlink" title="不同api是怎么适配的？"></a>不同api是怎么适配的？</h2><p>startDockOrHome<br>startHomeOnDisplay<br>ActivityTaskManagerService  startHomeOnDisplay</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, String reason, <span class="hljs-keyword">int</span> displayId,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">boolean</span> allowInstrumenting, <span class="hljs-keyword">boolean</span> fromHomeKey)</span> </span>&#123;  <br>    <span class="hljs-keyword">synchronized</span> (mGlobalLock) &#123;  <br>        <span class="hljs-function"><span class="hljs-keyword">return</span> mRootActivityContainer.<span class="hljs-title">startHomeOnDisplay</span><span class="hljs-params">(userId, reason, displayId,  </span></span><br><span class="hljs-params"><span class="hljs-function">                allowInstrumenting, fromHomeKey)</span></span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>RootActivityContainer</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">String</span> reason, <span class="hljs-type">int</span> displayId, <span class="hljs-type">boolean</span> allowInstrumenting,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">boolean</span> fromHomeKey)</span> </span>&#123;  <br>   ....<br>        homeIntent = mService.<span class="hljs-built_in">getHomeIntent</span>();  <br>  ...<br>    mService.<span class="hljs-built_in">getActivityStartController</span>().<span class="hljs-built_in">startHomeActivity</span>(homeIntent, aInfo, myReason,  <br>            displayId);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们看上面的3437行,获取Intent,再看3451行,如果不为空,则启动HomeActivity,我们看一下这个Intent是什么的Intent:</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-27-16-59-14cd7a6d32ddbee75cb1f22a0b666bdc-20230927165924-31c3d7.png" alt="image.png"><br>上面的3424行,有个Intent.CATEGORY_HOME,我们在Intent中找到这个属性的代码:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> CATEGORY_HOME = <span class="hljs-string">&quot;android.intent.category.HOME&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>在Application和ContentProvider同时存在时,ContentProvider 的onCreate方法要比Application的onCreate方法先启动<br>BIND_APPLICATION—–&gt;handleBindApplication<br>先 installContentProviders 后 callApplicationOnCreate</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7-INPUT</title>
    <link href="/2025/12/d61e87c7789d.html"/>
    <url>/2025/12/d61e87c7789d.html</url>
    
    <content type="html"><![CDATA[<h2 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h2><p>当用户触摸屏幕或者按键操作，首次触发的是硬件驱动，驱动收到事件后，将该相应事件写入到输入设备文件中（dev&#x2F;input&#x2F;）。接着，输入系统取出原生态的事件，经过层层封装后成为 KeyEvent 或者 MotionEvent ；最后，交付给相应的目标窗口 (Window) 来消费该输入事件。</p><p>在屏幕接收到触摸信息后，会把这个信息交给 InputServiceManager 去处理，最后通过 WindowManagerService 找到符合的 window。<br>并把触摸信息发送给 viewRootImpl, viewRootImpl 经过层层封和处理之后，产生一个 MotionEvent 事件分发给 view。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-5d019e92dfc7d4b934c262270bb0313e-unknown_filename.8-d6cfbc.png" alt="unknown_filename.8"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-6621832ccabd788a6e8c622f169c9dd3-unknown_filename.9-c1f77e.webp" alt="unknown_filename.9"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-5ed85a9e839734382a88e691e83be16d-unknown_filename.10-43c7cb.webp" alt="unknown_filename.10"></p><ol><li>SystemServer 创建并启动 InputManagerService</li><li>InputManagerService 在 native 层创建一个 NativeInputManager 对象</li><li>NativeInputManager 内部创建一个 InputManager 对象</li><li>InputManager 启动 InputReaderThread 和 InputDispatcherThread（2个线程）</li><li>在 InputReaderThread 线程中调用 EventHub 的 getEvents 获取设备节点中的输入事件。</li><li>并将输入事件封装为 NotifyKeyArgs 对象放入队列中。</li><li>之后再调用 flush，依次将事件传递给 InputDispatcher。</li><li>InputDispatcher 在收到事件后，会重新封装为一个 KeyEntry 对象，并压力压入 mInboundQueue 队列中。</li><li>唤醒 InputDispatcherThread 线程。Wake</li><li>事件交给 wms, 最后给 ViewRootImp；</li></ol><h3 id="Input-模块的主要组成"><a href="#Input-模块的主要组成" class="headerlink" title="Input 模块的主要组成"></a>Input 模块的主要组成</h3><ul><li><p>IMS 的作用：读取设备节点（dev&#x2F;input&#x2F;）中的输入事件，并对数据进行二次甚至三次加工后分发给合适的 Window 进行处理</p></li><li><p>Native 层的 InputReader 负责从 EventHub 取出事件并处理，再交给 InputDispatcher；</p></li><li><p>Native 层的 InputDispatcher 接收来自 InputReader 的输入事件，并记录 WMS 的窗口信息，用于派发事件到合适的窗口；</p></li><li><p>设备驱动层就会接受到原始事件最终将事件传递到用户空间的设备节点（dev&#x2F;input&#x2F;）中</p></li><li><p>Java 层的 InputManagerService 跟 WMS 交互，WMS 记录所有窗口信息，并同步更新到 IMS，为 InputDispatcher 正确派发事件到 ViewRootImpl 提供保障；</p></li><li><p>TYPE_KEY 按键事件，TYPE_MOTION 触摸事件</p></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-af7de711f9a5c8be66348d3ddc66c32b-unknown_filename.6-717a27.png" alt="unknown_filename.6"></p><p><a href="https://juejin.cn/post/7169421307421917214">Android Input系统（一）事件读取机制</a></p><p>在 SystemServer 的 run 方法中调用了 startOtherServices。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Private</span> <span class="hljs-literal">void</span> startOtherServices () &#123;<br>    <span class="hljs-params">...</span><br>    InputManager = <span class="hljs-literal">new</span> InputManagerService (context);<span class="hljs-comment">//1</span><br>    <span class="hljs-params">...</span><br>    Wm = WindowManagerService.Main (context, inputManager,<br>                    MFactoryTestMode != FactoryTest. FACTORY_TEST_LOW_LEVEL,<br>                    !MFirstBoot, mOnlyCore, <span class="hljs-literal">new</span> PhoneWindowManager ());<span class="hljs-comment">//2</span><br>    <span class="hljs-params">...</span><br>    InputManager.Start ();<span class="hljs-comment">//3</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6-系统源码</title>
    <link href="/2025/12/a97b25b96215.html"/>
    <url>/2025/12/a97b25b96215.html</url>
    
    <content type="html"><![CDATA[<h2 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h2><h4 id="SurfaceView-的绘制原理"><a href="#SurfaceView-的绘制原理" class="headerlink" title="SurfaceView 的绘制原理"></a>SurfaceView 的绘制原理</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-566532bd5ebd93d5f914b24ef6b00830-unknown_filename.2-9ff731.png" alt="unknown_filename.2"></p><p>在 WMS 中会为这个 Window 分配 Surface，并确定显示层级，可见负责显示界面的是画布 Surface，而不是窗口本身，WMS 将他管理的 Surface 交由 SurfaceFlinger 处理，SurfaceFlinger 将这些 Surface 合并后放入到 buffer 中，屏幕会定时从 buffer 中获取显示数据，显示到屏幕上。</p><h3 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h3><ul><li>在 App 进程中创建 PhoneWindow 后会创建 ViewRoot。ViewRoot 的创建会创建一个 Surface。</li><li>图像流的最常见消耗方是 SurfaceFlinger，该系统服务会消耗当前可见的 Surface，并使用窗口管理器中提供的信息将它们合成到显示部分。SurfaceFlinger 是可以修改所显示部分内容的唯一服务。SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface</li><li><strong>HWComposer 是基于硬件来产生 VSync 信号的，来通知 SurfaceFlinger 重绘控制显示的帧率。</strong></li><li>图像流生产方可以是生成图形缓冲区以供消耗的任何内容。例如 OpenGL ES、Canvas 2D 和 mediaserver 视频解码器。</li></ul><p>![[Pasted image 20250902172407.png]]</p><h3 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h3><p>取的的时间<br>[[2.Handler 里的各种消息]]</p><h2 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 system&#x2F;packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下&#x2F;data&#x2F;system&#x2F;packages.xml。</li><li>同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标</li></ul><h3 id="PackageManagerService"><a href="#PackageManagerService" class="headerlink" title="PackageManagerService"></a>PackageManagerService</h3><p><a href="https://juejin.cn/post/7028196921143459870#heading-8">APK安装过程 完全解析</a><br>PackageManagerService运行在SystemServer进程，App端和AMS、PMS进行交互都是通过Binder跨进程完成。AMS负责Activity等四大组件的管理，而PMS则负责 包package 的管理，APK的全称是Android Package，即PMS的作用就是管理APK。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IPackageManager <span class="hljs-title function_">getPackageManager</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (sPackageManager != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> sPackageManager;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ServiceManager.getService(<span class="hljs-string">&quot;package&quot;</span>);<br>    sPackageManager = IPackageManager.Stub.asInterface(b);<br>    <span class="hljs-keyword">return</span> sPackageManager;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="PMS的初始化"><a href="#PMS的初始化" class="headerlink" title="PMS的初始化"></a>PMS的初始化</h3><p>因为 所有App运行都需要 这些系统服务，所以是 系统开机的时候 完成 PMS、AMS这些的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SystemServer.java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The main entry point from zygote.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        ...<br>        <span class="hljs-comment">// Here we go!</span><br>        Slog.i(TAG, <span class="hljs-string">&quot;Entered the Android system server!&quot;</span>);<br>        ...<br>        <span class="hljs-comment">// Prepare the main looper thread (this thread).</span><br>        Looper.prepareMainLooper();<br>        ...<br>    <span class="hljs-comment">// Start services. </span><br>        startBootstrapServices(t); <span class="hljs-comment">//系统开启中 具有复杂相互依赖性的 关键服务</span><br>        startCoreServices(t); <span class="hljs-comment">//没有复杂依赖的核心服务</span><br>        startOtherServices(t); <span class="hljs-comment">//其他服务</span><br>        ...<br>    <span class="hljs-comment">// Loop forever.</span><br>    Looper.loop();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在开机系统启动时，zygote 进程会fork一个 SystemServer 进程然后执行上面main方法，这里进行大量的初始化，其中就包括 启动各种服务。 这里我们看 startBootstrapServices():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startBootstrapServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// Installer </span><br>    <span class="hljs-type">Installer</span> <span class="hljs-variable">installer</span> <span class="hljs-operator">=</span> mSystemServiceManager.startService(Installer.class);<br>    ...<br>    <span class="hljs-comment">//AMS</span><br>    mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);<br>    mActivityManagerService.setInstaller(installer);<br>    ...<br>    <span class="hljs-comment">//PMS</span><br>    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>发现这里开启了 AMS、PMS，并且都使用了Installer。Installer 看名字像是安装器，后面再做介绍。 PMS的main方法内用构造方法创建了PMS实例，而它的构造方法内容特别多，我们关注其中一句调用scanDirTracedLI()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** data/app，已安装app的目录 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">sAppInstallDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(Environment.getDataDirectory(), <span class="hljs-string">&quot;app&quot;</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PackageManagerService</span><span class="hljs-params">(Injector injector, <span class="hljs-type">boolean</span> onlyCore, <span class="hljs-type">boolean</span> factoryTest)</span>&#123;<br>    ...<br>    <span class="hljs-comment">//读取packages.xml中 上次的包信息，解析后将数据存放到mSettings中</span><br>    mFirstBoot = !mSettings.readLPw(mInjector.getUserManagerInternal().getUsers(<span class="hljs-literal">false</span>));<br>    ...<br>    <span class="hljs-comment">//扫描 data/app</span><br>    scanDirTracedLI(sAppInstallDir, <span class="hljs-number">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class="hljs-number">0</span>,packageParser, executorService);<br>    ...<br>    <span class="hljs-comment">//把新的 mSettings 内容更新到 packages.xml</span><br>    mSettings.writeLPr();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>packages.xml：记录系统中 所有安装的应用信息，包括基本信息、签名和权限。<br>mSettings：用来保存和PMS相关的一些设置，它保存的内容在解析应用时会用到。</p><p>先读取packages.xml文件，解析后将数据存放到mSettings中，代表上次启动时的应用包信息。然后扫描所有APK目录并解析APK，最后更新packages.xml文件。 而 packages.xml文件 是在 Settings 构造方法中创建。</p><p>data&#x2F;app 是用户已安装App所在的目录，另外还有system&#x2F;app存放 系统App。PMS构造方法中会对 这两个目录在内的多个目录进行扫描，我们这里可以猜想到这是开机时对所有已安装App的初始化。</p><p><strong>总结</strong><br>系统启动后创建并启动了PMS，并且PMS完成了对所有存在APK的目录进行了扫描，解析所有APK的AndroidManifest.xml，然后进一步扫描APK 最后提交包扫描结果到 PMS 的属性中。</p><h2 id="APK的安装过程"><a href="#APK的安装过程" class="headerlink" title="APK的安装过程"></a>APK的安装过程</h2><ul><li>APK用写入Session且包信息和APK安装操作 都提交到了PMS；</li><li>PMS中先把APK拷贝到 &#x2F;data&#x2F;app，然后使用PackageParser2解析APK 获取 四大组件、搜集签名、PackageSetting等信息，并进行校验确保安装成功；</li><li>接着提交信息包更新系统状态及PMS的内存数据；</li><li>然后使用 Installer 准备用户目录&#x2F;data&#x2F;user、进行 dexOpt；</li><li><strong>dexOpt 过程</strong>：目的：将 APK 中的 <code>.dex</code> 字节码转换为优化后的本地机器码</li><li>最后发送安装结果通知UI层。</li></ul><h2 id="crash流程"><a href="#crash流程" class="headerlink" title="crash流程"></a>crash流程</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-9564e77420be08d80e487b35d1279a64-unknown_filename.17-d02162.png" alt="unknown_filename.17"></p><hr><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul><li>Context指：一个应用程序环境的信息,即上下文。Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-cd7cb4e3634f82cb911a2d16766b3c2d-unknown_filename.9-4cbd16.png" alt="unknown_filename.9"></p><p>Activity 因为有了 一层 Theme ，所以中间有个 ContextThemeWrapper ，相当于它是Service和Application 的侄子<br>Context Wrapper 是一个包装类 ，没 任何具体的实现，真正的逻辑都在 Contextlmpl里面</p><ul><li>可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。</li><li>所以 Context 数量 &#x3D; Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。</li><li>Application 的 Context 生命周期与应用程序完全相同。Activity 或者 Service 的 Context 与他们各自类生命周期相同。</li><li>Application 通常作为工具类来使用的，Application 中在 onCreate ()方法里去初始化各种全局的变量数据是一种比较推荐的做法，但是如果你想把初始化的时间点提前到极致，也可以去重写 attachBaseContext ()方法。不能写在构造函数里。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>虽然 Context 神通广大，但是并不是随便拿到一个 Context 实例就可以为所欲为，还是有一些限制的。在绝大多数场景下，Activity、Service 和 Application 这三种类型的 Context 都是通用的，不过也有几种场景比较特殊，比如启动 Activity、弹出 Dialog。Android 是不允许 Activity 或 Dialog 凭空出现的，一个 Activity 的启动必须建立在另外一个 Activity 的基础之上，也就以此形成任务栈。而 Dialog 则必须在一个 Activity 的上面弹出（除非是 System Alert 类型的 Dialog），因此在这种场景下，我们只能使用 Activity 类的 Context。</p><ol><li>使用 ApplicationContext 去启动一个 LaunchMode 为 standard 的 Activity。</li></ol><p> 会报错，因为非 Activity 类型的 Context 没有所谓的任务栈。</p><ol start="2"><li>getApplication、getApplicationContext 区别</li></ol><p>在绝大多数场景下，getApplication 和 getApplicationContext 这两个方法完全一致，返回值也相同。区别在于 getApplication 只存在于 Activity 和 Service 对象，对于 BroadcastReceiver 和 ContentProvider 只能使用 getApplicationContext。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>四大组件的交互，包括启动 Activity、Broadcast、Service，获取 ContentResolver 等</li><li><strong>确定生命周期的</strong>、获取各种资源</li><li>文件、SharedPreference、数据库相关</li><li>获取系统 &#x2F; 应用资源，包括 AssetManager、PackageManager、Resources、SystemService 以及 color、string、drawable 等<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-b4e2fbc08e08f9e7481929820cb6d48f-unknown_filename.6-016b82.png" alt="unknown_filename.6"></li></ul><p><a href="https://blog.csdn.net/freekiteyu/article/details/79318031">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5-事件分发机制</title>
    <link href="/2025/12/d52f6c1eb84b.html"/>
    <url>/2025/12/d52f6c1eb84b.html</url>
    
    <content type="html"><![CDATA[<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-772a5c539ce4aa5f0e21c37de88b20a8-unknown_filename.4-cde615.png" alt="unknown_filename.4"></p><p>当点击事件发生时，事件最先传递给 Activity，Activity 会首先将事件将被所属的 Window（PhoneWinodw)进行处理，即调用 superDispatchTouchEvent () 方法。通过观察 superDispatchTouchEvent ()方法的调用链，我们可以发现事件的传递顺序：</p><ol><li>PhoneWinodw.SuperDispatchTouchEvent ()</li><li>DecorView（FrameLayout）. DispatchTouchEvent (event)</li><li>ViewGroup.DispatchTouchEvent (event)</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-3f1e3f67b10e49ce1cfb506b8ce0c874-unknown_filename.5-1a3852.png" alt="unknown_filename.5"></p><ul><li>事件一层层传递到了 ViewGroup 里。</li><li>每到一个子 view，看他的 onInterceptTouchEvent 方法是否拦截，ontouch 是否消费方法，如果没有继续向下 dispatchTouchEvent 分发事件，都不处理向上传（事件流向），都不处理就会回溯到 activity，若顶层（activity）也不对此事件进行处理，此事件相当于消失了（无效果）。</li><li>return true 代表终止事件传递，return false 则是回溯到父 View 的 onTouchEvent 方法。</li><li>View<strong>没有 onInterceptTouchEvent ()方法</strong>，有 dispatchTouchEvent，一但有点击事件传递给它，它的 ouTouchEvent ()方法就会被调用。</li><li>ouTouchEvent 是否消费事件取决于 ACTION_DOWN 事件或 POINT_DOWN 事件是否返回为 <code>true</code></li><li>只有前一个事件（如 ACTION_DOWN）返回 true，才会收到 ACTION_MOVE 和 ACTION_UP 的事件。</li></ul><h2 id="事件冲突"><a href="#事件冲突" class="headerlink" title="事件冲突"></a>事件冲突</h2><p><strong>不同向嵌套</strong></p><ol><li>外部处理，重写父 view 的 onInterceptTouchEvent ，MotionEvent 的事件全部返回 false，不拦截；</li><li>内部处理。重写子 view 的 dispatchTouchEvent，通过 requestDisallowInterceptTouchEvent 方法（这个方法可以在子元素中干预父元素的事件分发过程），请求父控件不拦截自己的事件，true 是不拦截，false 是拦截。</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事件分发, 请求父控件及祖宗控件是否拦截事件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (getCurrentItem() != <span class="hljs-number">0</span>) &#123;<br>getParent().requestDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 用getParent去请求,</span><br><span class="hljs-comment">// 不拦截</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果是第一个页面,需要显示侧边栏, 请求父控件拦截</span><br>getParent().requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 拦截</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p><strong>同向嵌套</strong><br>父 View 会彻底卡住子 View<br>原因：抢夺条件一致，但父 View 的 onInterceptTouchEvent () 早于子 View 的 dispatchTouchEvent ()<br>本质上是策略问题：嵌套状态下用户手指滑动，他是想滑谁？<br>解决⽅方案：<br>实现策略—父 View、子 View 谁来消费事件可以实时协商</p><ol><li>换成 NestedScrollView：可以滑动</li><li>实现 NestedScrollingChild 3 接口来实现自定义的嵌套滑动逻辑</li></ol><p>[[NestedScrollingParent]]</p><h2 id="自定义-ViewGroup-的触摸反馈"><a href="#自定义-ViewGroup-的触摸反馈" class="headerlink" title="自定义 ViewGroup 的触摸反馈"></a>自定义 ViewGroup 的触摸反馈</h2><ul><li>除了重写 onTouchEvent () ，还需要重写 onInterceptTouchEvent ()</li><li>onInterceptTouchEvent () 不用在第一时间返回 true，而是在任意事件，需要拦截的时候返回 true 就行<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-comment">//伪代码</span><br>view.<span class="hljs-title function_">dispatchTouchEvent</span>();<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent event</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">ontouchEvent</span>();<br>&#125;<br>    <br><span class="hljs-title class_">ViewGroup</span>.<span class="hljs-title function_">dispatchTouchEvent</span>();<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent event</span>) &#123;<br>    <span class="hljs-built_in">boolean</span> result;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">interceptTouchEvent</span>()) &#123;<br>        result = <span class="hljs-title function_">ontouchEvent</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = 子 view的 dispatchTouchEvent ();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Dialog 是 Focusable 的。如果不是 Focusable 的，那么 Dialog 弹出后 Activity 还是可以响应用户事件的</p><blockquote><p>ViewGroup 类中，实际是没有 onTouchEvent 方法的，但是由于 ViewGroup 继承自 View，而 View 拥有 onTouchEvent 方法，故 ViewGroup 的对象也是可以调用 onTouchEvent 方法的。故在表格中表明 ViewGroup 中存在 onTouchEvent 方法的。</p></blockquote><p>递归<br>ViewGroup (View). DispatchTouchEvent ()</p><ul><li>ViewGroup.OnInterceptTouchEvent ()</li><li>child.DispatchTouchEvent ()<ul><li>View.OnTouchEvent ()</li></ul></li></ul><p><strong>Activity 的分发方法中调用了 onUserInteraction法，你能说说这个方法有什么作用吗?</strong></p><p>这个方法在 Activity 接收到 down 的时候会被调用，本身是个空方法，需要开发者自己去重写。<br>这个方法会在我们以任意的方式开始与 Activity 进行交互的时候被调用。<br>比较常见的场景就是屏保: 当我们段时间没有操作会显示一张图片，当我们开始与 Activity 交互的时候可在这个方法中取消屏保: 另外还有没有操作自动隐藏工具栏，可以在这个方法中让工具栏重新显示。</p><h4 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景"></a>一个场景</h4><blockquote><p>有一个 ViewGroup, 然后手指头接触 Button , 手指头滑开了, 滑开又松手的过程, 整个事件发生了什么? 经历了什么?</p></blockquote><p>一开始 ViewGroup 会接受到整个事件序列的第一个事件： ACTION_DOWN，ViewGroup <em>dispatchTouchEvent</em> 收到 ACTION_DOWN 后,<br>  开始询问 ViewGroup <em>onInterceptTouchEvent</em> 是否需要拦截，<br>  默认情况下 ViewGroup <em>onInterceptTouchEvent</em> 返回 false 不拦截，开始向下传递 ACTION_DOWN 事件，<br>  Buttton <em>dispatchTouchEvent</em> 收到 ACTION_DOWN 询问 onTouchEvent 是否处理，<br>  Button 默认处理，此后的所有事件序列都直接跨过 ViewGroup <em>onInterceptTouchEvent</em> 的判断直接传递给 Button，<br>  但 ViewGroup <em>dispatchTouchEvent</em> 会收到所有事件。随着手指的滑动 Button 的坐标发生了改变，当手指抬起时触发 <code>Button onClick</code> 事件。（<strong>移动出自己的范围，就消失了</strong>）</p><p>点击 button，recycleview 中滑动，滑动会收到 cancel 事件</p><h2 id="自定义单-View-的触摸反馈"><a href="#自定义单-View-的触摸反馈" class="headerlink" title="自定义单 View 的触摸反馈"></a>自定义单 View 的触摸反馈</h2><h3 id="View-OnTouchEvent"><a href="#View-OnTouchEvent" class="headerlink" title="View.OnTouchEvent ()"></a>View.OnTouchEvent ()</h3><ul><li><p>如果不在滑动控件中，切换至按下状态，并注册长按计时器</p></li><li><p>重绘 Ripple Effect</p></li><li><p>如果<em>移动出自己的范围，自我标记本次事件失效，忽略后续事</em>件</p></li><li><p>如果是按下状态并且未触发长按，切换至抬起状态并触发点击事件，并清除⼀切状态</p></li><li><p>如果已经触发长按，切换至抬起状态并清除一切状态</p></li><li><p>切换至抬起状态，并清除一切状态</p></li></ul><p>判断是否需要拦截 —&gt; 主要是根据 onInterceptTouchEvent 方法的返回值来决定是否拦截；<br>在 DOWN 事件中将 touch 事件分发给子 View —&gt; 这一过程如果有子 View 捕获消费了 touch 事件，会对 mFirstTouchTarget 进行赋值；<br>最后一步，DOWN、MOVE、UP 事件都会根据 mFirstTouchTarget 是否为 null，决定是自己处理 touch 事件，还是再次分发给子 View。</p><p>然后介绍了整个事件分发中的几个特殊的点。<br>DOWN 事件的特殊之处：事件的起点；决定后续事件由谁来消费处理；<br>MFirstTouchTarget 的作用：<em>记录捕获消费 touch 事件的 View，是一个链表结构</em></p><h3 id="View-DispatchTouchEvent"><a href="#View-DispatchTouchEvent" class="headerlink" title="View.DispatchTouchEvent ()"></a>View.DispatchTouchEvent ()</h3><p>View 中 setOnTouchListener 的 onTouch，onTouchEvent，onClick 的执行顺序</p><p>View 的 <em>dispatchTouchEvent</em> 源码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (!onFilterTouchEventForSecurity(<span class="hljs-keyword">event</span>)) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        &#125;  <br><br>        <span class="hljs-keyword">if</span> (mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; <br>                mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> onTouchEvent(<span class="hljs-keyword">event</span>);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当以下三个条件任意一个不成立时</p><ol><li>mOnTouchListener 不为 null</li><li>View 是 enable 的状态</li><li>mOnTouchListener.OnTouch (this, event)返回 true</li></ol><p>函数会执行到 onTouchEvent。在这里我们可以看到，首先执行的是 mOnTouchListener. OnTouch 的方法，然后是 onTouchEvent 方法继续追溯源码，到 onTouchEvent ()观察，发现在处理 ACTION_UP 事件里有这么一段代码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">If</span> <span class="hljs-comment">(! Post (mPerformClick)</span>) &#123;        performClick <span class="hljs-comment">()</span>;    &#125;<br></code></pre></td></tr></table></figure><p>此时可知，onClick 方法也在最后得到了执行所以三者的顺序是：</p><ol><li>OnTouchListener () 的 onTouch</li><li>OnTouchEvent ()</li><li>OnClick ()</li></ol><p>首先，他会判断是否存在 onTouchListener，存在则会调用他的 onTouch 方法来处理事件。如果该方法返回 true 那么就分发结束直接返回。<br>而如果该监听器为 null 或者 onTouch 方法返回了 false，则会调用 onTouchEvent 方法来处理事件</p><p><em>OnTouchEvent 方法中支持了两种监听器:</em> onClickListener 和 onLongClickListener。 View 会根据不同的触摸情况来调用这两个监听器。同时进入到 onTouchEvent 方法中，无论该 view 是否是 enable，只要是 clickable，他的分发方法都是返回 true。</p><p>总结一下就是: 先调用 onTouchListener，再调用 onClickListener 利 onlongClicklistener.</p><p><strong>OnTouch 利 onTouchEvent 区别，调用顺序?</strong><br>在 Android 开发中，<code>onTouch</code> 和 <code>onTouchEvent</code> 都是用来处理触摸事件的方法，但是它们之间有一些区别：</p><ol><li><code>onTouch</code> 方法是 View 类的一个回调方法，用于处理触摸事件。它通常用于实现对触摸事件的自定义处理逻辑。<code>onTouch</code> 方法需要返回一个布尔值，表示是否消费了该触摸事件。</li><li><code>onTouchEvent</code> 方法同样是 View 类的一个回调方法，也用于处理触摸事件。与 <code>onTouch</code> 方法不同的是，<code>onTouchEvent</code> 方法是一个事件处理器，用于处理特定类型的触摸事件。在 <code>onTouchEvent</code> 方法中，你可以根据不同的动作类型（如<strong>按下、移动、抬起</strong>等）来处理触摸事件。</li></ol><p>调用顺序通常是这样的：</p><ol><li>当一个触摸事件发生时，首先会调用 <code>dispatchTouchEvent</code> 方法，该方法会将触摸事件分发给相应的 View。</li><li>如果一个 View 的 <code>onTouch</code> 方法被调用，那么它会处理该触摸事件，并返回一个布尔值，表示是否消费了该事件。如果 <code>onTouch</code> 方法返回 true，表示事件被消费；如果返回 false，会继续向下传递。</li><li>如果事件未被 <code>onTouch</code> 方法消费，那么会调用该 View 的 <code>onTouchEvent</code> 方法进行处理。</li></ol><p>总结起来，<code>onTouch</code> 方法和 <code>onTouchEvent</code> 方法都是用于处理触摸事件的，但是 <code>onTouch</code> 方法更加灵活，可以自定义处理逻辑并决定是否消费事件，而 <code>onTouchEvent</code> 方法则是针对具体的触摸事件类型进行处理的事件处理器。</p><p><strong>一般什么时候需要 onTouch 返回 true</strong></p><ol><li>拦截点击事件：如果你想拦截点击事件，阻止它向下传递给其他视图或控件，可以在 <code>onTouch</code> 方法中返回 <code>true</code>。</li><li>处理滑动事件：当你需要在自定义 View 中实现滑动操作时，你可能会在 <code>onTouch</code> 方法中捕获滑动手势并返回 <code>true</code>，以表示你已经处理了该滑动操作。</li><li>自定义触摸交互：如果你希望在自定义 View 中实现特定的触摸交互，例如绘制、缩放、旋转等，你可能需要在 <code>onTouch</code> 方法中返回 <code>true</code> 以消费触摸事件。</li></ol><p>总的来说，当你希望在自定义 View 中控制触摸事件的传递和处理逻辑时，你可能需要在 <code>onTouch</code> 方法中返回 <code>true</code>。这样可以确保触摸事件被当前视图消费，并阻止其传递给其他视图或控件。</p><p><strong>view 的事件分发：View 为啥会有 dispatchTouchEvent 方法？</strong><br>View 可以注册很多事件监听器，事件的调度顺序是 onTouch&gt; onTouchEvent&gt;onLongClickListener&gt; onClickListener</p><p><strong>事件分发的流程</strong><br>事件分发是针对一次手势的过程，这个手势包含一次 ACTION_DOWN，多次 ACTION_MOVE，和一次 ACTION_UP”，在 ACTION_DOWN 的时候来决定本次事件的“<em>TargetView</em>”，该 View 会决定这次事件分发的事件流向。父控件可以在 ACTION_DOWN 或者 targetView 不为空的情况下，进行拦截，如果拦截了 targetView 的事件，会给它发一个 <em>ACTION_CANCEL</em>。</p><p><strong>CANCEL 事件的触发场景</strong><br>当父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件。</p><p><strong>TouchTarget</strong><br>作用：记录每个子 View 是被哪些 pointer（手指）按下的<br>结构：单向链表</p><p><strong>一次事件分发过程中会有多次 ACTION_POINT_DOWN 吗</strong><br>会。多指的时候，你按下第一个手指，再按下第二个手指 ACTION_POINTER_DOWN 就来了。你可以看看 ViewPager，ScrollView 这些官方类源码，都有多指的处理。</p><p><strong>一个 LinearLayout 内部有两个 Button，当我第一个手指按在第一个 Button 上，第二个手指按在第二个 Button 上，这两个 Button 哪个会收到 ACTION_DOWN？分别抬起每个手指，哪个 Button 的 Click 会被触发？</strong><br>第一个手指按下第一个 Button 上，第一个 Button 收到 ACTION_DOWN。第二个手指按在第二个 Button 上，第二个 Button 竟然也收到了 ACTION_DOWN。分别抬起时，两个 Button 的 Click 依次触发。<br>当第二根手指去按下 Button 2 之后，确实会在 Button 2 中收到 ACTION_ DOWN 事件, 这样加上 Button 1 按下时收到的 ACTION_ DOWN, - -共就两次了，这两次 ACTION_ DOWN 都是在同- -次事件分发中发生的。<br>但是，<strong>对于一个 View 自身来说，同一次事件分发中是不会收到两次 ACTION_ DOWN 的</strong>(手动重写 dispatchTouchEvent 并在里面改了Action 的不算)。</p><p><strong>一次事件分发过程中，可能会有多次 ACTION_DOWN 吗？</strong><br>没有，只有你第一个手指按下才是 ACTION_DOWN，从第二个开始都是 ACTION_POINTER_DOWN，当然了前提是你自己不修改 dispatchTouchEvent 分发逻辑哈。</p><h3 id="ViewGroup-DispatchTouchEvent"><a href="#ViewGroup-DispatchTouchEvent" class="headerlink" title="ViewGroup.DispatchTouchEvent ()"></a>ViewGroup.DispatchTouchEvent ()</h3><ul><li>如果是用户初次按下（ACTION_DOWN），清空 TouchTargets 和 DISALLOW_INTERCEPT 标记</li><li>拦截处理</li><li>如果不拦截并且不是 CANCEL 事件，并且是 DOWN 或者 POINTER_DOWN，尝试把 pointer（手指）通过 TouchTarget 分配给子 View；并且如果分配给了新的子 View，调用 child.DispatchTouchEvent () 把事件传给子 View<ul><li>如果没有，调用⾃己的 super.DispatchTouchEvent ()</li><li>如果有，调用 child.DispatchTouchEvent () 把事件传给对应的子 View（如果有的话）</li></ul></li><li>如果是 POINTER_UP，从 TouchTargets 中清除 POINTER 信息；如果是 UP 或 CANCEL，重置状态</li></ul><p>ViewGroup 第一步会判读这个事件是否需要分发给了 view，如果是则调用 onInterceptTouchEvent 方法判断是否要进行拦截。<br>第二步是如果这个事件是 down 事件，那么需要为他寻找一个消费此事件的子控件，如果找到则为他创建一个 TouchTarget。<br>第三步是派发事件，<em>如果存在 TouchTarget，说明找到了消费事件序列的子 view，直接分发给他</em>。如果没有则交给自己处理</p><p><strong>onInterceptTouchEvent返回false， dispatchTouchEvent返回true会发生什么</strong></p><p>当 <code>onInterceptTouchEvent</code> 方法返回 <code>false</code>，而 <code>dispatchTouchEvent</code> 方法返回 <code>true</code> 时，<strong>触摸事件会继续传递给子视图进行处理，并且该 ViewGroup 不会拦截触摸事件</strong>。许触摸事件在视图层次结构中向下传递，直到找到一个视图来处理该事件。</p><p>具体来说，当一个触摸事件到达一个 ViewGroup 时，首先会调用该 ViewGroup 的 <code>onInterceptTouchEvent</code> 方法来判断是否要拦截该触摸事件。如果 <code>onInterceptTouchEvent</code> 返回 <code>false</code>，表示该 ViewGroup 不拦截触摸事件，将会继续传递给子视图。</p><p>接着，如果 <code>dispatchTouchEvent</code> 方法返回 <code>true</code>，则表示该 ViewGroup 处理了触摸事件，并且将事件传递给子视图进行进一步处理。子视图的 <code>dispatchTouchEvent</code> 方法会被调用，触摸事件会在子视图间进行传递，直到找到一个视图处理该事件或事件被消费。</p><p><strong>如果都是false</strong><br><em>事件会继续向上传递给它的父视图，以便父视图处理该事件</em>。 因此，在 onInterceptTouchEvent 返回 false 且 dispatchTouchEvent 返回 false 的情况下，触摸事件会继续向上层视图传递，直到找到一个视图来处理该事件。如果没有找到可以处理该事件的视图，那么事件可能会被传递给包含该视图的 Activity 或窗口进行处理，或者被丢弃。最终的处理结果取决于视图层次结构中的其他视图和应用程序的逻辑</p><h3 id="自定义-viewpager-的-onInterceptTouchEvent"><a href="#自定义-viewpager-的-onInterceptTouchEvent" class="headerlink" title="自定义 viewpager 的 onInterceptTouchEvent"></a>自定义 viewpager 的 onInterceptTouchEvent</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-85736f53cca2c4b9b4958f6fd2b4b4dc-unknown_filename.1-27d911.png" alt="unknown_filename.1"></p><p>OnTouchEvent<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-31da755be9ce2a1a186e834a01189ac6-unknown_filename.2-e828cf.png" alt="unknown_filename.2"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88%E3%80%81input.resources/2023/09/15/18-49-14-ee874c7ca1c7886f6af40e4d35b1579e-unknown_filename.3-5b00cd.png" alt="unknown_filename.3"></p><p><strong>一般自定义 onTouchEvent 方法流程</strong></p><ol><li>在 down 的时候去记录坐标点<br> GetX&#x2F;getY 获取相对于当前 View 左上角的坐标，getRawX&#x2F;getRawY 获取相对于屏幕左上角的坐标。比如接触到按钮时，x，y 是相对于该按钮左上点的相对位置。而 rawx, rawy 始终是相对于屏幕的位置。</li><li>Move 的时候计算偏移量，并用 scrollTo ()或 scrollBy ()方法移动 view。这俩个方法都是快速滑动，是瞬间移动的。注意：滚动的并不是 viewgroup 内容本身，而是它的矩形边框。</li><li>在 up 的时候，判断应显示的页面位置，并计算距离、滑动页面。</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4-WMS</title>
    <link href="/2025/12/e0c946fd77df.html"/>
    <url>/2025/12/e0c946fd77df.html</url>
    
    <content type="html"><![CDATA[<h1 id="View-绘制流程"><a href="#View-绘制流程" class="headerlink" title="View 绘制流程"></a>View 绘制流程</h1><p>Activity 的界面是在 onResume 之后才开始进行绘制的，onWindowFocusChanged 回调里能确认 UI 可见可操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">onCreate - onStart - onResume - measure - layout -measure - layout - draw - onWindowFocusChanged<br></code></pre></td></tr></table></figure><ul><li>每个 Activity 包含了一个 Window 对象，这个对象是由 PhoneWindow 做的实现（Window 是一个抽象类，而 PhoneWindow 是它的子类）。而 PhoneWindow 将 DecorView 作为了一个应用窗口的根 View，这个 DecorView 又把屏幕划分为了两个区域：一个是 TitleBar，一个是 ContentView，而我们平时在 Xml 文件中写的布局正好是展示在 ContentView 中的.</li><li>PhoneWindow 是 Android 系统中最基本的窗口系统，每个 Activity 会创建一个。同时，PhoneWindow 也是 Activity 和 View 系统交互的接口。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-7052a93b389d0d561ed14c1efa8ff5eb-unknown_filename-55099a.jpeg" alt="unknown_filename|300"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-771d41b8371c973d1d35c8e428eb0153-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191116113902-4c7ba5.png" alt="微信截图_20191116113902|600"></p><h2 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h2><ul><li>ActivityThread 初始启动应用，创建 Activity 的方法 handleLaunchActivity 方法中调用了 Activity 的 attach 方法</li><li>attach 把 window，windowmanager 创建出来，和 activity 建立联系</li><li>然后 mInstrumentation. callActivityOnCreate 调 prePerformCreate</li><li>Activity. onCreate () 调用 setContentView</li><li>setContview 中解析 xml，最后通过 phoneWindow 把 DecorView 创建出来了</li><li>然后在 onResume，WindowManager 的 addview 方法将 DecorView 与 WindowManager 建立联系，然后创建了 viewRootImpl，并将 ViewRootImpl 对象和 DecorView 建立关联（assignParent）</li><li>接着 ViewRootImpl 的 setView 里面有 requestLayout——&gt;performTraversals——&gt;三大流程绘制</li></ul><hr><h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><p><a href="https://github.com/maoqitian/Nice-Knowledge-System/blob/master/AndroidFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%20%E8%A7%86%E5%9B%BE%E5%B1%82/Window%20WindowManager%20Activity%20%E4%B9%8B%E9%97%B4%E8%81%94%E7%B3%BB.md">Window WindowManager Activity 之间联系</a></p><p>WindowManager: 接口类, 同时实现了 ViewManager. 定义了大量 Window 的状态值<br>WindowManagerlmpl: WindowManager 的接口实现类, 但具体的方法实现交给了 WindowManagerGlobal.<br>WindowManagerGlobal: 真正的 WindowManager 接口方法的处理类, 如: 创建 ViewRootlmpl 等..<br>Window&#x2F;WindowManager 均在 Activity 的 attach 中完成</p><h2 id="Attach"><a href="#Attach" class="headerlink" title="Attach"></a>Attach</h2><p>Window 实例化</p><ul><li>ActivityThread 初始启动应用创建 Activity 的方法 handleLaunchActivity 方法中调用了 Activity 的 attach 方法，创建了 Window 对象为 PhoneWindow</li><li>Window 的 Callback 对象指向的是当前 Activity 对象，方便事件分发传递回 Activity</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Context context, ActivityThread aThread ...)</span> &#123;<br>attachBaseContext(context);<br>...<br>mWindow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneWindow</span>(<span class="hljs-built_in">this</span>, window, activityConfigCallback);<span class="hljs-comment">//1</span><br>...<br>mWindow.setCallback(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//2</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Window-和-Activity-以及-WindowManager-什么时候建立的关系？"><a href="#Window-和-Activity-以及-WindowManager-什么时候建立的关系？" class="headerlink" title="Window 和 Activity 以及 WindowManager 什么时候建立的关系？"></a>Window 和 Activity 以及 WindowManager 什么时候建立的关系？</h4><p> 在<em>attach</em>里</p><ol><li>new 一个 PhoneWindow 对象并传入当前 Activity 引用，建立 Window 和 Activity 的一一对应关系。此 Window 是 Window 类的子类 PhoneWindow 的实例。Activity 在 Window 中是以 mContext 属性存在。</li><li>调用 PhoneWindow 的 setWindowManager 方法，在这个方法中让 Window 和 WindowManager 建立了一一关系。此 WindowManager 是<em>WindowManagerImpl</em>的实例</li></ol><h2 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-2a53d44c380b593e37d1144b9ab7d32d-unknown_filename.28-f14ce9.jpeg" alt="unknown_filename.28|1000"></p><h3 id="Window-什么时候和-View-进行关联？"><a href="#Window-什么时候和-View-进行关联？" class="headerlink" title="Window 什么时候和 View 进行关联？"></a>Window 什么时候和 View 进行关联？</h3><p>在<em>setContentView</em>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContentView</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutResID)</span> &#123;<br>...<br><span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-literal">null</span>) &#123;<br>installDecor();<span class="hljs-comment">//注释1</span><br>&#125; <br>mLayoutInflater.inflate(layoutResID, mContentParent);<span class="hljs-comment">//注释2</span><br>...<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installDecor</span><span class="hljs-params">()</span> &#123;<br>...<br><span class="hljs-keyword">if</span> (mDecor == <span class="hljs-literal">null</span>) &#123;<br>mDecor = generateDecor(-<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mDecor.setWindow(<span class="hljs-built_in">this</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title function_">generateDecor</span><span class="hljs-params">(<span class="hljs-type">int</span> featureId)</span> &#123;<br>    ...<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorView</span>(context, featureId, <span class="hljs-built_in">this</span>, getAttributes());<br>&#125;<br></code></pre></td></tr></table></figure><p>布局加载: 首先，Activity 会加载布局文件。布局文件通常是一个 XML 文件，其中定义了界面上的各种元素及其位置和属性。布局文件被解析并转化为一个视图树 (View Tree)<br>这是一个由 View 对象组成的层次结构, 视图树的构建: 一旦布局文件被解析，系统会根据布局文件的定义构建视图树。每个 View 对象在树中占据一个节点，它们之间的关系和层级关系由布局文件的 XML 结构决定。</p><h2 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h2><ul><li>handlerResumeActivity</li><li>WindowManager 的 addview 方法将 DecorView 与 WindowManager 建立联系，也就是从 addview 方法触发了绘制界面，实际上调用的是 WindowManagerImpl 的 addview 方法</li><li>又调了 WindowManagerGlobal 的 addview 方法，这里创建了 ViewRootImpl</li><li>ViewRootImpl，<em>每个 ViewRootImpl 对应一个 Window</em></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-6fc6eb8dac1fd49a9664148daeaa5235-unknown_filename.29-1288b7.jpeg" alt="unknown_filename.29"></p><h3 id="View-是如何一步一步添加到屏幕上的？更新？删除呢？"><a href="#View-是如何一步一步添加到屏幕上的？更新？删除呢？" class="headerlink" title="View 是如何一步一步添加到屏幕上的？更新？删除呢？"></a>View 是如何一步一步添加到屏幕上的？更新？删除呢？</h3><p>屏幕中所有的 View 首先需要经过 WindowManager 的处理，最后提交给 WMS 来处理。</p><p>handlerResumeActivity   ——&gt;WindowManagerImpl. addView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowManagerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WindowManager</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">WindowManagerGlobal</span> <span class="hljs-variable">mGlobal</span> <span class="hljs-operator">=</span> WindowManagerGlobal.getInstance();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;<br>        applyDefaultToken(params);<br>        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateViewLayout</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;<br>        applyDefaultToken(params);<br>        mGlobal.updateViewLayout(view, params);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeView</span><span class="hljs-params">(View view)</span> &#123;<br>        mGlobal.removeView(view, <span class="hljs-literal">false</span>);<br>    &#125;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到这三个方法都是委托给了 WindowManagerGlobal 进行处理，这是设计模式中的<strong>桥接模式</strong> [[设计模式2（结构型模式）#桥接模式]]。</p><h3 id="addView"><a href="#addView" class="headerlink" title="addView"></a>addView</h3><p>WindowManagerGlobal 的addView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span><br><span class="hljs-params">Display display, Window parentWindow)</span> &#123;<br>...<br>ViewRootImpl root;<br><span class="hljs-comment">//将params强转为WindowManager.LayoutParams类型</span><br><span class="hljs-keyword">final</span> WindowManager.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">wparams</span> <span class="hljs-operator">=</span> (WindowManager.LayoutParams) params;<br><span class="hljs-keyword">synchronized</span> (mLock) &#123;<br><br><span class="hljs-comment">//创建一个ViewRootImpl对象</span><br>root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewRootImpl</span>(view.getContext(), display);<br><span class="hljs-comment">//给View设置LayoutParams参数</span><br>view.setLayoutParams(wparams);<br>mViews.add(view);<br><span class="hljs-comment">//存储root到mRoots列表</span><br>mRoots.add(root);<br><span class="hljs-comment">//存储wparams到mParams列表</span><br>mParams.add(wparams);<br><br><span class="hljs-keyword">try</span> &#123;<br>root.setView(view, wparams, panelParentView);<br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br><span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span><br><span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>removeViewLocked(index, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">throw</span> e;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用了 ViewRootImpl 的 setView 方法</p><h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p> ViewRoot 不是 View，它的实现类是 ViewRootImpl，ViewRoot 是 DecorView 的“管理者”。它是 DecorView 和 WindowManager 之间的交互。View 的三大流程均是通过 ViewRoot 来完成的。</p><p>ViewRootImpl 身负了很多职责：</p><ol><li><strong>管理 View 树，且其是 View 的根</strong></li><li><strong>触发三大绘制流程：测量，布局，绘制</strong></li><li><strong>输入事件中转站</strong></li><li><strong>管理 Surface</strong></li><li><strong>负责与 WMS 通讯</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;<br>...<br>requestLayout();<span class="hljs-comment">//注释1</span><br>...<br>res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                            getHostVisibility(), mDisplay.getDisplayId(),<br>                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                            mAttachInfo.mOutsets, mInputChannel);<span class="hljs-comment">//注释2,看下面</span><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><p>requestLayout调用 scheduleTraversals</p><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl. java</p><ul><li>如下源码，ViewRootImpl 的 scheduleTraversals 方法注释1处在主线程 Handler <em>插入一个异步空消息，等到 Vsync 信号来时，Handler 会优先执行这个异步消息，保证绘制的优先级</em></li><li>注释2执行了 Choreographer. postCallback 方法，Choreographer 能够监听 Vsync 信号，当 Vsync 信号到来时执行 callback，也就是执行 mTraversalRunnable，它是 Runnable 对象</li></ul><p>[[1.Handler消息机制#「9、同步屏障和异步消息有具体的使用场景吗？」]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTraversals</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<span class="hljs-comment">//1</span><br>        mChoreographer.postCallback(<br>                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);<span class="hljs-comment">//2</span><br>        pokeDrawLockIfNeeded();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="performTraversals"><a href="#performTraversals" class="headerlink" title="performTraversals"></a>performTraversals</h4><p><strong>View 的绘制流程是从 ViewRoot（ViewRootImpl）的 performTraversals 方法开始的</strong>。所以 performTraversals 方法依次调用 performMeasure, performLayout 和 performDraw 三个方法。然后各自经历 measure、layout、draw 三个流程最终显示在用户面前。</p><p>mTraversalRunnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            doTraversal();<br>        &#125;<br>    &#125;<br>    <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTraversal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>            mTraversalScheduled = <span class="hljs-literal">false</span>;<br>            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br>            performTraversals();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-afa045848120d625f289795cd091bc3f-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191116143525-704839.png" alt="微信截图_20191116143525"></p><h3 id="addToDisplay"><a href="#addToDisplay" class="headerlink" title="addToDisplay"></a>addToDisplay</h3><p><strong>将 Window 添加到屏幕上</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">mWindowSession = WindowManagerGlobal.getWindowSession();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IWindowSession <span class="hljs-title function_">getWindowSession</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (WindowManagerGlobal.class) &#123;<br>        <span class="hljs-keyword">if</span> (sWindowSession == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">InputMethodManager</span> <span class="hljs-variable">imm</span> <span class="hljs-operator">=</span> InputMethodManager.getInstance();<br>                <span class="hljs-type">IWindowManager</span> <span class="hljs-variable">windowManager</span> <span class="hljs-operator">=</span> getWindowManagerService();<span class="hljs-comment">//1</span><br>                sWindowSession = windowManager.openSession(<span class="hljs-comment">//2</span><br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">IWindowSessionCallback</span>.Stub() &#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorScaleChanged</span><span class="hljs-params">(<span class="hljs-type">float</span> scale)</span> &#123;<br>                                        ValueAnimator.setDurationScale(scale);<br>                                &#125;<br>                        &#125;,<br>                        imm.getClient(), imm.getInputContext());<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sWindowSession;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mWindowSession 是 IWindowSession（<strong>看到 i 就是代理</strong>）类型的，它是一个 binder 对象，用于进程间通讯，IWindowSession 是 C 端代理，在 S 端使用的是 Session 类实现。addToDisplay 运行在<em>WMS 进程</em>中。</p><p>&#x3D;&#x3D;调用 WMS 的 addWindow 方法添加 Window，在 WMS 眼里，一切 View 都是以 Window 形式存在的，剩下的工作就交由 WMS 进行处理了&#x3D;&#x3D;</p><h2 id="View-post"><a href="#View-post" class="headerlink" title="View.post ()"></a>View.post ()</h2><p>为什么可以获取到宽高信息</p><ul><li><p>内部执行是通过 handler 去执行的， View. post 调用时会把 Runnable 保存到一个缓存数组中（handle. post, HandlerActionQueue），等到 View 加载到 Window 时会调用 View 的 dispatchAttachedToWindow 方法，然后通过 handler 执行 Runnable 方法，就可以获取到他的宽高。</p></li><li><p>在 onCreate () 和 onResume () 中是无法获取到宽高的，而 View. post () 回调中可以</p></li><li><p>setContentView () 逻辑很复杂，但干的事情很直白。创建 DecorView ，然后根据我们传入的布局文件 id 解析 xml，将得到的 view 塞进 DecorView 中。注意，到现在，<em>我们得到的只是一个空壳子 View 树，它并没有被添加到屏幕上</em>，其实也不能添加到屏幕上。所以，在 onCreate () 回调中获取视图宽高显然是不可取的。</p></li><li><p>View 是 Android 中视图的程序方式, View 不能单独存在, 必须依附 Window 这个抽象概念上, 因此有视图的地方就有 Window。</p></li><li><p>activity 所有界面的呈现都是在 window 上的，window 中的 type 是用来控制它的显示层级关系。</p></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><a href="https://juejin.cn/post/6895735092438630407">原理</a></h3><p>根据 ViewRootImpl 是否已经创建，View.post () 会执行不同的逻辑。如果 ViewRootImpl 已经创建，即 mAttachInfo 已经初始化，直接通过 Handler 发送消息来执行任务。如果 ViewRootImpl 未创建，即 View 尚未开始绘制，会将任务保存为 HandlerAction，暂存在队列 HandlerActionQueue 中，等到 View 开始绘制，执行 performTraversal () 方法时，在 dispatchAttachedToWindow () 方法中通过 Handler 分发 HandlerActionQueue 中暂存的任务。</p><p>performTraversal——》<em>dispatchAttachedToWindow</em></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-eebbd80772f6e7766c74a93ebc2e53c7-unknown_filename.18-2828ba.png" alt="unknown_filename.18"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-6e6fa98791128bb71fb71815dbb69241-unknown_filename.19-ceb3a1.png" alt="unknown_filename.19"></p><ul><li>如果 View 是 new 出来的，并且没有通过 addView 等方法依赖到 DecorView 上面，它的 post 方法也是不会执行的，因为它没有机会和 ViewRootImpl 进行互动了</li></ul><hr><h1 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h1><ul><li>简称Wms，WindowManagerService管理窗口的创建、更新和删除，显示顺序等，是WindowManager这个管理接品的真正的实现类。<em>它运行在System_server进程</em></li><li>WindowManager和WMS通过binder进行通讯，<strong>真正对Window添加，更新，删除等操作的执行者</strong>。</li><li>Window(phoneWindow)只控制视图</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023/09/18/15-27-17-7b8ce2ba48faf7df2be0706ff232c1cc-20230918152716-7c43ff.png" alt="image.png"></p><ul><li><em>一个Activity包含一个Window</em>，如果Activity没有Window，那就相当于Service</li><li>Activity只负责生命周期和事件处理</li><li>WindowManager 的 addView 方法调 viewRoot，和 wms 交互，display 显示</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Window有哪些属性？类型？层级关系？z-order？Window标志？"><a href="#Window有哪些属性？类型？层级关系？z-order？Window标志？" class="headerlink" title="Window有哪些属性？类型？层级关系？z-order？Window标志？"></a>Window有哪些属性？类型？层级关系？z-order？Window标志？</h3><ul><li><p>子窗口看名字就知道其是一个窗口的子窗口，所以<strong>不能独立存在，需要依附于父窗口存在</strong>，比如PopupWindow，Dialog等就属于子窗口</p></li><li><p>z-order：在Z轴上处于最高位置</p></li><li><p><strong>类型值越大，越靠近用户</strong>。通过上面分析可知：<strong>系统窗口&gt;子窗口&gt;应用程序窗口</strong>。 这也就是系统窗口会覆盖应用窗口最直接的原因。</p></li><li><p><strong>那么如果多个窗口都是应用程序窗口如何显示呢？</strong> WMS会结合实际情况，去显示窗口合适的层级。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-56b7a56c9359fd5ba35c627cbbebab1d-unknown_filename.15-c05d02.png" alt="unknown_filename.15"></p></li></ul><h4 id="Window-软键盘模式（SoftInputModel）"><a href="#Window-软键盘模式（SoftInputModel）" class="headerlink" title="Window 软键盘模式（SoftInputModel）"></a>Window 软键盘模式（SoftInputModel）</h4><p><strong>软键盘也是窗口的一种，属于系统窗口，层级较高，所以在一些场景下会覆盖层级较低的应用窗口</strong>。</p><h2 id="WMS中窗口容器树的概念"><a href="#WMS中窗口容器树的概念" class="headerlink" title="WMS中窗口容器树的概念"></a>WMS中窗口容器树的概念</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-10-21-6431e8ccbff114ae76ef1b6149cf4eb4-20230919102112-934b78.png" alt="image.png"></p><p><strong>容器</strong>：这个大家都熟悉，在WMS中通过继承WindowContainer类来实现容器机制：</p><p>而<strong>树</strong>就是说每个容器在作为父容器的时候，同时也可能是其他容器的子容器。<br><em>树结构</em><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023/09/19/09-41-33-59c840a8db2599bf274d36fcaf2c37ec-20230919094132-f97565.png" alt="image.png"></p><h3 id="WindowToken"><a href="#WindowToken" class="headerlink" title="WindowToken"></a>WindowToken</h3><p>WindowToken在窗口体系中有<strong>两个作用</strong>：</p><ul><li>1.<strong>应用组件标识</strong>：将属于同一个应用组件的窗口组织在一起，这里的应用组件可以是：Activity、InputMethod、Wallpaper以及Dream。 WMS在对窗口的管理过程中：用WindowToken来指代一个应用组件。例如在进行窗口的Z-Order排序时，属于同一个WindowToken的窗口会被安排在一起。</li><li>2.<strong>令牌作用</strong>：WindowToken由应用组件或其管理者负责向WMS声明并持有，应用组件在需要更新窗口时，需要向WMS提供令牌表明自己的身份， 并且窗口的类型必须与所持有的WindowToken的类型一致。</li></ul><p><strong>但是系统窗口是个例外，并不需要提供token，WMS会隐式声明一个WindowToken</strong>。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-10-14-4346405659237d9a54803fedd29aba99-20230919101417-d2075f.png" alt="image.png"></p><p><strong>Dialog 不能用 Application 的 Context</strong></p><p>我说不能，解释的是以前在崩溃日志中看到 Activity 不存在，但 Dialog 还存在，然后造成崩溃，后来使用 DialogFragment ，这样可以管理弹窗的生命周期，不再存在 Dialog 的崩溃。但不知道为什么 Dialog 不能使用 Application 的 Context。查了资料总结一下。</p><p>用 Application 的上下文来创建 Dialog，在调用它的 show 方法时程序会 Crash，LogCat 的异常信息如下：</p><blockquote><p>Caused by: android. view. WindowManager$BadTokenException: Unable to add window – token null is not for an application  </p></blockquote><p>Token：这里提到的 Token 主是指窗口令牌（Window Token），是一种特殊的 Binder 令牌，Wms 用它唯一标识系统中的一个窗口。必须在一个窗口上</p><hr><h2 id="输入事件处理"><a href="#输入事件处理" class="headerlink" title="输入事件处理"></a>输入事件处理</h2><p>[[5-事件分发机制#INPUT]]<br>通过<strong>sockets</strong>通信<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-10-16-fc013925201ce0608a7ccc073247bc91-20230919101628-b0a5f5.png" alt="image.png"></p><h2 id="Surface管理"><a href="#Surface管理" class="headerlink" title="Surface管理"></a>Surface管理</h2><p>WMS负责创建Surface以及对Surface的摆放工作，之后将Surface提交给SurfaceFlinger进行合并。 <strong>在App层也创建了一个Surface对象，但是那个是空对象，用于WMS的填充</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3-Activity 生命周期</title>
    <link href="/2025/12/0ee019040495.html"/>
    <url>/2025/12/0ee019040495.html</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>startSpecificActivityLocked ——&gt; realStartActivityLocked 设置 LaunchActivityItem 和 ResumeActivityItem——&gt; IApplicationThread. scheduleTransaction () </p><p> sendMessage ——&gt; EXECUTE_TRANSACTION (也是打开 activity 的 H)——&gt;execute——&gt; executeCallbacks (onCreate)——&gt;cycleToPath (onStart )——&gt;performLifecycleSequence ——&gt;handleResumeActivity ——&gt; onResume</p><h2 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h2><p>[[2-Activity进程启动流程#第二步]]</p><p>startActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">realStartActivityLocked</span> <span class="hljs-params">(ActivityRecord r, ProcessRecord app,</span><br><span class="hljs-params">                                          <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br>    ......<br><br>    <span class="hljs-comment">// 1. addCallback ()</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">clientTransaction</span> <span class="hljs-operator">=</span> ClientTransaction.obtain (app. thread,<br>                r.appToken);<br>    clientTransaction.addCallback (LaunchActivityItem.obtain (<span class="hljs-keyword">new</span> ...<br><br><br>    <span class="hljs-comment">// 2. setLifecycleStateRequest</span><br>         <span class="hljs-keyword">final</span> ActivityLifecycleItem lifecycleItem;<br>     <span class="hljs-keyword">if</span> (andResume) &#123;<br>         lifecycleItem = ResumeActivityItem.obtain (mService.isNextTransitionForward ());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        lifecycleItem = PauseActivityItem.obtain ();<br>    &#125;<br>     clientTransaction.setLifecycleStateRequest (lifecycleItem);<br><br>    <span class="hljs-comment">// 3. 调用 ClientLifecycleManager.scheduleTransaction ()</span><br>     mService.getLifecycleManager (). scheduleTransaction (clientTransaction);<br>    ......<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><code>addCallback()</code> 传入的参数是 <code>LaunchActivityItem</code> , 正是 <code>ClientTransactionItem</code> 的实现类。</li><li><code>setLifecycleStateRequest</code> 表示当前的 ClientTransaction 执行之后应该处于的最终生命周期状态 （ResumeActivityItem）。</li><li><code>mService.getLifecycleManager()</code> 返回的是 <code>ClientLifecycleManager</code> 对象，是 Android 9.0 新增的辅助处理生命周期的类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> &gt; ClientLifecycleManager.java<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">IApplicationThread</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> transaction.getClient(); <span class="hljs-comment">// -&gt; ApplicationThread</span><br>        transaction.schedule(); <span class="hljs-comment">// ClientTransaction</span><br>        <span class="hljs-keyword">if</span> (!(client <span class="hljs-keyword">instanceof</span> Binder)) &#123;<br>            <span class="hljs-comment">// If client is not an instance of Binder - it&#x27;s a remote call and at this point it is</span><br>            <span class="hljs-comment">// safe to recycle the object. All objects used for local calls will be recycled after</span><br>            <span class="hljs-comment">// the transaction is executed on client in ActivityThread.</span><br>            transaction.recycle();<br>        &#125;<br>    &#125;<br>    <br>&gt; ClientTransaction.java<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-comment">// 调用 ActivityThread.ApplicationThread.scheduleTransaction()</span><br>        mClient.scheduleTransaction(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>首先明确一点，到目前为止的方法调用都处于 AMS 所在进程，并不是我们的应用进程，会调用到 App 的 ApplicationThread</p><h2 id="回到-App"><a href="#回到-App" class="headerlink" title="回到 App"></a>回到 App</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IApplicationThread</span>.Stub &#123;<br>        ......<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-comment">// 这里调用的是父类 ClientTransactionHandler 的 scheduleTransaction() 方法</span><br>            ActivityThread.<span class="hljs-built_in">this</span>.scheduleTransaction(transaction);<br>        &#125;<br>        ......<br>&#125;<br><br>&gt; ClientTransactionHandler.java<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>        transaction.preExecute(<span class="hljs-built_in">this</span>);java<br>        <span class="hljs-comment">// sendMessage() 方法在 ActivityThread类中实现</span><br>        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>H 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            ......<br>             <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> (ClientTransaction) msg.obj;<br>                    <span class="hljs-comment">// 执行 TransactionExecutor.execute()</span><br>                    mTransactionExecutor.execute(transaction);<br>                    <span class="hljs-keyword">if</span> (isSystem()) &#123;<br>                        transaction.recycle();<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>            ......<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="TransactionExecutor"><a href="#TransactionExecutor" class="headerlink" title="TransactionExecutor"></a>TransactionExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span> <span class="hljs-params">(ClientTransaction transaction)</span> &#123;          <br>    executeCallbacks (transaction);<br>    <span class="hljs-comment">// 执行生命周期状态</span><br>    executeLifecycleState (transaction);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>addCallback ()</strong> &gt;&gt;&gt; <strong>executeCallbacks ()</strong><br><strong>setLifecycleStateRequest</strong> &gt;&gt;&gt; <strong>executeLifecycleState ()</strong></p><p><code>executeCallbacks ()</code> 会执行 <code>addCallback ()</code> 方法添加的生命周期回调。当前添加的是 <code>LaunchActivityItem</code> 。</p><p><code>executeLifecycleState ()</code> 方法会将当前生命周期同步到 <code>setLifecycleStateRequest ()</code> 方法设置的生命周期状态。当前设置的是 <code>ResumeActivityItem</code> 。</p><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h3><p>TransactionExecutor.executeCallbacks</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; TransactionExecutor. java<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCallbacks</span> <span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>        <span class="hljs-keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks ();<br><br>        ......<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> callbacks.size ();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransactionItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> callbacks.get (i);<br>            ......<br>            item.execute (mTransactionHandler, token, mPendingActions);<br>            item.postExecute (mTransactionHandler, token, mPendingActions);<br>            ......<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>调用 <code>XXXActivityItem</code> 的 <code>execute ()</code> 和 <code>postExecute ()</code> 方法。例如：LaunchActivityItem、ActivityResultItem 等等，<code>execute ()</code> 方法中会 Binder 调用 <code>ActivityThread</code> 中对应的 <code>handleXXXActivity ()</code> 方法，performXXXXActivity</p><h4 id="performLaunchActivity"><a href="#performLaunchActivity" class="headerlink" title="performLaunchActivity"></a>performLaunchActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; ActivityThread.java<br><br>    <span class="hljs-keyword">private</span> Activity <span class="hljs-title function_">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> &#123;<br>        <span class="hljs-type">ActivityInfo</span> <span class="hljs-variable">aInfo</span> <span class="hljs-operator">=</span> r.activityInfo;<br><br>        <span class="hljs-comment">// 获取 Context</span><br>        <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> createBaseContextForActivity(r);<br>        <span class="hljs-type">Activity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> appContext.getClassLoader();<br>        <span class="hljs-comment">// 反射创建 Activity</span><br>        activity = mInstrumentation.newActivity(<br>                cl, component.getClassName(), r.intent);<br><br>        <span class="hljs-comment">// 获取 Application系统永远不会直接终止 Activity 以释放内存，而是会终止 Activity 所在的进程。系统不仅会销毁 Activity，还会销毁在该进程中运行的所有其他内容。</span><br>        <span class="hljs-keyword">if</span> (activity != <span class="hljs-literal">null</span>) &#123;<br><br>            activity.attach(appContext, <span class="hljs-built_in">this</span>, getInstrumentation(), r.token,<br>                    r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                    r.embedded  <span class="hljs-comment">// 获取 Context</span><br>                    CID, r.lastNonConfigurationInstances, config,<br>                    r.referrer, r.voiceInteractor, window, r.configCallback);<br><br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">theme</span> <span class="hljs-operator">=</span> r.activityInfo.getThemeResource();<br>            <span class="hljs-keyword">if</span> (theme != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 设置主题</span><br>                activity.setTheme(theme);<br>            &#125;<br><br>            activity.mCalled = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 执行 onCreate()</span><br>            <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mInstrumentation.callActivityOnCreate(activity, r.state);<br>            &#125;<br>            r.activity = activity;<br>        &#125;<br>        r.setState(ON_CREATE);<br><br>        mActivities.put(r.token, r);<br><br><br>        <span class="hljs-keyword">return</span> activity;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>callActivityOnCreate &gt;&gt;&gt; performCreate &gt;&gt;&gt; 最后调用 onCreate</p><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; TransactionExecutor.java<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeLifecycleState</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ActivityLifecycleItem</span> <span class="hljs-variable">lifecycleItem</span> <span class="hljs-operator">=</span> transaction.getLifecycleStateRequest();<br>        <span class="hljs-keyword">if</span> (lifecycleItem == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// No lifecycle request, return early.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ......<br><br>        <span class="hljs-comment">// Cycle to the state right before the final requested state.</span><br>        cycleToPath(r, lifecycleItem.getTargetState(), <span class="hljs-literal">true</span> <span class="hljs-comment">/* excludeLastState */</span>);<br><br>        <span class="hljs-comment">// Execute the final transition with proper parameters.</span><br>        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);<br>        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>现在是 ResumeActivityItem,方法体内直接调用其 <code>execute()</code> 方法。和 <code>onCreate()</code> 的套路是一模一样的，调用 <code>ActivityThread.handleResumeActivity()</code> ，接着是 <code>Instrumentation.callActivityOnResume()</code> ，最后回调 <code>Activity.onResume()</code> 。</p><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h3><p>cycleToPath</p><p>正常的生命周期流程应该是 <code>onCreate () -&gt; onStart () -&gt; onResume ()</code> ,但是代码中好像又没有显示调用。其实是在 <code>executeLifecycleState ()</code> 中的 <code>cycleToPath ()</code> 方法中做了生命周期的同步。简单说就是，当前处于 <code>onCreate ()</code> 状态，<code>setLifecycleState ()</code> 设置的 <strong>final state</strong> 是 <strong>onResume ()</strong> ，就需要执行 onCreate 到 onResume 之间的状态，即 <code>onStart ()</code> 。</p><p><code>getLifecyclePath</code> 计算出中间的生命周期</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-04-11-41-d10c6510995be95c11c671bccaa261ad-18-23-14-d10c6510995be95c11c671bccaa261ad-unknown_filename.30-c8cf82-c39fc8.png" alt="unknown_filename.30|600|600"></p><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h3><p>在 <code>resumeTopActivityInnerLocked</code> 中会先对 resume 状态的 activity 执行 pause。</p><h2 id="为什么-Activity-finish-之后-10s-才-onDestroy-？"><a href="#为什么-Activity-finish-之后-10s-才-onDestroy-？" class="headerlink" title="为什么 Activity.finish() 之后 10s 才 onDestroy ？"></a>为什么 Activity.finish() 之后 10s 才 onDestroy ？</h2><p>Activity 的 <em>onStop&#x2F;onDestroy 是依赖 IdleHandler 来回调的，正常情况下当主线程空闲时会调用</em>。但是由于某些特殊场景下的问题，导致主线程迟迟无法空闲，onStop&#x2F;onDestroy 也会迟迟得不到调用。但这并不意味着 Activity 永远得不到回收，系统提供了一个兜底机制，<em>当 onResume 回调 10s 之后，如果仍然没有得到调用，会主动触发。</em></p><p>虽然有兜底机制，但无论如何这肯定不是我们想看到的。如果我们项目中的 onStop&#x2F;onDestroy 延迟了 10s 调用，该如何排查问题呢？可以利用 <code>Looper.getMainLooper().setMessageLogging()</code> 方法，打印出主线程消息队列中的消息。每处理一条消息，都会打印如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br></code></pre></td></tr></table></figure><p>另外，由于 <code>onStop/onDestroy</code> 调用时机的不确定性，在做资源释放等操作的时候，一定要考虑好，以避免产生资源没有及时释放的情况。<br>不要做耗时操作，例如：循环动画</p><h3 id="是谁指挥着-onStop-onDestroy-的调用？"><a href="#是谁指挥着-onStop-onDestroy-的调用？" class="headerlink" title="是谁指挥着 onStop&#x2F;onDestroy 的调用？"></a>是谁指挥着 onStop&#x2F;onDestroy 的调用？</h3><p>在 Activity 跳转过程中，为了保证流畅的用户体验，只要前一个 Activity 与用户不可交互，即 onPause() 被回调之后，下一个 Activity 就要开始自己的生命周期流程了。所以 <code>onStop/onDestroy</code> 的调用时间是不确定的，甚至像文章开头的例子中，整整过了 10s 才回调。那么，到底是由谁来驱动 <code>onStop/onDestroy</code> 的执行呢？我们来看看下一个 Activity 的 onResume 过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; ActivityThread.java<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-type">boolean</span> finalStateRequest, <span class="hljs-type">boolean</span> isForward,</span><br><span class="hljs-params">        String reason)</span> &#123;<br>    ......<br>    <span class="hljs-comment">// 回调 onResume</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ActivityClientRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> performResumeActivity(token, finalStateRequest, reason);<br>    ......<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Activity</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> r.activity;<br>    ......<br>    <span class="hljs-keyword">if</span> (r.window == <span class="hljs-literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;<br>        ......<br>        <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;<br>            <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;<br>                a.mWindowAdded = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 添加 decorView 到 WindowManager</span><br>                wm.addView(decor, l);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a.onWindowAttributesChanged(l);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>        ......<br>    &#125;<br>    ......<br><br>    <span class="hljs-comment">// 主线程空闲时会执行 Idler</span><br>    Looper.myQueue().addIdleHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Idler</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h3><p>在完成最终的界面绘制和显示之后，有这么一句代码 <code>Looper.myQueue().addIdleHandler(new Idler())</code> 。<code>IdleHandler</code> 不知道大家是否熟悉，它提供了一种机制，当主线程消息队列空闲时，会执行 IdleHandler 的回调方法。至于怎么算 “空闲”，我们可以看一下 <code>MessageQueue.next()</code> 方法。</p><p>[[4.IdleHandler]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; MessageQueue.java<br><br>Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    ......<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 阻塞方法，主要是通过 native 层的 epoll 监听文件描述符的写入事件来实现的。</span><br>        <span class="hljs-comment">// 如果 nextPollTimeoutMillis = -1，一直阻塞不会超时。</span><br>        <span class="hljs-comment">// 如果 nextPollTimeoutMillis = 0，不会阻塞，立即返回。</span><br>        <span class="hljs-comment">// 如果 nextPollTimeoutMillis &gt; 0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// msg.target == null表示此消息为消息屏障（通过postSyncBarrier方法发送来的）</span><br>                <span class="hljs-comment">// 如果发现了一个消息屏障，会循环找出第一个异步消息（如果有异步消息的话），所有同步消息都将忽略（平常发送的一般都是同步消息）</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// 消息触发时间未到，设置下一次轮询的超时时间</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 得到 Message</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    msg.markInUse(); <span class="hljs-comment">// 标记 FLAG_IN_USE</span><br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>            ......<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 两个条件：</span><br><span class="hljs-comment">             * 1. pendingIdleHandlerCount = -1</span><br><span class="hljs-comment">             * 2. 此次取到的 mMessage 为空或者需要延迟处理</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 没有 idle handler 需要运行，继续循环</span><br>                mBlocked = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// 下一次 next 时，pendingIdleHandlerCount 又会被置为 -1，不会导致死循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行 Idler</span><br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将 pendingIdleHandlerCount 置零</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>在正常的消息处理机制之后，额外对 IdleHandler 进行了处理。当本次取到的 Message 为空或者需要延时处理的时候，就会去执行 <code>mIdleHandlers</code> 数组中的 IdleHandler 对象。其中还有一些关于 pendingIdleHandlerCount 的额外逻辑来防止循环处理。</li><li>当新的 Activity 完成页面绘制并显示之后，主线程就可以停下歇一歇，来执行 <code>IdleHandler</code> 了。再回来 <code>handleResumeActivity()</code> 中来，<code>Looper.myQueue().addIdleHandler(new Idler())</code> ，这里的 <code>Idler</code> 是 <code>IdleHandler</code> 的一个具体实现类。</li><li>最后获取要 stop 的 Activity，该 stop 的 stop，该 destroy 的 destroy</li></ul><h3 id="stop-和-destroy-系统10s兜底"><a href="#stop-和-destroy-系统10s兜底" class="headerlink" title="stop 和 destroy 系统10s兜底"></a>stop 和 destroy 系统10s兜底</h3><p>在 <code>ActivityRecord.completeResumeLocked</code> 会在 activity resume 之后调用，在这个方法中会调用<br>ActivityStackSuperVisor.scheduleIdleTimeoutLocked()，即使主线程迟迟没有机会执行 Idler，系统仍然提供了兜底机制，防止已经不需要的 Activity 长时间无法被回收，从而造成内存泄漏等问题。<br>&#96;</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&gt; ActivityStackSuperVisor.java<br><br><span class="hljs-keyword">void</span> scheduleIdleTimeoutLocked(ActivityRecord <span class="hljs-keyword">next</span>) &#123;<br>    Message msg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG, <span class="hljs-keyword">next</span>);<br>    mHandler.sendMessageDelayed(msg, IDLE_TIMEOUT);   <span class="hljs-comment">//IDLE_TIMEOUT= 10*1000</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>  应用进程发起请求 -&gt; <code>AMS</code> 处理请求(对 <code>Activity</code> 发起 <code>pause</code> 生命周期) -&gt; 应用进程处理 <code>pause</code> 生命周期 (处理完成后通知 <code>AMS</code>) -&gt; <code>AMS</code> 预处理 finishing 的 <code>Activity</code> (将 <code>Activity</code> 添加至 <code>stop</code> 队列中，开启一个 10s 延迟任务) -&gt; <code>AMS</code> <code>resume</code> 一个新的 <code>Activity</code> -&gt; 应用进程执行新 <code>Activity</code> 的 <code>resume</code> 生命周期，完成后开启一个 <code>IdleHandler</code> (<code>IdleHandler</code> 执行时会通知 <code>AMS</code>) -&gt; <code>AMS</code> 处理 <code>stop</code> 列表中的 <code>Activity</code> （首先清除前面的延迟任务，然后发送 <code>destory</code> 生命周期到应用进程）-&gt; 应用进程处理 <code>destroy</code> 生命周期。</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2-Activity进程启动流程</title>
    <link href="/2025/12/cd8c25862b1a.html"/>
    <url>/2025/12/cd8c25862b1a.html</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><p>App 的入口，启动 App 后，会调用 ActivityThread.main ()，开启 Looper、MessageQueue，与 ActivityManagerService 配合完成对 Activity 的管理。就是主线程</p><h3 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h3><p>负责了系统中四大组件的启动、切换、应用进程管理（<code>创建进程</code>）。（是一个 system service 进程，系统进程，和一个 APP 一样）</p><p>activity 相关都交给了 ActivityTaskManagerService<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-51ea737c26f17886b89be17097c0d78b-unknown_filename.6-6cb56f.png" alt="unknown_filename.6|600"></p><h3 id="ActivityTaskManagerService"><a href="#ActivityTaskManagerService" class="headerlink" title="ActivityTaskManagerService"></a>ActivityTaskManagerService</h3><ul><li>启动应用程序 Activity 已经走到 ActivityTaskManagerService 中，如果你熟悉前以往版本的 Android 源码，你肯定会知道 ActivityManagerService，而在 Android 10 中则将 AMS 用于管理 Activity 及其容器（任务，堆栈，显示等）的系统服务分离出来放到 ATMS 中，也许是谷歌不想让 AMS 的代码越来越膨胀吧 (Android 10中 AMS 代码有一万九千行</li><li>ATMS 负责管理系统所有 Activity，所以应用 startActivity 最终会通过 Binder 调用到 ATMS 的 startActivity 方法，<em>ATMS 启动一个 Activity 之前会做一些检查，例如权限、是否在清单文件注册，是否需要创建新的进程</em>等，然后就可以启动了，ATMS 是一个系统服务，又涉及到跨进程调用，这个跨进程同样采用 Binder，媒介是通过 ActivityThread 的内部类 ApplicationThread，AMS 将生命周期跨进程传到 ApplicationThread，然后 ApplicationThread 再分发给 ActivityThread 内部的 Handler，这时候生命周期已经回调到应用主线程了，回调 Activity 的各个生命周期方法。</li></ul><hr><h2 id="打开-Acitivty-整个流程"><a href="#打开-Acitivty-整个流程" class="headerlink" title="打开 Acitivty 整个流程"></a>打开 Acitivty 整个流程</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-27b38029d68f8867bb9055f66953c809-unknown_filename.12-33049a.png" alt="unknown_filename.12|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-95449b20b6c9852922fb2d96b1cc2b3d-unknown_filename.14-ace3d6.png" alt="unknown_filename.14"></p><ol><li>点击图标后 Launcher 进程会通过 Binder 向 AMS 发起打开 Activity 的请求【IPC-&gt;Binder】</li><li>AMS 会通过 ActivityStarter 处理 Intent 和 Flag 启动模式等相关内容，做一些检查，例如权限、是否在清单文件注册，是否需要创建新的进程，如果需要创建进程，通过 Socket 通知 zygote 进程【IPC-&gt;Socket】</li><li>zygote 进程会进行孵化 (虚拟机和资源的复制)，然后 fork 出新进程（然后在新的进程里）</li><li>然后 zygote 进程会通过 invokeDynamicMain ()方法调用到 ActivityThread 的 main 方法（也就是 APP 的入口）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   ...<br>       Looper.prepareMainLooper();<br>       ...<br>       <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>       thread.attach(<span class="hljs-literal">false</span>, startSeq);<br><br>       <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>           sMainThreadHandler = thread.getHandler();<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>           Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                   <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>       &#125;<br>       Looper.loop();<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>主线程 Looper 和 Handler 的创建、开启主线程 Looper 的消息循环。</li><li><em>ActivityThread. attach</em> () 建立 Binder 通道</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-type">boolean</span> system, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>  ...<br>          <span class="hljs-keyword">final</span> <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManager.getService();<br>          <span class="hljs-keyword">try</span> &#123;<br>              mgr.attachApplication(mAppThread, startSeq);<br>          &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>              <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>          &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>IActivityManager. attachApplication—-&gt;（通知 AMS 打开 activity  RootActivityContainer (attachApplication)—-&gt; realStartActivityLocked—-&gt;scheduleTransaction）</li><li>完了以后AMS 会发送消息</li><li>ApplicationThread 收到 EXECUTE_TRANSACTION，通过 handler 调用 performLaunchActivity</li><li>ActivityThread.<strong>performLaunchActivity</strong>() 中<ul><li>loadApk 反射创建 application，activity</li><li>activity. attach 里 window，windowmanager 创建出来，和 activity 建立联系 [[4-WMS#整个流程]]</li><li>mInstrumentation.callActivityOnCreate 调 prePerformCreate</li><li>Activity.onCreate () 调用 setContentView ()  解析xml，最后通过 phoneWindow 把 DecorView 创建出来了</li></ul><ul><li>然后在 onResume，WindowManager 的 addview 方法将 DecorView 与 WindowManager 建立联系，然后创建了 viewRootImpl，并将 ViewRootImpl 对象和 DecorView 建立关联（assignParent）</li><li>接着 ViewRootImpl 的 setView 里面有 requestLayout——&gt;performTraversals——&gt;三大流程绘制</li></ul></li></ul><h2 id="android10-Activity-启动流程详细"><a href="#android10-Activity-启动流程详细" class="headerlink" title="android10 Activity 启动流程详细"></a>android10 Activity 启动流程详细</h2><p><a href="https://juejin.cn/post/6844904145191698439#heading-8">https://juejin.cn/post/6844904145191698439#heading-8</a><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-155430bcadc03ce93d114047b4a63d85-unknown_filename.7-23198f.png" alt="unknown_filename.7|1000"></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-81fd0032ee230240c587cd5b2be21dd7-unknown_filename.8-d21f73.png" alt="unknown_filename.8|1200"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-8c2fe6a21bd76b16791f70c03d6bffb7-unknown_filename.9-2d73fc.png" alt="unknown_filename.9|1200"></p><p>如果进程 没创建创建进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//ActivityStackSupervisor.java</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">startSpecificActivityLocked</span><span class="hljs-params">(ActivityRecord r, <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">WindowProcessController</span> <span class="hljs-variable">wpc</span> <span class="hljs-operator">=</span><br>                mService.getProcessController(r.processName, r.info.applicationInfo.uid);<br><br>        <span class="hljs-keyword">if</span> (wpc != <span class="hljs-literal">null</span> &amp;&amp; wpc.hasThread()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// app.thread 不为空，表示对应的进程存在，直接启动activity</span><br>                realStartActivityLocked(r, wpc, andResume, checkConfig); <span class="hljs-comment">//打开acitivty</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>      ...<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//startProcess   进程不存在，创建进程</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> PooledLambda.obtainMessage(<br>                    ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,<br>                    r.info.applicationInfo, knownToBeDead, <span class="hljs-string">&quot;activity&quot;</span>, r.intent.getComponent());<br>            mService.mH.sendMessage(msg);<br>        &#125; <br>    &#125;<br><br><br><span class="hljs-comment">/** Target client. */</span><br>    <span class="hljs-keyword">private</span> IApplicationThread mClient;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        mClient.scheduleTransaction(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//1 </span><br>    &#125;<br></code></pre></td></tr></table></figure><p>mClient 则代表要启动的应用程序进程的 IApplicationThread，而当前还处于 ATMS 服务的进程，也就是 SystemServer 进程，这时 ATMS 要与即将启动的应用程序进程通信则通过 IApplicationThread 来执行 AIDL</p><p>IApplicationThread 实现为 ApplicationThread，它是 ActivityThread 的内部类，所以前面也说过 ApplicationThread 为进程间通信的桥梁。</p><p>注释1处则相当于是 IApplicationThread. scheduleTransaction，并将包含要启动 Activity 信息的 ClientTransaction 传递到了应用程序进程</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>回到 APP 中的是这个消息：<em>EXECUTE_TRANSACTION</em><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-a2a0bb9857bc6e0e5ce13b879546d696-unknown_filename.10-42b69c.png" alt="unknown_filename.10"></p><p>ActivityThread 关键方法<br>下面在 <em>performLaunchActivity</em> 代码中<br>想想代码： [[3-Activity 生命周期#performLaunchActivity]]</p><p>注释1处获取了前面保存启动应用程序信息的 ActivityClientRecord 中的应用程序信息，包括应用程序在清单文件中注册了哪些四大组件，启动的根 Activity 是什么，<br>并在注释2处通过 getPackageInfo 方法获取 LoadedApk 描述对应 Apk 文件资源，<br>注释3处的 ComponentName 类获取则对应启动 Activity 的包名和类名，<br>注释4处则生成了启动应用程序的 Base 上下文环境 Context，<br>注释5处通过注释3获取的类名，通过类加载器和 Intent 对象实例化了 Activity 对象，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> @<span class="hljs-selector-tag">NonNull</span> <span class="hljs-selector-tag">Activity</span> <span class="hljs-selector-tag">instantiateActivity</span> (<span class="hljs-variable">@NonNull</span> ClassLoader cl, <span class="hljs-variable">@NonNull</span> String className,<br>        <span class="hljs-variable">@Nullable</span> Intent intent)<br>        <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">InstantiationException</span>, <span class="hljs-selector-tag">IllegalAccessException</span>, <span class="hljs-selector-tag">ClassNotFoundException</span> &#123;<br>    <span class="hljs-selector-tag">return</span> (Activity) <span class="hljs-selector-tag">cl</span><span class="hljs-selector-class">.loadClass</span> (className). <span class="hljs-selector-tag">newInstance</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><p>注释6则根据注释2处获取 Apk 描述对象 LoadedApk 创建了应用程序的 Application 对象，并在 makeApplication 方法中调用了它的 OnCreate 方法，所以应用程序最新启动的是 Application 才到根 Activity</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">public</span> @<span class="hljs-selector-tag">NonNull</span> <span class="hljs-selector-tag">Application</span> <span class="hljs-selector-tag">instantiateApplication</span> (<span class="hljs-variable">@NonNull</span> ClassLoader cl,<br>        <span class="hljs-variable">@NonNull</span> String className)<br>        <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">InstantiationException</span>, <span class="hljs-selector-tag">IllegalAccessException</span>, <span class="hljs-selector-tag">ClassNotFoundException</span> &#123;<br>    <span class="hljs-selector-tag">return</span> (Application) <span class="hljs-selector-tag">cl</span><span class="hljs-selector-class">.loadClass</span> (className). <span class="hljs-selector-tag">newInstance</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><p>注释7处则前面创建的 Context、Application、Window 对象与 Activity 关联来初始化 Activity，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> attach (Context <span class="hljs-keyword">context</span>, ActivityThread aThread,<br>                      Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,<br>                      Application application, Intent intent, ActivityInfo info,<br>                      CharSequence title, Activity parent,...) &#123;<br>        attachBaseContext (<span class="hljs-keyword">context</span>);<br>        ...<br>        mWindow = <span class="hljs-keyword">new</span> PhoneWindow (<span class="hljs-keyword">this</span>, window, activityConfigCallback);<br>        ...<br>        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-literal">null</span>) &#123;<br>            mWindow<span class="hljs-variable">.setContainer</span> (mParent<span class="hljs-variable">.getWindow</span> ());<br>        &#125;<br>        mWindowManager = mWindow<span class="hljs-variable">.getWindowManager</span> ();<br>         ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>最后注释8处还继续调用了 Instrumentation 对象的 callActivityOnCreate 方法。调用 onCreate 方法</p><p><strong>四大组件主线程的消息模型</strong><br>重要<br>  主线程消息循环开始以后, ActivityThread 还需要一个 handler 来和消息队列进行交互, 这个 handler 就是 ActivityThread. H，它内部定义了一组消息类型，包括四大组件的启动和停止等过程。<br>   ActivityThread 通过<strong>ApplicationThread 和 AMS 进行进程通信</strong>，AMS 以进程通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 会向 H 发送消息（sendMessage）, H 收到消息后会将 ApplicationThread 逻辑切换到 ActivityThread 中去执行, 即切换到主线程中执行, 这就是主线程的消息模型（binder 线程到主线程）。</p><h3 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h3><p>ActivityManager 是客户端用来管理系统中正在运行的所有 Activity 包括 Task、Memory、Service 等的一些信息。在 ActivityManager 中有大量的 get ()方法，他只是提供信息给 AMS，由 AMS 去完成交互和调度工作。AMS 和 ActivityManager 之间通信需要利用 Binder 来完成。<br>有这些方法：<br>getLargeMemoryClass、getTotalRam、getAppTasks、moveTaskToFront、getMemoryInfo<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-9dc4315bdf0d17dcbe8433a53c846b85-unknown_filename.11-5d2ef9.png" alt="unknown_filename.11"></p><hr><h2 id="应用程序进程启动流程"><a href="#应用程序进程启动流程" class="headerlink" title="应用程序进程启动流程"></a>应用程序进程启动流程</h2><p>深入理解 Android 之应用程序进程启动流程 (Android 10) - 掘金<br><a href="https://juejin.cn/post/6844904119803576333#commen">https://juejin.cn/post/6844904119803576333#commen</a></p><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor. java<br>打开 activity 时发现应用没启动，就创建进程</p><h3 id="ActivityManagerService-到-Zygote"><a href="#ActivityManagerService-到-Zygote" class="headerlink" title="ActivityManagerService 到 Zygote"></a>ActivityManagerService 到 Zygote</h3><p><strong>ActivityManagerInternal 实现类 LocalService 是 SystemServer 进程的本地服务 Service</strong>，通过本地服务注册到 <em>LocalServices</em> 中，而 AMS 也是运行在 SystemServer 进程，则可以直接使用 LocalService。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-3b4bfcfc5ab8d5feab918b3118b87235-unknown_filename.1-252c87.png" alt="unknown_filename.1|1300"></p><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ZygoteProcess. java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attemptConnectionToPrimaryZygote</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-keyword">if</span> (primaryZygoteState == <span class="hljs-literal">null</span> || primaryZygoteState.isClosed ()) &#123;<br>primaryZygoteState =<br>ZygoteState.connect (mZygoteSocketAddress, mUsapPoolSocketAddress);<span class="hljs-comment">//1</span><br><br>maybeSetApiBlacklistExemptions (primaryZygoteState, <span class="hljs-literal">false</span>);<br>maybeSetHiddenApiAccessLogSampleRate (primaryZygoteState);<br>maybeSetHiddenApiAccessStatslogSampleRate (primaryZygoteState);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由注释1调用 ZygoteState 的 connect 方法来打开 Socket 连接，mZygoteSocketAddress 则是<em>名称为 zygote</em> 的 Socket 服务, 并传递启动应用程序进程参数</p><h3 id="Zygote-启动应用程序进程"><a href="#Zygote-启动应用程序进程" class="headerlink" title="Zygote 启动应用程序进程"></a>Zygote 启动应用程序进程</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-2f8c6283e6f2485e401a1b6fcbb9b786-unknown_filename.2-98e541.png" alt="unknown_filename.2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">zygoteSocketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zygote&quot;</span>;<span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p>注释3出设置 Socket 连接名称为 zygote</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">caller = zygoteServer.runSelectLoop (abiList);<span class="hljs-comment">//8</span><br><span class="hljs-keyword">if</span> (caller != <span class="hljs-literal">null</span>) &#123;<br>          caller.run (); <span class="hljs-comment">//9</span><br>      &#125;<br>    <br><br></code></pre></td></tr></table></figure><p>注释8的 runSelectLoop 方法则是 Zygote 进程等待接收 AMS 请求启动应用程序进程的关键方法，如果获取到就执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable <span class="hljs-title function_">processOneCommand</span> <span class="hljs-params">(ZygoteServer zygoteServer)</span> &#123;<br>...<br>args = Zygote.readArgumentList (mSocketReader);<br>    <br></code></pre></td></tr></table></figure><p>传过来的参数有：进程 ID、包名</p><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteServer. java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable <span class="hljs-title function_">runSelectLoop</span> <span class="hljs-params">(String abiList)</span> &#123;<br>        ......<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>   ...<br>                    <span class="hljs-comment">//   从 Zygote 服务器套接字接受会话套接字</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ZygoteConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> peers.get (pollIndex);<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> connection.processOneCommand (<span class="hljs-built_in">this</span>); <span class="hljs-comment">//1</span><br>                        ......<br>                            <span class="hljs-keyword">return</span> command;<br>                        &#125; <br>        .......                <br>    &#125;<br></code></pre></td></tr></table></figure><p>通过一个死循环等待接收请求, 底层 Native fork 进程，if (pid &#x3D;&#x3D; 0) 就创建成功，创建成功后创建 binder 线程池、则当前应用程序就拥有了 Binder 通信的能力，通过反射创建 android. app. ActivityThread，调用 main 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">findStaticMain</span> <span class="hljs-params">(String className, String[] argv,</span><br><span class="hljs-params">           ClassLoader classLoader)</span> &#123;<br>       Class&lt;?&gt; cl;<br>    <br>       <span class="hljs-keyword">try</span> &#123;<br>           cl = Class.forName (className, <span class="hljs-literal">true</span>, classLoader);<span class="hljs-comment">//1</span><br>       &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<br>                   <span class="hljs-string">&quot;Missing class when invoking static main &quot;</span> + className,<br>                   ex);<br>       &#125;<br>    <br>       Method m;<br>       <span class="hljs-keyword">try</span> &#123;<br>           m = cl.getMethod (<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String[]. class &#125;);<span class="hljs-comment">//2</span><br>       &#125; <br>       ......<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAndArgsCaller</span> (m, argv);<br>   &#125;<br>    <br></code></pre></td></tr></table></figure><p>run 调用 main 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAndArgsCaller</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mMethod.invoke (<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; mArgs &#125;); <span class="hljs-comment">//1</span><br>        &#125; <br>        ...<br>    &#125;<br>&#125;<br>    <br><br></code></pre></td></tr></table></figure><p>ActivityThread 是每个应程序主线程的管理类，到此，应用程序进程启动完成，当 ATMS 与应用程序 Binder 通信通过 IApplicationThread 为 ActivityThread 的内部类，然后调用 ActivityThread 的 performLaunchActivity 方法来启动 Activity。</p><h3 id="Socket-通信方式"><a href="#Socket-通信方式" class="headerlink" title="Socket 通信方式"></a>Socket 通信方式</h3><p>Socket 通信方式也是 C&#x2F;S 架构，在 Android 系统中采用 Socket 通信方式的主要有：</p><ul><li>zygote：用于孵化进程，system_server 创建进程是通过 socket 向 zygote 进程发起请求；</li><li>installd：用于安装 App 的守护进程，上层 PackageManagerService 很多实现最终都是交给它来完成；<br>  Socket 方式更多的用于 Android framework 层与 native 层之间的通信.</li></ul><p><strong>ZygoteServer</strong><br>ZygoteServer 类负责创建和管理 Zygote 的服务器套接字。通过 LocalServerSocket 创建</p><p>具体来说，通过调用 ServerSocket 类的构造函数创建一个服务器套接字 ServerSocket 对象，并绑定到指定的端口上。然后使用 ServerSocket 对象的 accept () 方法监听客户端的连接请求。</p><p>一旦有客户端发起连接请求，accept () 方法会返回一个新的 Socket 对象，表示与客户端建立的连接。然后，可以使用返回的 Socket 对象与客户端进行通信，发送和接收数据（getInputStream）。</p><p>这里的 Zygote 服务器套接字负责监听并接受来自客户端的命令请求，然后根据请求的内容执行相应的操作，并将结果返回给客户端。在 zygoteServer.<em>runSelectLoop</em> (abiList) 中的循环中，不断接收和处理客户端的请求</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-67e0b45bba566013f3e9e592a3f63fce-unknown_filename.15-57bc32.png" alt="unknown_filename.15|1000"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-2f8c6283e6f2485e401a1b6fcbb9b786-unknown_filename.2-98e541.png" alt="unknown_filename.2"></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="SystemServiceManager-和-ServiceManager-的区别和作用"><a href="#SystemServiceManager-和-ServiceManager-的区别和作用" class="headerlink" title="SystemServiceManager 和 ServiceManager 的区别和作用"></a>SystemServiceManager 和 ServiceManager 的区别和作用</h3><p>[[多进程Binder#ServiceManager]]</p><ul><li><strong>ServiceManager</strong>：是一个通用的服务管理类，用于管理系统中所有服务。</li><li><strong>SystemService</strong>：是一个具体的 ServiceManager 实例，用于管理系统服务。</li></ul><p>作用</p><ul><li><strong>ServiceManager</strong>：提供通用的服务管理功能，包括服务注册、服务获取、服务启动、服务停止等。其他进程可以通过ServiceManager获取SystemServiceManager实例，并通过SystemServiceManager来访问系统服务。</li><li><strong>SystemService</strong>：用于管理系统服务，包括ActivityManagerService、WindowManagerService、PowerManagerService等。</li></ul><h3 id="ams-Zygote-通信为什么用-Socket"><a href="#ams-Zygote-通信为什么用-Socket" class="headerlink" title="ams-Zygote 通信为什么用 Socket"></a>ams-Zygote 通信为什么用 Socket</h3><p>时序问题， Zygote 不一定 binder 创建完成</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-5fd879bbbbb96d6c600aa61fd0f3f477-unknown_filename.3-3d7842.png" alt="unknown_filename.3|900"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Activity%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.resources/2023/09/15/18-34-41-2903794cba3ed8f5a2013bafdee5f318-unknown_filename.4-5bd448.png" alt="unknown_filename.4|900"></p><p><strong>为何 Binder&#x2F;Socket 用于进程间通信，能否用于线程间通信呢？</strong></p><ul><li>答案是肯定，对于两个具有独立地址空间的进程通信都可以，当然也能用于共享内存空间的两个线程间通信，这就好比杀鸡用牛刀。接着可能还有人会疑惑，那 <em>handler 消息机制能否用于进程间通信</em>？答案是不能，Handler 只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。</li><li>Handler 消息机制用于同进程的线程间通信，其核心是线程间共享内存空间，而不同进程拥有不同的地址空间</li><li>Handler 可以是 UI 线程向工作线程发送消息，也可以是多个工作线程之间通过 handler 发送消息</li></ul><p><strong>Instrumentation （ins 追妹忒神）是什么？</strong><br>管理着组件 Application, Activity，Service 等的创建，生命周期调用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> <span class="hljs-operator">=</span> Process. <span class="hljs-keyword">start</span> (“android . app . ActivityThread” , <br>mSimpleProcessManagement? app. processName : gid, debugFlags, <span class="hljs-keyword">null</span>);<br><br></code></pre></td></tr></table></figure><p><strong>什么是 actityrecord</strong></p><p>一个 Activityrecord 对应一个 Activity, 保存了一个 Activity 的所有信息; 但是一个 Activity 可能会有多个 Activityrecord, 因为 Activity 可以被多次启动，这个主要取决于其启动模式</p><p><strong>什么是 Taskrecord</strong></p><p>Taskrecord, 内部维护一个 Arraylist&lt;Activityrecord 用来保存 Activityrecord.<br>一个 Taskrecord 由一个或者多个 Actvityrecord 组成，这就是我们常说的任务栈，具有后进先出的特点。</p><p><a href="https://blog.csdn.net/qijinglai/article/details/81163574">https://blog.csdn.net/qijinglai/article/details/81163574</a></p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-服务广播提供者</title>
    <link href="/2025/12/d52411f76b00.html"/>
    <url>/2025/12/d52411f76b00.html</url>
    
    <content type="html"><![CDATA[<h2 id="Service-工作原理"><a href="#Service-工作原理" class="headerlink" title="Service 工作原理"></a>Service 工作原理</h2><p>众所周知， Service 有两套流程，一套是启动流程，另一套是绑定流程<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-d8db38f03b4eeb682ec769a3700bb242-unknown_filename.10-4cb978.png" alt="unknown_filename.10"></p><p>假设要启动的 Service 是在一个新的进程中，启动过程可分为5个阶段<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-abf29d796ef7e8e26531b39d01bf8c9b-unknown_filename.26-504aee.jpeg" alt="unknown_filename.26"></p><ol start="2"><li>AMS 检查启动 Service 的进程是否存在，如果不存在，先把 Service 信息存下来，然后新建一个新的进程<br> AMS 检查 Service 是否在 AndroidManifest 声明了，若没声明则会直接报错 AMS 检查启动 Service 的进程是否存在，如果不存在，先把 Seic 信息存下来，然后创建一个新的进程, 在 AMs 中，每个 rice ，都使用 SeviceRecord 对象来保存</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-7d9727f25cda6031a6784e64887e9cc0-unknown_filename.27-afa6e8.jpeg" alt="unknown_filename.27"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-28072f84ea308092f6ab02110c4f9693-unknown_filename.11-a2fbb6.png" alt="unknown_filename.11"></p><p>你会发现，这段代码和前面介绍的 handleLaunchActivity 差不多，都是 PMS 中取出包的信息 packagelnfo ，这是一个 LoadedApk 对象，然后获取它的 classload 反射出来一个类的对象，在这里反射的是 Service.<br>四大组件的逻辑都是如此，所以我们要做插件化，可以在这里做文章，换成插件的 classLoader ，加载插件中的四大组件<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-14aea50780ee7febd7c5e3296c70ac24-unknown_filename.12-600c2f.png" alt="unknown_filename.12"></p><p><strong>广播原理</strong><br>BroadcastManager 静态注册是通过 PMS (即: PackageManagerService 完成整个注册过程的，除此之外四大组件也是通过 PMS 完成注册)。<br>acitivityManagerService 通知 packmanagerService 去查询静态广播，查到后将广播放到 BroadcastQueue 里，然后用 handler 机制去动态注册广播<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-14-794ea4506b2a3bc07e7837ccaa7aa815-unknown_filename.5-f821b1.png" alt="unknown_filename.5"></p><p><strong>内容提供者原理</strong><br>原理：packmanagerservice 里注册，在使用 ContentResolver 来进行查询操作时，query 方法层层调用到 ActivityThread 的 acquireExistingProvider 方法，根据 URI 字符串当中的授权 host（即 authority ）和当前所在用户的 userId 来获取对应的 Provider 实例。</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1-Android的启动流程</title>
    <link href="/2025/12/eb15bb15668b.html"/>
    <url>/2025/12/eb15bb15668b.html</url>
    
    <content type="html"><![CDATA[<h2 id="Android-的启动流程"><a href="#Android-的启动流程" class="headerlink" title="Android 的启动流程"></a>Android 的启动流程</h2><p><a href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/Android%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.md">Android-Notes&#x2F;blogs&#x2F;Android&#x2F;Framework&#x2F;Android 系统启动.md at master · Omooo&#x2F;Android-Notes</a></p><p>当启动电源系统启动后加载 Linux 内核后，加载各种驱动，当有了驱动以后，开始启动 Android 系统同时会加载用户级别的第一个进程 init（system\core\init. c），加载 init. rc 文件，会启动一个 Zygote 进程，此进程是 Android 系统的一个母进程，用来启动 Android 的其他服务进程，然后接着在里面启动了 System Server 进程，负责启动和管理整个 Java framework，包含 ActivityManager，WindowManager，PackageManager，PowerManager 等服务，被 SystemServer 进程启动的 ActivityManagerService 会启动 Launcher，Launcher 启动后会将已安装应用的快捷图标显示到界面上。</p><ul><li>System Server 进程，是由 Zygote 进程 fork 而来（fork 一般都用 socket），System Server 是 Zygote 孵化的第一个进程，负责启动和管理整个 Java framework，包含 ActivityManager，WindowManager，PackageManager，PowerManager 等服务。</li><li>Zygote 进程孵化出的第一个 App 进程是 Launcher，这是用户看到的桌面 App；</li><li>Zygote 进程还会创建 Browser，Phone，Email 等 App 进程，每个 App 至少运行在一个进程上。<br>  所有的 App 进程都是由 Zygote 进程 fork 生成的。</li></ul><h3 id="启动流程总结"><a href="#启动流程总结" class="headerlink" title="启动流程总结"></a>启动流程总结</h3><ol><li>启动电源以及系统启动<br>当电源按下时引导芯片代码开始从预定义的地方（固化在 ROM）开始执行。加载引导程序 Bootloader 到 RAM，然后执行。</li><li>引导程序 BootLoader<br>引导程序 BootLoader 是在 Android 操作系统开始运行前的一个小程序，它的主要作用是把系统 OS 拉起来并运行。</li><li>Linux 内核启动<br>内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置，它首先在系统文件中寻找 init. rc 文件，并启动 init 进程。</li><li>init 进程启动<br>初始化和启动属性服务，并且启动 Zygote 进程。</li></ol><blockquote><p>解析 init. zygote. rc 中的参数，创建 AppRuntime 并调用 AppRuntime.start()方法；<br>调用 AndroidRuntime 的 startVM ()方法创建虚拟机，再调用 startReg ()注册 JNI 函数；<br>通过 JNI 方式调用 ZygoteInit. main ()，第一次进入 Java 世界</p></blockquote><ol start="5"><li><p>Zygote 进程启动</p><blockquote><p>创建 JavaVM 并为 JavaVM 注册 JNI，创建服务端 Socket，启动 SystemServer 进程。</p></blockquote></li><li><p>SystemServer 进程启动</p><blockquote><p>启动 Binder 线程池和 SystemServiceManager，并且启动各种系统服务。</p></blockquote></li><li><p>Launcher 启动</p><blockquote><p>被 SystemServer 进程启动的 ActivityManagerService 会启动 Launcher，Launcher 启动后会将已安装应用的快捷图标显示到界面上。</p></blockquote></li></ol><h3 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h3><p>1.启动电源以及系统启动-&gt;2. 引导程序 BootLoader-&gt;3. Linux 内核启动-&gt;4. init 进程启动-&gt;5. Zygote 进程启动-&gt;6. SystemServer 进程启动-&gt;7. Launcher 启动</p><h3 id="init-进程启动"><a href="#init-进程启动" class="headerlink" title="init 进程启动"></a>init 进程启动</h3><p>init 是 Android 系统中用户控件的第一个进程，init 进程启动过程中主要分三个部分：</p><ol><li>创建和挂载启动所需的文件目录</li><li>初始化和启动属性服务</li><li>解析 init. rc 配置文件并启动 Zygote 进程<br>源码如下 system&#x2F;core&#x2F;init&#x2F;init. cpp</li></ol><p>init. rc 是一个配置文件，里面是一些脚本，该脚本的意思是 service 通知 init 进程创建名 zygote 的进程（fork 出来的）并启动 SystemService</p><h3 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h3><p>Zygote 进程主要包括：</p><ul><li>加载 ZygoteInit 类，注册 Zygote Socket 服务端套接字</li><li>加载虚拟机</li><li>提前加载类 preloadClasses</li><li>提前加载资源 preloadResources</li></ul><p>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer. java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String argv[])</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//...</span><br>      <span class="hljs-comment">//1. 创建一个 Server 端的 Socket，socketName 为 zygote</span><br>        zygoteServer.registerServerSocketFromEnv(socketName);<br>        <br>        <span class="hljs-keyword">if</span> (!enableLazyPreload) &#123;<br>            bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;ZygotePreload&quot;</span>);<br>            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,<br>                SystemClock.uptimeMillis());<br>          <span class="hljs-comment">//2. 预加载资源和类</span><br>            preload(bootTimingsTraceLog);<br>            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,<br>                SystemClock.uptimeMillis());<br>            bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// ZygotePreload</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Zygote.resetNicePriority();<br>        &#125;<br><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (startSystemServer) &#123;<br>          <span class="hljs-comment">//3. 启动 SystemServer 进程</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> forkSystemServer(abiList, socketName, zygoteServer);<br><span class="hljs-comment">//4. 等待 AMS 请求</span><br>        caller = zygoteServer.runSelectLoop(abiList);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;System zygote died with exception&quot;</span>, ex);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        zygoteServer.closeServerSocket();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>Zygote 进程主要做了以下几件事：</p><ol><li>创建 AppRuntime 并调用其 start 方法，启动 Zygote 进程</li><li>创建 Java 虚拟机并为 Java 虚拟机注册 JNI 方法</li><li>通过 JNI 调用 ZygoteInit 的 main 方法进入 Zygote 的 Java 框架层</li><li>通过 registerZygoteSocket 方法创建服务端 Socket，并通过 runSelectLoop 方法等待 AMS 的请求来创建新的应用程序进程</li><li>启动 SystemServer 进程</li></ol><h4 id="应用程序进程启动过程"><a href="#应用程序进程启动过程" class="headerlink" title="应用程序进程启动过程"></a>应用程序进程启动过程</h4><p>启动过程可以分为两步：</p><ol><li>AMS 发送启动应用程序进程的请求<br> AMS 如果想要启动应用程序进程，就需要向 Zygote 进程发送创建应用程序进程的请求，AMS 会通过调用 startProcessLocked 方法向 Zygote 进程发送请求。</li><li>Zygote 接受请求并创建应用程序进程</li></ol><h3 id="SystemServer-进程启动"><a href="#SystemServer-进程启动" class="headerlink" title="SystemServer 进程启动"></a>SystemServer 进程启动</h3><p>SystemServer 进程主要用于创建系统服务，比如 AMS、WMS、PMS 等都是由它来创建的。</p><p>SystemServer 进程被创建后，主要做了以下工作：</p><ol><li>启动 Binder 线程池，这样就可以与其他进程进行通信</li><li>启动 SystemServiceManager，其用于对系统的服务进程创建、启动和生命周期管理</li><li>启动各种系统服务</li></ol><p>从上面 ZygoteInit 的 main 方法中我们可以看到调用了 startSystemServer 方法启动 SystemServic。</p><p>解析 SyetemServer 进程，我们看下 SystemService 的 main 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>main 函数中只调用了 SystemServer 的 run 函数，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        ......<br>            Looper.prepareMainLooper();<br>            <span class="hljs-comment">// Initialize native services.</span><br>            System.loadLibrary(<span class="hljs-string">&quot;android_servers&quot;</span>);<br>            performPendingShutdown();<br>            createSystemContext();<br>            <span class="hljs-comment">//  创建SystemServiceManager</span><br>            mSystemServiceManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServiceManager</span>(mSystemContext);<br>            mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);<br>            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);<br>            <span class="hljs-comment">// Prepare the thread pool for init tasks that can be parallelized</span><br>            SystemServerInitThreadPool.get();<br>       ......<br>        <span class="hljs-comment">// Start services.</span><br>        <span class="hljs-comment">//启动系统的各种服务</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            traceBeginAndSlog(<span class="hljs-string">&quot;StartServices&quot;</span>);<br>        <span class="hljs-comment">//引导服务、</span><br>            startBootstrapServices();<br>        <span class="hljs-comment">//核心服务</span><br>            startCoreServices();<br>        <span class="hljs-comment">//和其他服务</span><br>            startOtherServices();<br>            SystemServerInitThreadPool.shutdown();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            Slog.e(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;******************************************&quot;</span>);<br>            Slog.e(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;************ Failure starting system services&quot;</span>, ex);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            traceEnd();<br>        &#125;<br>       ......<br>        <span class="hljs-comment">// Loop forever.</span><br>        Looper.loop();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="SystemServiceManager"><a href="#SystemServiceManager" class="headerlink" title="SystemServiceManager"></a>SystemServiceManager</h3><p>创建的 SystemServiceManager 会对系统的服务进行创建、启动和生命周期管理，启动的引导服务 startBootstrapServices 函数中用 SystemServiceManager 启动了 ActivityManagerService、PowerManagerService、PackageManagerService 等服务。</p><p>SystemServiceManager 用来管理系统中的各种 Service，用于系统 C&#x2F;S 架构中的 Binder 机制通信：Client 端要使用某个 Service，则需要先到 ServiceManager 查询 Service 的相关信息，然后根据 Service 的相关信息与 Service 所在的 Server 进程建立通讯通路，这样 Client 端就可以使用 Service 了</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>车载应用</title>
    <link href="/2025/12/00dc98906bd4.html"/>
    <url>/2025/12/00dc98906bd4.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7155869454792917005?searchId=202401241808311012EC739EC068115F5F">从应用工程师的角度再谈车载 Android 系统 - 掘金</a></p><p><a href="https://www.bilibili.com/video/BV1NY411z7TK/?spm_id_from=333.788.recommend_more_video.1&vd_source=6755b5c807a3565e73af94c1d30cd071">车载Android应用开发与分析 - 开发Android系统应用_哔哩哔哩_bilibili</a></p><p><a href="https://juejin.cn/post/7202826051541532727?searchId=202401241808311012EC739EC068115F5F">【视频文稿】车载Android应用开发与分析 - AOSP的下载与编译 - 掘金</a></p><h2 id="车载操作系统"><a href="#车载操作系统" class="headerlink" title="车载操作系统"></a>车载操作系统</h2><p>汽车操作系统是从传统汽车电子不断演变而来的，传统汽车电子产品可分为两类：</p><p>一类是汽车电子控制装置，通过直接向执行机构（如电子阀门、继电器开关、执行马达）发送指令，以控 制车辆关键部件（如发动机、变速箱、动力电池）协同工作，这类系统一般统称为电子控制单元（ECU）；</p><p>另一类是车载电子设备，如仪表、娱乐音响、导航系统、HUD等，这类系统不直接参与汽车行驶的控制 决策，不会对车辆行驶性能和安全产生影响，通常统称为车载信息娱乐系统（IVI）。这也是Android程序员主要负责的领域。</p><h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><p>微控制器单元，它负责着汽车很大一部分的功能，例如通过车载控制器对各项数据进行分析处理，以做出最优决策；负责对车辆的信息娱乐交互和运动控制等等。</p><p>总的来说，MCU可以应用于车辆的通讯、能源、存储、感知以及计算，对汽车行业有着重要的作用</p><h4 id="SOC"><a href="#SOC" class="headerlink" title="SOC"></a>SOC</h4><p>SoC的定义多种多样，由于其内涵丰富、应用范围广，很难给出准确定义。一般说来， SoC称为系统级芯片，也有称片上系统（System on Chip），意指它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。</p><p>车载Soc和常见的手机Soc非常类似，内部集成了CPU和GPU。目前最主流的车载Soc是高通的8155，它就是高通在手机Soc骁龙855的基础上发展而来的。</p><h2 id="车载-Android-系统"><a href="#车载-Android-系统" class="headerlink" title="车载 Android 系统"></a>车载 Android 系统</h2><p>车载Android系统，又称Android Automotive，是对原始Android系统的一个功能扩充版本，在编译AOSP源码时可以看到相应的编译选项。Android Automotive 是一个基于 Android 平台扩展后，适用于现代汽车的智能操作系统，可以直接运行为Android系统开发的应用</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-25-10-24-dc4381371f1763d8e458a51913e43f16-20240125102447-265b76.png" alt="image.png|600"><br>Android Automotive与Android最大的区别在于，Android Automotive增加了对汽车特定要求、功能和技术的支持。</p><blockquote><p>Google的官方文档：<a href="https://link.juejin.cn/?target=https://source.android.google.cn/docs/devices/automotive" title="https://source.android.google.cn/docs/devices/automotive">source.android.google.cn&#x2F;docs&#x2F;device…</a></p></blockquote><p><strong>Android Auto</strong> 是一个基于用户手机运行的平台，可通过 USB 连接将 Android Auto 用户体验投射到兼容的车载信息娱乐系统。Android Auto本质上就是一个运行在Android系统上的车载应用，与苹果的CarPlay，百度的CarLife类似。</p><p>需要说明的是，使用Android Auto需要用户的手机支持Google服务框架，所以一般只在国内销售的汽车基本都不支持Android Auto，一些沿用了国外车机系统的合资车型可能会支持Android Auto。</p><h3 id="常见的车载应用"><a href="#常见的车载应用" class="headerlink" title="常见的车载应用"></a>常见的车载应用</h3><h4 id="SystemUI"><a href="#SystemUI" class="headerlink" title="SystemUI"></a>SystemUI</h4><p>系统的UI。<code>SystemUI</code>是一个标准的android应用程序，它提供了系统UI的统一管理方案。 常见的状态栏、导航栏、消息中心、音量调节弹窗、蓝牙连接弹窗等一系列后台弹窗都是由SystemUI模块负责管理。</p><p>开发难度：<code>SystemUI</code>作为Android系统启动的第一个带有UI的应用程序，对启动性能和稳定性都有很高的要求。<code>SystemUI</code>需要管理的模块非常多，导致开发任务比较繁重，有的车载项目会要求<code>SystemUI</code>兼容原有的应用层API，那么开发难度还会上升。开发人员需要对Android原生的<code>SystemUI</code>源码有一定的了解。</p><h4 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h4><p>Android系统的桌面。</p><p>开发难度：Launcher是与用户交互最多的应用程序之一，同样对启动性能和稳定性都有很高的要求。Launcher开发难度主要集中在与3D车模的互动（如果有3D模型），可能需要支持Widget的显示（WidgetHost），各种应用的拖动和编辑等。开发人员最好对Android原生的Launcher源码有一定的了解。</p><h4 id="CarService"><a href="#CarService" class="headerlink" title="CarService"></a>CarService</h4><p>车载Android系统的核心服务之一，所有应用都需要通过CarService来查询、控制整车的状态。例如：车辆的速度、档位、点火状态等等。</p><h3 id="车载应用与移动应用的区别"><a href="#车载应用与移动应用的区别" class="headerlink" title="车载应用与移动应用的区别"></a>车载应用与移动应用的区别</h3><p>夸张一点说，移动端的应用开发和车载应用开发，完全就不是一个技术思路。总结一下大致有以下几个区别：</p><p><strong>1）应用级别不同</strong></p><p>多数车载应用属于<strong>系统级应用</strong>，可以调用Android SDK内部隐藏的API，也不需要动态地向用户申请权限。移动应用是<strong>普通应用</strong>，系统对其限制很多，需要遵守Android应用的开发规范。</p><p>由于车载应用是系统级应用，所以移动端很多常用的技术比如热修复、插件化基本都不会采用，但是相对的进程保活、开机自启就变得非常简单了。</p><p>总得来说系统应用具有以下特点</p><ul><li>可以访问Android SDK内部的API</li><li>不需要申请动态权限</li><li>可配置开机自启动</li><li>必须对应用进行签名</li></ul><p><strong>2）迭代方式不同</strong></p><p>移动应用只要用户的手机接入了WiFi就可以进行在线升级，所以移动应用多采用小步快跑的形式，进行快速迭代。</p><p>车载系统级应用的更新只能以<em>整车OTA的形式进行</em>，而OTA可能会消耗宝贵的车机流量，所以车载应用在SOP（量产）前，就必须完成全部需求的开发，而且不能出现严重的bug。在正式交付用户前，车厂内部或4S店还会进行几次OTA升级用做最后的bug修复。（如果在交付用户后还有严重的bug或需求未完成，那么大概率项目经理、程序员都要祭天了)</p><p><strong>3）技术路线不同</strong></p><p>正是因为车载应用对稳定性的要求极高，所以车载应用在开发时，对待新型技术会非常的慎重，比如，目前只有少数主机厂商在使用Kotlin开发车载应用，<em>毕竟Android Framework都还没有改成Kotlin</em>，大部分厂商对Kotlin的积极性不高。而且车载应用也<em>不允许随意使用开源框架，如果必须使用，务必注意框架的开源协议</em>，以免给汽车厂商带来不必要的麻烦。</p><p><strong>4）运行环境不同</strong></p><p>车载应用的运行环境是经过高度定制化的Android系统，定制化也就意味着bug。移动端的应用出现bug时，我们的第一反应是应用的代码有缺陷。车载应用发现bug也要考虑到是不是系统本身出现了bug，这是一件非常有挑战性的事，应用开发与系统开发相互扯皮、泼脏水也属于家常便饭。</p><h3 id="车载应用需要掌握的技能"><a href="#车载应用需要掌握的技能" class="headerlink" title="车载应用需要掌握的技能"></a>车载应用需要掌握的技能</h3><p><strong>性能优化</strong></p><p>应用的性能优化是个亘古不变的话题，掌握应用的各种性能优化方式，也是一个Android程序员必备的生存手段，汽车座舱的SOC性能比旗舰手机要差不少，如果优化好车载应用将是一个非常有挑战性的任务。</p><p><strong>IPC通信</strong></p><p>Android中最常用的跨进程通信手段是Binder，因为有大量的Service需要与应用进行交互，所以基于Binder的AIDL在车载应用开发中使用得非常广泛，学会使用AIDL也同样属于必备技能之一。</p><p><strong>系统应用源码</strong></p><p>这一项是我认为最重要的，不少车载应用层项目都是反复定制各种SystemUI、Launcher、Settings等等，读懂Android系统应用源码对我们定制化开发这些应用有非常大的好处。</p><h2 id="编写一个系统级应用"><a href="#编写一个系统级应用" class="headerlink" title="编写一个系统级应用"></a>编写一个系统级应用</h2><p><a href="https://juejin.cn/post/7094058821600935950">Android车载应用开发与分析（11）- 车载Android应用开发入门指南 - 掘金</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.car&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:sharedUserId</span>=<span class="hljs-string">&quot;android.uid.system&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:persistent</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:roundIcon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/Theme.First&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面源码中我们需要关注两个普通应用用不到的属性： <strong><code>android:sharedUserId</code></strong> 将与其他应用程序共享的 Linux 用户 ID 的名称。默认情况下，Android 会为每个应用分配自己唯一的用户 ID。但是，如果为两个或多个应用将此属性设置为相同的值，则它们将共享相同的 ID，前提是它们的证书集相同。具有相同用户 ID 的应用可以访问彼此的数据，如果需要，可以在同一进程中运行。 开发系统应用时，此项不是必须配置的。配置为<code>android.uid.system</code>后，该应用会变成system用户，可以访问一些system用户才能访问的空间。</p><p><strong><code>android:persistent</code></strong> 配置应用程序是否应始终保持运行，默认为false。设为true之后，应用在开机广播发出之前就会自行启动，而且应用被杀死后，也会立即重启。 开发系统应用时，此项不是必须配置的。</p><p>基于Android源码环境的app工程结构与基于Gradle的AndroidStudio工程结构是完全不一样的，目录结构如下：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-25-11-12-82a82d5560260d52f52d5f46a6f0a86f-20240125111203-56b5fd.png" alt="image.png|600"></p><p>编写一个Android.bp或Android.mk脚本，然后完整编译一次Android的源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译Android源码</span><br>/aosp$ <span class="hljs-built_in">source</span> build/envsetup.sh <br>/aosp$ lunch 12<br>/aosp$ make -j 32<br>/aosp$ emulator -writable-system -netdelay none -netspeed full<br></code></pre></td></tr></table></figure><p>目录<br><strong><code>/system/priv-app</code></strong> 该路径存放一些系统底层的应用，比如Setting，systemUI等。该目录中的app拥有较高的系统权限，而且如果要使用<code>android:protectionLevel=signatureOrSystem</code>，那么该app必须放到priv-app目录中去。</p><p><strong><code>/system/app</code></strong> 该目录中存放的系统app权限相对较低，而且当拥有root权限时，就有可能卸载掉这些app。</p><p><strong><code>/vendor/app</code></strong> 该目录存放vendor厂商的app</p><p><strong><code>/data/app</code></strong> 用户安装的第三方app</p><p>调试耗时且费力车载应用开发难度其实并不大，但是很烦！特别是调试，不同于开发手机应用，车载应用的运行环境是基于AOSP定制的，而且大多数时候都会存在数不清的BUG，有时系统底层的bug会在上层应用中体现，<em>这就要求应用开发者必须有能力准确识别出这个bug的归属方</em>。</p><p>引用：<br><a href="https://www.jianshu.com/p/bbc02e0f6575">Android车载应用开发与分析（1） - Android Automotive概述与编译 - 简书</a></p>]]></content>
    
    
    <categories>
      
      <category>AOSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim 学习</title>
    <link href="/2025/12/7ceb30e1d028.html"/>
    <url>/2025/12/7ceb30e1d028.html</url>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>[[命令快捷键#Vim]]</p><h1 id="vim-基本使用"><a href="#vim-基本使用" class="headerlink" title="vim 基本使用"></a>vim 基本使用</h1><h4 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h4><p>通过 <code>vim + 文件名</code>，进入 vim 环境（test. txt 可以是当前目录已存在的文件，也可以是当前目录不存在的文件。）：</p><p>此时，我们在 vim 的一般模式下，如果 test. txt 文件有内容，我们可以通过：</p><ul><li>j 下移光标</li><li>k 上移光标</li><li>h 左移光标</li><li>l 右移光标</li></ul><p>如果用的不习惯，上下左右方向键也可以移动光标。</p><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>在一般模式下，输入 a i o 可以进入编辑模式，编辑模式下，我们可以输入文本修改文件内容。</p><p>a i o 的区别如下:</p><ul><li>a：在当前光标下一位插入</li><li>i：当前光标处插入</li><li>o：换行并创建全新空白行，并在行首插入</li></ul><p>在编辑模式下，我们点击 esc 键即可回到一般模式。</p><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>在一般模式下，输入分号，就会进入命令行模式。在命令行中，可以输入不同的指令或者字符串以实现不同的功能。其中涉及的最常用的功能包括了两类：</p><ul><li>退出 vim</li><li>当前文本中，搜索字符串</li></ul><p>进入命令行模式后，有三种方式来退出 vim：</p><ul><li>当前文件没有做任何改变时，输入 <code>q</code> 指令，退出 vim 环境</li><li>当前文件做了一些修改，如果想放弃已修改的内容，输入 <code>q!</code> 指令，退出 vim 环境</li><li>当前文件做了一些修改，如果想保存已修改的内容，输入 <code>wq</code> 指令，退出 vim 环境</li></ul><p>进入命令行模式后，我们还可以输入 <code>/</code> + 字符串，点击回车键，进入搜索模式，点击 N 键，光标就会在匹配处依次跳动。</p><p>在一般模式下，我们也可以直接输入 <code>/</code> + 字符串进行搜索。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.v2ex.com/t/756770">IDE 使用 Vim 插件，喜欢点击鼠标切换光标位置，总觉得按键盘切换太麻烦了 - V2EX</a></p><p><a href="https://blog.csdn.net/kl28978113/article/details/53981137">IntelliJ IDEA 必备插件之键盘流篇-CSDN博客</a></p><p><a href="https://github.com/ayamir/nvimdots">ayamir&#x2F;nvimdots: A well configured and structured Neovim.</a></p><h1 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a href="https://www.cnblogs.com/tuilk/p/16421831.html">解决Windows下(Neo)Vim中文输入法的切换问题 - Leaos - 博客园</a> </p><ul><li><ol><li>下载AutoHotKey 打开 <a href="https://www.autohotkey.com/">AutoHotKey</a> 官网下载相应软件，点击 <code>Download Current Version</code> 即可。 下载完成后，进行安装。安装包很小，仅仅 3MB。选择默认安装，或者自定义安装都可以。 自定义安装仅仅更改安装路径即可，其它使用默认即可。</li></ol></li></ul><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><h3 id="ieda"><a href="#ieda" class="headerlink" title="ieda"></a>ieda</h3><p><a href="https://smart-input-source-1315501506.cos.ap-shanghai.myqcloud.com/guidedoc/mac-started-guide">https://smart-input-source-1315501506.cos.ap-shanghai.myqcloud.com/guidedoc/mac-started-guide</a></p><h3 id="MacOS-底下使用Vundle或者Vim-plug-配置vim-简书"><a href="#MacOS-底下使用Vundle或者Vim-plug-配置vim-简书" class="headerlink" title="MacOS 底下使用Vundle或者Vim-plug 配置vim - 简书"></a><a href="https://www.jianshu.com/p/ce4ab4b71f93">MacOS 底下使用Vundle或者Vim-plug 配置vim - 简书</a></h3><p>安装 plugged</p><ul><li><p>使用vim-plug管理插件</p></li><li><p>清除之前的设置<br><code>sudo rm -rf ~/.vim  sudo rm .vimrc</code></p></li><li><p>拷贝vimrc</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/yxrdydh/</span>vimrc_Mac.git ~<span class="hljs-regexp">/.vim/</span><br></code></pre></td></tr></table></figure><p>&#96;</p></li><li><p>安装插件管理vim-plug.vim</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">curl -fLo ~<span class="hljs-regexp">/.vim/</span>autoload/plug.<span class="hljs-property">vim</span> --create-dirs \<br>    <span class="hljs-attr">https</span>:<span class="hljs-comment">//raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></code></pre></td></tr></table></figure><h3 id="如何让-Neovim-中文输入时自动切换输入法-jdhao’s-digital-space"><a href="#如何让-Neovim-中文输入时自动切换输入法-jdhao’s-digital-space" class="headerlink" title="如何让 Neovim 中文输入时自动切换输入法 - jdhao’s digital space"></a><a href="https://jdhao.github.io/2021/02/25/nvim_ime_mode_auto_switch/">如何让 Neovim 中文输入时自动切换输入法 - jdhao’s digital space</a></h3><ul><li><p>vim-barbaric</p></li><li><p><a href="https://github.com/rlue/vim-barbaric">vim-barbaric</a> 是一款帮助用户自动设置输入法模式的插件。</p></li><li><p>安装依赖</p></li><li><p>在 macOS 下，需要额外安装 <a href="https://github.com/myshov/xkbswitch-macosx">xkbswitch-macosx</a> ：</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>xkbswitch https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/myshov/</span>xkbswitch-macosx<span class="hljs-regexp">/master/</span>bin/xkbswitch<br></code></pre></td></tr></table></figure><ul><li>然后使用插件管理器安装该插件即可：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Plug <span class="hljs-string">&#x27;rlue/vim-barbaric&#x27;</span><br></code></pre></td></tr></table></figure></li><li>该插件开箱即用，无需额外设置。</li></ul><h3 id="vim-plug简介"><a href="#vim-plug简介" class="headerlink" title="vim-plug简介"></a><a href="http://blog.fpliu.com/it/software/Vim/plugin/vim-plug">vim-plug简介</a></h3><ul><li>安装在 <a href="https://github.com/">GitHub</a> 仓库中的插件</li><li>如果您要安装的插件在 <a href="https://github.com/">GitHub</a> 仓库中， 那么，配置的格式如下：</li><li>Plug ‘userName&#x2F;repoName’</li><li>执行这个指令的时候，首先检测该插件是否已经下载到本地了，如果没有下载， 就会使用 <a href="http://blog.fpliu.com/it/software/git">git</a> 下载，下载的方式如下：</li><li>git<code> -C ~/.vim/bundle clone --recursive https://github.com/tpope/vim-fugitive.git</code></li><li>下载到 <code>~/.vim/bundle/vim-fugitive</code> 目录中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git -C ~/.vim/bundle <span class="hljs-built_in">clone</span> --recursive https://github.com/rlue/vim-barbaric.git<br></code></pre></td></tr></table></figure><ul><li>安装插件  在vim中 :PlugInstall</li></ul><p>call plug#begin(‘~&#x2F;.vim&#x2F;plugged’)<br>call plug#end()</p><h1 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 🍰🍰🍰 Extensions 🍰🍰🍰  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br>Plug &#x27;preservim/nerdtree&#x27;  <br>  <br><span class="hljs-string">&quot;下列插件需要在IDEA中下载  </span><br><span class="hljs-string">&quot;ideaVim  </span><br><span class="hljs-string">&quot;IdeaVim-EasyMotion  </span><br><span class="hljs-string">&quot;IdeaVimExtension  </span><br><span class="hljs-string">&quot;which-key  </span><br><span class="hljs-string">&quot;CodeGlance Pro  </span><br><span class="hljs-string">&quot;TranslateAction  </span><br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 🐧🐧🐧 Basic settings 🐧🐧🐧  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot;设置在光标距离窗口顶部或底部一定行数时，开始滚动屏幕内容的行为  </span><br>set scrolloff=<span class="hljs-number">10</span>  <br>  <br><span class="hljs-string">&quot;--递增搜索功能：在执行搜索（使用 / 或 ? 命令）时，  </span><br><span class="hljs-string">&quot;Vim 会在您输入搜索模式的过程中逐步匹配并高亮显示匹配的文本。  </span><br>set incsearch  <br>  <br><span class="hljs-string">&quot;--在搜索时忽略大小写  </span><br>set ignorecase  <br>  <br><span class="hljs-string">&quot;--将搜索匹配的文本高亮显示  </span><br>set hlsearch  <br>  <br><span class="hljs-string">&quot;--设置相对行号 和 当前行的绝对行号  </span><br>set number relativenumber  <br>  <br><span class="hljs-string">&quot;--设置返回normal模式时回到英文输入法  </span><br>set keep-english-in-normal  <br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 🌍🌍🌍 No Leader Keymaps 🌍🌍🌍  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot;--普通模式下使用回车键，向下/向上 增加一行  </span><br>nmap &lt;CR&gt; o&lt;Esc&gt;  <br>nmap &lt;S-Enter&gt; O&lt;Esc&gt;  <br>  <br><span class="hljs-string">&quot;--在普通和插入模式下，向下交换行/向上交换行  </span><br>nnoremap &lt;C-j&gt; :m +<span class="hljs-number">1</span>&lt;CR&gt;  <br>nnoremap &lt;C-k&gt; :m -<span class="hljs-number">2</span>&lt;CR&gt;  <br>inoremap &lt;C-j&gt; &lt;Esc&gt; :m +<span class="hljs-number">1</span>&lt;CR&gt;gi  <br>inoremap &lt;C-k&gt; &lt;Esc&gt; :m -<span class="hljs-number">2</span>&lt;CR&gt;gi  <br>  <br><span class="hljs-string">&quot;--将 jj 和 jk 映射为 &lt;Esc&gt;  </span><br><span class="hljs-string">&quot;jj和jk为主流配置，可按喜好自行调整  </span><br>inoremap jj &lt;ESC&gt;  <br>  <br><span class="hljs-string">&quot;--格式化（规范化）文本，即对选定的文本进行换行或重排，适应指定的文本宽度。  </span><br><span class="hljs-string">&quot;全文规范化：Ctrl+Alt+l  </span><br>map Q gq  <br><span class="hljs-string">&quot;跳转到下一个错误或警告  </span><br>nmap ge &lt;action&gt;(GotoNextError)  <br><span class="hljs-string">&quot;在源代码和测试代码之间快速切换  </span><br>nmap gt &lt;action&gt;(GotoTest)  <br><span class="hljs-string">&quot;将光标移动到上一个方法的声明处  </span><br>nmap gm &lt;action&gt;(MethodUp)  <br><span class="hljs-string">&quot; last changed in current buffer(file)  </span><br><span class="hljs-string">&quot;跳转到当前接口或抽象类的实现处  </span><br>nmap ga &lt;action&gt;(GotoImplementation)  <br>  <br><span class="hljs-string">&quot; bookmark 切换书签  </span><br>nmap ma &lt;action&gt;(ToggleBookmark)  <br>  <br><span class="hljs-string">&quot;切换标签页  </span><br>nmap L &lt;action&gt;(NextTab)  <br>nmap H &lt;action&gt;(PreviousTab)  <br>  <br><span class="hljs-string">&quot;将Ctrl + s 映射为保存文档(也可以在VIM设置里将此快捷键设置为IDEA的快捷键)  </span><br>nmap &lt;C-S&gt; &lt;action&gt;(SaveAll)  <br>imap &lt;C-S&gt; &lt;Esc&gt;&lt;action&gt;(SaveAll)  <br>  <br><span class="hljs-string">&quot; e: Extract  </span><br><span class="hljs-string">&quot; extract method/function 将选中的代码片段提取为一个独立的方法(Ctrl + Alt + M)  </span><br>vmap &lt;leader&gt;em &lt;action&gt;(ExtractMethod)  <br><span class="hljs-string">&quot; extract constant （引入常量）的重构操作:将选中的代码片段抽取为一个常量，并自动替换选中的代码片段为新的常量引用(Ctrl + Alt + C)  </span><br>vmap &lt;leader&gt;ec &lt;action&gt;(IntroduceConstant)  <br><span class="hljs-string">&quot; extract field （引入字段）的重构操作:将选中的代码片段转化为一个新的字段，并自动将选中的代码片段替换为对该字段的引用(Ctrl + Alt + F)  </span><br>vmap &lt;leader&gt;ef &lt;action&gt;(IntroduceField)  <br><span class="hljs-string">&quot; extract variable （引入变量）的重构操作:将选中的代码片段抽取为一个新的变量，并自动替换选中的代码片段为新的变量引用(Ctrl + Alt + V)  </span><br>vmap &lt;leader&gt;ev &lt;action&gt;(IntroduceVariable)  <br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; ⭐️⭐️⭐️ Leader Keymaps ⭐️⭐️⭐️ =====================================&quot;</span> ================================================================================================  <br><span class="hljs-string">&quot;--将&lt;leader&gt;设置为 空格 键  </span><br><span class="hljs-string">&quot;可自行更改，只需更改双引号内的内容即可  </span><br><span class="hljs-string">&quot;推荐&lt;leader&gt;:  &quot;</span>空格<span class="hljs-string">&quot;  &quot;</span>;<span class="hljs-string">&quot;  &quot;</span>\<span class="hljs-string">&quot;  &quot;</span>-<span class="hljs-string">&quot;  &quot;</span>,<span class="hljs-string">&quot;  </span><br>let mapleader = <span class="hljs-string">&quot; &quot;</span>  <br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 👻👻👻 Which-Key 👻👻👻  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br>  <br><span class="hljs-string">&quot;which-key的官方推荐配置  </span><br>set which-key  <br>set notimeout  <br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 🌞🌞🌞 目录-食用手册 🌞🌞🌞  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br>  <br><span class="hljs-string">&quot;===================================== A =====================================  </span><br><span class="hljs-string">&quot; a:  </span><br><span class="hljs-string">&quot;===================================== B =====================================  </span><br><span class="hljs-string">&quot; b:  </span><br><span class="hljs-string">&quot;===================================== C =====================================  </span><br><span class="hljs-string">&quot; c:  CodeAndClose-[目录]🎈  </span><br><span class="hljs-string">&quot; cc: CodeCompletion-自动补全  </span><br><span class="hljs-string">&quot; cd: CloseEditor-关闭当前标签页  </span><br><span class="hljs-string">&quot; ca: CloseAllEditors-关闭所有标签页  </span><br><span class="hljs-string">&quot;===================================== D =====================================  </span><br><span class="hljs-string">&quot; d: DebugOrDelete-[目录]🎈  </span><br><span class="hljs-string">&quot; dp: BreakPoint-打断点/解除断点  </span><br><span class="hljs-string">&quot; db: DeBug-调试  </span><br><span class="hljs-string">&quot; [V]d: DeleteAndCopyClipboard-在可视模式中：删除选择的文本并复制到剪切板  </span><br><span class="hljs-string">&quot;===================================== E =====================================  </span><br><span class="hljs-string">&quot; e: ToggleExplorer ⭐️ 激活项目工具窗口&quot;</span>===================================== F =====================================  <br><span class="hljs-string">&quot; f: Find/Format ⭐🎈[目录]  </span><br><span class="hljs-string">&quot; ff: FindFile-快速 导航/查找 项目中的其他文件(Ctrl + n)  </span><br><span class="hljs-string">&quot; fl: FindFileLocation-将当前编辑的文件在项目视图中进行选中定位(Alt + F1)  </span><br><span class="hljs-string">&quot; ft: FindText-在整个项目中查找指定的文本、关键字或正则表达式，包括代码文件、配置文件和其他文件等(Ctrl + Shift + F)  </span><br><span class="hljs-string">&quot; fc: Commands-打开 &quot;</span>Find Action<span class="hljs-string">&quot;（查找动作）对话框(Ctrl + Shift + A)  </span><br><span class="hljs-string">&quot; fm: Format-重新格式化代码，使其符合预定义的代码样式和规范 and 优化导入语句，删除未使用的导入，并将导入语句按字母顺序进行排列  </span><br><span class="hljs-string">&quot;===================================== G =====================================  </span><br><span class="hljs-string">&quot; g: GitOrGenerate 🎈[目录]  </span><br><span class="hljs-string">&quot; gr: RollbackHunk-执行版本控制（VCS）的回滚操作，将修改的代码还原到之前的版本  </span><br><span class="hljs-string">&quot; gc: GenerateConstructor-生成构造函数  </span><br><span class="hljs-string">&quot; gg: GenerateGetter-生成getter函数  </span><br><span class="hljs-string">&quot; gs: GenerateSetter-生成setter函数  </span><br><span class="hljs-string">&quot; ga: GenerateGetterAndSetter-生成getter和setter函数  </span><br><span class="hljs-string">&quot; ge: GenerateEquals-生成equals和hashcode的重写方法  </span><br><span class="hljs-string">&quot; gd: ShowTabbedFileHistory-显示文件的版本控制历史(git)  </span><br><span class="hljs-string">&quot;===================================== H =====================================  </span><br><span class="hljs-string">&quot; h: PreviousTab-切换到上一个标签页  </span><br><span class="hljs-string">&quot;===================================== I =====================================  </span><br><span class="hljs-string">&quot; i: Insert ⭐快速查找并跳转到下一个以 ( 开始的函数或方法调用的位置️  </span><br><span class="hljs-string">&quot;===================================== J =====================================  </span><br><span class="hljs-string">&quot; j: InsertSemicolon⭐️ 普通模式下在行尾一个分号，然后进入插入模式并在当前行的下方新建一行&quot;</span>===================================== K =====================================  <br><span class="hljs-string">&quot; k:  </span><br><span class="hljs-string">&quot;===================================== L =====================================  </span><br><span class="hljs-string">&quot; l: NextTab-切换到下一个标签页  </span><br><span class="hljs-string">&quot;===================================== M =====================================  </span><br><span class="hljs-string">&quot; m: CodeGlance-打开/关闭地图(需要CodeGlance Pro插件)  </span><br><span class="hljs-string">&quot;===================================== N =====================================  </span><br><span class="hljs-string">&quot; n: NERDTreeOrNo ⭐️[目录]🎈  </span><br><span class="hljs-string">&quot; nn: NERDTreeFocus-将使焦点转移到 NERDTree 窗口(配置在NERDTree专栏)  </span><br><span class="hljs-string">&quot; nl: NoHighlight-取消搜索高亮显示  </span><br><span class="hljs-string">&quot; nd: NewDir-新建文件夹  </span><br><span class="hljs-string">&quot; nc: NewClass-新建类  </span><br><span class="hljs-string">&quot;===================================== O =====================================  </span><br><span class="hljs-string">&quot; o:  </span><br><span class="hljs-string">&quot;===================================== P =====================================  </span><br><span class="hljs-string">&quot; p: PasteClipboardDown-从剪切板粘贴到下面行  </span><br><span class="hljs-string">&quot; P: PasteClipboardUp-从剪切板粘贴到上面行  </span><br><span class="hljs-string">&quot; [V]p: PasteClipboardDown-在可视模式中：从剪切板粘贴到下面行  </span><br><span class="hljs-string">&quot; [V]P: PasteClipboardUp-在可视模式中：从剪切板粘贴到上面行  </span><br><span class="hljs-string">&quot;===================================== Q =====================================  </span><br><span class="hljs-string">&quot; q:  </span><br><span class="hljs-string">&quot;===================================== R =====================================  </span><br><span class="hljs-string">&quot; r: Run/Re ⭐️[目录]🎈  </span><br><span class="hljs-string">&quot; ru: RunClass-运行当前编辑器中的文件或类(Shift + F10)  </span><br><span class="hljs-string">&quot; rr: ReRun-重新运行最近一次运行的程序或测试(Ctrl + Shift + F10)  </span><br><span class="hljs-string">&quot; rt: ReRunTests-重新运行最近一次运行的测试（Unit Tests）(Ctrl + Shift + F10)  </span><br><span class="hljs-string">&quot; rn: Rename-在代码中快速更改一个标识符的名称，并自动处理所有相关的引用(Shift + F6)  </span><br><span class="hljs-string">&quot;===================================== S =====================================  </span><br><span class="hljs-string">&quot; s: Show ⭐️[目录]🎈  </span><br><span class="hljs-string">&quot; ss: ShowFileStructure-显示当前打开文件的文件结构弹出窗口，其中包含文件中的类、方法、字段等结构(Alt + 7)  </span><br><span class="hljs-string">&quot; sb: ShowBookmarks-显示书签（Bookmarks）工具窗口，其中包含当前文件中设置的书签列表(Ctrl + F11)  </span><br><span class="hljs-string">&quot; sp: ShowParameterInfo-用于显示方法或函数的参数信息(Ctrl + p)  </span><br><span class="hljs-string">&quot;===================================== T =====================================  </span><br><span class="hljs-string">&quot; t: Translate-翻译(需要Translate插件)  </span><br><span class="hljs-string">&quot;===================================== U =====================================  </span><br><span class="hljs-string">&quot; u:  </span><br><span class="hljs-string">&quot;===================================== V =====================================  </span><br><span class="hljs-string">&quot; v:  </span><br><span class="hljs-string">&quot;===================================== W =====================================  </span><br><span class="hljs-string">&quot; w: Window ⭐️[目录]🎈  </span><br><span class="hljs-string">&quot; wo: maximize-取消分割窗口 并 隐藏所有编辑器窗口  </span><br><span class="hljs-string">&quot; wl: splitWindowVertically-在垂直方向上分割编辑器窗口，将一个编辑器窗口拆分为两个垂直排列的窗格  </span><br><span class="hljs-string">&quot; wc: closeActiveWindow-关闭当前窗口或分割窗格  </span><br><span class="hljs-string">&quot; wh: HideActiveWindow-关闭提示窗口  </span><br><span class="hljs-string">&quot;===================================== X =====================================  </span><br><span class="hljs-string">&quot; x:  </span><br><span class="hljs-string">&quot;===================================== Y =====================================  </span><br><span class="hljs-string">&quot; y: CopyClipboard-将选中行复制到剪切板  </span><br><span class="hljs-string">&quot; [V]y: CopyClipboard-在可视模式中：将选中文字复制到剪切板  </span><br><span class="hljs-string">&quot;===================================== Z =====================================  </span><br><span class="hljs-string">&quot; z: zip(fold) ⭐️[目录]🎈  </span><br><span class="hljs-string">&quot; zo: unZipAll-展开所有代码折叠区域(Ctrl + Shift + 加号键)  </span><br><span class="hljs-string">&quot; zc: ZipAll-折叠所有代码折叠区域(Ctrl + Shift + 减号键)  </span><br><span class="hljs-string">&quot;=============================================================================  </span><br><span class="hljs-string">&quot;=============================================================================  </span><br><span class="hljs-string">&quot;=============================================================================  </span><br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 🌟🌟🌟 &lt;leader&gt;详细配置 🌟🌟🌟  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot;========= NULL ========  </span><br><span class="hljs-string">&quot;这一行为在按下&lt;leader&gt;后显示的,甭管就行  </span><br>let g:WhichKeyDesc_LeaderKeymap= <span class="hljs-string">&quot;&lt;leader&gt; 🌟🌟🌟LeaderKeymap🌟🌟🌟&quot;</span>  <br>  <br>  <br><span class="hljs-string">&quot;========== b ==========  </span><br>  <br>  <br><span class="hljs-string">&quot;========== c ==========  </span><br>let g:WhichKeyDesc_CodeAndClose = <span class="hljs-string">&quot;&lt;leader&gt;c CodeAndClose&quot;</span>  <br>  <br><span class="hljs-string">&quot;关闭所有标签页  </span><br>let g:WhichKeyDesc_CodeAndClose_CloseAllEditors = <span class="hljs-string">&quot;&lt;leader&gt;ca CloseAllEditors&quot;</span>  <br>nmap &lt;leader&gt;ca &lt;action&gt;(CloseAllEditors)  <br><span class="hljs-string">&quot;关闭当前标签页  </span><br>let g:WhichKeyDesc_CodeAndClose_CloseEditor = <span class="hljs-string">&quot;&lt;leader&gt;ce CloseEditor&quot;</span>  <br>nmap &lt;leader&gt;ce :action CloseEditor&lt;CR&gt;  <br><span class="hljs-string">&quot;代码自动补全  </span><br>let g:WhichKeyDesc_CodeAndClose_CodeCompletion = <span class="hljs-string">&quot;&lt;leader&gt;cc CodeCompletion)  </span><br>nmap &lt;leader&gt;cc &lt;action&gt;(CodeCompletion)  <br>  <br>  <br><span class="hljs-string">&quot;========== d ==========  </span><br>let g:WhichKeyDesc_DeBugOrDelete= <span class="hljs-string">&quot;&lt;leader&gt;d DebugOrDelete&quot;</span>  <br><span class="hljs-string">&quot;打断点/解除断点  </span><br>let g:WhichKeyDesc_DebugOrDelete_BreakPoint = <span class="hljs-string">&quot;&lt;leader&gt;dp BreakPoint&quot;</span>  <br>nmap &lt;leader&gt;dp &lt;Action&gt;(ToggleLineBreakpoint)  <br><span class="hljs-string">&quot;调试  </span><br>let g:WhichKeyDesc_DebugOrDelete_DeBug = <span class="hljs-string">&quot;&lt;leader&gt;db DeBug&quot;</span>  <br>nmap &lt;leader&gt;db &lt;Action&gt;(Debug)  <br><span class="hljs-string">&quot;在可视模式中：删除选择的文本并复制到剪切板  </span><br>let g:WhichKeyDesc_DebugOrDelete_DeleteAndCopyToClipboard = <span class="hljs-string">&quot;&lt;leader&gt;dd DeleteAndCopyClipboard&quot;</span>  <br>vmap &lt;leader&gt;dd <span class="hljs-string">&quot;+d  </span><br>  <br>  <br><span class="hljs-string">&quot;========== e ==========  </span><br><span class="hljs-string">&quot;激活项目工具窗口(Alt + 1)  </span><br>let g:WhichKeyDesc_ToggleExplorerOrExtract = <span class="hljs-string">&quot;&lt;leader&gt;e ToggleExplorer&quot;</span>  <br>nmap &lt;leader&gt;e &lt;action&gt;(ActivateProjectToolWindow)  <br>  <br>  <br><span class="hljs-string">&quot;========== f ==========  </span><br>let g:WhichKeyDesc_FindOrFormat = <span class="hljs-string">&quot;&lt;leader&gt;f FindOrFormat&quot;</span>  <br>  <br><span class="hljs-string">&quot;快速 导航/查找 项目中的其他文件(Ctrl + n)  </span><br>let g:WhichKeyDesc_FindOrFormat_FindFile = <span class="hljs-string">&quot;&lt;leader&gt;ff FindFile&quot;</span>  <br>nmap &lt;leader&gt;ff &lt;action&gt;(GotoFile)  <br><span class="hljs-string">&quot;将当前编辑的文件在项目视图中进行选中定位(Alt + F1)  </span><br>let g:WhichKeyDesc_FindOrFormat_FindFileLocation = <span class="hljs-string">&quot;&lt;leader&gt;fl FindFileLocation&quot;</span>  <br>nmap &lt;leader&gt;fl &lt;action&gt;(SelectInProjectView)  <br><span class="hljs-string">&quot;在整个项目中查找指定的文本、关键字或正则表达式，包括代码文件、配置文件和其他文件等(Ctrl + Shift + F)  </span><br>let g:WhichKeyDesc_FindOrFormat_FindText = <span class="hljs-string">&quot;&lt;leader&gt;ft FindText&quot;</span>  <br>nmap &lt;leader&gt;ft &lt;action&gt;(FindInPath)  <br><span class="hljs-string">&quot;打开 &quot;</span>Find Action<span class="hljs-string">&quot;（查找动作）对话框(Ctrl + Shift + A)  </span><br>let g:WhichKeyDesc_FindOrFormat_Commands = <span class="hljs-string">&quot;&lt;leader&gt;fc Commands&quot;</span>  <br>nmap &lt;leader&gt;fc &lt;action&gt;(GotoAction)  <br><span class="hljs-string">&quot;重新格式化代码，使其符合预定义的代码样式和规范 \| 优化导入语句，删除未使用的导入，并将导入语句按字母顺序进行排列  </span><br>let g:WhichKeyDesc_FindOrFormat_Format = <span class="hljs-string">&quot;&lt;leader&gt;fm Format&quot;</span>  <br>nmap &lt;leader&gt;fm &lt;action&gt;(ReformatCode) \<span class="hljs-string">| &lt;action&gt;(OptimizeImports)  </span><br>  <br>  <br><span class="hljs-string">&quot;========== g ==========  </span><br>let g:WhichKeyDesc_GitOrGenerate = <span class="hljs-string">&quot;&lt;leader&gt;g GitOrGenerate&quot;</span>  <br>  <br><span class="hljs-string">&quot;执行版本控制（VCS）的回滚操作，将修改的代码还原到之前的版本  </span><br>let g:WhichKeyDesc_GitOrGenerate_RollbackHunk = <span class="hljs-string">&quot;&lt;leader&gt;gr RollbackHunk&quot;</span>  <br>nmap &lt;leader&gt;gr :action Vcs.RollbackChangedLines&lt;CR&gt;  <br><span class="hljs-string">&quot;生成构造器  </span><br>let g:WhichKeyDesc_GitOrGenerate_GenerateConstructor = <span class="hljs-string">&quot;&lt;leader&gt;gc GenerateConstructor&quot;</span>  <br>nmap &lt;leader&gt;gc :action GenerateConstructor&lt;CR&gt;  <br><span class="hljs-string">&quot;生成getter  </span><br>let g:WhichKeyDesc_GitOrGenerate_GenerateGetter = <span class="hljs-string">&quot;&lt;leader&gt;gg GenerateGetter&quot;</span>  <br>nmap &lt;leader&gt;gg :action GenerateGetter&lt;CR&gt;  <br><span class="hljs-string">&quot;生成setter  </span><br>let g:WhichKeyDesc_GitOrGenerate_GenerateSetter = <span class="hljs-string">&quot;&lt;leader&gt;gs GenerateSetter&quot;</span>  <br>nmap &lt;leader&gt;gs :action GenerateSetter&lt;CR&gt;  <br><span class="hljs-string">&quot;生成setter和getter  </span><br>let g:WhichKeyDesc_GitOrGenerate_GenerateGetterAndSetter = <span class="hljs-string">&quot;&lt;leader&gt;ga GenerateGetterAndSetter&quot;</span>  <br>nmap &lt;leader&gt;ga &lt;action&gt;(GenerateGetterAndSetter)  <br><span class="hljs-string">&quot;生成 equals() 和 hashcode() 的重写方法  </span><br>let g:WhichKeyDesc_GitOrGenerate_GenerateEquals = <span class="hljs-string">&quot;&lt;leader&gt;ge GenerateEquals&quot;</span>  <br>nmap &lt;leader&gt;ge &lt;action&gt;(GenerateEquals)  <br><span class="hljs-string">&quot;生成toString  </span><br>let g:WhichKeyDesc_GitOrGenerate_GenerateToString = <span class="hljs-string">&quot;&lt;leader&gt;ge GenerateToString&quot;</span>  <br>nmap &lt;leader&gt;gt &lt;action&gt;(Actions.ActionsPlugin.GenerateToString)  <br><span class="hljs-string">&quot;diff 显示文件的版本控制历史(git)  </span><br>nmap &lt;leader&gt;gd &lt;action&gt;(Vcs.ShowTabbedFileHistory)  <br>let g:WhichKeyDesc_DebugOrDelete_ShowTabbedFileHistory = <span class="hljs-string">&quot;&lt;leader&gt;gd ShowTabbedFileHistory&quot;</span>  <br>  <br>  <br><span class="hljs-string">&quot;========== h ==========  </span><br><span class="hljs-string">&quot;切换到上一个标签页  </span><br>let g:WhichKeyDesc_PreviousTab = <span class="hljs-string">&quot;&lt;leader&gt;h PreviousTab&quot;</span>  <br>nmap &lt;leader&gt;h :action PreviousTab&lt;CR&gt;  <br>  <br>  <br><span class="hljs-string">&quot;========== i ==========  </span><br><span class="hljs-string">&quot;快速查找并跳转到下一个以 ( 开始的函数或方法调用的位置️  </span><br>let g:WhichKeyDesc_InsertAfterBrackets = <span class="hljs-string">&quot;&lt;leader&gt;i InsertAfterBrackets&quot;</span>  <br>nmap &lt;leader&gt;i f(a  <br>  <br>  <br><span class="hljs-string">&quot;========== j ==========  </span><br><span class="hljs-string">&quot;普通模式下在行尾一个分号，然后进入插入模式并在当前行的下方新建一行  </span><br>let g:WhichKeyDesc_InsertSemicolon = <span class="hljs-string">&quot;&lt;leader&gt;j InsertSemicolon&quot;</span>  <br>nmap &lt;leader&gt;j A;&lt;ESC&gt;o  <br>  <br>  <br><span class="hljs-string">&quot;========== l ==========  </span><br><span class="hljs-string">&quot;切换到下一个标签页  </span><br>let g:WhichKeyDesc_NextTab = <span class="hljs-string">&quot;&lt;leader&gt;l NextTab&quot;</span>  <br>nmap &lt;leader&gt;l :action NextTab&lt;CR&gt;  <br>  <br>  <br><span class="hljs-string">&quot;========== m ==========  </span><br><span class="hljs-string">&quot;打开/关闭 代码小地图  </span><br>let g:WhichKeyDesc_CodeGlance = <span class="hljs-string">&quot;&lt;leader&gt;m CodeGlance&quot;</span>  <br>nmap &lt;leader&gt;m &lt;action&gt;(CodeGlance.toggle)  <br>  <br>  <br><span class="hljs-string">&quot;========== n ==========  </span><br>let g:WhichKeyDesc_NERDTreeOrNew = <span class="hljs-string">&quot;&lt;leader&gt;n NERDTreeOrNew&quot;</span>  <br>  <br><span class="hljs-string">&quot;取消搜索高亮显示(No light)  </span><br>let g:WhichKeyDesc_NERDTreeOrNew_Highlight = <span class="hljs-string">&quot;&lt;leader&gt;nl NoHighlight&quot;</span>  <br>nmap &lt;leader&gt;nl :nohlsearch&lt;CR&gt;  <br><span class="hljs-string">&quot;在当前目录新建文件夹  </span><br>let g:WhichKeyDesc_NERDTreeOrNew_NewDir = <span class="hljs-string">&quot;&lt;leader&gt;nd NewDir&quot;</span>  <br>nmap &lt;leader&gt;nd &lt;action&gt;(NewDir)  <br><span class="hljs-string">&quot;在当前目录新建类  </span><br>let g:WhichKeyDesc_NERDTreeOrNew_NewClass = <span class="hljs-string">&quot;&lt;leader&gt;nc NewClass&quot;</span>  <br>nmap &lt;leader&gt;nc &lt;action&gt;(NewClass)  <br>  <br>  <br><span class="hljs-string">&quot;========== p ==========  </span><br><span class="hljs-string">&quot;从剪切板粘贴到下面行  </span><br>let g:WhichKeyDesc_PasteClipboardDown = <span class="hljs-string">&quot;&lt;leader&gt;p PasteClipboardDown&quot;</span>  <br>nmap &lt;leader&gt;p <span class="hljs-string">&quot;+p  </span><br><span class="hljs-string">&quot;从剪切板粘贴到上面行  </span><br>let g:WhichKeyDesc_PasteClipboardUp = <span class="hljs-string">&quot;&lt;leader&gt;P PasteClipboardUp&quot;</span>  <br>nmap &lt;leader&gt;P <span class="hljs-string">&quot;+P  </span><br><span class="hljs-string">&quot;在可视模式中：从剪切板粘贴到下面行  </span><br>let g:WhichKeyDesc_PasteClipboardDown = <span class="hljs-string">&quot;&lt;leader&gt;p PasteClipboardDown&quot;</span>  <br>vmap &lt;leader&gt;p <span class="hljs-string">&quot;+p  </span><br><span class="hljs-string">&quot;在可视模式中：从剪切板粘贴到上面行  </span><br>let g:WhichKeyDesc_PasteClipboardUp = <span class="hljs-string">&quot;&lt;leader&gt;P PasteClipboardUp&quot;</span>  <br>vmap &lt;leader&gt;P <span class="hljs-string">&quot;+P  </span><br>  <br>  <br><span class="hljs-string">&quot;========== r ==========  </span><br>let g:WhichKeyDesc_RunOrRe = <span class="hljs-string">&quot;&lt;leader&gt;r RunOrRe&quot;</span>  <br>  <br><span class="hljs-string">&quot;运行当前编辑器中的文件或类(Shift + F10)  </span><br>let g:WhichKeyDesc_RunOrRe_RunCalss = <span class="hljs-string">&quot;&lt;leader&gt;ru RunClass&quot;</span>  <br>nmap &lt;leader&gt;ru :action RunClass&lt;CR&gt;  <br><span class="hljs-string">&quot;重新运行最近一次运行的程序或测试(Ctrl+Shift + F10)  </span><br>let g:WhichKeyDesc_RunOrRe_ReRun = <span class="hljs-string">&quot;&lt;leader&gt;rr ReRun&quot;</span>  <br>nmap &lt;leader&gt;rr &lt;action&gt;(Rerun)  <br><span class="hljs-string">&quot;重新运行最近一次运行的测试（Unit Tests）(Ctrl + Shift + F10)  </span><br>let g:WhichKeyDesc_RunOrRe_ReRunTests = <span class="hljs-string">&quot;&lt;leader&gt;rt ReRunTests&quot;</span>  <br>nmap &lt;leader&gt;rt &lt;action&gt;(RerunTests)  <br><span class="hljs-string">&quot;在代码中快速更改一个标识符的名称，并自动处理所有相关的引用(Shift + F6)  </span><br>let g:WhichKeyDesc_RunOrRe_Rename = <span class="hljs-string">&quot;&lt;leader&gt;rn Rename&quot;</span>  <br>map &lt;leader&gt;rn &lt;action&gt;(RenameElement)  <br>  <br>========= s ==========  <br>let g:WhichKeyDesc_Show = <span class="hljs-string">&quot;&lt;leader&gt;s Show&quot;</span>  <br>  <br><span class="hljs-string">&quot;显示当前打开文件的文件结构弹出窗口，其中包含文件中的类、方法、字段等结构(Alt + 7)  </span><br>let g:WhichKeyDesc_Show_FileStructure = <span class="hljs-string">&quot;&lt;leader&gt;ss ShowFileStructure&quot;</span>  <br>nmap &lt;leader&gt;ss &lt;action&gt;(FileStructurePopup)  <br><span class="hljs-string">&quot;显示书签（Bookmarks）工具窗口，其中包含当前文件中设置的书签列表(Ctrl + F11)  </span><br>let g:WhichKeyDesc_Show_Bookmarks = <span class="hljs-string">&quot;&lt;leader&gt;sb ShowBookmarks&quot;</span>  <br>nmap &lt;leader&gt;sb &lt;action&gt;(ShowBookmarks)  <br><span class="hljs-string">&quot;用于显示方法或函数的参数信息(Ctrl + p)  </span><br>let g:WhichKeyDesc_Show_ParameterInfo = <span class="hljs-string">&quot;&lt;leader&gt;sp ShowParameterInfo&quot;</span>  <br>nmap &lt;leader&gt;sp &lt;action&gt;(ParameterInfo)  <br>  <br>  <br><span class="hljs-string">&quot;========= t ==========  </span><br><span class="hljs-string">&quot;翻译  </span><br>let g:WhichKeyDesc_Translate = <span class="hljs-string">&quot;&lt;leader&gt;t Translate&quot;</span>  <br>nmap &lt;leader&gt;t &lt;action&gt;($EditorTranslateAction)  <br>vmap &lt;leader&gt;t &lt;action&gt;($EditorTranslateAction)  <br>  <br>  <br><span class="hljs-string">&quot;========== w ==========  </span><br><span class="hljs-string">&quot;&quot;&quot;&quot;</span>   包含自定义宏，可能无法使用   <span class="hljs-string">&quot;&quot;&quot;&quot;</span>  <br>let g:WhichKeyDesc_Windows = <span class="hljs-string">&quot;&lt;leader&gt;w Windows&quot;</span>  <br>  <br><span class="hljs-string">&quot;取消分割窗口 并 隐藏所有编辑器窗口  </span><br>let g:WhichKeyDesc_Windows_maximize = <span class="hljs-string">&quot;&lt;leader&gt;wo maximize&quot;</span>  <br>nmap &lt;leader&gt;wo &lt;action&gt;(UnsplitAll) \<span class="hljs-string">| &lt;action&gt;(HideAllWindows)  </span><br><span class="hljs-string">&quot;在垂直方向上分割编辑器窗口，将一个编辑器窗口拆分为两个垂直排列的窗格(???)  </span><br>let g:WhichKeyDesc_Windows_splitWindowVertically = <span class="hljs-string">&quot;&lt;leader&gt;wl splitWindowVertically&quot;</span>  <br>nmap &lt;leader&gt;wl &lt;action&gt;(Macro.SplitVertically)  <br><span class="hljs-string">&quot;关闭当前窗口或分割窗格  </span><br>let g:WhichKeyDesc_Windows_closeActiveWindow = <span class="hljs-string">&quot;&lt;leader&gt;wc closeActiveWindow&quot;</span>  <br>nmap &lt;leader&gt;wc &lt;c-w&gt;c  <br>let g:WhichKeyDesc_Windows_HideActiveWindow = <span class="hljs-string">&quot;&lt;leader&gt;wh HideActiveWindow&quot;</span>  <br>nmap &lt;leader&gt;wh &lt;Alt-<span class="hljs-number">6</span>&gt;  <br>  <br>  <br><span class="hljs-string">&quot;========== y ==========  </span><br><span class="hljs-string">&quot;将 &quot;</span>+ 简化为 &lt;leader&gt;  <br>let g:WhichKeyDesc_CopyClipboard = <span class="hljs-string">&quot;&lt;leader&gt;y CopyClipboard&quot;</span>  <br>vmap &lt;leader&gt;y <span class="hljs-string">&quot;+y  </span><br><span class="hljs-string">&quot;将 &quot;</span>+ 简化为 &lt;leader&gt;  <br>let g:WhichKeyDesc_CopyClipboard= <span class="hljs-string">&quot;&lt;leader&gt;y CopyClipboard&quot;</span>  <br>nmap &lt;leader&gt;y <span class="hljs-string">&quot;+yy  </span><br>  <br>  <br><span class="hljs-string">&quot;========== z ==========  </span><br>let g:WhichKeyDesc_Zip = <span class="hljs-string">&quot;&lt;leader&gt;z Zip&quot;</span>  <br>  <br><span class="hljs-string">&quot;展开所有代码折叠区域(Ctrl + Shift + 加号键)  </span><br>let g:WhichKeyDesc_Zip_unZipAll = <span class="hljs-string">&quot;&lt;leader&gt;zo unZipAll&quot;</span>  <br>nmap &lt;leader&gt;zo &lt;action&gt;(ExpandAllRegions)  <br><span class="hljs-string">&quot;折叠所有代码折叠区域(Ctrl + Shift + 减号键)  </span><br>let g:WhichKeyDesc_Zip_ZipAll = <span class="hljs-string">&quot;&lt;leader&gt;zc ZipAll&quot;</span>  <br>nmap &lt;leader&gt;zc &lt;action&gt;(CollapseAllRegions)  <br>  <br>  <br>  <br>  <br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot; 🌸🌸🌸 NERDTree 🌸🌸🌸  </span><br><span class="hljs-string">&quot; ================================================================================================  </span><br><span class="hljs-string">&quot;&lt;C-w-w&gt;：在多个打开的编辑器窗口之间切换  </span><br><span class="hljs-string">&quot;在目录中，按下 go 打开文件并保持光标在目录  </span><br><span class="hljs-string">&quot;在目录中，按下 gi 以上下并排窗口形式打开文件(并关闭目录)  </span><br><span class="hljs-string">&quot;光标在目录时，按Esc回到编辑器  </span><br><span class="hljs-string">&quot;编辑器和目录间切换存在许多功能类似的快捷键，相似但不完全相同  </span><br><span class="hljs-string">&quot;仅 打开/关闭 目录推荐使用&lt;leader&gt;wo 其次 Alt + 1  </span><br>  <br><span class="hljs-string">&quot;按下 &lt;leader&gt;nn 将使焦点转移到 NERDTree 窗口  </span><br>nnoremap &lt;leader&gt;nn :NERDTreeFocus&lt;CR&gt;  <br>let g:WhichKeyDesc_NERDTreeOrNo_NERDTreeFocus = <span class="hljs-string">&quot;&lt;leader&gt;nn NERDTreeFocus&quot;</span>  <br><span class="hljs-string">&quot;按下 &lt;C-n&gt; 将打开 NERDTree 文件资源管理器  </span><br>nnoremap &lt;C-n&gt; :NERDTree&lt;CR&gt;  <br><span class="hljs-string">&quot;按下 &lt;C-t&gt; 将切换 NERDTree 文件资源管理器的显示状态，即打开或关闭 NERDTree  </span><br>nnoremap &lt;C-t&gt; :NERDTreeToggle&lt;CR&gt;  <br><span class="hljs-string">&quot;按下 &lt;C-f&gt; 将在 NERDTree 文件资源管理器中定位当前编辑文件所在的节点，并使其可见  </span><br>nnoremap &lt;C-f&gt; :NERDTreeFind&lt;CR&gt;  <br>  <br>  <br>noremap f :action AceAction&lt;CR&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AOSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux相关</title>
    <link href="/2025/12/75b9a8195245.html"/>
    <url>/2025/12/75b9a8195245.html</url>
    
    <content type="html"><![CDATA[<h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p><a href="https://yuandaimaahao.github.io/AndroidFrameworkTutorialPages/004.%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%AF%87/004.Linux%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E6%9C%BA%E5%88%B6.html">Linux IO 多路复用 epoll 机制 | Android Framework</a></p><p>在 Linux 中：</p><ul><li>IO 就是对文件的读写操作</li><li>多路是指同时读写多个文件</li><li>复用是指使用一个程序处理多个文件的同时读写<br>问题来了，为什么需要多路复用，为了快</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 用于创建一个文件<br>touch test<br>mkdir 用于创建目录<br>mkdir -p dir/dir2/dir3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除文件</span><br>rm file <br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除文件夹</span><br>rm -r dir<br><span class="hljs-meta prompt_">#</span><span class="language-bash">强制删除</span><br>rm -f file<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 强制删除文件夹</span></span><br>rm -rf dir<br>tree . -L 2   查看目录<br><br>在图像界面打开文件夹<br>nautilus /opt<br><br>sudo apt-get install aapt     ##安装软件用apt<br>sudo dpkg -i ScrcpyGui-1.5.1.deb <br><br>sudo apt install vlc<br><br>cd   ~       当前用户主目录<br>cd   /        根目录<br>cd   ..       上一级目录<br>cd            当前用户主目录<br>ls   -l       dir 列出当前目录下的文件信息（此命令很常用，简化的格式为 ll）<br>mkdir: 创建目录<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/schips/p/using_scrcpy_debug_android.html">使用Scrcpy 在电脑显示手机画面并控制安卓设备 - schips - 博客园</a></p><p><strong>sudo</strong> vim 保存没有权限的文件 ：wq!<br><a href="https://www.cnblogs.com/wudaojiuxiao/p/17051622.html">https://www.cnblogs.com/wudaojiuxiao/p/17051622.html</a><br><a href="https://blog.csdn.net/lianghecai52171314/article/details/111098573">https://blog.csdn.net/lianghecai52171314/article/details/111098573</a></p><h2 id="找文件"><a href="#找文件" class="headerlink" title="找文件"></a>找文件</h2><p>比如 service_manager.c</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> . -name <span class="hljs-string">&quot;service_manager.c&quot;</span><br></code></pre></td></tr></table></figure><p>找文件内容，找 recyclerview 库</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">find . -name <span class="hljs-string">&quot;Android.bp&quot;</span> <span class="hljs-string">| xargs grep &quot;</span>name: \<span class="hljs-string">&quot;.*recyclerview.*\&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>find . -name “Android.bp”: 这个指令会从当前目录（. 代表当前目录）开始，递归地查找所有名为”Android.bp” 的文件。<br>|: 管道符号，它将前一个命令的输出作为下一个命令的输入。</p><p>xargs grep “name: &quot;.*recyclerview.*&quot;“: 这个指令会接收上一条find指令找到的所有”Android.bp” 文件路径，并将这些路径作为参数传递给grep 命令。<br>然后, grep 命令会在这些文件中查找与正则表达式 “name: &quot;.*recyclerview.*&quot;“ 匹配的行。<br>正则表达式 “name: &quot;.<em>recyclerview.<em>&quot;“ 意味着匹配包含字符串 “name:”, 紧跟任意字符(.</em>)并且包含字符串 “recyclerview” 和任意字符(.</em>)以及最后是双引号(“) 的行。</p><p>总结起来，这条命令就是查找当前目录及其子目录下所有名为 “Android.bp” 的文件，并检测其中是否有包含特定格式（即”name:” 后跟任意字符并且有 “recyclerview”, 再跟上任意字符和双引号）文本行</p><p>grep -r “messaging.apk”<br>grep 是一个用于在文件中搜索指定模式（字符串）的命令。<br>-r 是 grep 命令的选项之一，代表递归搜索（recursive search）。这个选项告诉 grep 命令在当前目录及其所有子目录中进行搜索。</p><p><em>. 表示当前目录</em>。这个命令将在当前目录及其子目录中搜索文件。<br>因此，grep -r “messaging.apk” . 命令会在当前目录及其所有子目录中搜索包含 “messaging.apk” 的文件行，并将匹配的行打印输出到终端。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> . -name <span class="hljs-string">&quot;ComponentActivity.java&quot;</span><br></code></pre></td></tr></table></figure><h3 id="找文件夹"><a href="#找文件夹" class="headerlink" title="找文件夹"></a>找文件夹</h3><p> sudo find &#x2F;  -name “<em>Android Studio</em>“<br>这个命令会从根目录（”&#x2F;“）开始搜索所有包含”Android Studio”关键字的文件和文件夹。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>env</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/path/to/your/directory:<span class="hljs-variable">$PATH</span>&quot;</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/opt/android studio/bin<br></code></pre></td></tr></table></figure><p>export JAVA_HOME&#x3D;&#x2F;home&#x2F;sixrain&#x2F;aosp11&#x2F;prebuilts&#x2F;jdk&#x2F;jdk11&#x2F;linux-x86&#x2F;bin&#x2F;java&#x2F;<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</p><h2 id="su-root-权限"><a href="#su-root-权限" class="headerlink" title="su root 权限"></a>su root 权限</h2><p>chmod 777 file.txt<br>chmod -R 777 folder_name<br>r 表示读取权限；<br>w 表示写入权限；<br>x 表示执行权限；</p><ul><li>表示无权限。<br>  例如，数字 7 表示所有者、用户组和其他用户都具有读取、写入和执行权限，数字 6 表示所有者和用户组具有读取和写入权限，其他用户没有任何权限。<br>chown -R sixrain ~&#x2F;aosp 更改文件的所有者</li></ul><p>sudo chmod -R 777 out<br>sudo chmod -R 777 aosp </p><h2 id="使用htop查看程序运行的内存状态"><a href="#使用htop查看程序运行的内存状态" class="headerlink" title="使用htop查看程序运行的内存状态"></a>使用htop查看程序运行的内存状态</h2><p><code>htop</code> 是一个在 Linux 系统中常用的系统监控工具，它可以实时地展示系统中各个进程的资源占用情况，如 CPU、内存等。相比于传统的 <code>top</code> 命令，<code>htop</code> 提供了更友好的界面和更方便的操作方式。</p><p>以下是一些基本使用方法：</p><ol><li><strong>安装 htop</strong>：不同的Linux发行版可能有不同的安装命令。在Ubuntu或Debian上，你可以使用 <code>sudo apt-get install htop</code> 来安装。而在CentOS上，则可以使用 <code>sudo yum install htop</code>.</li><li><strong>启动 htop</strong>：在终端输入 <code>htop</code> 并回车即可启动。</li><li><strong>理解界面</strong>：从上至下分别为系统概览（包括CPU、内存、交换空间利用率等）、进程列表和操作提示。</li><li><strong>操作指南</strong>：<ul><li>上下箭头: 在进程列表中移动。</li><li>F1 或者h: 显示帮助。</li><li>F2 或者S: 进入设置菜单。</li><li>F3 或者&#x2F; : 搜索进程。</li><li>F4 或者: 根据用户过滤进程。</li><li>F5 或者t: 展示&#x2F;隐藏树状视图。</li><li>F6,&gt;,&lt;,: 根据CPU%,MEM%,TIME+等排序进程列表</li><li>F9 k: 结束选定进程.</li><li>F10 q : 退出htop.<br>这只是基础功能介绍，你还可以通过F2来自定义显示内容或颜色主题等。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-27-16-01-25b9f22da78dfc035f4bbf467cad703f-2023-09-22-10-25-25b9f22da78dfc035f4bbf467cad703f-20230922102517-497185-781bf1.png" alt="image.png"></li></ul></li></ol><h2 id="固定IP"><a href="#固定IP" class="headerlink" title="固定IP"></a>固定IP</h2><p>[[Android 系统开发工具推荐#[ ](https &#x2F;&#x2F;yuandaimaahao.github.io&#x2F;AndroidFrameworkTutorialPages&#x2F;002.%E7%8E%A9%E8%BD%ACAOSP%E7%AF%87&#x2F;002.%20%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90.html _1-2-ssh-%E5%AE%A2%E6%88%B7%E7%AB%AF-tabby-terminal) 1.2 ssh 客户端 Tabby Terminal|ssh的安装]]</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">ens33:</span>   <span class="hljs-comment"># 网卡名称</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>     <span class="hljs-comment"># 关闭dhcp</span><br>      <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.123</span><span class="hljs-number">.102</span><span class="hljs-string">/24</span>]  <span class="hljs-comment"># 静态ip，根据自己网络情况配置</span><br>      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.123</span><span class="hljs-number">.1</span>     <span class="hljs-comment"># 网关，根据自己网络情况配置</span><br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>] <span class="hljs-comment">#dns，根据自己网络情况配置</span><br><br><span class="hljs-string">//192.168.123.102</span><br></code></pre></td></tr></table></figure><h2 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h2><p>SELinux（Security-Enhanced Linux）是一种Linux内核的安全模块，它为Linux系统提供了访问控制安全策略。在Android中，SELinux以强制访问控制（MAC）形式存在，用于增强系统安全性。</p>]]></content>
    
    
    <categories>
      
      <category>AOSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AOSP总结</title>
    <link href="/2025/12/ce9b0a1a7f53.html"/>
    <url>/2025/12/ce9b0a1a7f53.html</url>
    
    <content type="html"><![CDATA[<h1 id="AOSP"><a href="#AOSP" class="headerlink" title="AOSP"></a>AOSP</h1><p>看分析文章，看源码，调试源码，自己实现，是四个完全不同的层级，每一级对源码的理解都不一样<br>Android Open Source Project</p><p> 引用： </p><blockquote><p><a href="https://yuandaimaahao.github.io/AndroidFrameworkTutorialPages/002.%E7%8E%A9%E8%BD%ACAOSP%E7%AF%87/001.%20AOSP%E6%9E%81%E9%80%9F%E4%B8%8A%E6%89%8B.html">Android Framework</a><br><a href="https://github.com/yuandaimaahao/AndroidFrameworkTutorial">https://github.com/yuandaimaahao/AndroidFrameworkTutorial</a><br><a href="https://juejin.cn/post/7207358268804579386">使用 Android Studio 开发系统 App</a><br><a href="https://juejin.cn/post/7277799790287912960?utm_source=gold_browser_extension">系统开发专用版 Android Studio 上手指南 - 掘金</a></p></blockquote><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><a href="https://www.jianshu.com/p/197096d3206d">下载AOSP源码编译、调试、刷机</a><br><a href="https://juejin.cn/post/6942379122077204517">Ubuntu 20.04 添加新的Swap分区 - 掘金</a></p><p>下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-string">&quot;&quot;</span> <br>git config --global user.name <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-built_in">mkdir</span> aosp11 <br><span class="hljs-built_in">cd</span> aosp11<br><span class="hljs-comment">#初始化仓库,-b 指示分支，这里使用 android10</span><br>repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r4<br><span class="hljs-comment">#同步远程代码</span><br>repo <span class="hljs-built_in">sync</span><br></code></pre></td></tr></table></figure><p>编译源码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">source</span> build/envsetup.<span class="hljs-keyword">sh</span><br>lunch aosp_x86_64-eng<br><span class="hljs-keyword">make</span> -j1   <span class="hljs-number">12</span>  <span class="hljs-keyword">m</span><br><span class="hljs-keyword">make</span> clean<br></code></pre></td></tr></table></figure><h2 id="源码文件目录结构"><a href="#源码文件目录结构" class="headerlink" title="源码文件目录结构"></a>源码文件目录结构</h2><p><a href="https://juejin.cn/post/7202826051541532727?searchId=202401241808311012EC739EC068115F5F">【视频文稿】车载Android应用开发与分析 - AOSP的下载与编译 - 掘金</a></p><ul><li>package<br>应用层（Application）源码。系统应用就在这里了，比如说系统设置，桌面，相机，电话之类的。</li><li>frameworks<br>系统框架（Framework）层源码。</li><li>hardware<br>硬件抽象（HAL）层源码。</li><li>out<br>输出目录。编译以后生成的目录，相关的产出就在这里了<br>在 Android 的源代码编译系统中，<em>out&#x2F;soong 通常是一个存放编译过程中生成的临时文件和最终构建产物的目录</em>。</li><li>build<br>用于构建 Android 系统的工具。也就是用于编译 Android 系统的</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><a href="https://blog.csdn.net/liudi_ly/article/details/108773356">同步用python 3.8，编译用2.7</a><br>切换Python配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sudo <span class="hljs-keyword">update</span><span class="hljs-operator">-</span>alternatives <span class="hljs-comment">--config python</span><br></code></pre></td></tr></table></figure><p>如果可能，尝试清理构建环境并重新编译（例如运行 make clean 或者直接删除整个 out&#x2F;soong&#x2F;.intermediates&#x2F; 目录后再次编译）。</p><p><a href="https://blog.csdn.net/didayuye/article/details/130462203">AOSP编译问题</a></p><p><a href="https://blog.csdn.net/mingmigndfds/article/details/113884464">ubuntu16.04 编译Android AOSP源码 android10</a></p><h2 id="Android-bp"><a href="#Android-bp" class="headerlink" title="Android.bp"></a>Android.bp</h2><p>Android.bp 文件是用于构建 Android 系统或 Android 应用的<em>构建描述文件</em>。它是在 Android Open Source Project (AOSP) 中引入的一种构建系统脚本语言，<strong>取代了旧版本的 Makefile，一种新的编译文件</strong>。</p><p><em>Android.bp 文件用于定义项目的模块、依赖关系、编译选项以及其他构建规则</em>。通过编写 Android.bp 文件，可以指定项目的源代码文件、资源文件、库依赖关系、编译选项等信息，以及生成最终构建产物（例如 APK 文件）所需的各个步骤和过程。</p><p>使用 Android.bp 文件进行构建有以下优势：</p><p>可读性好：相比于 Makefile，Android.bp 文件更易于阅读和理解，使构建配置更加清晰明了。<br>扩展性强：Android.bp 提供了丰富的构建规则和函数，可以方便地扩展和定制构建流程。<br>并行构建：Android.bp 支持并行构建，提高构建效率。<br>需要注意的是，Android.bp 文件通常与 Soong 构建系统配合使用。Soong 是 Android 中的新构建系统，用于替代旧的 Make 构建系统。Android.bp 文件是 Soong 构建系统的配置文件之一，用于描述单个模块的构建规则。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/AOSP.resources/2023/09/15/17-21-45-5f6a8510df59588834a839d1a1bf792f-unknown_filename-677872.png" alt="unknown_filename"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">android_app <span class="hljs-punctuation">&#123;</span><br>    name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FirstSystemApp&quot;</span><span class="hljs-punctuation">,</span><br>    srcs<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*.java&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    resource_dirs<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;res&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    manifest<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AndroidManifest.xml&quot;</span><span class="hljs-punctuation">,</span><br>    platform_apis<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><br>    sdk_version<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    certificate<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;platform&quot;</span><span class="hljs-punctuation">,</span><br>    product_specific<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//依赖</span><br>    static_libs<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;androidx.appcompat_appcompat&quot;</span><span class="hljs-punctuation">,</span><br>                 <span class="hljs-string">&quot;com.google.android.material_material&quot;</span><span class="hljs-punctuation">,</span><br>                 <span class="hljs-string">&quot;androidx-constraintlayout_constraintlayout&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="AIDEGen"><a href="#AIDEGen" class="headerlink" title="AIDEGen"></a>AIDEGen</h2><p>AIDEGen，我叫它 “爱得跟”，大概是 Android10 中，google 推出的一个工具，用于方便开发者使用 IDE 来查看和修改系统源码,使用 “爱得跟” 之前我们需要做一些准备工作，编译 sdk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br>lunch sdk-eng<br><span class="hljs-comment"># or</span><br><span class="hljs-comment">#lunch sdk-userdebug</span><br><span class="hljs-comment"># or</span><br><span class="hljs-comment">#lunch sdk-user</span><br>make sdk<br></code></pre></td></tr></table></figure><p>接着我们需要去 google 官方下载 Android Studio，这里推荐3.6.3版本，并将其放到 &#x2F;opt 目录下。</p><p>接下来，选择我们的目标 Product：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br>lunch aosp_x86_64-eng<br></code></pre></td></tr></table></figure><p>做好以上准备工作后，我们就可以打开系统模块了，这里我们以 Settings 为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"># Settings 更换为其他模块名或是模块存在的路径即可打开其他模块<br>aidegen Settings -<span class="hljs-selector-tag">i</span> s  # -<span class="hljs-selector-tag">i</span> 表示使用ide，s 表示 Android Studio<br><br>aidegen Launcher3 -<span class="hljs-selector-tag">i</span> s  <br></code></pre></td></tr></table></figure><p><em>settings的路径</em>：aosp&#x2F;packages&#x2F;app&#x2F;Settings</p><h2 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">emulator -<span class="hljs-built_in">verbose</span>    查看日志<br>emulator -<span class="hljs-built_in">verbose</span> -cores <span class="hljs-number">4</span> -<span class="hljs-built_in">show</span>-kernel<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.resources/2023/09/15/17-43-51-0d757e05ff2bc085b0c2f1d1ae861bdf-unknown_filename-cf14ca.png" alt="unknown_filename"><br><a href="https://www.cnblogs.com/chiefhsing/p/5175624.html">https://www.cnblogs.com/chiefhsing/p/5175624.html</a></p><h2 id="mm和mmm的主要区别"><a href="#mm和mmm的主要区别" class="headerlink" title="mm和mmm的主要区别"></a>mm和mmm的主要区别</h2><p>在Android源码编译中，mm和mmm的主要区别在于它们编译的范围。</p><ol><li>mm：这个命令用于<em>在当前目录下编译模块</em>。所谓模块，就是一个可执行文件、库或者APK等。比如你正在某个应用的目录下（例如packages&#x2F;apps&#x2F;Calculator），执行mm将会只编译这个计算器应用。</li><li>mmm：这个命令与mm类似，但是它<em>允许你指定一个路径来编译模块</em>。例如，在源代码根目录下执行mmm packages&#x2F;apps&#x2F;Calculator将会只编译计算器应用。<br>总结一下，如果你已经处在需要编译的模块目录下，则使用mm；如果你不在需要编译的模块目录下，则使用mmm并指定相对应的路径。</li></ol><h2 id="mm和mma"><a href="#mm和mma" class="headerlink" title="mm和mma"></a>mm和mma</h2><p>在Android源码编译中，<code>mma</code>和<code>mm</code>命令都是用于编译模块的，但它们之间存在一些区别：</p><ol><li><code>mm</code>: 这个命令只会编译当前目录下的模块，<em>并且不包括依赖项</em>。这意味着如果你正在尝试编译一个模块，而这个模块依赖于另一个尚未编译的模块，则该命令可能会失败。因此，使用 <code>mm</code> 前需要确保所有依赖项都已经被正确地构建了。</li><li><code>mma</code>: 这个命令将会编译当前目录下的模块<em>以及其所有依赖项</em>。也就是说，如果你正在尝试构建一个有很多依赖项的大型项目或者库文件，那么使用 <code>mma</code> 可能更为方便。</li></ol><p>总结来说, mm 是单独对某一组件进行增量式构建, 不考虑其相关联组件；而 mma 则会考虑到相关联组件进行增量式构建</p><h2 id="编译某个单独的模块"><a href="#编译某个单独的模块" class="headerlink" title="编译某个单独的模块"></a>编译某个单独的模块</h2><p>如果我们要编译系统的Settings应用模块，这就属于源码单编某一个模块，在AOSP根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br>lunch aosp_x86_64-eng<br></code></pre></td></tr></table></figure><p>进入Settings的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> packages/apps/Settings<br></code></pre></td></tr></table></figure><p>通过mm编译当前目录下的模块，不编译依赖模块。</p><p>编译成功后会有提示生成文件的存放路径。除了Settings.odex文件，还会在out&#x2F;target&#x2F;product&#x2F;generic_x86&#x2F;system&#x2F;priv-app&#x2F;Settings目录下生成Settings.apk。</p><p>如果对系统模块的源码进行修改，查看生成的APK文件，有两种方式：</p><ul><li>通过adb push或者adb install 来安装APK。</li><li>使用make snod命令，重新生成 system.img，运行模拟器查看。</li></ul><h2 id="熟悉模块"><a href="#熟悉模块" class="headerlink" title="熟悉模块"></a>熟悉模块</h2><p>熟悉Android framework中一个或数个功能模块框架，如GPS、WiFi、BT，Camera，音视频编解码，Telephony ，系统应用(Settings，SystemUl， Launcher) 等</p><p><a href="https://github.com/Launcher3-dev/Launcher3">Launcher3-dev&#x2F;Launcher3: 来源 AOSP Launcher3 源码，单层桌面请查看Launcher-mx项目：</a><br>[[8-Launcher学习]]</p><h2 id="调试系统App-Settings"><a href="#调试系统App-Settings" class="headerlink" title="调试系统App Settings"></a>调试系统App Settings</h2><p>首先，我们开一个新的终端，打开模拟器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br>lunch aosp_x86_64-eng<br>emulator<br></code></pre></td></tr></table></figure><ul><li>接着我们在 Settings&#x2F;AndroidManifest.xml 查找到 Settings App 的首 Activity 为 SettingsHomepageActivity，我们在其 onCreate 出打一个断点</li><li>接着在 Android 模拟器中打开 Settings 应用。</li><li>点击 android studio 的 debug 按钮，选择进程，和普通APP一样</li></ul><h2 id="添加-Product"><a href="#添加-Product" class="headerlink" title="添加 Product"></a>添加 Product</h2><p>Android 的系统源码，经过简单的配置，可以打包出不同的系统镜像，<em>用于不同的产品。例如小米 12s，小米12s pro</em>，小米12s ultra 均源于骁龙8+平台。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-10-45-986307ec847097835d58ba2a0bd55475-20230919104546-5784a9.png" alt="image.png"></p><p>添加自己的product</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Jelly/</span><br><span class="hljs-keyword"></span>└── Rice14<br>    ├── <span class="hljs-keyword">AndroidProducts.mk</span><br><span class="hljs-keyword"></span>    ├── <span class="hljs-keyword">BoardConfig.mk</span><br><span class="hljs-keyword"></span>    └── Rice14.mk<br></code></pre></td></tr></table></figure><p>BoardConfig.mk 包含了硬件芯片架构配置，分区大小配置等信息</p><p>Rice14.mk 修改最后4行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Overrides</span><br>PRODUCT_BRAND := Jelly<br>PRODUCT_NAME := Rice14<br>PRODUCT_DEVICE := Rice14<br>PRODUCT_MODEL := Android SDK built for x86_64 Rice14<br></code></pre></td></tr></table></figure><p>AndroidProducts.mk 内容如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">PRODUCT_MAKEFILES := <span class="hljs-string">\</span><br>    $(LOCAL_DIR)/Rice14.mk<br><br>COMMON_LUNCH_CHOICES := <span class="hljs-string">\</span><br>    Rice14-eng <span class="hljs-string">\</span><br>    Rice14-userdebug <span class="hljs-string">\</span><br>    Rice14-user <span class="hljs-string">\</span><br></code></pre></td></tr></table></figure><p>最后</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">source</span> build/envsetup.<span class="hljs-keyword">sh</span><br>lunch Rice14-eng<br><span class="hljs-keyword">make</span> -j16<br>emulator<br></code></pre></td></tr></table></figure><h2 id="ARM-Android-行业流程与-Android-分区"><a href="#ARM-Android-行业流程与-Android-分区" class="headerlink" title="ARM + Android 行业流程与 Android 分区"></a>ARM + Android 行业流程与 Android 分区</h2><p>ARM + Android 这个行业，一个简化的普遍流程：</p><ol><li>Google 开发迭代 AOSP + Kernel</li><li>芯片厂商，针对自己的芯片特点，移植 AOSP 和 Kernel，使其可以在自己的芯片上跑起来。</li><li>方案厂商（很多芯片厂商也扮演了方案厂商的角色），设计电路板，给芯片添加外设，在芯片厂商源码基础上开发外设相关软件，主要是驱动和 hal，改进性能和稳定性。</li><li>产品厂商，主要是系统软件开发，UI 定制以及硬件上的定制(添加自己的外设)，改进性能和稳定性.</li></ol><p><em>不同产品之间公共的部分放在 System 和 Vender 分区，差异的部分放在 Odm 和 Product 分区</em>。<br>硬件上，产品 A 可能用的是京东方的屏，产品 B 可能用的是三星的屏；差异硬件相关的软件部分都会放在 Odm 分区<br>产品 A 可能是带广告的版本，产品 B 可能是不带广告的版本。这些有差异的软件部分都放在 Product 分区</p><h2 id="删除已有模块"><a href="#删除已有模块" class="headerlink" title="删除已有模块"></a>删除已有模块</h2><p>有的时候，我们需要删除系统中已有的模块，比如我们系统的应用场景是广告牌、电视，那我们就需要删除电话，通信录等应用。下面以删除通信录（Contacts）为例，演示如何操作：</p><p>在源码的 build 目录下，先查找<br>grep -r “Contacts” .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">./make/target/product/handheld_product.mk:    Contacts \<br>./make/target/product/mainline_arm64.mk:  system/priv-app/Contacts/Contacts.apk \<br>./make/target/product/base_system.mk:    ContactsProvider \<br>./make/core/build-system.html:Dialer, Contacts, etc.  This will probably change or go away when we <span class="hljs-keyword">switch</span><br></code></pre></td></tr></table></figure><p>在源码的 build 目录下的 .&#x2F;make&#x2F;target&#x2F;product&#x2F;handheld_product.mk 中删除 PRODUCT_PACKAGES 变量的 Contacts</p><p>接着重新编译启动模拟器：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">source</span> build/envsetup.<span class="hljs-keyword">sh</span><br>lunch Rice14-eng<br><span class="hljs-keyword">make</span> clean<br><span class="hljs-keyword">make</span> -j16<br>emulator<br></code></pre></td></tr></table></figure><p>可以看到，Contacts 应用已经没有了</p><h2 id="新建一个系统-App-项目"><a href="#新建一个系统-App-项目" class="headerlink" title="新建一个系统 App 项目"></a>新建一个系统 App 项目</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-10-58-825b451301b535ef2b94db40d5a251bd-20230919105803-118a80.png" alt="image.png"></p><ol><li>创建as项目</li><li>修改已添加的 Android.bp 文件<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">android_app</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;FirstSystemApp&quot;</span>,<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    srcs:</span> [<span class="hljs-string">&quot;src/**/*.java&quot;</span>],<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    resource_dirs:</span> [<span class="hljs-string">&quot;res&quot;</span>],<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    manifest:</span> <span class="hljs-string">&quot;AndroidManifest.xml&quot;</span>,<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    platform_apis:</span> true,<br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">    sdk_version:</span> <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    certificate:</span> <span class="hljs-string">&quot;platform&quot;</span>,<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    product_specific:</span> true,<br><br>    <span class="hljs-comment">//依赖</span><br><span class="hljs-symbol">    static_libs:</span> [<span class="hljs-string">&quot;androidx.appcompat_appcompat&quot;</span>,<br>                 <span class="hljs-string">&quot;com.google.android.material_material&quot;</span>,<br>                 <span class="hljs-string">&quot;androidx-constraintlayout_constraintlayout&quot;</span>],<br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>接着在我们的 Product 中添加这个App，修改 <code>device/Jelly/Rice14/Rice14.mk</code>：</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 添加以下内容</span><br>PRODUCT_PACKAGES += FirstSystemApp<br></code></pre></td></tr></table></figure><ol start="4"><li>接着编译系统，启动虚拟机，打开 app</li></ol><p>当我们的系统 App 需要引入一个库的时候，通常会在 prebuilds 目录下查找：</p><ul><li>androidx 相关库引入，先在 prebuilts&#x2F;sdk&#x2F;current&#x2F;androidx 下寻找配置好的 bp 文件</li><li>其他库引入，先在 prebuilts&#x2F;tools&#x2F;common&#x2F;m2 下寻找寻找配置好的 bp 文件</li></ul><h3 id="以-aar-包形式引入"><a href="#以-aar-包形式引入" class="headerlink" title="以 aar 包形式引入"></a>以 aar 包形式引入</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">liblottie</span>/<br>├── Android.<span class="hljs-keyword">bp</span><br>└── lottie-<span class="hljs-number">5</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.aar<br></code></pre></td></tr></table></figure><p>其中 Android.bp 的内容如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">android_library_import</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;lib-lottie&quot;</span>,<br><span class="hljs-symbol">    aars:</span> [<span class="hljs-string">&quot;lottie-5.2.0.aar&quot;</span>],<br><span class="hljs-symbol">    sdk_version:</span> <span class="hljs-string">&quot;current&quot;</span>,<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>static_libs</strong> :添加依赖库<br>然后我们修改 FirstSystemApp 中的 Android.bp 引入这个库：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">static_libs:</span> [<span class="hljs-string">&quot;androidx.appcompat_appcompat&quot;</span>,<br>              <span class="hljs-string">&quot;com.google.android.material_material&quot;</span>,<br>              <span class="hljs-string">&quot;androidx-constraintlayout_constraintlayout&quot;</span>,<br>              <span class="hljs-string">&quot;FirstSystemAndroidLibrary&quot;</span>,<br>               <span class="hljs-string">&quot;lib-lottie&quot;</span>],<br></code></pre></td></tr></table></figure><p>这样就可以在 App 中使用 lottie 库了</p><h3 id="系统-App-与-普通-App-的差异"><a href="#系统-App-与-普通-App-的差异" class="headerlink" title="系统 App 与 普通 App 的差异"></a>系统 App 与 普通 App 的差异</h3><h4 id="系统-App-可以使用更多的-api"><a href="#系统-App-可以使用更多的-api" class="headerlink" title="系统 App 可以使用更多的 api"></a>系统 App 可以使用更多的 api</h4><p>调用 Hide 的 Api<br>当 platform_apis 为 true 时，sdk_version 必须为空。这种情况下我们的 app 会使用平台 API 进行编译而不是 SDK，这样我们的 App 就能访问到非 SDK API 了</p><h4 id="系统-App-的签名"><a href="#系统-App-的签名" class="headerlink" title="系统 App 的签名"></a>系统 App 的签名</h4><p>AOSP 内置了 apk 签名文件，我们可以在 Android.bp 中通过 certificate 配置系统 app 的签名文件</p><h4 id="系统-App-能使用更多的权限"><a href="#系统-App-能使用更多的权限" class="headerlink" title="系统 App 能使用更多的权限"></a>系统 App 能使用更多的权限</h4><h4 id="系统-App-能更轻松地实现进程保活"><a href="#系统-App-能更轻松地实现进程保活" class="headerlink" title="系统 App 能更轻松地实现进程保活"></a>系统 App 能更轻松地实现进程保活</h4><p>三方 App 为了不被杀掉，可以说是用尽了千方百计。保活对于系统 App 其实是非常简单的：</p><p>在 AndroidManifest.xml 中添加如下参数即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;application<br>    android:<span class="hljs-attribute">persistent</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="系统-App-添加依赖"><a href="#系统-App-添加依赖" class="headerlink" title="系统 App 添加依赖"></a>系统 App 添加依赖</h3><p>在 <code>Android.bp</code> 中引入：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">android_library_import</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;androidx.recyclerview_recyclerview-nodeps&quot;</span>,<br><span class="hljs-symbol">    aars:</span> [<span class="hljs-string">&quot;m2repository/androidx/recyclerview/recyclerview/1.1.0-alpha07/recyclerview-1.1.0-alpha07.aar&quot;</span>],<br><span class="hljs-symbol">    sdk_version:</span> <span class="hljs-string">&quot;current&quot;</span>,<br><span class="hljs-symbol">    min_sdk_version:</span> <span class="hljs-string">&quot;14&quot;</span>,<br><span class="hljs-symbol">    static_libs:</span> [<br>        <span class="hljs-string">&quot;androidx.annotation_annotation&quot;</span>,<br>        <span class="hljs-string">&quot;androidx.collection_collection&quot;</span>,<br>        <span class="hljs-string">&quot;androidx.core_core&quot;</span>,<br>        <span class="hljs-string">&quot;androidx.customview_customview&quot;</span>,<br>    ],<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><h2 id="Android里AIDEGen和Idegen"><a href="#Android里AIDEGen和Idegen" class="headerlink" title="Android里AIDEGen和Idegen"></a>Android里AIDEGen和Idegen</h2><p>Idegen 编译成android.ipr 和 android.iml  方便查看源码<br>AIDEGen 方便开发者使用 IDE 来查看和修改系统源码。</p><p> <strong>aidegen介绍</strong><br> [[Android 系统开发工具推荐#^3b8a5e| 如何编译aidegen]]<br>aidegen是AOSP中自带的一个工具，可以将源码中的某个工程导入进IDE，从而可以使用IDE的智能提示，提高编码效率。而源码中的工程并不是独立存在的，还会依赖其他工程中的各种模块，aidegen 会主动把对应的模块编译一遍，同时把这些依赖都整理好导入到IDE中，从而避免因为找不到依赖而爆红的问题。</p><h2 id="mk文件"><a href="#mk文件" class="headerlink" title="mk文件"></a>mk文件</h2><p>在软件开发中，.mk 文件通常是用于构建（build）和编译（compile）代码的 Makefile 文件的扩展名。Makefile 是一种脚本文件，其中包含了一系列构建和编译源代码的规则、命令和依赖关系。</p><p>Makefile 文件使用 Make 工具来根据规则中定义的依赖关系和命令来自动化代码构建过程。Make 工具会解析 Makefile 文件，并根据需要执行相应的构建命令，以确保源代码正确地编译成可执行文件、库文件或其他所需的目标。</p><p>在 .mk 文件中，您可以定义变量、规则（例如编译规则、链接规则等）和其他构建相关的配置。这些文件通常由开发人员根据项目的需要进行编写和维护。</p><h2 id="fastboot"><a href="#fastboot" class="headerlink" title="fastboot"></a>fastboot</h2><p>Android fastboot 是一种用于在 Android 设备上执行各种操作的命令行工具。它是 Android 平台上的一个工具集之一，通常与 Android SDK（软件开发工具包）一起使用。</p><p>Fastboot 提供了一种与设备进行通信并执行一系列操作的方式，包括但不限于以下内容：</p><p>刷写固件：通过 fastboot 命令，您可以将新的固件（如操作系统、引导程序等）刷写到 Android 设备中，从而更新或修改设备的软件。</p><p>进入 bootloader 模式：通过 fastboot 命令，您可以将 Android 设备设置为 bootloader 模式，这是设备的引导程序。在 bootloader 模式下，您可以执行诸如刷写固件、解锁引导加载程序等操作。</p><p>解锁引导加载程序：某些 Android 设备的引导加载程序（bootloader）可能被锁定，以防止未经授权的固件刷写。fastboot 命令可以用于解锁引导加载程序，以便您可以自由刷写或修改设备的固件。</p><p>查看设备状态：fastboot 命令可以用于获取有关设备的信息，例如设备序列号、产品型号、固件版本等。</p><p>请注意，使用 fastboot 命令需要在计算机上安装 Android SDK，并在 USB 调试模式下连接支持 fastboot 的 Android 设备。</p><p>使用 fastboot 命令需要谨慎操作，因为错误的使用可能导致设备出现问题或数据丢失。在使用 fastboot 前，请确保您对操作有足够的了解或按照官方文档和指南进行操作。</p><h2 id="HIDL"><a href="#HIDL" class="headerlink" title="HIDL"></a>HIDL</h2><p>HIDL，全称为Hardware Interface Definition Language（硬件接口定义语言），是Android 8.0引入的一种新的硬件抽象层（HAL）框架。</p><p>在以往的Android系统版本中，HAL是通过C语言实现的，并且通常与特定版本的Android系统紧密耦合。这就意味着当Android系统升级时，相关的硬件驱动也需要更新以适配新版系统。</p>]]></content>
    
    
    <categories>
      
      <category>AOSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>adb快捷键</title>
    <link href="/2025/12/01510837f138.html"/>
    <url>/2025/12/01510837f138.html</url>
    
    <content type="html"><![CDATA[<p><strong>代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">adb shell settings put global http_proxy :<span class="hljs-number">0</span><br><br>adb shell settings put global http_proxy <span class="hljs-number">10.14</span><span class="hljs-number">.164</span><span class="hljs-number">.31</span>:<span class="hljs-number">9090</span><br><br>adb shell dumpsys <span class="hljs-keyword">package</span> com.miui.home | grep  versionName·<br></code></pre></td></tr></table></figure><p>不能断点时</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">adb kill-<span class="hljs-keyword">server</span><br>adb <span class="hljs-keyword">start</span>-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>查看当前页面</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">adb shell dumpsys activity <span class="hljs-built_in">top</span> | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;ACTIVITY&quot;</span><br></code></pre></td></tr></table></figure><p>ipconfig &#x2F;flushdns 清除DNS缓存内容。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">adb devices<br>adb install D:\\allin\_android\\allinmd\_android\_social\\app\\build\\outputs\\apk\\debug\\app-debug.apk<br><br>adb pull <span class="hljs-regexp">/sdcard/</span>charles.zip <span class="hljs-regexp">/Users/</span>allin156<span class="hljs-regexp">/Desktop/</span><br>adb pull <span class="hljs-regexp">/data/</span>anr/traces.txt<br>adb <span class="hljs-keyword">push</span> <span class="hljs-regexp">/Users/</span>jgwl<span class="hljs-regexp">/Documents/</span>reqable-ca.crt <span class="hljs-regexp">/sdcard/</span><br><br>adb bugreport<br></code></pre></td></tr></table></figure><p><strong>奔溃日志</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> dumpsys dropbox --<span class="hljs-built_in">print</span> &gt;&gt;Desktop/1.<span class="hljs-built_in">log</span></span><br>adb <span class="hljs-keyword">shell</span><span class="language-bash"> dumpsys dropbox --<span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;newest\_time&#125;</span> &gt;&gt;Desktop/1.<span class="hljs-built_in">log</span></span><br><br>adb <span class="hljs-keyword">shell</span><span class="language-bash"> dumpsys meminfo  com.esread.sunflowerstudent -d</span><br>adb <span class="hljs-keyword">shell</span><span class="language-bash"> dumpsys meminfo \[PackageName\]</span><br></code></pre></td></tr></table></figure><p>可以打印出指定包名的应用内存信息<br>目前栈中所有的Activity的实例，如果数量大于1，说明有内存泄漏的界面。</p>]]></content>
    
    
    <categories>
      
      <category>AOSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络库源码</title>
    <link href="/2025/12/6700cce7f7bf.html"/>
    <url>/2025/12/6700cce7f7bf.html</url>
    
    <content type="html"><![CDATA[<h2 id="网络框架比较"><a href="#网络框架比较" class="headerlink" title="网络框架比较"></a>网络框架比较</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-32-44351e3e33aa204282926a28c2cdf16a-453842de-7718-465d-9dbd-210f6c940968-03f153.png" alt="453842de-7718-465d-9dbd-210f6c940968"></p><ul><li><p>在Android 2.3版本及以后，HttpClientHttpURLConnection则是最佳的选择，HttpURLConnection的API提供的比较简单，可以更加容易地去使用和扩展它。而且速度快、节省电量。内部也改成了OkHttp</p></li><li><p>OkHttp 处理了很多网络问题：自动重连、会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题、SSL握手失败问题、自签名。</p></li><li><p>volley的设计目标就是非常适合数据量小，通信量大的客户端，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。Volley停止了更新，而OkHttp得到了官方的认可，并在不断优化。因此我最终替换为了OkHttp</p></li><li><p>如何取消一个网络请求call.cancel();(okhttp)，在activity的ondestory里取消网络请求</p></li></ul><h2 id="okHttp"><a href="#okHttp" class="headerlink" title="okHttp"></a>okHttp</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>大部分库都有，自动智能请求重试 ;持久化 cookie 存储<br>1.高性能Http请求库。<br>2.支持SPDY，共享同一个Socket来处理同一个服务器所有的请求.<br>3.支持http2.0、websocket;支持同步、异步。<br>4.内部封装了线程池、数据转换、参数使用、错误处理等。<br>5.支持GZIP来减少数据流量。<br>6.基于NIO和<strong>OKio</strong>，性能更高。</p><p>HTTP 1. x 中，如果想并发多个请求，必须使用多个 TCP 链接<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-32-fbc7923dd2429956477daaa572db2d28-unknown_filename.4-55dd62.png" alt="unknown_filename.4"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//okhttp第一步</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">okhttpAsyGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//okhttp第二步</span><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>                .url(<span class="hljs-string">&quot;http://publicobject.com/helloworld.txt&quot;</span>)<br>                .build();<br><br>        <span class="hljs-comment">//okhttp第三步</span><br>        okhttp3.<span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br><br>        <span class="hljs-keyword">if</span> (!response.isSuccessful()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unexpected code &quot;</span> + response);<br><br>        <span class="hljs-type">Headers</span> <span class="hljs-variable">responseHeaders</span> <span class="hljs-operator">=</span> response.headers();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; responseHeaders.size(); i++) &#123;<br>            System.out.println(responseHeaders.name(i) + <span class="hljs-string">&quot;: &quot;</span> + responseHeaders.value(i));<br>        &#125;<br><br>        System.out.println(response.body().string());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">OkHttpSyncGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>                .url(<span class="hljs-string">&quot;http://publicobject.com/helloworld.txt&quot;</span>)<br>                .build();<br><br>        client.newCall(request).enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call call, okhttp3.Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-keyword">if</span> (!response.isSuccessful()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unexpected code &quot;</span> + response);<br><br>                <span class="hljs-type">Headers</span> <span class="hljs-variable">responseHeaders</span> <span class="hljs-operator">=</span> response.headers();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;<br>                    System.out.println(responseHeaders.name(i) + <span class="hljs-string">&quot;: &quot;</span> + responseHeaders.value(i));<br>                &#125;<br>                System.out.println(response.body().string());<span class="hljs-comment">//只能获取一次，可以用string保存</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>  <br>String <span class="hljs-title function_">post</span><span class="hljs-params">(String url, String json)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br> <br>     <span class="hljs-type">RequestBody</span> <span class="hljs-variable">formBody</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormEncodingBuilder</span>()<br>    .add(<span class="hljs-string">&quot;platform&quot;</span>, <span class="hljs-string">&quot;android&quot;</span>)<br>    .add(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;bug&quot;</span>)<br>    .add(<span class="hljs-string">&quot;subject&quot;</span>, <span class="hljs-string">&quot;XXXXXXXXXXXXXXX&quot;</span>)<br>    .build();<br> <br>      <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>      .url(url)<br>      .post(body)<br>      .build();<br> <br>      <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br>    <span class="hljs-keyword">if</span> (response.isSuccessful()) &#123;<br>        <span class="hljs-keyword">return</span> response.body().string();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unexpected code &quot;</span> + response);<br>    &#125;<br>&#125;<br>  <br></code></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/peiniwan/okhttpTest">peiniwan&#x2F;okhttpTest: okhttp源码解析注释</a></p><p>先构建request对象，然后 okhttp3.Response response &#x3D; client.newCall(request).execute();</p><p>总结：</p><ul><li>在 newCall (Request request) （request 是请求参数和 URL）的时候，其实是里面创建了一个 RealCall 的对象，里面有 execute () 方法。里面有 getResponseWithInterceptorChain () ，添加了很多 Interceptor，并返回 Response 对象的。</li><li>RealCall.enqueue () 被调⽤的时候⼤同⼩异，区别在于 enqueue () 会使⽤ Dispatcher 的线程池来把请求放在后台线程进⾏（<code>把当前的请求Call.enqueue添加（AsyncCall）到请求队列中，并通过回调（Callback）的方式来获取最后结果</code>），但实质上使⽤的同样也是 getResponseWithInterceptorChain () ⽅法。</li><li>getResponseWithInterceptorChain () ⽅法做的事：把所有配置好的 Interceptor 放在⼀个 List ⾥，然后作为参数，创建⼀个 RealInterceptorChain 对象，并调⽤ chain.proceed (request) 来发起请求和获取响应。<ol><li>RetryAndFollowlnterceptor：负责失败重试、重定向</li><li>Bridgelnterceptor 负责向服务器发送请求数据，例如头消息、cookie 等等</li><li>Cachelnterceptor： 读取缓存、更新缓存</li><li>Connectlnterceptor：负责和服务器建立连接的。在这⾥，OkHttp 会创建出⽹络请求所需要的 TCP 连接（如果是 HTTP），或者是建⽴在 TCP 连接之上的 TLS 连接（如果是 HTTPS），并且会创建出对应的 HttpCodec 对象（⽤于编码解码 HTTP 请求）</li><li>Networklnterceptor：从服务器读取响应数据，数据流拦截器，io 操作，报文封装和解析。</li></ol></li><li>每一个功能都只是一个 Interceptor，它们再连接成一个 Interceptor. Chain，最终完成一次网络请求。</li><li>责任链模式，工厂模式，建造者模式</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-32-8de890c9cbd00edf1153908f913c2782-QQ%E6%88%AA%E5%9B%BE20200404104435-d5553a.png" alt="QQ截图20200404104435"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-18-40-ba65bf9fb8942d10db114f7e9cd2bd72-18-23-32-ba65bf9fb8942d10db114f7e9cd2bd72-unknown_filename.2-d0497d-9cb647.jpeg" alt="unknown_filename.2|700"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-18-40-7fb6e1570491f6575081b984c99a665b-18-23-32-7fb6e1570491f6575081b984c99a665b-unknown_filename.1-590a0e-99a288.jpeg" alt="unknown_filename.1|700"></p><p><strong>其他类</strong></p><ol><li>dispatcher ：调度器，⽤于调度多线程发起⽹络请求。默认最大并发数 64，单域名最大并发 5。里面用到了线程池和队列，线程池核心数是0。可运行线程数通过队列的个数限制的（ArrayDeque&lt;AsyncCall&gt;），AsyncCall 是个 runable</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程池，核心线程数为0，最大线程数为最大整数，线程空闲存活时间60s，//SynchronousQueue 直接提交策略</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>,<br>      Integer.MAX_VALUE , <span class="hljs-number">60L</span> , TimeUnit.SECONDS,<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="hljs-literal">true</span>));<br><br></code></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能纳 Integer. MAX_VALUE 个线程，且线程的空闲存活时间为 60s（可以理解为 okhttp 随时可以创建新的线程来满足需要。可以保证网络的 I&#x2F;O 任务有线程来处理，不被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">internal inner <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncCall</span>(<br>    <span class="hljs-keyword">private</span> val responseCallback: Callback<br>  ) : Runnable &#123;<br>...<br>    val host: String<br>      <span class="hljs-title function_">get</span><span class="hljs-params">()</span> = originalRequest.url.host<br>    val request: Request   <span class="hljs-comment">//url/method/headers/body</span><br>        get() = originalReques<br>        ...<br>    fun <span class="hljs-title function_">executeOn</span><span class="hljs-params">(executorService: ExecutorService)</span> &#123;<br>...<br>      <span class="hljs-keyword">try</span> &#123;<br>        executorService.execute(<span class="hljs-built_in">this</span>)<br>        success = <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><p>2. List&lt;Protocol&gt; protocols ：⽀持的应⽤层协议，即 HTTP&#x2F;1.1、HTTP&#x2F;2 等<br>3. Cache cache ：Cache 存储的配置。默认是没有，如果需要⽤，得⾃⼰配置出 Cache 存储的⽂件位置以及存储空间上限。</p><p>4. boolean followRedirects ：遇到重定向的要求是，是否⾃动 follow。<strong>根据响应码判断是否是重定向</strong>（3开头3xx）。RetryAndFollowUpInterceptor：如果不需要重定向，那么 followUp 为空，会释放资源，返回 response。若为重定向就销毁旧连接，创建新连接，将重定向操作得到的新请求设置给 request。统计重定向次数，不能大于20</p><p>5. 连接、读取、写入超时<br>6. ConnectionPool :连接池默认是可以保持5个空闲的连接。这些空闲的连接如果超过5分钟不被使用，则将被连接池移除。</p><p>Exchange ，单个 Http 请求，传输交换数据实现类，封装上面结果，为后续网络读写工作提供 API<br>ExchangeFinder ，请求连接获取，请求编解码实例构建<br>ExchangeCodec，Http 连接 I&#x2F;O 操作上层封装类，实际 I&#x2F;O 工作逻辑</p><p>前置<br>response &#x3D; realChain.proceed (request) 中置，传给下一个<br>后置</p><p>java. net 包下<br>最后也是 socket：socket.connect (address, connectTimeout)</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>复用机制</strong><br>Http 中添加了一种 KeepAlive 机制，当数据传输完毕后仍然保持连接，等待下一次请求时直接复用该连接。<br>ConnectionPool ：取到的话复用，没有取到放到连接池中。<br>ConnectionPool 关键代码：</p><p><strong>okhttp 重试逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;<br>       <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> SocketTimeoutException &amp;&amp; isRetry &amp;&amp; retryCount &lt; MAX_RETRY_COUNT) &#123;<br>           retryCount++;<br>           call = client.newCall(call.request());<br>           call.enqueue(<span class="hljs-built_in">this</span>);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-type">NetWorkResultEntity</span> <span class="hljs-variable">resultEntity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetWorkResultEntity</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>);<br>           resultEntity.setErrorMessage(e.getMessage());<br>           stringAsyncEmitter.onNext(resultEntity);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="addInterceptor-和-addNetworkInterceptor"><a href="#addInterceptor-和-addNetworkInterceptor" class="headerlink" title="addInterceptor 和 addNetworkInterceptor"></a>addInterceptor 和 addNetworkInterceptor</h4><p>addInterceptor 在 addNetworklnterceptor 之前，addInterceptor 一般是<strong>为了业务</strong>，添加头之类的信息，而 addNetworkInterceptor0) 一般是做<strong>网络调试</strong>的</p><p>addInterceptor（应用拦截器）在前：</p><ol><li>不需要担心中间过程的响应,如重定向和重试.</li><li><strong>总是只调用一次,即使HTTP响应是从缓存中获取</strong>.<br> 原始数据，⽽不是没有加 Content-Length 的请求数据，或者 Body还没有被 gzip 解压的响应数据</li><li>观察应用程序的初衷. 不关心OkHttp注入的头信息如: If-None-Match.</li><li>允许短路而不调用 Chain.proceed(),即中止调用</li><li>允许重试,使 Chain.proceed()调用多次<br> 刚开始的时候</li></ol><p>addNetworkInterceptor（网络拦截器）：</p><ol><li><strong>能够操作中间过程的响应,如重定向和重试</strong>执行多次</li><li>当网络短路而返回缓存响应时不被调用.</li><li><strong>只观察在网络上传输的数据.</strong></li><li><strong>携带请求来访问连接</strong><br> 最后：做网络调试</li></ol><p><strong>自定义一个拦截器</strong><br>addNetworkInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Interceptor.Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    logger.info(String.format(<span class="hljs-string">&quot;Sending request %s on %s%n%s&quot;</span>,<br>        request.url(), chain.connection(), request.headers()));<br><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(request);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    logger.info(String.format(<span class="hljs-string">&quot;Received response for %s in %.1fms%n%s&quot;</span>,<br>        response.request().url(), (t2 - t1) / <span class="hljs-number">1e6d</span>, response.headers()));<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Okhttp 是通过 CacheInterceptor 进行 Cache,它负责网络交互相关。它里面包含了一些复杂的 CRUD逻辑.我们只需要知道如何进行 http 参数配置 ,何时禁止网络，只使用缓存,什么时候忽略网络数据,他的核心还是通过 DiskLruCache 实现了缓存在磁盘中的 LRU 存储,然后通过 Cache-Control 进行更好的 https 协议的缓存的 header。</p><p>OKHTTP一般控制缓存有两种方式：<br>1、在request里面去设置cacheControl()策略<br>2、在header里面去添加cache-control</p><p><a href="https://www.jianshu.com/p/dbda0bb8d541">Android okhttp缓存真正正确的实现方式</a><br>有网时不走缓存，没网时获取缓存，通过Cache-Control和max-age</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpCacheInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br><span class="hljs-meta">@Overridepublic</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>    <span class="hljs-keyword">if</span> (!NetWorkHelper.isNetConnected(MainApplication.getContext())) &#123;<br>        request = request.newBuilder()<br>                .cacheControl(CacheControl.FORCE_CACHE)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(request);<br><br>    <span class="hljs-keyword">if</span> (NetWorkHelper.isNetConnected(MainApplication.getContext())) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxAge</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span>; <span class="hljs-comment">// 如果想要不缓存，直接时间设置为0，但是需要保存下来吧</span><br>        response.newBuilder()<br>                .removeHeader(<span class="hljs-string">&quot;Pragma&quot;</span>)<br>                .header(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;public, max-age=&quot;</span> + maxAge)<br>                .build();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxStale</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">28</span>; <span class="hljs-comment">// tolerate 4-weeks stale</span><br>        response.newBuilder()<br>                .removeHeader(<span class="hljs-string">&quot;Pragma&quot;</span>)<br>                .header(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;public, only-if-cached, max-stale=&quot;</span> + maxStale)<br>                .build();<br>    &#125;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;&#125;<br><br>  <span class="hljs-comment">//设置缓存100M</span><br>        <span class="hljs-type">Cache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cache</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(MainApplication.getContext().getCacheDir(),<span class="hljs-string">&quot;httpCache&quot;</span>),<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder()<br>            .cache(cache)<br>            .addNetworkInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpCacheInterceptor</span>())<br>            .build();<br><br></code></pre></td></tr></table></figure><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-18-20-20ac2436771079aeb38284cbb602db43-18-23-32-20ac2436771079aeb38284cbb602db43-unknown_filename.3-571cf7-26cd29.png" alt="unknown_filename.3|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-32-79768ff055ad8b012009ccf0d0ce1c07-unknown_filename-0774d3.png" alt="unknown_filename|600"></p><h2 id="Retrofit-原理"><a href="#Retrofit-原理" class="headerlink" title="Retrofit 原理"></a>Retrofit 原理</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">netApi</span> &#123;<br>        <span class="hljs-meta">@GET(&quot;repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>        Call&lt;ResponseBody&gt; <span class="hljs-title function_">contributorsBySimpleGetCall</span><span class="hljs-params">(<span class="hljs-meta">@Path(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Path(&quot;repo&quot;)</span> String repo)</span>;<br>    &#125;<br>    <br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">retrofitHttpRequest</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">Retrofit</span> <span class="hljs-variable">retrofit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>                    .baseUrl(<span class="hljs-string">&quot;https://api.github.com/&quot;</span>)<br>                    .build();<br>    <br>            <span class="hljs-type">netApi</span> <span class="hljs-variable">repo</span> <span class="hljs-operator">=</span> retrofit.create(netApi.class);<br>    <br>            retrofit2.Call&lt;ResponseBody&gt; call = repo.contributorsBySimpleGetCall(<span class="hljs-string">&quot;userName&quot;</span>, <span class="hljs-string">&quot;path&quot;</span>);<br>            call.enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">retrofit2</span>.Callback&lt;ResponseBody&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(retrofit2.Call&lt;ResponseBody&gt; call, retrofit2.Response&lt;ResponseBody&gt; response)</span> &#123;<br>                    <span class="hljs-comment">//response</span><br>                &#125;<br>    <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(retrofit2.Call&lt;ResponseBody&gt; call, Throwable t)</span> &#123;<br>    <br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><ul><li>Retrofit 底层依赖OkHttp实现，也就是说Retrofit本质上就是对OkHttp的更进一步封装，还支持Rxjava。Retrofit和其它Http库最大区别在于<em>使用注解简化Http请求(请求方式、请求参数）</em></li></ul><h5 id="1-Retrofit-对象创建：配置-“翻译规则”"><a href="#1-Retrofit-对象创建：配置-“翻译规则”" class="headerlink" title="1. Retrofit 对象创建：配置 “翻译规则”"></a><strong>1. Retrofit 对象创建：配置 “翻译规则”</strong></h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Retrofit retrofit = <span class="hljs-keyword">new</span> <span class="hljs-type">Retrofit</span>.Builder()<br>.client(<span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpClient</span>())              <span class="hljs-comment">// 底层请求引擎</span><br>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())  <span class="hljs-comment">// 响应适配器</span><br>.addConverterFactory(GsonConverterFactory.create())        <span class="hljs-comment">// 数据转换器</span><br>.baseUrl(<span class="hljs-string">&quot;https://api.example.com/&quot;</span>)    <span class="hljs-comment">// 基础URL</span><br>.build();<br><br></code></pre></td></tr></table></figure><ul><li><strong>CallAdapterFactory</strong>：负责将 OkHttp 的 Call 转换为 RxJava 的 Observable、Flowable 等异步类型；</li><li><strong>ConverterFactory</strong>：定义数据转换规则（如 Gson 将 JSON 转为对象）；</li><li><strong>OkHttpClient</strong>：实际执行 HTTP 请求的底层引擎</li></ul><h5 id="2-动态代理：接口的-“魔法翻译”"><a href="#2-动态代理：接口的-“魔法翻译”" class="headerlink" title="2. 动态代理：接口的 “魔法翻译”"></a><strong>2. 动态代理：接口的 “魔法翻译”</strong></h5><p>当调用 <code>retrofit.create(InfoApi.class)</code> 时，Retrofit 通过 Java 动态代理生成接口的代理对象：这个过程构建了一个 ServiceMethod 对象。（扩展 apiservice 的功能）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> &lt;T&gt; T create(<span class="hljs-keyword">final</span> Class&lt;T&gt; service) &#123;<br>    <span class="hljs-comment">// 生成代理对象，拦截接口方法调用</span><br>    <span class="hljs-keyword">return</span> Proxy.<span class="hljs-keyword">new</span><span class="hljs-type">ProxyInstance</span>(service.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[]&#123;service&#125;, <br>        (proxy, method, args) -&gt; &#123;<br>            <span class="hljs-comment">// 解析方法注解（@GET、@Query等）</span><br>            ServiceMethod serviceMethod = loadServiceMethod(method);<br>            <span class="hljs-comment">// 生成OkHttpCall对象</span><br>            OkHttpCall okHttpCall = <span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpCall</span>(serviceMethod, args);<br>            <span class="hljs-comment">// 通过CallAdapter转换为目标类型（如Observable）</span><br>            <span class="hljs-keyword">return</span> serviceMethod.adapt(okHttpCall);<br>        &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>关键步骤</strong>：</p><ul><li><p><strong>ServiceMethod</strong>：解析方法注解，生成请求参数（URL、请求方式、参数）；</p></li><li><p><strong>OkHttpCall</strong>：封装 OkHttp 的 Call，处理请求发送；</p></li><li><p><strong>适配器模式</strong>：通过 CallAdapter 将 OkHttp 的 Call 转换为 RxJava 的 Observable。</p></li><li><p><strong>缓存</strong>：为了提高性能，解析过的 <code>ServiceMethod</code> 会被缓存起来，下次调用同一方法时直接使用。</p></li></ul><ul><li><p>loadServiceMethod (method) 方法：通过 Method. getAnnotations (); 是获取方法上面对应的注解。method. getParameterAnnotations ()，解析注解获取请求方式，<em>参数类型和参数注解拼接请求的链接</em>，当一切都准备好之后会把数据添加到 Retrofit 的 RequestBuilder 中。 最终，一个 <code>ServiceMethod</code> 对象包含了创建一个 HTTP 请求所需的所有信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;<br>    <span class="hljs-comment">// 获取方法上的注解</span><br>    Annotation[] annotations = method.getAnnotations();<br><br>    <span class="hljs-comment">// 创建 ServiceMethod.Builder 实例</span><br>    ServiceMethod.Builder&lt;?&gt; builder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMethod</span>.Builder&lt;&gt;(<span class="hljs-built_in">this</span>, method);<br><br>    <span class="hljs-comment">// 解析方法上的注解，构建 ServiceMethod.Builder 对象</span><br>    builder.parseAnnotations(annotations);<br><br>    <span class="hljs-comment">// 解析方法的返回类型，获取适当的 CallAdapter 对象</span><br>    CallAdapter&lt;?&gt; callAdapter = builder.createCallAdapter();<br><br>    <span class="hljs-comment">// 解析方法的返回类型，获取对应的 Type 对象</span><br>    <span class="hljs-type">Type</span> <span class="hljs-variable">responseType</span> <span class="hljs-operator">=</span> builder.parseResponseType();<br><br>    <span class="hljs-comment">// 构建 ServiceMethod 对象</span><br>    <span class="hljs-keyword">return</span> builder.build(callAdapter, responseType);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其实 Retrofit 内部是通过动态代理，内部是通过反射实现的，大家都知道反射其实是很消耗性能的，为了避免这种高性能的消耗，反射成功以后就缓存起来，下次如果有用到就重用，如果不能重用则用反射构建出来，但是 Builder 是不能重用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Builder(Retrofit retrofit, Method method) &#123;<br>  <span class="hljs-built_in">this</span>.retrofit = retrofit;<br>  <span class="hljs-built_in">this</span>.method = method;<br>  <span class="hljs-built_in">this</span>.methodAnnotations = method.getAnnotations();<br>  <span class="hljs-built_in">this</span>.parameterTypes = method.getGenericParameterTypes();<br>  <span class="hljs-built_in">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="3-请求发送：从接口到-HTTP-的-“翻译过程”"><a href="#3-请求发送：从接口到-HTTP-的-“翻译过程”" class="headerlink" title="3. 请求发送：从接口到 HTTP 的 “翻译过程”"></a><strong>3. 请求发送：从接口到 HTTP 的 “翻译过程”</strong></h5><ul><li>然后当我们主动发起网络请求的时候会调用 okhttp 发起网络请求，okhttp 的配置包括请求方式，URL 等在 Retrofit 的 RequestBuilder 的 build () 方法中实现，并发起真正的网络请求。<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory,responseConverter)<br></code></pre></td></tr></table></figure><strong>调用接口方法</strong>：<ul><li><code>Call&lt;User&gt; call = service.getUser(123);</code></li><li>触发动态代理的 <code>invoke</code> 方法。</li></ul></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81.resources/2023/09/15/18-23-32-2431e140edbd94194fd29b89f473e52b-unknown_filename.5-36a059.png" alt="unknown_filename.5"></p><p>Method.getAnnotations(); 是获取方法上面对应的注解。<br>method.getParameterAnnotations()；获取的是方法参数上面的注解，是一个二维数组，第一个维度代表的是方法参数对应的下标，比如，一个方法有3个参数，那0代表第一个参数，1代表第二个参数，2代表第三个参数。<br>method.getGenericParameterTypes();获取的是方法参数的类型，里面带有实际的参数类型。</p><p>1.Retrofit构建过程<br>建造者模式、工厂方法模式</p><p>2.创建网络请求接口实例过程<br>外观模式、代理模式、单例模式、策略模式、装饰模式（建造者模式）</p><p>3.生成并执行请求过程<br>适配器模式（代理模式、装饰模式）</p><p><strong>自己写网络请求框架</strong></p><ul><li>volley，okHttp等，这类优秀的框架其底层的实现大部分也是基于系统的 线程池 和 httpClient 或 HttpUrlConnection的网络请求类框架，Android中是不能在主线程中（又称UI线程）进行网络操作的，那么框架中必不可少地要使用到子线程，可以使用简单的 Thread + Runnable + Handler或者重量级点的AsyncTask。</li><li>处理好并发操作，一个应用中往往要进行多线程操作，而Java虚拟机对于一个线程的内存分配大约在1M左右，具体多少要看它执行的任务而定。所有就要使用线程池，例如newFixdThreadPool 可以控制并发数量，且在整个APP运行过程中有几个常驻线程在，避免使用时反复地new，退出时再销毁，而 newCacheThreadPool 则会在任务完成后，自动回收线程，它会帮你释放线程内存，也就不会有常驻线程。</li><li>还要注意使接口分离，降低耦合，而且接口能够我们带来很大的方便。</li></ul><p><strong>应用中的网络层是怎么设计的</strong><br>用现成的一些框架，然后根据项目需要自己再封装下，比如说你的交互数据是JSON格式的，你就可以用一个网络请求框架+gson，然后写一些Bean 在Work(主)线程把数据用gson直接解析成对象返回，最后对一些错误统一处理。我用的是（volley），封装了下常用的方法,get post 上传 下载 ,所有的请求我都是用的同步请求. 具体的用法一般都是和业务逻辑在一起,而我的业务逻辑是用异步去处理的</p><h2 id="volley"><a href="#volley" class="headerlink" title="volley"></a>volley</h2><p>为什么说Volley适合数据量小，通信频繁的网络操作</p><p>volley中为了提高请求处理的速度，采用了ByteArrayPool进行内存中的数据存储的，如果下载大量的数据，这个存储空间就会溢出，所以不适合大量的数据，但是由于他的这个存储空间是内存中分配的，当存储的时候优是从ByteArrayPool中取出一块已经分配的内存区域, 不必每次存数据都要进行内存分配，而是先查找缓冲池中有无适合的内存区域，如果有，直接拿来用，从而减少内存分配的次数 ，所以他比较适合据量小，通信量大网络数据交互情况。<br>用法：</p><ol><li>创建一个RequestQueue对象。</li><li>创建一个StringRequest对象。</li><li>将StringRequest对象添加到RequestQueue里面。</li></ol><p>主线程中调用RequestQueue的add()方法来添加一条网络请求，这条请求会先被加入到缓存队列当中，如果发现可以找到相应的缓存结果就直接读取缓存并解析，然后回调给主线程。如果在缓存中没有找到结果，则将这条请求加入到网络请求队列中，然后处理发送HTTP请求，解析响应结果，写入缓存，并回调主线程。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//volley第一步</span><br>  <span class="hljs-title class_">RequestQueue</span> mQueue = <span class="hljs-title class_">Volley</span>.<span class="hljs-title function_">newRequestQueue</span>(<span class="hljs-title class_">MainActivity</span>.<span class="hljs-property">this</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">volleyStringRequest</span>(<span class="hljs-params"></span>) &#123;<br>    <br>      <span class="hljs-comment">//volley第二步</span><br>      <span class="hljs-title class_">StringRequest</span> stringRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRequest</span>(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>.<span class="hljs-property">Listener</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>                  <span class="hljs-meta">@Override</span><br>                  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onResponse</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> response</span>) &#123;<br>                      <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, response);<br>                  &#125;<br>              &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title class_">ErrorListener</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onErrorResponse</span>(<span class="hljs-params">VolleyError error</span>) &#123;<br>              <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">e</span>(<span class="hljs-string">&quot;TAG&quot;</span>, error.<span class="hljs-title function_">getMessage</span>(), error);<br>          &#125;<br>      &#125;);<br>      <span class="hljs-comment">//volley第三步</span><br>      mQueue.<span class="hljs-title function_">add</span>(stringRequest);<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">volleyJsonRequest</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">JsonObjectRequest</span> jsonObjectRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObjectRequest</span>(<span class="hljs-string">&quot;http://www.sina.com/sports/101010100.html&quot;</span>, <span class="hljs-literal">null</span>,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>.<span class="hljs-property">Listener</span>&lt;<span class="hljs-title class_">JSON</span><span class="hljs-built_in">Object</span>&gt;() &#123;<br>                  <span class="hljs-meta">@Override</span><br>                  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onResponse</span>(<span class="hljs-params">JSONObject response</span>) &#123;<br>                      <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, response.<span class="hljs-title function_">toString</span>());<br>                  &#125;<br>              &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title class_">ErrorListener</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onErrorResponse</span>(<span class="hljs-params">VolleyError error</span>) &#123;<br>              <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">e</span>(<span class="hljs-string">&quot;TAG&quot;</span>, error.<span class="hljs-title function_">getMessage</span>(), error);<br>          &#125;<br>      &#125;);<br>      mQueue.<span class="hljs-title function_">add</span>(jsonObjectRequest);<br>  &#125;<br>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三方框架源码</title>
    <link href="/2025/12/88520df66ade.html"/>
    <url>/2025/12/88520df66ade.html</url>
    
    <content type="html"><![CDATA[<h3 id="LeakCanary-原理"><a href="#LeakCanary-原理" class="headerlink" title="LeakCanary 原理"></a>LeakCanary 原理</h3><ol><li>lifecycleCallbacks 监听 Activity，在Activity  Destroyed 方法最终会调用 RefWatcher. watch 方法。此时，它会创建一个弱引用 <code>KeyedWeakReference</code> 指向这个 Activity，并将这个弱引用和一个引用队列（ReferenceQueue <strong>java 自己的类</strong>）关联起来。</li><li>在 Activity 销毁后，LeakCanary 延迟5秒触发一次 GC，然后检查引用队列。如果 Activity 被回收，那么弱引用 会被放入引用队列。</li><li>通过检查队列中是否有对应的引⽤来判断对象是否被垃圾回收了。（有的话被回收了，没有的话就没有被回收）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">gone</span><span class="hljs-params">(KeyedWeakReference reference)</span> &#123;<br><span class="hljs-keyword">return</span> !retainedKeys.contains(reference.key);<br> &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>如果 Activity 没有被回收，调用 GcTigger. runGc 方法运行 GC，如果这时候还没有被回收，那就说明 Activity 可能已经泄露。2次 gc</li><li>如果 Activity 没有被回收，生成 dunp 文件，获取泄漏对象，被计算泄漏对象到GC roots的最短路径</li><li>开启一个前台服务，将结果展示到可视化界面</li></ol><p>弱引用和引用队列<br>在 Java 中，弱引用（WeakReference）不会阻止其引用的对象被垃圾回收。当一个对象只被弱引用引用时，它会在下一次 GC 时被回收。同时，如果这个弱引用关联了一个引用队列（ReferenceQueue ），那么当对象被回收后，这个弱引用会被放入引用队列中。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Reference</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br><br>    <span class="hljs-comment">// 引用对象，被回收时置null</span><br>    volatile T <span class="hljs-built_in">ref</span>erent;<br>    <span class="hljs-comment">//保存即将被回收的reference对象</span><br>    <span class="hljs-keyword">final</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue;<br>    <br>    <span class="hljs-comment">//在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null</span><br>    Reference queueNext;<br>    <span class="hljs-comment">//在Pending状态下，待入列引用，默认为null</span><br>    Reference&lt;?&gt; pendingNext;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么生成文件时会 ANR<br>导出 heap 堆文件会短暂冻结 APP</p><p>watch () ⽅法<br>原理：就是<em>通过弱引⽤的⽅式来判断队列中是否有弱引⽤ ，来判断对象是否被垃圾回收了</em>。<br>KeyedWeakReference（key 是是個随机值，object 就是 view、fragment、activity）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyedWeakReference</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String key;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br><br>  KeyedWeakReference(Object referent, String key, String name,<br>      ReferenceQueue&lt;Object&gt; referenceQueue) &#123;<br>    <span class="hljs-built_in">super</span>(checkNotNull(referent, <span class="hljs-string">&quot;referent&quot;</span>), checkNotNull(referenceQueue, <span class="hljs-string">&quot;referenceQueue&quot;</span>));<br>    <span class="hljs-built_in">this</span>.key = checkNotNull(key, <span class="hljs-string">&quot;key&quot;</span>);<br>    <span class="hljs-built_in">this</span>.name = checkNotNull(name, <span class="hljs-string">&quot;name&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>触发 GC 的正确姿势<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.resources/2023/09/15/18-24-12-a3f46a69cc2c4941bb5b2bdab9dd9626-unknown_filename.2-9903de.png" alt="unknown_filename.2"></p><p>通过 dumpHprofData 来获取 hprof ⽂件，也可以直接 studio 里打开分析</p><p>2.0 LeakCanary 不需要主动初始化的原理<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.resources/2023/09/15/18-24-12-c93128eeed24b6821df5315f1c4d5227-unknown_filename.3-1aea76.png" alt="unknown_filename.3"></p><p>存放路径<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.resources/2023/09/15/18-24-12-ef4d38782e1e07edcf453a3c0a784d65-QQ%E6%88%AA%E5%9B%BE20191125132921-c37b68.png" alt="QQ截图20191125132921"></p><p>AndroidExcludeRefs 过滤</p><p>Shark 是 Leakcanary 2.0.0时推出的 Heap 分析工具，替代了之前使用的 HAHA 库，其作者称它比 haha 使用的 perflib 快6倍，使用的内存却是之前的10分之一</p><h3 id="EventBus-源码"><a href="#EventBus-源码" class="headerlink" title="EventBus 源码"></a>EventBus 源码</h3><p>register (this)就是去当前类遍历所有的方法，找到 onEvent 开头的然后进行存储（把匹配的方法最终保存在 subscriptionsByEventType（Map，key：eventType ； value：CopyOnWriteArrayList&lt;Subscription&gt; ），eventType 是我们方法参数的 Class，Subscription 中则保存着 subscriber, subscriberMethod（method, threadMode, eventType）, priority；包含了执行改方法所需的一切）。<br>然后 post 的时候，根据 post 传入的参数，去找到匹配的方法，数据传递是通过 handler。在 handmessage 里判断</p><p><strong>BroadcastReceiver 和 EventBus 有啥不同？</strong><br>系统系统级的事件都是通过广播来通知的，比如说网络的变化、电量的变化、短信接收和发送状态等。所以，如果是和 Android 系统相关的通知，我们还得选择本地广播。但是，广播相对于其他实现方式，是很重量级的，它消耗的资源较多，耗电占内存。<br>eventbus 调度灵活，使用简单、快速轻量，但是阅读性比较差。</p><p><strong>Evenbus 是做什么的？和 RXjava 有什么区别？</strong></p><ul><li>EventBus 是一款针对 Android 优化的发布&#x2F;订阅事件总线。主要功能是替代 Intent, Handler, BroadCast 在 Fragment，Activity，Service，线程之间传递消息. 优点是开销小，代码更优雅。以及将发送者和接收者解耦。</li><li>以前我们做组件间的消息分发更新，一般会采用观察者模式, 或者接口数据回调的相关方式。但是这样的做法虽然可以解决问题，但是组件之间的耦合比较严重，而且代码也不易阅读和相关维护。为了解决这样的问题我们可以使用消息总线 EventBus 框架。</li><li>原生的异步 AsnyTask 简直就是个坑，它就是一个任务队列，多个任务执行并不是并发的，有可能就卡在其中一个出不来了</li><li>RxJava 要比 EventBus 的应用更广泛，RxJava 里面几乎可以做任何事情。做异步、网络的数据处理，写出来的代码比较优雅。</li></ul><p>黏性事件<br>简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似，但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。</p><h3 id="BlockCanary-原理"><a href="#BlockCanary-原理" class="headerlink" title="BlockCanary 原理"></a>BlockCanary 原理</h3><p><a href="https://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/">BlockCanary — 轻松找出Android App界面卡顿元凶 | markzhai’s home</a></p><ul><li>View 的绘制也是通过 Handler 来执行的，所以如果能<em>知道每次 Handler 处理消息的时间，就能知道每次绘制的耗时了</em>， 那 Handler 消息的处理时间怎么获取呢？</li><li>可以发现，loop 方法内有一个 Printer 类，在 dispatchMessage 处理消息的前后分别打印了两次日志。</li><li>那我们把这个日志类 Printer 替换成我们自己的 Printer，然后统计两次打印日志的时间不就相当于处理消息的时间了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span> <span class="hljs-params">()</span> &#123;<br>...<br><span class="hljs-keyword">for</span> (;;) &#123;<br>...<br><span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me. mLogging;<br><span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>logging.println (<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg. target + <span class="hljs-string">&quot; &quot;</span> +msg. callback + <span class="hljs-string">&quot;: &quot;</span> + msg. what);<br>&#125;<br>msg.target.dispatchMessage (msg);<br><span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>logging.println (<span class="hljs-string">&quot; Finished to &quot;</span> + msg. target + <span class="hljs-string">&quot; &quot;</span> + msg. callback);<br>&#125;<br>&#125;<br>&#125;<br><br>Looper.getMainLooper (). setMessageLogging (mainLooperPrinter);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageLogging</span> <span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Printer printer)</span> &#123;<br>mLogging = printer;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着说说对各个 log 分析的过程。<br>看 timecost 和 threadtimecost，如果两者差得很多，则是主线程被等待或者资源被抢占。<br>看<em>卡顿发生前最近的几次堆栈，如果堆栈相同，则可以判定为是该处发生卡顿</em>，否则需要比较分析。</p><h3 id="ARouter-原理"><a href="#ARouter-原理" class="headerlink" title="ARouter 原理"></a>ARouter 原理</h3><p>核心思想:<br>我们在代码里加入的@Route 注解，会在编译时期通过 apt 生成一些存储 path 和 activityClass 映射关系的类文件，然后 app 进程启动的时候会拿到这些类文件，把保存这些映射关系的数据读到内存里 (保存在 map 里)，生成文件。<br>然后在进行路由跳转的时候，通过 build ()方法传入要到达页面的路由地址，ARouter 会通过它自己存储的路由表找到路由地址对应的 Activity.class (activity. class &#x3D; map.get (path))，然后 new Intent ()，当调用 ARouter 的 withString ()方法它的内部会调用 intent.putExtra (String name, String value)。<br>调用 navigation ()方法，它的内部会调用 startActivity (intent)进行跳转，这样便可以实现两个相互没有依赖的 module 顺利的启动对方的 Activity 了。</p><h4 id="arouter-compiler"><a href="#arouter-compiler" class="headerlink" title="arouter-compiler"></a>arouter-compiler</h4><p>自定义注解解析器生成文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouteProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> <br> <br>javaCompileOptions &#123;<br>   annotationProcessorOptions &#123;<br>    arguments = [ moduleName : project.getName () ]<br>   &#125;<br>  &#125;<br><br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span> <span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;<br>  <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty (annotations)) &#123;<br>   <span class="hljs-comment">// 获取所有添加 Route 注解的元素</span><br>   Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith (Route. class);<br>   <span class="hljs-keyword">try</span> &#123;<br>    logger.info (<span class="hljs-string">&quot;&gt;&gt;&gt; Found routes, start... &lt;&lt;&lt;&quot;</span>);<br>    <span class="hljs-comment">// 调用 arseRoute ()函数进行处理获取的注解元素集合</span><br>    <span class="hljs-built_in">this</span>.parseRoutes (routeElements);<br><br>   &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    logger.error (e);<br>   &#125;<br>   <span class="hljs-comment">// 如果有 Route 元素的注解，并且处理过程中无异常则返回 true</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 否则返回 false</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.resources/2023/09/15/18-24-12-81d3f0771a1a4b1138954748b83473c9-unknown_filename.9-018c18.png" alt="unknown_filename.9"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.resources/2023/09/15/18-24-12-8db8e1b5a5424e812a522a7c3327460d-unknown_filename.10-63dc7f.png" alt="unknown_filename.10"></p><p>[[注解、AOP、APT#APT]]</p><p><a href="https://juejin.cn/post/6844903648690962446#comment">ARouter原理剖析及手动实现 - 掘金</a></p><p><a href="https://www.jianshu.com/p/6021f3f61fa6">探索Android路由框架-ARouter之基本使用（一） - 简书</a></p><p><a href="https://www.jianshu.com/p/5b35309e9bb2">探索Android路由框架-ARouter之深挖源码（二） - 简书</a></p><p><strong>RouteMeta：基本路由信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target</span> (&#123;ElementType. TYPE&#125;)<br><span class="hljs-meta">@Retention</span> (RetentionPolicy. CLASS)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Route &#123;<br>    String <span class="hljs-title function_">path</span> <span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">group</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    String <span class="hljs-title function_">name</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">extras</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Integer. MIN_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化：ARouter.init (Application. this)，实则是 LogisticsCenter 在帮我们管理逻辑，这是一个外观模式（创建一个统一的类，用来包装子系统中一个或多个复杂的类）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161459045.png" alt="Pasted image 20250902191552"></p><ul><li>LogisticsCenter 内部先获取arouter-compiler生成的文件，然后将该文件，存储在sp中，下次启动应用的时候，直接从sp缓存中读取。</li><li>存储 SP，然后遍历、匹配（满足条件则添加到具体的集合中，按照文件的前缀不同，将他们添加到路由映射表 Warehouse 的 groupsIndex、interceptorsIndex、providersIndex 中）</li><li>Warehouse：路由元数据和其他数据的存储。这个类本质就是路由文件映射表。<em>里面提供了各种HashMap集合</em>（Map不允许重复的key），去存储SP存储的值。</li><li>如果navigation()不传入Activity作为context，则使用Application作为context</li></ul><h4 id="group分组"><a href="#group分组" class="headerlink" title="group分组"></a>group分组</h4><p>在 ARouter 中会要求路由地址至少需要两级，如”&#x2F;xx&#x2F;xx”, 一个模块下可以有多个分组。这里我们就将路由地址定为必须大于等于两级，其中第一级是 group。如 app module 下的路由注解：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">ARouter.getInstance (). build (<span class="hljs-string">&quot;/test/login&quot;</span>)<br>. <span class="hljs-keyword">with</span><span class="hljs-built_in">String</span> (<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-number">666666</span>)<br>. <span class="hljs-keyword">with</span><span class="hljs-built_in">String</span> (<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小三&quot;</span>)<br>. navigation ();<br></code></pre></td></tr></table></figure><p>ARouter group 作用：ARouter 在编译期框架扫描了所有的注册页面／字段／拦截器等，那么很明显运行期不可能一股脑全部加载进来，这样就太不和谐了。所以就使用分组来管理。<br>Group 的值默认就是第一个 &#x2F; &#x2F;（两个分隔符） 之间的内容。</p><h3 id="图片加载框架比较"><a href="#图片加载框架比较" class="headerlink" title="图片加载框架比较"></a>图片加载框架比较</h3><p><strong>共同优点</strong></p><ol><li>都对多级缓存、线程池、缓存算法做了处理</li><li>自适应程度高，根据系统性能初始化缓存配置、系统信息变更后动态调整策略。比如根据 CPU 核数确定最大并发数，根据可用内存确定内存缓存大小，网络状态变化时调整最大并发数等。</li><li>支持多种数据源支持多种数据源，网络、本地、资源、Assets 等</li></ol><p><strong>不同点</strong></p><ol><li>Picasso 所能实现的功能，Glide 都能做，无非是所需的设置不同。但是 Picasso 体积比起 Glide 小太多。</li><li>Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图、视频的某一帧。Glide 支持加载 Gif 动态图，而 Picasso 不支持该特性</li><li>Fresco 在5.0以下的内存优化非常好，代价就是体积也非常的大，按体积算 Fresco&gt;Glide&gt;Picasso</li><li>UIL 可以算是老牌最火的图片加载库了，该作者在项目中说明已经停止了对该项目的维护。</li></ol><p><strong>图片框架的缓存</strong></p><ol><li>MemorycCache 图片内存缓存。默认使用了 LRU 算法。</li><li>DiskCache 图片磁盘缓存，默认使用 LruDiskCache 算法，在缓存满时删除最近最少使用的图片</li></ol><h4 id="Glide-源码"><a href="#Glide-源码" class="headerlink" title="Glide 源码"></a>Glide 源码</h4><p>Glide.with (MainActivity. this). load (url). into (headerImage);</p><ul><li>with 方法把 context 传进去，返回 RequestManager 。并且调用 GlideBuilder. build（做初始化的），在这里做一些初始化操作，比如构建线程池（包括 sourceExecutor ，diskCacheExecutor ），缓存大小和缓存器，默认的连接监听工厂（connectivityMonitorFactory ），Engine 对象（怎么使用缓存的，<em>先弱引用，后 Lru，最后走网络</em>）和 RequestManagerRetriever 对象、<br>  DecodeJob（解析 InputStream 生成图片）。</li><li>RequestManager 监听了 ActivityFragmentLifecycle ，会在 onStop pauseRequests ();  onStart 恢复 resumeRequests();</li><li>load（URL）Glide.with (context)已经返回了 RequestManager, 其实就是 RequestManager.load (“”)。主要就是把 URL 传进去，获取 RequestBuilder 对象。</li><li>主要的操作都在 into 方法里</li><li>在这里判断是取活动缓存（是否有另一个view展示这张图片）还是 lru 缓存还是 disk本地缓存，还是没有，告诉 RequestBuilder。</li><li>RequestBuilder 的 into 方法里（上面返回了）开启了线程池进行加载资源。网络请求是通过 url 打开连接，返回一个 HttpURLConnection 对象，进行网络请求的。加载得资源后转换到主线程并进行回调设置给 imageview。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;<br>    <span class="hljs-built_in">this</span>. decodeJob = decodeJob;<br>    <span class="hljs-comment">//获取 GlideExecutor 线程池</span><br>    <span class="hljs-type">GlideExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> decodeJob.willDecodeFromCache () ? diskCacheExecutor : getActiveSourceExecutor ();<br>     <span class="hljs-comment">//开始执行 decodeJob 这个 Runnable</span><br>    executor.execute (decodeJob);<br>  &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">MAIN_THREAD_EXECUTOR</span> <span class="hljs-operator">=</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Executor</span> () &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span> (Looper.getMainLooper ());<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span> <span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable command)</span> &#123;<br>          handler.post (command);<br>        &#125;<br>      &#125;;<br><br></code></pre></td></tr></table></figure><ul><li>Glide 支持图片的二级缓存 (并不是三级缓存，因为从网络加载并不属于缓存)，即<em>内存缓存和磁盘缓存</em>。</li><li>glide 为什么有 lru 还会内存溢出。因为直接把整个大图片的整个内存加载进去了。对于大图可以下载下来，asdrawale 来加载，drawable 更省内存，Drawable 应该不属于常驻内存的对象，不然的话，不可能不会出现 OOM 的～～</li><li>Glide 内部处理了网络图片加载的错位或者闪烁 (tag)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> Request <span class="hljs-title function_">getRequest</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//本质还是 getTag</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> getTag ();<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (tag != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (tag <span class="hljs-keyword">instanceof</span> Request) &#123;<br>                request = (Request) tag;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;You must not call setTag () on a view </span><br><span class="hljs-string">Glide is targeting&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>   <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRequest</span> <span class="hljs-params">(Request request)</span> &#123;<br>        <span class="hljs-comment">//本质是 setTag</span><br>        setTag (request);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>对图片加载用到了 LruCache（最少最近使用）算法</strong></p><p><strong>自己设计一个 handler 或者线程池</strong></p><p><a href="https://www.jianshu.com/p/9f3b96937253">链接</a></p><p>Java 里面链表可以作为队列的实例（都是 Collection 子类）<br>Queue&lt;Request&gt; requestQueue &#x3D; new LinkedList&lt;Request&gt;();<br>线程池原理：创建了个队列，然后从队列里取线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br><br>    <span class="hljs-comment">//用一个 Set 或者其他数据结构把创建的线程保存起来，为的是方便以后获取线程的 handle，做其他操作。</span><br>    Set&lt;WorkerThread&gt; set = <span class="hljs-literal">null</span>;<span class="hljs-comment">//（可以不看）</span><br>    <span class="hljs-keyword">private</span> Queue&lt;Runnable&gt; queue;<br>    <span class="hljs-comment">//初始化线程池，创建内部类 WorkerThread 并且启动它</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span> <span class="hljs-params">(<span class="hljs-type">int</span> size)</span>&#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; size ;i++ )&#123;<br>            <span class="hljs-type">WorkerThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerThread</span> ();<br>            t.start ();<br>            set.add ( t );<br>        &#125;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Runnable&gt;();<br>    &#125;<br><br><br>    <span class="hljs-comment">//submit 一个 runnable 进线程池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submit</span> <span class="hljs-params">(Runnable runnable)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (queue)&#123;<br>            queue.add (runnable);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//WorkerThread 用一个死循环不停的去向 Runnable 队列拿 Runnable 执行。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">WorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.run ();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (queue)&#123;<br>                        <span class="hljs-keyword">if</span> ( !queue.isEmpty () )&#123;<br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> queue.poll ();<br>                    current.run ();<br>                      &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/2112e452a894">解析文章</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-16-33-6d586b5987259ece66f0cff4efbdf69a-18-24-12-6d586b5987259ece66f0cff4efbdf69a-unknown_filename.4-016ec3-5214e2.png" alt="unknown_filename.4|600"></p><h4 id="不传-application"><a href="#不传-application" class="headerlink" title="不传 application"></a>不传 application</h4><p> <em>不使用 application 作为 context</em>。当 context 为 application 时，会把 imageView 是生命周期延长到整个运行过程中，imageView 不能被回收，从而造成 OOM 异常。<br>因为在 Glide 内部都给我们处理好了。反而是应该用当前组件的生命周期，少用 Application，否则在组件（比如 Activity）销毁的时候就无法正确释放 Glide 相关资源</p><p>当你调用 <code>Glide.with(context)</code> 时，Glide 会根据传入的 Context 类型自动绑定到对应的生命周期：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 不同参数的重载方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-keyword">with</span>(Context context)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-keyword">with</span>(Activity activity)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-keyword">with</span>(FragmentActivity activity)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-keyword">with</span>(Fragment fragment)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-keyword">with</span>(View view)  <span class="hljs-comment">// 通过View查找宿主</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161459046.png" alt="Pasted image 20250705142537"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Glide 中的 ActiveResource（活动资源）是用于跟踪当前正在展示的图片资源的机制。ActiveResource 用于判断当前是否有其他 View 正在展示同一张图片。</p><p>在 Glide 中，每当一个 View 请求加载一张图片时，Glide 会将该图片关联到对应的 ActiveResource 中。当图片加载完成并显示在 View 上时，Glide 会将 ActiveResource 中的引用计数加1。同样地，当图片从 View 中被移除时，Glide 会将 ActiveResource 中的引用计数减1。</p><p>通过检查 ActiveResource 中的引用计数，可以判断是否有其他 View 正在展示同一张图片。如果引用计数大于1，则表示当前有其他 View 正在展示该图片；如果引用计数等于1，则表示当前没有其他 View 正在展示该图片。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-16-33-17e14b7541ab100a92bf815bccfdb78a-18-24-12-17e14b7541ab100a92bf815bccfdb78a-unknown_filename.5-da3059-c0d2b5.png" alt="unknown_filename.5|800|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-16-33-25d6a4e1ff51fd40bb91f2b3dba6454d-18-24-12-25d6a4e1ff51fd40bb91f2b3dba6454d-unknown_filename.6-8fadc5-eb5094.png" alt="unknown_filename.6|800|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-16-33-99199a0ffb4cbeafc0e16456ad8aab8d-18-24-12-99199a0ffb4cbeafc0e16456ad8aab8d-unknown_filename.7-4a5423-fb8b67.png" alt="unknown_filename.7|600"></p><hr><h3 id="如何读源码"><a href="#如何读源码" class="headerlink" title="如何读源码"></a>如何读源码</h3><ol><li><p>理想情况下，逐⾏通读可以最⾼效率读通⼀个项⽬的代码，因为每⾏代码都只需要读⼀遍；但实时情况下，逐⾏通读会导致脑中积累太多没有成体系的代码，导致你读个⼏⼗⼏百⾏就读不下去了，因此⼀点也不实⽤。⽽从切⼊点开始读，可以在最快时间内把看到的代码体系化，形成⼀个「完整的⼩世界」；在把「⼩世界」看明⽩之后，再去⼀步步扩⼤和深⼊，就能够逐渐掌握更多的细节。</p></li><li><p>寻找切⼊点的⽅式：离你最近的位置就是切⼊点，通常是业务代码中的最后⼀⾏。</p></li><li><p>以 Retrofifit 为例，最后的 Call.enqueue () 会被我作为切⼊点；在尝试从 Call.enqueue () 切⼊失败后，逐步回退到 Retrofit.create ()⽅法，找到项⽬结构的核⼼，然后开始继续发散和深⼊</p></li><li><p>代码阅读过程中，不懂的代码会越来越多，脑⼦就会越来越乱。如果不断尝试把看到的代码结合起来组合成完整逻辑，就能让头脑始终保持清晰，⽽不是深⼊到某个细节好久之后忽然⼀抬头：「我为什么点进这个⽅法来着？」可以试着在读源码的时候，经常把多⾏或多段代码在脑⼦⾥（或者笔记⾥）组合成⼀整块，从⽽让代码结构更清晰，让阅读过程不断增加进度感，也减⼩继续阅读的难度。</p></li><li><p>以 Retrofifit 为例，当读懂 Proxy.newProxyInstance () ⽅法实际上是创建了⼀个代理对象的时候，可以停下来做⼀个总结：「这是 Retrofifit 的⼤框架」，在脑⼦⾥或者笔记上都可以。总结消化过后，再继续阅读。</p></li><li><p>读代码经常会出现「横向逻辑还没看清晰，纵向深度也没挖透」的情况。那么到底是要横向扩展阅读结构，还是纵向挖深度，最好是在每次遇到这种分岔路⼝的时候就先做好决定。不能在每个分岔路⼝都想也不想地看到不懂的就追下去，容易迷路。</p></li><li><p>在遇到「横向也⼴，纵向也深」的时候，根据情况选择其中⼀个就好，并没有必然哪种选择更优的铁律。⽽如果遇到越钻越头⼤的情况，可以退回之前的某⼀步，换条路继续⾛。<em>换路的时候记得做好标记</em>：「我在哪⾥探路失败了」。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据存储</title>
    <link href="/2025/12/7efc84cd0a08.html"/>
    <url>/2025/12/7efc84cd0a08.html</url>
    
    <content type="html"><![CDATA[<h1 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sharedPreferences</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getSharedPreferences(getLocalClassName(), MODE_PRIVATE);<br>SharedPreferences.<span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> sharedPreferences.edit();<br>editor.putString(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>editor.apply();<br></code></pre></td></tr></table></figure><p>SharedPreferences 本身是一个接口，程序无法直接创建 SharedPreferences 实例，只能通过 Context 提供的 getSharedPreferences(String name, int mode) 方法来获取 SharedPreferences 实例，name 表示要存储的 xml 文件名，第二个参数直接写 Context.MODE_PRIVAT，表示该 SharedPreferences 数据只能被本应用读写。当然还有 MODE_WORLD_READABLE 等，但是已经被废弃了，因为 SharedPreference 在多进程下表现并不稳定。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>保存基于 XML 文件存储的 key-value 键值对数据，在 &#x2F;data&#x2F;data&#x2F;&lt;\package name&gt;&#x2F;shared_prefs 目录下。</p><p><strong>总结：</strong></p><ol><li>sSharedPrefsCache 是一个 ArrayMap&lt;String,ArrayMap&lt;File,SharedPreferencesImpl&gt;&gt;，它会保存加载到内存中的 SharedPreferences 对象，ContextImpl 类中并没有定义将 SharedPreferences 对象移除 sSharedPrefsCache 的方法，所以<em>一旦加载到内存中，就会存在直至进程销毁</em>。相对的，也就是说，SP 对象一旦加载到内存，后面任何时间使用，都是从内存中获取，不会再出现读取磁盘的情况</li><li>key 是包名</li><li>获取 SP 只能通过 ContextImpl#getSharedPerferences 来获取，它里面首先通过 mSharedPrefsPaths 根据传入的 name 拿到 File ，然后根据 File 从 ArrayMap&lt;File, SharedPreferencesImpl&gt; cache 里取出对应的 SharedPrederenceImpl 实例</li><li>SharedPreferencesImpl 实例化的时候会<em>启动子线程来读取磁盘文件</em>，但是在此之前如果通过 SharedPreferencesImpl#getXxx 或者 SharedPreferences.Editor 会阻塞 UI 线程，因为在从 SP 文件中读取数据或者往 SP 文件中写入数据的时候必须等待 SP 文件加载完</li><li>在 EditorImpl 中 putXxx 的时候，是通过 HashMap 来存储数据，提交的时候分为 commit 和 apply</li><li><strong>SP 的读写操作是线程安全的，它对 mMap 的读写操作用的是同一把锁</strong>，考虑到 SP 对象的生命周期与进程一致，一旦加载到内存中就不会再去读取磁盘文件，所以只要保证内存中的状态是一致的，就可以保证读写的一致性</li></ol><h3 id="apply-和-commit"><a href="#apply-和-commit" class="headerlink" title="apply () 和 commit ()"></a>apply () 和 commit ()</h3><ul><li>提交的时候分为 commit 和 apply，它们都会把修改先提交到内存中，然后在写入磁盘中。只不过 apply 是异步写磁盘，而 commit 可能是同步写磁盘也可能是异步写磁盘，在于前面是否还有写磁盘任务</li><li>如果频繁操作的话 apply 的性能会优于 commit， apply 会将最后修改内容写入磁盘。</li><li>但是如果希望立刻获取存储操作的结果，并据此做相应的其他操作，应当使用 commit。</li></ul><p>对于 apply 和 commit ，它是如何保证同步的呢？在这两个方法里都有 mcr.writtenToDiskLatch.await()，它其实是一个 CountDownLatch。</p><blockquote><p>CountDownLatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完成后在执行。</p></blockquote><p>commit 同步提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">commit</span> <span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MemoryCommitResult</span> <span class="hljs-variable">mcr</span> <span class="hljs-operator">=</span> commitToMemory (); <span class="hljs-comment">// 提交到内存</span><br>    <br>    <span class="hljs-comment">// 同步写入磁盘</span><br>    SharedPreferencesImpl.<span class="hljs-built_in">this</span>.enqueueDiskWrite(mcr, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        mcr.writtenToDiskLatch.await(); <span class="hljs-comment">// 等待写入完成</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mcr.writeToDiskResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>apply 异步提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span> <span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MemoryCommitResult</span> <span class="hljs-variable">mcr</span> <span class="hljs-operator">=</span> commitToMemory ();<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">awaitCommit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mcr.writtenToDiskLatch.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;&#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 添加到QueuedWork中，在Activity.onPause()等时机执行</span><br>    QueuedWork.addFinisher(awaitCommit);<br>    <br>    <span class="hljs-comment">// 异步写入磁盘</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">postWriteRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            awaitCommit.run();<br>            QueuedWork.removeFinisher(awaitCommit);<br>        &#125;<br>    &#125;;<br>    <br>    SharedPreferencesImpl.<span class="hljs-built_in">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>跨进程不安全。SharedPreferences 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，SP 大约会有万分之一的损坏率。</li><li>加载缓慢。SharedPreferences 文件的加载使用了异步线程，而且加载线程并没有设置线程优先级，如果这个时候主线程读取数据就需要等待文件加载线程的结束。<br> 这就导致出现主线程等待低优先级线程锁的问题，比如一个 100KB 的 SP 文件读取等待时间大约需要 50~100ms，我建议<strong>提前用异步线程预加载启动过程用到的 SP 文件</strong>。</li><li>全量写入。无论是调用 commit () 还是 apply ()，即使我们只改动其中的一个条目，都会把整个内容全部写到文件。而且即使我们多次写入同一个文件，SP 也没有将多次修改合并为一次，这也是性能差的重要原因之一。ANR</li><li>卡顿。由于提供了异步落盘的 apply 机制，在崩溃或者其他一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 onPause 等一些时机，系统会强制把所有的 SharedPreferences 对象数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。</li></ol><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol><li>强烈建议不要在 SP 里面存储特别大的 key&#x2F;value ，有助于减少卡顿 &#x2F; ANR</li><li>请不要高频的使用 apply，尽可能的批量提交；commit 直接在主线程操作，更要注意了</li><li>不要使用 MODE_MULTI_PROCESS</li><li><em>高频写操作的 key 与高频读操作的 key 可以适当的拆分文件</em>，以减少同步锁竞争 (一次全部加载)</li><li>不要连续多次 edit，每次 edit 就是打开一次文件，应该获取一次 edit，然后多次执行 putXxx，<em>减少内存波动</em>，所以在封装方法的时候要注意了</li></ol><h1 id="MMKV"><a href="#MMKV" class="headerlink" title="MMKV"></a>MMKV</h1><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-06-11-25-f1aadf32f59291e428be7591a38668ea-18-23-45-f1aadf32f59291e428be7591a38668ea-f1aadf32f59291e428be7591a38668ea-ba2779-22e4b4.png" alt="f1aadf32f59291e428be7591a38668ea|800|600"></p><p>mmap 将一个文件或者其它对象映射进内存。(linux 上的东西)<br>常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。（从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中）<br>而 mmap 操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap 的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此 mmap 效率更高。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>首先进行自定义一个类进行继承 SQLiteOpenHelper,  因为如果继承 SQLiteDatabase 那么会，要覆盖其中的许多的方法。如果已经有数据库，就不需要 sqliteopenhelper<br>  MysqlLite (Context context, String name,  CursorFactory factory, int version)传入当前的应用环境, 数据库的名称，游标的工厂, 版本号, 让底层为你进行创建数据库</li><li>oncreate (SQLiteDatabase db): 当数据库创建好之后进行运行的函数，主要是在数据库创建好之后进行创建表</li><li>onUpgrade (SQLiteDatabase db, int oldVersion, int newVersion): 当数据库进行更新后需要进行执行的方法</li><li>integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。另外， primary key 将 id 列设为主键，并用 autoincrement 关键字表示 id 列是自增长的</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> CREATE_BOOK = <span class="hljs-string">&quot;create table book (&quot;</span><br>+ <span class="hljs-string">&quot;id integer primary key autoincrement, &quot;</span><br>+ <span class="hljs-string">&quot;author text, &quot;</span><br>+ <span class="hljs-string">&quot;price real, &quot;</span><br>+ <span class="hljs-string">&quot;pages integer, &quot;</span><br>+ <span class="hljs-string">&quot;name text)&quot;</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多进程Binder</title>
    <link href="/2025/12/d842c8b35664.html"/>
    <url>/2025/12/d842c8b35664.html</url>
    
    <content type="html"><![CDATA[<h1 id="进程间通信-ipc"><a href="#进程间通信-ipc" class="headerlink" title="进程间通信(ipc)"></a>进程间通信(ipc)</h1><p>[[7-Webview多进程方案]]</p><p>IPC的主要目的是<em>调用其他进程的函数</em></p><ul><li>使用多进程显而易见的好处就是分担主进程的内存压力。我们的应用越做越大，内存越来越多，将一些独立的组件放到不同的进程，它就不占用主进程的内存空间了。当然还有其他好处，有些应用后台是有多个进程的，启动一个不可见的轻量级私有进程，在后台收发消息，或者做一些耗时的事情，或者开机启动这个进程，然后做监听等。还有就是防止主进程被杀守护进程，守护进程和主进程之间相互监视，有一方被杀就重新启动它。因为它们要常驻后台，特别是即时通讯或者社交应用</li><li>推送、融云</li></ul><p><strong>什么时候用服务</strong><br>不需要和用户交互而且还要长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另一个应用程序，服务仍然能够保持独立运行。音乐、播放器</p><p>如果一个 app 两个进程同时操作 sharedpreferences，如何保证数据安全。不能，使用ContentProvider、mmkv </p><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p><a href="https://blog.csdn.net/freekiteyu/article/details/70082302">https://blog.csdn.net/freekiteyu/article/details/70082302</a></p><p><a href="https://yuandaimaahao.github.io/AndroidFrameworkTutorialPages/003.%E5%AD%A6%E7%A9%BFBinder%E7%AF%87/006.Android%20Binder%20%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90.html">Android Binder 驱动框架设计与分析</a></p><ul><li>Binder 是 Android 系统中进程间通讯（IPC）的一种方式。不同进程、不同 APP 间就是通过 binder 通讯的。Binder 通信采用 C&#x2F;S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动。</li><li>服务端提供服务，客户端获取数据。<em>ServiceManager 的作用查询服务和注册服务</em>。Binder 驱动是运行在内核空间 (liux)，进程间通讯的最底层就是 Binder 驱动。它使用的是操作系统中一种内存映射的方法。</li><li>ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行方法的事务（事务（Transaction），一般是指要做的或所做的事情）。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程 (binder_send_reply 发送 reply、binder_write 客户端写)，响应结果，通讯就结束了。</li><li>在 Android 开发中，可以使用 AIDL，并通过系统生成的代码来实现客户端和服务端的通信。AIDL 可以处理跨进程的方法调用、数据传输、回调等功能，简化了开发者在进行跨进程通信时的代码编写工作。</li></ul><p>Binder 驱动：运行在<strong>内核空间 kernel</strong>，负责各个用户进程通过 Binder 实现通信的内核模块（Binder Dirver）底层就是 Binder 驱动</p><ul><li>内存映射就是<em>将用户空间的一块内存区域映射到内核空间</em>。映射关系建立后不同的进程的内核地址空间是共享的。能减少数据拷贝次数，实现进程间通讯的高效互动。</li><li><em>2次拷贝</em>，内核空间与用户空间共享内存通过 copy_from_user (), copy_to_user () 内核方法来完成用户空间与内核空间内存的数据传输。</li><li>不同进程之间的<strong>内核地址空间映射到相同的物理地址</strong>，即不同的进程的内核地址空间是共享的。不同进程之间的用户地址空间映射到不同的物理地址，相互之间是隔离的，无法访问的。</li></ul><p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。<br><em>完成映射后，进程只需调用一次 <code>copy_from_user</code>，A 进程的用户空间就可以访问到 <code>int a</code>。这里优化到了一次拷贝</em></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-d535d118941b2ce613d96a00372c86b5-unknown_filename.12-47e09f.png" alt="unknown_filename.12|600"></p><p><em>流程图</em></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-21161fa4518997147db59bd538a79188-unknown_filename.3-11cf0f.png" alt="unknown_filename.3"></p><h3 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h3><p>Binder 只需要一次数据拷贝，性能更好<br>内核空间与用户空间共享内存通过 copy_from_user (), copy_to_user () 内核方法来完成用户空间与内核空间内存的数据传输</p><p>Binder IPC 机制中涉及到的内存映射通过 mmap () 来实现，mmap () 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。<em>映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</em></p><p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。<br><em>完成映射后，进程只需调用一次 <code>copy_from_user</code>，A 进程的用户空间就可以访问到 <code>int o</code>。这里优化到了一次拷贝</em></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-d535d118941b2ce613d96a00372c86b5-unknown_filename.12-47e09f.png" alt="unknown_filename.12|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-b0a684a7ade4b9dcbfe5d57315147ab6-unknown_filename-389477.png" alt="unknown_filename|600"></p><h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>[[1-Android的启动流程#ServiceManager]]</p><ul><li>ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用。</li><li>ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。</li><li>负责管理系统中的 Service 组件，并且向 Client 组件提供获取 Service 代理对象的服务。</li></ul><p>ServiceManager 运行在一个独立的进程中，因此，Service 组件和 Client 组件也需要通过进程间通信机制来和它交互，而采用的进程间通信机制正好也是 Binder 进程间通信机制。</p><p><em>ServiceManager 是由 init 进程负责启动的</em>，而 init 进程是在系统启动时启动的，因此，ServiceManager 也是在系统启动时启动。</p><p><strong>最后开启 loop 不断的处理共享内存中的数据</strong>，无限循环来等待和处理 Service 组件和 Client 组件的进程间通信请求</p><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>Binder是一种虚拟的物理设备驱动</p><ul><li>虚拟设备驱动程序：虚拟设备驱动程序是模拟硬件设备的驱动程序。它模拟了一块硬件，因此软件可能会有访问真实硬件的错觉。一些虚拟设备驱动程序示例是虚拟网络适配器，虚拟DVD &#x2F; CD驱动器，虚拟磁盘（内存）等</li><li>驱动是干什么的？仅从功能的角度来说，驱动程序使得应用程序可以访问硬件。</li><li>那应用是如何访问硬件的？<em>linux 中一切皆文件，访问硬件就是对文件的读写操作</em>。比如 led 灯对应的文件是 &#x2F;dev&#x2F;led, 读写这个文件就能操作 led 灯。而binder驱动就是读写硬件内存区域</li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在 Linux 中，每个进程都有自己的虚拟内存地址空间。虚拟内存地址空间又分为了用户地址空间和内核地址空间。</p><p>虚拟内存 通过创建虚拟地址空间来隔离不同进程的内存访问，解决了多进程运行时的内存冲突问题。<em>每个进程都有自己的虚拟地址空间，并通过 MMU（内存管理单元） 将虚拟地址映射到物理内存地址上</em>，从而实现对物理内存的访问和管理。</p><p><a href="https://yuandaimaahao.github.io/AndroidFrameworkTutorialPages/003.%E5%AD%A6%E7%A9%BFBinder%E7%AF%87/002.Binder%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html">Binder 基本原理 | Android Framework</a></p><p><strong>客户端怎么执行服务端的方法</strong></p><ul><li>我们们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。</li><li>首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。</li><li>ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。</li></ul><p><strong>Binder 通信中的代理模式</strong></p><ul><li>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</li><li>在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 ProxyObject，这个 ProxyObject 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</li><li>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-7a752757f78b00d53af8a44434318362-unknown_filename.1-cad1b1.png" alt="unknown_filename.1|600"></p><h2 id="常规通讯"><a href="#常规通讯" class="headerlink" title="常规通讯"></a>常规通讯</h2><p>进程间通信就是为了实现数据共享。一个程序不同组件在不同进程也叫多进程，和俩个应用没有本质区别。使用 process 属性可以实现多进程，但是会带来很多麻烦，主要原因是共享数据会失败，弊端有: <em>静态和单利失效，同步失效，sharedprefer 也变的不可靠等问题</em>。</p><p>只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程（多任务）时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。无论如何，在实现 AIDL 之前，请您务必理解绑定服务。</p><p><a href="https://developer.android.com/guide/components/aidl?hl=zh-cn">aidl文档</a></p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>Android interface definition language (android接口定义语言) , 用来跨进程的访问方法。</p><p><strong>AIDL 是什么，怎么实现的，为什么要创建个文件 aidl</strong><br>1）、定义AIDL文件；——类似于后台给了一个接口文档，里面描述了各种各样的接口，而在AIDL文件中描述的是类似于JAVA接口的方法定义<br>2）、实现AIDL文件里面定义的接口；——类似于后台实现接口文档的接口控制器，里面定义了接口的具体实现<br>3）、暴露接口；——这个就像后台开发人员把接口文档给App开发人员，然后App开发人员就知道有哪些接口可以调用来实现业务了<br>4）、调用；——这个就是App开发人员调用后台的接口来获取过程数据了。<br>从上面的描述可以看出，这个AIDL实际上就是一个C&#x2F;S模型，一边是客户端，一边是服务器。</p><h4 id="aidl-操作步骤"><a href="#aidl-操作步骤" class="headerlink" title="aidl 操作步骤"></a>aidl 操作步骤</h4><ol><li>在两个项目中新建aidl文件，客户端和服务端中这个文件所在的包名要保持一致，内容也要一样，在接口文件AIDLFunctions.aidl中，我们定义一个方法 show</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">AidlFunctions</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>编译之后， 会在build目录下，自动产生同名的，后缀为 java 的文件。里面有我们要用到的 Stub内部类。 com.example.aidl.AidlFunctions是刚定义。<br> 里面的东西</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public static <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span> <span class="hljs-title">implements</span>  <span class="hljs-title">com</span>.<span class="hljs-title">example</span>.<span class="hljs-title">aidl</span>.<span class="hljs-title">AidlFunctions</span></span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-42c476195f8b467a65124b26e57e4978-unknown_filename.2-5f90d1.png" alt="unknown_filename.2"></p><ol start="3"><li>AIDL的使用，需要一个Service配合，所以我们在服务端还要声明一个Service，来接收消息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AIDLService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br><span class="hljs-comment">//stub就是系统自动产生的</span><br>    AidlFunctions.Stub binder;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-built_in">super</span>.onCreate();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        binder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AidlFunctions</span>.Stub() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">//这里是我们在接口中声明的方法的实现</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                System.out.println(<span class="hljs-string">&quot;--------------------收到----------------------&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> binder;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/29999c1a93cd">https://www.jianshu.com/p/29999c1a93cd</a><br>需要把服务端的AIDL文件以及Book类复制过来，将 aidl 文件夹整个复制到和Java文件夹同个层级下，不需要改动任何代码</p><p><em>远端服务通过action绑定</em><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-d772d3e8ddede1b16cb9d97bc67c5849-unknown_filename.8-d4944c.png" alt="unknown_filename.8"></p><ol start="4"><li>客户端：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绑定服务，要用到ServiceConnection </span><br><span class="hljs-keyword">private</span> ServiceConnection serviceConnection;<br><span class="hljs-comment">//自定义的接口，和服务端一样</span><br><span class="hljs-keyword">private</span> AidlFunctions aidlFunctions;<br><br>serviceConnection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------------ServiceDisconnected----------------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------------ServiceConnected----------------------&quot;</span>);<br>        aidlFunctions = AidlFunctions.Stub.asInterface(service);<br>    &#125;<br>&#125;;<br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.example.androidaidl.AIDLService&quot;</span>);<br>bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);<br><span class="hljs-comment">//调用show方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    aidlFunctions.show();<br>&#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>    <span class="hljs-comment">// TODO Auto-generated catch block</span><br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AIDL-生成的文件"><a href="#AIDL-生成的文件" class="headerlink" title="AIDL 生成的文件"></a>AIDL 生成的文件</h4><p><strong>stub 具体实现类、proxy 代理类</strong></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-17-32-0b27ffc6ca61560ee597113bd4cf43ca-18-50-43-0b27ffc6ca61560ee597113bd4cf43ca-unknown_filename.7-0448c0-598490.png" alt="unknown_filename.7"></p><ol><li>基本角色</li></ol><ul><li><p><strong>Client 端（左边 Activity 部分）</strong></p><ul><li>调用 <code>bindService()</code> 绑定服务。</li><li>绑定成功后，系统回调 <code>onServiceConnected()</code>，得到一个 <code>IBinder</code> 对象（<code>mRemoteService</code>）。</li><li>通过 <code>Stub.asInterface()</code> 将 <code>IBinder</code> 转换为 <code>Ixxx</code> 接口对象（其实是 <code>Stub.Proxy</code>）。</li></ul></li><li><p><strong>Service 端（右边 RemoteService 部分）</strong></p><ul><li>在 <code>onBind()</code> 方法里返回一个 <code>Binder</code> 对象（<code>mRemoteBinder</code>）。</li><li>这个 Binder 实际上是 <code>Ixxx.Stub</code> 的实例。</li></ul></li><li><p><strong>Binder 驱动层（中间的 AMS &#x2F; Binder Driver）</strong></p><ul><li>属于 <strong>内核空间</strong>，负责进程间通信（IPC）的数据传输。</li><li>Client 和 Service 不直接通信，而是通过 Binder 驱动。</li></ul></li></ul><ol start="2"><li>AIDL 工具生成的代码</li></ol><ul><li><p>**<code>Ixxx.aidl</code>**：定义接口方法（如 <code>doXXX()</code>）。</p></li><li><p><strong><code>Ixxx.java</code>（AIDL 工具自动生成）</strong></p><ul><li><p>**<code>Ixxx.Stub</code>**（抽象类，继承自 Binder）</p><ul><li>在 Service 端使用，负责接收调用并分发到具体实现。</li><li>核心方法：<ul><li><code>onTransact()</code>：接收来自 Client 的请求（IPC）。</li><li><code>doXXX()</code>：实际逻辑实现。</li></ul></li></ul></li><li><p>**<code>Ixxx.Stub.Proxy</code>**（内部类）</p><ul><li>在 Client 端使用，代表 Service 的代理对象。</li><li>调用 <code>doXXX()</code> 时，最终通过 Binder 驱动发到远程 Service。</li></ul></li></ul></li></ul><ol start="3"><li><p>通信流程（按图走一遍）</p></li><li><p><strong>客户端发起绑定</strong></p><ul><li><code>Activity.bindService()</code> → AMS → 远程 <code>Service.onBind()</code>。</li><li>Service 返回 <code>Ixxx.Stub</code> 的实例（<code>mRemoteBinder</code>）。</li></ul></li><li><p><strong>客户端获得接口对象</strong></p><ul><li>系统回调 <code>onServiceConnected()</code>。</li><li>得到 <code>IBinder</code> 对象 → <code>Stub.asInterface(mRemoteBinder)</code> → 生成 <code>Ixxx.Stub.Proxy</code>。</li></ul></li><li><p><strong>调用远程方法</strong></p><ul><li>客户端调用 <code>mRemoteService.doXXX()</code>。</li><li>实际上是调用 <code>Proxy.doXXX()</code>，数据通过 Binder 驱动发到 Service 进程。</li></ul></li><li><p><strong>服务端接收请求</strong></p><ul><li><code>Stub.onTransact()</code> 被触发。</li><li>根据事务 code 找到对应方法 → 调用真正的实现 <code>doXXX()</code>。</li></ul></li><li><p><strong>结果返回</strong></p><ul><li>执行结果通过 Binder 驱动回传给客户端。</li><li><code>Proxy</code> 接收结果并返回给调用的 Activity。</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>Proxy</strong>：客户端的远程代理，假装自己就是服务。</li><li><strong>Stub</strong>：服务端的 Binder，负责接收并转发调用。</li><li><strong>Binder Driver</strong>：系统内核，负责 IPC。</li><li><strong>AIDL 工具</strong>：自动生成 <code>Stub</code> 和 <code>Proxy</code>，开发者只需要实现接口。</li></ul><p>一句话总结：<br>👉 <strong>Activity 调用 Proxy → Binder 驱动转发 → Service 的 Stub 接收并执行 → 返回结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyAidlInterface</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sendData</span><span class="hljs-params">(String data)</span>;<br>    String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-comment">//生成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyAidlInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.IInterface &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.zero.aidleservicedemo.IMyAidlInterface &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">DESCRIPTOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.zero.aidleservicedemo.IMyAidlInterface&quot;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stub</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.attachInterface(<span class="hljs-built_in">this</span>, DESCRIPTOR);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Cast an IBinder object into an com.zero.aidleservicedemo.IMyAidlInterface interface,</span><br><span class="hljs-comment">         * generating a proxy if needed.   生成代理需要</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.zero.aidleservicedemo.IMyAidlInterface <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> &#123;<br>            <span class="hljs-keyword">if</span> ((obj == <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            android.os.<span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(DESCRIPTOR);<br>            <span class="hljs-keyword">if</span> (((iin != <span class="hljs-literal">null</span>) &amp;&amp; (iin <span class="hljs-keyword">instanceof</span> com.zero.aidleservicedemo.IMyAidlInterface))) &#123;<br>                <span class="hljs-keyword">return</span> ((com.zero.aidleservicedemo.IMyAidlInterface) iin);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.zero.aidleservicedemo.IMyAidlInterface.Stub.Proxy(obj);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>            java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">descriptor</span> <span class="hljs-operator">=</span> DESCRIPTOR;<br>            <span class="hljs-keyword">switch</span> (code) &#123;<br>               <span class="hljs-comment">//自己的方法</span><br>                <span class="hljs-keyword">case</span> TRANSACTION_sendData: &#123;<br>           <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> TRANSACTION_getData: &#123;<br>                    data.enforceInterface(descriptor);<br>                    java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">_result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getData();<br>                    reply.writeNoException();<br>                    reply.writeString(_result);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>: &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTransact(code, data, reply, flags);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>       <span class="hljs-comment">//代理类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.zero.aidleservicedemo.IMyAidlInterface &#123;<br>            <span class="hljs-keyword">private</span> android.os.IBinder mRemote;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> mRemote;<br>            &#125;<br><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sendData</span><span class="hljs-params">(java.lang.String data)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>                <span class="hljs-keyword">return</span> _result;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                java.lang.String _result;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    _data.writeInterfaceToken(DESCRIPTOR);<br>                    mRemote.transact(Stub.TRANSACTION_getData, _data, _reply, <span class="hljs-number">0</span>);<br>                    _reply.readException();<br>                    _result = _reply.readString();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    _reply.recycle();<br>                    _data.recycle();<br>                &#125;<br>                <span class="hljs-keyword">return</span> _result;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sendData</span><span class="hljs-params">(java.lang.String data)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException;<br><br>    <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>onTransact</strong>, 典型的代理模式</p><ul><li>Server 则是通过 onTransact 方法接收 Client 进程传过来的数据，包括函数名称、函数参数，找到对应的函数（这里是 sum ），把参数喂进去，得到结果，返回。</li><li>所以 onTransact 函数经历了读数据→执行要调用的函数→把执行结果再写数据的过程</li><li>注意，在 AIDL 的另一端，是通过 Stub 类的 onTransact 把值从 data 中取出来，计算完得到结果，再把结果通过 reply 返回。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-27-17-31-059823902e225e7587438407a9672fe5-18-50-43-059823902e225e7587438407a9672fe5-unknown_filename.4-d31a09-940e82.png" alt="unknown_filename.4|700|600"></li></ul><h3 id="其他通讯方法"><a href="#其他通讯方法" class="headerlink" title="其他通讯方法"></a>其他通讯方法</h3><p>socket、binder、信号链、共享内存<br>Intent、 Messenger、AIDL，sharedpre、广播、scheme</p><ol><li>使用intent的附加信息extras来传递，通过bundle，传递的是bundle支持的类型，比如基本数据类型、实现pracellable或serializeable的对象</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**指定包名和带包名的Activity的名字*/</span><br>ComponentName componentName = <span class="hljs-keyword">new</span> <span class="hljs-type">ComponentName</span>(<span class="hljs-string">&quot;com.example.androidaidl&quot;</span>, <span class="hljs-string">&quot;com.example.androidaidl.MainActivity&quot;</span>);<br>Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-type">Intent</span>();<br>intent.putExtra(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1001</span>);<br>intent.setComponent(componentName);<br>startActivity(intent);      <br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用文件共享，序列化或是sharedpre，不过不适用于读写并发的操作</li><li>广播：Android的广播是系统级的，只要传递的Action一样，就可以接收到其他进程广播的消息，广播中可以通过Intent传递数据。</li><li>scheme协议是android中的一种页面内跳转协议，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面，并且传递数据，还是可以通过H5页面跳转指定页面等。</li><li><a href="https://www.cnblogs.com/ganchuanpu/p/9288014.html">soket</a>,长链接读网络数据</li></ol><h3 id="ElegantBus"><a href="#ElegantBus" class="headerlink" title="ElegantBus"></a>ElegantBus</h3><blockquote><p>这是一个<strong>基于 Binder 的多进程事件总线方案</strong>。<br>核心思路是引入一个<strong>中间 Service 作为通信枢纽</strong>，所有业务进程通过 <code>bindService</code> 连接到它。</p></blockquote><blockquote><p>各进程在 Service 中通过 <strong>AIDL Callback 注册自己</strong>，Service 使用 <code>RemoteCallbackList</code> 统一管理这些跨进程回调，自动处理进程死亡。</p></blockquote><blockquote><p>当某个进程 <code>post</code> 事件时，只需要通过 Binder 把 <code>EventWrapper</code> 发给 Service，<br>Service 再 <strong>遍历 callback 列表，将事件 fan-out 分发到其他进程</strong>，由各进程本地处理。</p></blockquote><blockquote><p>这种设计避免了进程之间直接互调，<strong>降低耦合度</strong>，同时对 WebView 多进程、插件化场景比较友好。</p></blockquote><p><strong>Q：为什么不让主进程直接调 web 进程？</strong></p><blockquote><p>会形成 N×N 的 Binder 依赖，生命周期和异常处理都很复杂，用中心 Service 可以统一管理。</p></blockquote><p><strong>Q：为什么用 RemoteCallbackList？</strong></p><blockquote><p>它能自动感知进程死亡并清理 callback，避免内存泄漏，这是 Binder 回调的最佳实践。</p></blockquote><p><em>总结流程</em></p><ol><li>客户端通过 AIDL 注册回调接口给服务端：<br><code>service.registerCallback(myCallback);</code></li><li>服务端将回调保存到 <code>RemoteCallbackList</code>。</li><li>服务端需要通知客户端时：<ul><li>遍历 <code>RemoteCallbackList</code> → 调用 <code>callback.call()</code></li></ul></li><li><code>RemoteCallbackList</code> 自动处理死掉的客户端，避免内存泄漏。</li></ol><p>call 方法是 IProcessCallback 的方法，IProcessCallback 自己定义的，调用 call 其实就是客户端调用代理类的方法，然后真正的服务端方法执行<br>aidl 发送的是 JSON 字符串，然后转成对应的对象</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Binder_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.resources/2023/09/15/18-50-43-c8625b252f78ea946bc9408ae352c0e9-unknown_filename.9-dfbae2.png" alt="unknown_filename.9|900"></p><h4 id="RemoteCallbackList"><a href="#RemoteCallbackList" class="headerlink" title="RemoteCallbackList"></a>RemoteCallbackList</h4><ul><li>在 Android 多进程环境下，<strong>客户端可能注册多个回调接口</strong>，而且这些回调对象可能跨进程。</li><li><strong><code>RemoteCallbackList</code></strong> 是专门用来管理远程回调的线程安全列表。</li><li>作用<ul><li>自动处理死掉的进程（当客户端进程退出，<code>RemoteCallbackList</code> 会自动移除回调）。</li><li>提供 <code>beginBroadcast()</code> 和 <code>finishBroadcast()</code> 来安全遍历回调列表。</li></ul></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">RemoteCallbackList&lt;IProcessCallback&gt; mCallbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteCallbackList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 注册回调</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerCallback</span><span class="hljs-params">(IProcessCallback callback)</span> &#123;<br>    mCallbacks.register(callback);<br>&#125;<br><br><span class="hljs-comment">// 取消注册</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unregisterCallback</span><span class="hljs-params">(IProcessCallback callback)</span> &#123;<br>    mCallbacks.unregister(callback);<br>&#125;<br><br><span class="hljs-comment">// 通知所有客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyClients</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mCallbacks.beginBroadcast();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mCallbacks.getBroadcastItem(i).call(message);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    mCallbacks.finishBroadcast();<br>&#125;<br><br></code></pre></td></tr></table></figure><p> <code>callback.call()</code></p><ul><li>这是实际触发回调的方法。</li><li>关键点：<ul><li>**可能抛出 <code>RemoteException</code>**，因为跨进程通信可能失败。</li><li>每个 <code>callback</code> 对象都是 <strong>远程代理</strong>，调用它会触发 IPC 通信。</li><li>通常在 <code>RemoteCallbackList</code> 遍历时使用。</li></ul></li></ul><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>（进程间数据共享）和message一样，底层也是binder，除了oncreate方法其他方法(crud)都是运行在bindler线程里。所以在oncerate里不能做耗时操作。Android本身就提供了不少的ContentProvider访问，比如联系人、相册等。 访问ContentProvider，需要通过Uri，需要以“content:&#x2F;&#x2F;”开头。在其他应用访问通过uri(主机名)：</p><p>缺点：互相传递数据麻烦，2个provider</p><p><a href="https://www.jianshu.com/p/4b04d50485ec">ContentProvider</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">contentResolver?.call(<br>          MainProcessContentProvider.MAINCONTENTPROVIDER_URI,<br>          <span class="hljs-string">&quot;getAge&quot;</span>,<br>          <span class="hljs-literal">null</span>,<br>          bundleOf(<span class="hljs-string">&quot;student&quot;</span> to <span class="hljs-string">&quot;小米&quot;</span>)<br>      )<br>    <br></code></pre></td></tr></table></figure><p>一般的跨进程通信就是基于 aidl，这种方式存在的缺点就是每次都需要定义一个Service，再通过BindService来进行进程间通信。也能用ContentProvider.call()来实现便捷的跨进程通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Bundle <span class="hljs-title function_">call</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String method, <span class="hljs-meta">@Nullable</span> String arg, <span class="hljs-meta">@Nullable</span> Bundle extras)</span> &#123;<br>     <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(method) &amp;&amp; TextUtils.equals(method, <span class="hljs-string">&quot;setData&quot;</span>)) &#123;<br>         mBinderParcel.mProxy = extras.getBinder(<span class="hljs-string">&quot;binder&quot;</span>);<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(method) &amp;&amp; TextUtils.equals(method, <span class="hljs-string">&quot;getData&quot;</span>)) &#123;<br>         <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>         bundle.putBinder(<span class="hljs-string">&quot;binder&quot;</span>, mBinderParcel.mProxy);<br>         <span class="hljs-keyword">return</span> bundle;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>    <br></code></pre></td></tr></table></figure><p>method可以用来区分调用的逻辑，arg貌似没什么用，extras是一个Bundle类型用来存放数据。<br>调用的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">getContentResolver().call(Uri.parse(<span class="hljs-string">&quot;content://com.example.mycontentprovider&quot;</span>), <span class="hljs-string">&quot;setData&quot;</span>, <span class="hljs-literal">null</span>, bundle); <span class="hljs-comment">//设置数据</span><br><br><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> getContentResolver().call(Uri.parse(<span class="hljs-string">&quot;content://com.example.mycontentprovider&quot;</span>), <span class="hljs-string">&quot;getData&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>mBinder = IMyAidlInterface.Stub.asInterface(bundle.getBinder(<span class="hljs-string">&quot;binder&quot;</span>));<br><br>Log.i(<span class="hljs-string">&quot;kingiyu&quot;</span>, <span class="hljs-string">&quot;RemoteActivity--&gt;--&gt;onCreate--&gt;&quot;</span> + mBinder.getData());<br></code></pre></td></tr></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>[[2-Activity进程启动流程#ams-Zygote 通信为什么用 Socket]]</p><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><ol><li>通过 Messenger进行传递（<strong>handler</strong>），在远程服务里创建handler（接收客户端发送的消息）、 Messenger对像，在onbind里返回( Messenger.getbinder)。在客户端绑定服务，拿着 Messenger对象发消息(可以用bundle)。在远程服务的handlermessage方法就会收到。他是一个个处理的，如果大量并发请求用aidl， Messenger底层就是aidl</li></ol><blockquote><p>在客户端中创建一个Messenger。然后，当客户端收到 onServiceConnected() 回调时，会向服务发送一条 Message，并在其 send() 方法的 replyTo 参数中包含客户端的 Messenger。<br>注意：Messenger和Message是俩个东西</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(View v)</span> &#123;<br><span class="hljs-keyword">if</span> (!mBound) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain(<span class="hljs-literal">null</span>, MessengerService.MSG_SAY_HELLO, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">try</span> &#123;<br>   mService.send(msg);<br>&#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>直接使用Binder对象：缺点是这种方式不能进行跨进程，跨应用程序的函数调用。只能实现在同一个进程之中，同一个应用程序之中的不同的组件之间通讯。</li></ol><blockquote><p>用法：继承Binder，然后在service里return<br>继承Binder用它的对象返回，客户端将bind对象强转成自定义Bind</p></blockquote><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>Binder 代理对象泄露问题</p><ol><li>跨进程回调：当一个进程通过Binder将自己的代理对象传递给另一个进程，并且在另一个进程中注册回调接口时，如果没有适时地取消注册或解除引用，就会导致泄露。例如，一个Activity通过Binder传递自己的代理对象给Service，并在Service中注册回调接口，<em>如果Activity销毁时没有取消注册，就会导致Activity的代理对象无法释放</em>。</li><li>跨进程单例模式：当一个进程中的组件（如Service或ContentProvider）通过Binder提供单例对象给其他进程时，如果其他进程持有该对象的引用，并且没有适时地释放引用，就会导致泄露。这种情况下，其他进程可能会长时间持有对象的引用，使对象无法被垃圾回收。</li><li>跨进程数据缓存：<em>当一个进程通过Binder将数据提供给其他进程，并且其他进程持有数据的引用时，如果没有适时地释放引用</em>，就会导致泄露。这种情况下，数据对象可能会占用大量内存，并且无法被回收，从而导致内存泄漏。</li></ol><p>为避免Binder代理对象泄露问题，可以采取以下措施：</p><ol><li>确保在不再需要Binder代理对象时及时解除引用或取消注册回调接口，避免长时间持有代理对象的引用。</li><li>在使用Binder进行跨进程通信时，遵循良好的生命周期管理原则，确保在合适的时机释放资源。</li><li>对于跨进程传递的数据对象，尽量避免长时间持有引用，或者使用弱引用等机制来管理引用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SparseArray 和 ArrayMap</title>
    <link href="/2025/12/96e9a68a331d.html"/>
    <url>/2025/12/96e9a68a331d.html</url>
    
    <content type="html"><![CDATA[<h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>Android 专门针对内存优化而设计的，用于取代 Java API 中的 HashMap 数据结构。为了更进一步优化<strong>key 是 int 类型的 Map</strong>，Android 再次提供效率更高的数据结构 SparseArray，可避免自动装箱过程。对于 key 为其他类型则可使用 ArrayMap。<br>HashMap 的查找和插入时间复杂度为 O (1)的<strong>代价是牺牲大量的内存</strong>来实现的，而 SparseArray 和 ArrayMap<strong>性能略逊于 HashMap，但更节省内存</strong>。</p><p>ArrayMap 相比 HashMap 在内存占用方面更为节省的主要原因是其内部数据结构设计的差异。</p><p><strong>内部数据结构设计</strong>：<br>    - HashMap：HashMap 内部使用数组 + 链表&#x2F;红黑树的结构来存储 key-value 对。在 HashMap 中，数组的大小（即容量）通常会选择一个比较大的值，以减少哈希冲突的概率，但这也会导致在<em>数据量较小的情况下可能存在大量未被利用的空间</em>。<br>    - ArrayMap：ArrayMap 内部使用两个数组来分别存储 key 和 value，而且默认情况下 ArrayMap 使用稀疏数组进行存储，<em>只有在必要时才会进行数组扩容操作</em>。这种设计使得 ArrayMap 在数据量较小的情况下可以更加紧凑地存储 key-value 对，减少了不必要的内存消耗。<br>    - 当删除 key 键时，不是立马删除这一项，而是留下需要删除的选项给一个删除的标记（放 object），避免数组的移动。该条目可以被重新用于相同的 key, 或者实际数据大于等于数组容量，都有可能会主动调用 gc () 方法来清理 DELETE 数据。<br>    - 避免空间的浪费</p><p>扩容机制<br>    - ArrayMap 是在容量满的时机触发容量扩大至原来的1.5倍，在容量不足1&#x2F;3时触发内存收缩至原来的0.5倍，更节省的内存扩容机制<br>    - HashMap 是在容量的0.75倍时触发容量扩大至原来的2倍，且没有内存收缩机制。HashMap 扩容过程有 hash 重建，相对耗时。所以能大致知道数据量，可指定创建指定容量的对象，能减少性能浪费。</p><p>总的来说，由于 ArrayMap 的内部数据结构更为简单和紧凑，在数据量较小的情况下可以更有效地利用内存空间，相对于 HashMap 来说更为节省内存。但是在数据量较大或需要频繁进行插入、删除操作的情况下，HashMap 可能会更适合，因为其在处理大量数据时性能更为优秀。<br>[[HashMap、lru、散列表]]</p><p>ArraySet：和 ArrayMap 的目的类似，用来提高 HashSet 的效率。使用方法跟 HashSet 类似<br>ArrayMap 假设 key 类型为其他的类型，则使用 ArrayMap，获取数据简单<br>map. keyAt (0)<br>map. valueAt (0)</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>ArrayMap 的内部实现是两个数组，一个 int 数组存储 key 的哈希值，一个对象数组保存 key 和 value，内部使用二分法对 key 进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，适合小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而 HashMap 内部则是数组+链表结构，所以在数据量较小的时候，HashMap 的 Entry Array 比 ArrayMap 占用更多的内存。</p><p>在 Android 中，建议用 ArrayMap 来替换 HashMap。ArrayMap 和 HashMap 都是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleArrayMap</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-type">int</span>[] mHashes;<span class="hljs-comment">//由 key 的 hashCode 所组成的数组，从小到大排序</span><br>    Object[] mArray;<span class="hljs-comment">// 由key-value键值对所组成的数组，是mHashes大小的2倍；</span><br>    <span class="hljs-type">int</span> mSize;<span class="hljs-comment">//</span><br> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-07-11-29-90be176d3eea18a933040c47cef23991-20240207112929-94f14b.png" alt="image.png|600"></p><ul><li>mArray 是一个记录着 key-value 键值对所组成的数组，是 mHashes 大小的2倍；</li><li>其中 mSize 记录着该 ArrayMap 对象中有多少对数据，执行 put 或者 append 操作，则 mSize 会加一，执行 remove，mSize 则减一。mSize 往往小于 mHashes. length，如果大于或等于，则说明需要扩容。</li></ul><p>更多源码分析可以参考：<a href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-07-11-04-81076368d9cd7eaa5511f4f0ebeda860-09-57-22-81076368d9cd7eaa5511f4f0ebeda860-unknown_filename.11-fd0e11-f26274.png" alt="unknown_filename.11|600"></p><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p>SparseArray 和 ArrayMap 类似，但是 SparseArray 只能存储 key 为 int 型的，它比 ArrayMap 少了计算 key 的哈希值，同时对象数组只需要存 value 即可，这也就避免了 key 的装箱操作和分配空间，，建议用 SparseArray&lt;V&gt; 替换 HashMap&lt;Integer,V&gt;。</p><p>类似的还有 SparseIntArray 代替 HashMap&lt;Integer,Integer&gt; 等。<br>SparseBooleanArray: 当 map 的结构为 Map&lt;Integer,Boolean&gt;的时候使用，效率较高。<br>SparseLongArray: 当 map 的结构为 Map&lt;Integer,Long&gt;的时候使用，效率较高。<br>LongSparseArray: 当 map 的结构为 Map&lt;Long,Value&gt;的时候使用，效率较高。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-07-11-29-345954adb16ecabb277f3e201564bd6f-20240207112906-fabb28.png" alt="image.png|600"></p><ul><li>SparseArray 的内部实现是两个数组，一个 int 数组是存储对象数据对应下标，一个对象数组保存 value，在 put 的通过二分法放 int 数组去，查找也是二分法查找</li><li>内部使用二分法对 key 进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，<strong>只适合于小数据量操作</strong>，通常情况下要比传统的 HashMap 慢，因为查找是用二分查找法搜索，添加和删除需要对数组进行添加和删除。</li></ul><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>key 是 int[]，比 hashmap 的 key 是对象，例如 Integer 8个字节，int 4个字节更耗内存，还得装箱拆箱<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-07-11-04-fcb3848731fd127dcb63a020a50097d8-09-57-22-fcb3848731fd127dcb63a020a50097d8-unknown_filename.13-b2b626-69815c.png" alt="unknown_filename.13|600"></li><li>默认负载因子为0.75，必然会有空间的浪费，需要用来存数据，而 SparseArray 不会浪费空间</li><li>为了提高性能，该容器提供了一个优化：当删除 key 键时，不是立马删除这一项，而是留下需要删除的选项给一个删除的标记（放 object），避免数组的移动。该条目可以被重新用于相同的 key, 或者实际数据大于等于数组容量，都有可能会主动调用gc()方法来清理DELETE数据。<br>  好想法：如果已经删除，直接放进去（15删了，放16），删除的越多越好。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-07-11-04-cf5d932648505f923cb4c8b88a80b57a-09-57-22-cf5d932648505f923cb4c8b88a80b57a-unknown_filename.14-d9b5ca-0c1723.png" alt="unknown_filename.14|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-07-11-04-49924872cceeaf6f4394030acb952c9a-09-57-22-49924872cceeaf6f4394030acb952c9a-unknown_filename.15-0163b9-22e169.png" alt="unknown_filename.15|600"></li></ul><p><a href="https://juejin.cn/post/7268221660527870004">Android中的SparseArray你了解吗</a></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">growSize</span><span class="hljs-params">(<span class="hljs-type">int</span> currentSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> currentSize &lt;= <span class="hljs-number">4</span> ? <span class="hljs-number">8</span> : currentSize * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩容：当前 Size &lt;&#x3D; 4 时恒定大小为8，否则就是 Size 的两倍了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-07-11-35-a846a4b7d125fd8c785b9a9843047229-2024-02-07-11-04-a846a4b7d125fd8c785b9a9843047229-09-57-22-a846a4b7d125fd8c785b9a9843047229-unknown_filename.12-6ae3b4-8cbcf1-b53e3d.png" alt="unknown_filename.12|600|600"></p><h2 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h2><p><strong>Bundle 被用来传递数据，为什么不用 HashMap 代替</strong></p><ol><li>Bundle 内部是由 ArrayMap 实现的，ArrayMap 在设计上比传统的 HashMap 更多考虑的是内存优化。</li><li>Bundle 使用的是 Parcelable 序列化，而 HashMap 使用 Serializable 序列化。</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Serializable 与 Parcelable</title>
    <link href="/2025/12/7f82c2b853c1.html"/>
    <url>/2025/12/7f82c2b853c1.html</url>
    
    <content type="html"><![CDATA[<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化的三种场景：</p><ol><li>持久化存储</li><li>通过 Socket 进行网络传输</li><li>深拷贝</li></ol><p>把数据对象（⼀般是内存中的，例如 JVM 中的对象）转换成<strong>字节序列</strong>的过程。对象在程序内存⾥的存放形式是散乱的（存放在不同的内存区域、并且由引⽤进⾏连接），<strong>通过序列化可以把内存中的对象转换成⼀个字节序列，从⽽使⽤ byte[] 等形式进⾏本地存储或⽹络传输</strong>，在需要的时候重新组装（反序列化）来使⽤。<br>把内存中的对象变成二进制形式</p><p><strong>⽬的</strong><br>让内存中的对象可以被储存和传输。</p><p><strong>序列化是编码吗？</strong><br>不是</p><p><strong>和编码的区别</strong><br>编码是把数据由⼀种数据格式转换成另⼀种数据格式；⽽序列化是把数据由内存中的对象（⽽不是某种具体的格式）转换成字节序列。</p><p><strong>如何实现序列化，有什么意义</strong><br>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p><p><strong>浅拷贝和深拷贝</strong><br>深拷贝是指在计算机编程中，将一个对象的所有属性和方法复制到另一个对象的过程。<br>与浅拷贝不同，深拷贝会递归地复制对象的所有子对象，而不仅仅是复制对象的引用<br>这样，当修改原始对象时，深拷贝的对象不会受到影响，因为它们是独立的副本。</p><h3 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a><strong>如何实现对象克隆</strong></h3><p>有两种方式：</p><ol><li>实现 Cloneable 接口并重写 Object 类中的 clone ()方法；</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：<br>序列化其实就是将对象封装到本地。<strong>用作对象的持久化存储，也就是用流存放到硬盘上</strong>，Serializable: 用于给被序列化的类加入 ID 号。<br>用于判断类和对象是否是同一个版本。静态不能被序列化， transient 关键字修饰的不能被序列化<br>使用 <em>ByteArrayOutputStream</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUtil</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">MyUtil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">clone</span><span class="hljs-params">(T obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bout);<br>        oos.writeObject(obj);<br><br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bout.toByteArray());<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bin);<br>        <span class="hljs-keyword">return</span> (T) ois.readObject();<br><br> <span class="hljs-comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span><br><span class="hljs-comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>下面是测试代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 人类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> implements Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID = <span class="hljs-number">-9102017020286042305L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;    <span class="hljs-comment">// 姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;        <span class="hljs-comment">// 年龄</span><br>    <span class="hljs-keyword">private</span> Car car;        <span class="hljs-comment">// 座驾</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">int</span> age, Car car)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.car = car;<br>    &#125;<br><span class="hljs-comment">//get、set方法...</span><br><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;, car=&quot;</span> + car + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小汽车类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> implements Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID = <span class="hljs-number">-5713945027627603702L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> brand;       <span class="hljs-comment">// 品牌</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSpeed;       <span class="hljs-comment">// 最高时速</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(<span class="hljs-type">String</span> brand, <span class="hljs-type">int</span> maxSpeed)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>        <span class="hljs-keyword">this</span>.maxSpeed = maxSpeed;<br>    &#125;<br><span class="hljs-comment">//get、set方法、tostring...</span><br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CloneTest</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Person p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Hao LUO&quot;</span>, <span class="hljs-number">33</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>(<span class="hljs-string">&quot;Benz&quot;</span>, <span class="hljs-number">300</span>));<br>            Person p2 = MyUtil.<span class="hljs-built_in">clone</span>(p1);   <span class="hljs-comment">// 深度克隆</span><br>            p2.<span class="hljs-built_in">getCar</span>().<span class="hljs-built_in">setBrand</span>(<span class="hljs-string">&quot;BYD&quot;</span>);<br> <span class="hljs-comment">// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span><br><span class="hljs-comment">// 原来的Person对象p1关联的汽车不会受到任何影响</span><br><span class="hljs-comment">// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span><br>            System.out.<span class="hljs-built_in">println</span>(p1);<br>        &#125; <span class="hljs-built_in">catch</span> (Exception e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a><strong>Serializable</strong></h2><p>Serializable 和 Parcelable 是用来序列化和反序列化的，其中 Serializable 是 Java 提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用起来比较简单。而 Parcelable 则稍显复杂，实现该接口重写两个模版方法，并且需要提供一个 Creator。</p><ul><li>原理是<em>通过 ObjectInputStream 和 ObjectOutputStream 来实现的</em>，整个序列化过程使用了大量的反射和临时变量，而且在序列化对象的时候，不仅会序列化当前对象本身，还需要递归序列化对象引用的其他对象。</li><li>整个过程计算非常复杂，而且因为存在大量反射和 GC 的影响，序列化的性能会比较差。另外一方面因为<em>序列化文件需要包含的信息非常多，导致它的大小比 Class 文件本身还要大很多</em>，这样又会导致 I&#x2F;O 读写上的性能问题</li><li>Serializable 使用 I&#x2F;O 读写存储在硬盘上，序列化过程中产生大量的临时变量，会引起频繁 GC，效率低下。而 Parcelable 是直接在内存中读写，更加高效。</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">long</span> serialVersionUID = <span class="hljs-number">-541329592684050557</span>L;<br><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h5><p>它是用来辅助序列化和反序列化的，虽然在序列化的时候系统会自动生成一个 UID，但是还是推荐在手动提供一个 serialVersionUID。序列化操作的时候系统会<em>把当前类的 serialVersionUID 写入序列化文件中，当反序列化的时候会去检测文件中的 serialVersionUID，判断它是否与当前类的 serialVersionUID 一致，如果一致就说明序列化类与当前类版本一致，可以反序列化成功</em>，否则就可能抛异常。手动添加 serialVersionUID 的话，即使当类结构发生变化时，系统也会尽可能的恢复原有类结构，也不至于抛 InvalidClassException 异常。</p><h5 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h5><p>一个子类实现了 Serializable 接口，而父类没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的成员变量的值，该数值与序列化时的数值不同。</p><p>要想将父类对象也序列化，就需要让父类对象也实现 Serializable 接口。如果父类对象不实现的话，就需要有默认的无参的构造方法。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造方法作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值，即初始值。</p><p>因此，我们也可以通过将不需要序列化的成员变量放到未 Serializable 的父类当中，达到和 transient 关键字一样的效果。</p><h2 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-07-11-42-5b61ea69003ebac0802a791bc126f2fe-18-48-56-5b61ea69003ebac0802a791bc126f2fe-unknown_filename.1-868316-0dd353.png" alt="unknown_filename.1|600"></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="hljs-keyword">new</span> Creator&lt;User&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function">User <span class="hljs-title">createFromParcel</span><span class="hljs-params">(Parcel source)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(source);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> User[] newArray(<span class="hljs-keyword">int</span> size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User[size];<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">User</span><span class="hljs-params">(Parcel in)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = in.readString();<br>        <span class="hljs-keyword">this</span>.age = in.readInt();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">describeContents</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(Parcel dest, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;<br>        dest.writeString(<span class="hljs-keyword">this</span>.name);<br>        dest.writeInt(<span class="hljs-keyword">this</span>.age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Intent-序列化"><a href="#Intent-序列化" class="headerlink" title="Intent 序列化"></a>Intent 序列化</h2><p><strong>为何 Intent 不能直接在组件间传递对象而要通过序列化机制？</strong></p><ul><li>因为跨进程</li><li>Intent 在启动其他组件时，会离开当前应用程序进程，进入 ActivityManagerService 进程（intent. prepareToLeaveProcess ()），这也就意味着，Intent 所携带的数据要能够在不同进程间传输。首先我们知道，Android 是基于 Linux 系统，不同进程之间的 java 对象是无法传输，所以我们此处要对对象进行序列化，从而实现对象在应用程序进程和 ActivityManagerService 进程之间传输。</li><li>而 Parcel 或者 Serializable 都可以将对象序列化，其中，Serializable 使用方便，但性能不如 Parcel 容器，后者也是 Android 系统专门推出的用于进程间通信等的接口</li></ul><h2 id="Serial-的优点"><a href="#Serial-的优点" class="headerlink" title="Serial 的优点"></a><strong>Serial 的优点</strong></h2><ol><li>相比起传统的反射序列化方案更加高效（没有使用反射）</li><li>性能相比传统方案提升了3倍 （序列化的速度提升了5倍，反序列化提升了2.5倍）</li><li>序列化生成的数据量（byte[]）大约是之前的1&#x2F;5</li><li>开发者对于序列化过程的控制较强，可定义哪些 object、field 需要被序列化</li><li>有很强的 debug 能力，可以调试序列化的过程（详见：调试）</li></ol><p><strong>数据的序列化</strong></p><p>Serial 性能看起来还不错，但是对象的序列化要记录的信息还是比较多，在操作比较频繁的时候，对应用的影响还是不少的，这个时候我们可以选择使用数据的序列化。</p><p>json: 原生、gosn、fastjson（数据量大了的时候最快）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-07-11-43-1afba11681441b6a8ab8f0d86337ea28-18-23-45-1afba11681441b6a8ab8f0d86337ea28-1afba11681441b6a8ab8f0d86337ea28-f2bdba-7800d2.png" alt="1afba11681441b6a8ab8f0d86337ea28|600"></p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap、lru、散列表</title>
    <link href="/2025/12/5adbecbe8164.html"/>
    <url>/2025/12/5adbecbe8164.html</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>Hash：从数据中提出摘要信息，数字指纹，验证唯一性，完整性。</p><ul><li>HashMap 的数据结构：HashMap 实际上是一个数组和链表（“链表散列”）的数据结构。底层就是一个数组结构，数组中的每一项又是一个链表。<br>  entry 每个元素<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-077263b869afcd7040fba661a1d7b23d-unknown_filename-d5f8a1.png" alt="unknown_filename"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-de59a0b4a71e3c45b95234c6784edb17-unknown_filename.5-04d752.png" alt="unknown_filename.5"></li><li>通过 hashCode 来算出指定数组的索引可以快速定位到要找的对象在数组中的位置，之后再遍历链表找到对应值，理想情况下时间复杂度为 O(1)</li><li>不同对象可以拥有相同的 hashCode（hash 碰撞），发生碰撞后会把相同 hashcode 的对象放到同一个链表里，但是在数组大小不变的情况下，存放键值对越多，查找的时间效率也会降低</li><li>扩容可以解决该问题，而负载因子决定了什么时候扩容，负载因子是已存键值对的数量和总的数组长度的比值。默认情况下负载因子为0.75，我们可在初始化 HashMap 的时候自己修改。阀值 &#x3D; 当前数组长度✖负载因子</li><li><em>hashmap 中默认负载因子为0.75，长度默认是16</em>，默认情况下第一次扩容判断阀值是16 ✖ 0.75 &#x3D; 12；所以第一次存键值对的时候，在存到第13个键值对时就需要扩容了, 变成16X2&#x3D;32。Hashmap 的 hash 算法?</li><li><em>每次扩容是至少是当前大小的2倍，扩容的大小一定是2^n</em>，；另外，扩容后还需要将原来的数据都 transfer 到新的 table，这是耗时操作。</li><li>Java8中链表长度超过8时会把长度超过8的链表转化成红黑树；</li><li>hashCode 是一个对象的标识，Java 中对象的 hashCode 是一个 int 类型值。</li></ul><p>在不考虑哈希冲突的情况下，在哈希表中的增减、查找操作的时间复杂度为的 O (1)。HashMap 是如何做到这么优秀的 O (1)呢？<em>核心在于哈希函数能将 key 直接转换成哈希表中的存储位置，而哈希表本质是一个数组</em>，在指定下标的情况下查找数组成员是一步到位的。</p><p>红黑树的优点<br>红黑树只是做到了近似平衡（通过旋转和变色），并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。<br>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O (logn)。</p><h4 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-8184e1714b82cf35c3c4bb3a1c50b6b4-unknown_filename.4-cfd229.png" alt="unknown_filename.4|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-74cc09d1dd18dfd7cc7e9936cde5ecf9-unknown_filename.2-8ae238.png" alt="unknown_filename.2|600"></p><p>Map. Entry 里就这四个数据</p><ol><li>对 key hash，二次 hash，hash 扰乱函数，减少 hash 碰撞</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()；<br>    <span class="hljs-title function_">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; (capitity <span class="hljs-number">-1</span>); <span class="hljs-comment">//capicity表示散列表的大小</span><br>&#125;<br></code></pre></td></tr></table></figure><p>获取对象的 hashcode 以后，先进行移位运算，然后再和自己做异或运算，即：hashcode ^ (hashcode &gt;&gt;&gt; 16)，这一步甚是巧妙，是将高16位移到低16位，这样计算出来的整型值将“具有”高位和低位的性质.<br>每个槽（链表）里的数据比较平均，增加了哈希值的<strong>随机性</strong>和分布性。这有助于减少哈希冲突的可能性，即不同键具有相同哈希值的情况。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161532718.png" alt="Pasted image 20250905153254"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512161532719.png" alt="Pasted image 20250905153310"></p><ol start="2"><li>通过 hash 算出数组角标（indexfor（））</li><li>如果 key 相同就把值覆盖；没有的话添加元素</li><li>添加元素，看是否需要扩容，需要的话变数组变成原来的2倍，把旧的拷贝到新的数组上去，然后旧的指针指向新的。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-keyword">return</span> h &amp; (length<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>h（哈希码）和 length（数组长度）</p><p><em>位运算快于十进制运算</em><br>而<em>按位与</em> 计算的原则是两位同时为“1”，结果才为“1”，否则为“0”。所以 h&amp; (length-1)运算从数值上来讲其实等价于对 length 取模（两个数相除的余数），也就是 h%length。</p><p>假设当前 table 的 length 是15，二进制表示为1111，那么 length-1就是1110，此时有两个 hash 值为8和9的 key 需要计算索引值，计算过程如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span>的二进制表示：<span class="hljs-number">1000</span><br><span class="hljs-symbol">8 </span>&amp;（length-<span class="hljs-number">1</span>）= <span class="hljs-number">1000</span> &amp; <span class="hljs-number">1110</span> = <span class="hljs-number">1000</span>，索引值即为<span class="hljs-number">8</span>;<br><br><span class="hljs-number">9</span>的二进制表示：<span class="hljs-number">1001</span><br><span class="hljs-symbol">9 </span>&amp;（length-<span class="hljs-number">1</span>）= <span class="hljs-number">1001</span> &amp; <span class="hljs-number">1110</span> = <span class="hljs-number">1000</span>，索引值也为<span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>这样一来就产生了相同的索引值，也就是说两个 hash 值为8和9的 key 会定位到数组中的同一个位置上形成链表，这就产生了碰撞。</p><h4 id="get-流程"><a href="#get-流程" class="headerlink" title="get 流程"></a>get 流程</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-f15ca9b61cff8182dcb904293055bf60-unknown_filename.6-fe31c5.png" alt="unknown_filename.6|600"></p><ol><li>get 对 key hash，找到数组角标（indexfor（））</li><li>如果 hash 相同 key 相同就找到了</li><li>如果 hash 相同 key 不相同，找链表的下一个（通过值找）</li></ol><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul><li><p>1.7 的 HashMap 怎么在链表上添加数据，在链表的前⾯还是链表的后⾯？<br>  「头插法」</p></li><li><p>1.7 HashMap 是怎么预防和解决 Hash 冲突的。<br>  <em>「⼆次哈希」+「拉链法」</em></p></li><li><p>1.7 HashMap 默认容量是多少？为什么是 16 可以是 15 吗？<br>  <em>16，需要是 2 的幂次⽅</em></p></li><li><p>1.7 HashMap 的数组是什么时候创建的？<br>  <em>⾸次调⽤ put 时</em></p></li><li><p>1.7 和 1.8 数据结构有什么不同？<br>  1.8 增加了转换为红⿊树</p></li><li><p>插⼊数据的⽅式<br>  1.7 的链表从前⾯插⼊，1.8 的链表从后⾯插⼊</p></li><li><p>扩容后存储位置的计算⽅式<br>  1.7 通过再次 indexFor () 找到数组位置，1.8 通过⾼低位的桶直接在链表尾部添加。</p></li><li><p>HashMap 什么时候会把链表转化为红⿊树？<br>  链表⻓度超过 8 ，并且数组⻓度不⼩于 64<br>  在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（<em>默认超过 8</em>）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p></li></ul><h4 id="HashMap-存对象"><a href="#HashMap-存对象" class="headerlink" title="HashMap 存对象"></a>HashMap 存对象</h4><p>HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。如果要用对象作为 key 的话需要重新该对象的 equals 方法和 hashCode 方法。</p><blockquote><p>new 一个新的对象时，地址变了，不能保证 hash 值和 equals 结果还是一样。所以取不到对应的 value。</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">Map</span>&lt;People,<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;People, <span class="hljs-built_in">Integer</span>&gt;();<br><span class="hljs-keyword">map</span>.put(<span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-number">18</span>),<span class="hljs-number">5</span>);<br>People p = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-number">18</span>);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">map</span>.get(p)); //不重写的话就是<span class="hljs-keyword">null</span><br>    <br></code></pre></td></tr></table></figure><h4 id="优化-hashmap"><a href="#优化-hashmap" class="headerlink" title="优化 hashmap"></a>优化 hashmap</h4><p>第一种：<br>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，<strong>如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数</strong>，这样会大大提高 HashMap 的性能。<br>第二种：提高锁的粒度，精确锁的分布。<br>第三种：ConcurrentHashMap<br>第四种使用： [[SparseArray 和 ArrayMap]]</p><p><strong>WeakValueHashMap</strong><br>WeakReference 是“弱键”实现的哈希表。它这个“弱键”的目的就是：实现对“键值对”的动态回收。当“弱键”不再被使用到时，GC 会回收它，WeakReference 也会将“弱键”对应的键值对删除。   <br>“弱键”是一个“弱引用 (WeakReference)”，在 Java 中，WeakReference 和 ReferenceQueue 是联合使用的。在 WeakHashMap 中亦是如此：如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。接着，WeakHashMap 会根据“引用队列”，来删除“WeakHashMap 中已被 GC 回收的‘弱键’对应的键值对”。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol><li>Concurrent 作用是处理并发情况的 HashMap，多线程并发下 HashMap 是不安全的 (如死循环)，更普遍的是多线程并发下，由于堆内存对于各个线程是共享的，而 HashMap 的 put 方法不是原子操作，假设 Thread1先 put 值，然后 sleep 2秒 (也可以是系统时间片切换失去执行权)，在这2秒内值被 Thread2改了，Thread1“醒来”<em>再 get 的时候发现已经不是原来的值了</em>，这就容易出问题。</li><li>如何避免这种多线程“奥迪变奥拓”的情况呢？常规思路就是给 HashMap 的 put 方法加锁 (synchronized)，保证同一个时刻只允许一个线程拥有对 hashmap 有写的操作权限即可。然而假如线程1中操作耗时，其他需要操作该 hashmap 的线程就需要在门口排队半天，严重影响用户体验 (HashTable 就是这么干的)。</li><li>ConcurrentHashMap 所使用的<em>锁分段技术</em>，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<em>首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</em>。</li><li>对 ConcurrentHashMap 边遍历边删除或者增加操作不会产生异常 (可以不用迭代方式删除元素)，因为其内部已经做了维护，遍历的时候都能获得最新的值。即便是多个线程一起删除、添加元素也没问题。</li></ol><h3 id="最近最少使用算法"><a href="#最近最少使用算法" class="headerlink" title="最近最少使用算法"></a>最近最少使用算法</h3><ul><li>会将内存控制在一定的大小内, 这个最大值可以自己定（一般使用最大可用内存的1&#x2F;8作为缓存的大小），超出最大值时会自动回收。他内部是是一个 linkedhashmap 存储外界的缓存对象，提供了 get, put 方法来操作，当缓存满了，lru 会移除较早使用的缓存对象，把新的添加进来。</li><li>HashMap 是无序的，而 LinkedHashMap 默认实现是按插入顺序排序的，怎么存怎么取。LinkedHashMap 每次调用 get 则将该对象移到链表的尾端。调用 put 插入新的对象也是存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。</li><li>内存中使用 LRUCache 是最合适的。如果用 HashMap 来实现，不是不可以，但需要注意在合适的时候释放缓存。至于具体怎么释放，很难控制缓存的大小，也就是说，只有等到你的内存快要撑爆，你的图片缓存才会被回收。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitmapCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImageCache</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> LruCache&lt;String, Bitmap&gt; mCache;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BitmapCache</span><span class="hljs-params">()</span> &#123;  <br>   <span class="hljs-type">long</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">8</span>;<span class="hljs-comment">//主流都是分配16m的8/1</span><br>      <span class="hljs-comment">//  int maxSize = 10 * 1024 * 1024;  </span><br>        mCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruCache</span>&lt;String, Bitmap&gt;(maxSize) &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sizeOf</span><span class="hljs-params">(String key, Bitmap bitmap)</span> &#123;  <br>            <span class="hljs-comment">//获取图片占用内存大小</span><br>                <span class="hljs-keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight();  <br>            &#125;  <br>        &#125;;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Bitmap <span class="hljs-title function_">getBitmap</span><span class="hljs-params">(String url)</span> &#123;  <br>        <span class="hljs-keyword">return</span> mCache.get(url);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putBitmap</span><span class="hljs-params">(String url, Bitmap bitmap)</span> &#123;  <br>        mCache.put(url, bitmap);  <br>    &#125;  <br>  <br>&#125;  <br><br></code></pre></td></tr></table></figure></li></ul><p><strong>什么时候用过</strong><br>在存视频和对应的进度的时候用过<br><strong>使用场景</strong><br>临时的比较多的数据，就可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> LRUCache&lt;String, Long&gt; mVideoPositionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;&gt;(<span class="hljs-number">50</span>);<br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getVideoPosition</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> mVideoPositionMap.get(url);<br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">videoPosition</span> <span class="hljs-operator">=</span> getVideoPositionFromLocal(url);<br>            <span class="hljs-keyword">if</span> (videoPosition &gt; <span class="hljs-number">0</span>) &#123;<br>                mVideoPositionMap.set(url, position);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> position;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVideoPosition</span><span class="hljs-params">(String url, <span class="hljs-type">long</span> position)</span> &#123;<br>        mVideoPositionMap.set(url, position);<br>        saveToLocal();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>散列表中数据是经过散列函数打乱之后无规律存储的，LinkedHashMap 是如何实现按照数据的插入顺序来遍历打印的呢？<br><strong>LinkedHashMap 是通过散列表和链表组合在一起实现的。实际上，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</strong>。你可以看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span><br>HashMap&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>);<br>m.put(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>);<br>m.put(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>);<br>m.put(<span class="hljs-number">5</span>, <span class="hljs-number">23</span>);<br>m.put(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>);<br><br>m.put(<span class="hljs-number">3</span>, <span class="hljs-number">26</span>);<br>m.get(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">for</span> (Map.Entry e : m.entrySet()) &#123;<br>  System.out.println(e.getKey());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码打印的结果是 1，2，3，5、<br>每次调用 put () 函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据是下面这样：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-e6037a16c61180592331dba400269464-unknown_filename.7-44d4b9.png" alt="unknown_filename.7"><br>在第 8 行代码中，再次将键值为 3 的数据放入到 LinkedHashMap 的时候，会先查找这个键值是否已经有了，然后，<em>再将已经存在的 (3,11) 删除，并且将新的 (3,26) 放到链表的尾部</em>。所以，这个时候链表中的数据就是下面这样：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-44645256433fb1b872e9a73ebe1c8fdd-unknown_filename.8-858926.png" alt="unknown_filename.8"><br>当第 9 行代码访问到 <em>key 为 5 的数据的时候，我们将被访问到的数据移动到链表的尾部</em>。所以，第 9 行代码之后，链表中的数据是下面这样：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-c716813c10c3455add6443dcebd45f1a-unknown_filename.9-37bd09.png" alt="unknown_filename.9"><br>从上面的分析，你有没有发现，按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统？实际上，它们两个的实现原理也是一模一样的。我也就不再啰嗦了。</p><p><strong>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。</strong></p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后<strong>无规律存储的</strong>。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”，其实 HashMap 就是实现一个散列表。</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>其中，参赛选手的编号我们叫作键（key）或者关键字。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值（或“Hash 值”“哈希值”）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-741141f41c062c7cf90aee36fc3c7ded-unknown_filename.1-ee8c97.png" alt="unknown_filename.1"><br>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O (1) 的特性。我们通过<strong>散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置</strong>。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><p><strong>时间复杂度</strong><br>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O (1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O (n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O (1)</p><p>然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O (k)。对于散列比较均匀的散列函数来说，理论上讲，k&#x3D;n&#x2F;m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash (key)，其中 key 表示元素的键值，hash (key) 的值表示经过散列函数计算得到的散列值。</p><p>该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：</p><ol><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 key1 &#x3D; key2，那 hash (key1) &#x3D;&#x3D; hash (key2)；</li><li>如果 key1 ≠ key2，那 hash (key1) ≠ hash (key2)</li></ol><p>我来解释一下这三点。其中，第一点理解起来应该没有任何问题。因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。第二点也很好理解。相同的 key，经过散列函数得到的散列值也应该是相同的。</p><p>第三点理解起来可能会有问题，我着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。<strong>即便像业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</strong></p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><ol><li>开放寻址法<br> 线性探测<br> 我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</li></ol><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。<br>ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突</p><p>散列表的装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度</p><p><strong>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降</strong></p><ol start="2"><li>链表法<br> Java 中 LinkedHashMap 就采用了链表法解决冲突<br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-25bf6252e17ceb49a97cb47758ba66a3-unknown_filename.10-3b5c10.png" alt="unknown_filename.10"></li></ol><h3 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h3><p>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</p><p>首先，散列函数的<strong>设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽（链表）里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><h4 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h4><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。<br>扩容解决<br>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。</p><p><strong>避免低效地扩容</strong><br>我举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？<br>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。<strong>经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了</strong>。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/HashMap%E3%80%81lru%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8.resources/2023/09/18/09-57-22-7f5c30da850bbb708944750cec7e5bb0-unknown_filename.3-83fe9b.png" alt="unknown_filename.3"><br>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p><a href="https://time.geekbang.org/column/intro/126">《数据结构与算法之美》</a></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>要保证HashMap线程安全，可以采取以下几种方法：</p><ol><li><strong>使用Collections.synchronizedMap()方法</strong>：这个方法会返回一个线程安全的Map，它通过装饰器模式为原始的HashMap提供了一个同步的包装器。这个包装器在调用任何Map操作时都会进行同步，从而保证线程安全。</li><li><strong>使用ConcurrentHashMap</strong>：ConcurrentHashMap是Java提供的一个线程安全的Map实现。它通过分段锁技术来提高并发性能，只锁定Map中的一部分而不是整个Map，这样可以减少线程之间的竞争，提高并发访问的效率。</li><li><strong>使用Hashtable</strong>：Hashtable是一个古老的线程安全的Map实现，它通过在每个方法上使用synchronized关键字来确保线程安全。但是，由于它在执行任何操作时都会锁定整个表，所以并发性能较差。</li><li><strong>使用volatile关键字</strong>：虽然将HashMap声明为volatile可以保证变量的可见性，但是它并不能保证复合操作的原子性，因此无法完全保证线程安全。这种方法通常不推荐使用。</li><li><strong>使用CopyOnWriteArrayList</strong>：如果你的使用场景主要是读操作远多于写操作，可以考虑使用CopyOnWriteArrayList。这是一个线程安全的List实现，它在每次写入时都会创建一个新的副本，读操作则在原始数据上进行，不会产生冲突。</li></ol><p>总的来说，在选择哪种方法时，需要根据具体的应用场景和对性能的要求来决定。如果对并发性能要求较高，推荐使用ConcurrentHashMap。如果对性能要求不是特别高，或者需要一个比较简单的解决方案，可以使用Collections.synchronizedMap()方法。而Hashtable则适用于那些对性能要求不高，但需要完全线程安全的场景。 </p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法分享</title>
    <link href="/2025/12/50fd4ce9422f.html"/>
    <url>/2025/12/50fd4ce9422f.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>部分内容来自极客时间课程</p><p><a href="https://time.geekbang.org/column/intro/126">数据结构与算法之美</a></p><h1 id="数据结构和算法-1"><a href="#数据结构和算法-1" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><ul><li>举个例子：图书管理员会将书籍分门别类进行“存储”，按照一定规律编号，这就是书籍这种“数据”的存储结构。</li><li>那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。</li><li>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构</li><li>“存储”需要的就是数据结构，“计算”需要的就是算法</li></ul><h3 id="常用数据结构与算法"><a href="#常用数据结构与算法" class="headerlink" title="常用数据结构与算法"></a>常用数据结构与算法</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-913e0ababe43a2d57267df5c5f0832a7-unknown_filename-aaca32.jpeg" alt="unknown_filename"></p><ul><li>20 个最常用的、最基础数据结构与算法<br>  10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</li><li>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</li><li>在学习数据结构和算法的过程中，你也要注意，不要只是死记硬背，不要为了学习而学习，而是要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</li><li><strong>基础的数据结构就是数组和链表， 而后面更加复杂的 树 队列 图 等等 都可以通过数组和链表等方式存储， 出现树 队列 图 等数据结构的原因 就是为了解决 部分问题处理过程中时间复杂度过高的问题， 所以数据结构就是为了算法而生的！</strong></li></ul><p>数据结构是相互之间存在一种或多种关系的数据元素的集合。逻辑结构有4种：<br>集合结构（数据元素之间仅以集合的方式体现，元素之间没有别的关系）<br>线性结构（数据元素之间存在一对一的关系）<br>树（数据元素之间为一对多或多对一的关系）<br>图（数据元素之间为多对多的关系）</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>所有代码的执行时间 T(n) 与每行代码的执行次数成正比。<br>T(n) &#x3D;O( f(n) )</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> cal(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br>  for (; i &lt;= <span class="hljs-built_in">n</span>; ++i) &#123;<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i;<br>  &#125;<br>  return <span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。当 n 无限大的时候，就可以忽略。</li><li>循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</li></ul><h4 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h4><ul><li><code>总的时间复杂度就等于量级最大的那段代码的时间复杂度</code></li><li>如果 T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么 T(n)&#x3D;T1(n)+T2(n)&#x3D;max(O(f(n)), O(g(n))) &#x3D;O(max(f(n), g(n))).</li><li>假设 T1(n) &#x3D; O(n)，T2(n) &#x3D; O(n2)，则 T1(n) * T2(n) &#x3D; O(n3)<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-6ea770ad3989b3998f2e62a572332352-unknown_filename.1-54151b.png" alt="unknown_filename.1"></li></ul><h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int i</span> = 8;<br><span class="hljs-attribute">int j</span> = 6;<br><span class="hljs-attribute">int sum</span> = i + j;<br></code></pre></td></tr></table></figure><p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。<br>跟数据规模 n 没有关系，都可忽略</p><h4 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;</span><br>while (i &lt;<span class="hljs-operator">=</span> n)   &#123;   <br>    i <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span><span class="hljs-comment">; </span><br>  &#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-594a537e65a8390b2d77b67e45fe7371-unknown_filename.2-ecf278.png" alt="unknown_filename.2"><br>2x&#x3D;n<br>x&#x3D;log2n</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">; </span><br>while (i &lt;<span class="hljs-operator">=</span> n)  <br>&#123;   i <span class="hljs-operator">=</span> i * <span class="hljs-number">3</span><span class="hljs-comment">; &#125;</span><br>    <br></code></pre></td></tr></table></figure><p>这段代码的时间复杂度为 O(log3n)。<br>但是实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)</p><p>O(nlogn)<br>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)</p><h4 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m* n)"></a>O(m+n)、O(m* n)</h4><p>代码的复杂度由两个数据的规模来决定</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-type">int</span> sum_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; m; ++i) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br><br>  <span class="hljs-type">int</span> sum_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; j &lt; n; ++j) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。针对这种情况，原来的加法法则就不正确了<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-8d830b4333fcfdf2d8f572f790be3594-unknown_filename.3-c397e9.png" alt="unknown_filename.3"></p><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><ul><li>如果时间复杂度表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。那么，空间复杂度表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。</li><li>我们常见的空间复杂度就是 <strong>O(1)、O(n)、O(n2)</strong> ，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br>而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><h4 id="为什么数组从0开始"><a href="#为什么数组从0开始" class="headerlink" title="为什么数组从0开始"></a>为什么数组从0开始</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-f67fc8ab7ab08d935633ff708a7cd96b-unknown_filename.4-62fb8d.png" alt="unknown_filename.4"><br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">a[i]_address = base_address + i * dat<span class="hljs-built_in">a_type</span>_size<br></code></pre></td></tr></table></figure><p>其中 base_address 是首地址，data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址。<br>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[k]</span>_address = base_address + (k-<span class="hljs-number">1</span>)*type_size<br></code></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。所以数组从0开始。</p><blockquote><p>一个错误：<br>很多人说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。<br>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)（k在第几个位置）。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p></blockquote><p><strong>数组和ArrayList</strong></p><ul><li>ArrayList最大的优势就是可以将很多数组操作的细节封装起来。<strong>支持动态扩容</strong>。</li><li>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</li><li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>从图中看到，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。<br>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将<strong>一组零散的内存</strong>块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-6f0bc75c9d512a528079f9e166b3677a-unknown_filename.5-159634.png" alt="unknown_filename.5"><br>针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-c1e8eee85c6083a1334765e29b16d960-unknown_filename.6-85be82.png" alt="unknown_filename.6"></p><h4 id="数组和链表对比"><a href="#数组和链表对比" class="headerlink" title="数组和链表对比"></a>数组和链表对比</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-46b847c856e6e5194cb1311980456aa5-unknown_filename.7-41e650.png" alt="unknown_filename.7"><br><strong>数组的缺点是大小固定，一经声明就要占用整块连续内存空间</strong>。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。<br>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p><h4 id="实现一个栈"><a href="#实现一个栈" class="headerlink" title="实现一个栈"></a>实现一个栈</h4><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 基于数组实现的顺序栈</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ArrayStack &#123;<br>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>;       <span class="hljs-comment">// 栈中元素个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">//栈的大小</span><br><br>  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span><br>  <span class="hljs-keyword">public</span> ArrayStack(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];<br>    <span class="hljs-keyword">this</span>.n = n;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 入栈操作</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-keyword">push</span>(String item) &#123;<br>    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span><br>    items[<span class="hljs-keyword">count</span>] = item;<br>    ++<span class="hljs-keyword">count</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 出栈操作</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-keyword">pop</span>() &#123;<br>    <span class="hljs-comment">// 栈为空，则直接返回null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br>    String tmp = items[<span class="hljs-keyword">count</span>-<span class="hljs-number">1</span>];<br>    --<span class="hljs-keyword">count</span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。<br>这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。<br>所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。空间复杂度分析是不是很简单？<br>时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><p>如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进者先出，这就是典型的“队列”。队列跟栈一样，也是一种操作受限的线性表数据结构。<br>队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。</p><h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 用数组实现的队列</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br>      <span class="hljs-comment">// 数组：items，数组大小：n</span><br>      <span class="hljs-keyword">private</span> <span class="hljs-type">String</span>[] items;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br>    <br>      <span class="hljs-comment">// 申请一个大小为capacity的数组</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>          items = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[capacity];<br>          n = capacity;<br>      &#125;<br>    <br>      <span class="hljs-comment">// 入队</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">String</span> item)</span> </span>&#123;<br>          <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span><br>          <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          items[tail] = item;<br>          ++tail;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    <br>      <span class="hljs-comment">// 出队</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-comment">// 如果head == tail 表示队列为空</span><br>          <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> null;<br>          <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br>          <span class="hljs-type">String</span> ret = items[head];<br>          ++head;<br>          <span class="hljs-keyword">return</span> ret;<br>      &#125;<br>  &#125;<br>    <br></code></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-b2d628d2e2c9c72a272c81423fd1cf78-unknown_filename.27-05b86f.png" alt="unknown_filename.27"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-9980d7c417ac55883bd7346741561c5a-unknown_filename.28-d6bbf8.png" alt="unknown_filename.28"><br>“高度”这个概念，其实就是<code>从下往上度量</code>，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。<br>“深度”这个概念在生活中是<code>从上往下度量</code>的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。<br>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="如何表示（或者存储）一棵二叉树"><a href="#如何表示（或者存储）一棵二叉树" class="headerlink" title="如何表示（或者存储）一棵二叉树"></a>如何表示（或者存储）一棵二叉树</h4><p>一种是基于指针或者引用的二叉链式存储法<br>一种是基于数组的顺序存储法。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TreeNode</span> &#123;<br>     <span class="hljs-built_in">int</span> val;<br>     <span class="hljs-comment">//左孩子</span><br>     TreeNode left;<br>     <span class="hljs-comment">//右孩子</span><br>     TreeNode right;<br> &#125;<br>    <br></code></pre></td></tr></table></figure><p><strong>链式存储法</strong><br>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。<strong>大部分二叉树代码都是通过这种结构来实现的</strong>。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-3366dcd99ebcb6946e18577cd3b274ae-unknown_filename.29-c28727.png" alt="unknown_filename.29"><br>基于数组的<strong>顺序存储法</strong><br>把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-c14b4f66b44fdfeb4fe0502ae9b924c2-unknown_filename.30-6f669b.png" alt="unknown_filename.30"></p><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>前序遍历、中序遍历和后序遍历<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-419bef62a53c1b1fe1f68822e75f3ddf-unknown_filename.31-93ba4d.png" alt="unknown_filename.31"><br>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。</p><p><strong>二叉树遍历的时间复杂度</strong><br>从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p><h3 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h3><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。<br>叉查找树最大的特点就是，<strong>支持动态数据集合的快速插入、删除、查找操作</strong>。不需要有序</p><p><strong>1. 二叉查找树的查找操作</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span> &#123;<br>  <span class="hljs-keyword">private</span> Node tree;<br><br>  <span class="hljs-keyword">public</span> Node find(int <span class="hljs-keyword">data</span>) &#123;<br>    Node p = tree;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> &lt; p.<span class="hljs-keyword">data</span>) p = p.left;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> &gt; p.<span class="hljs-keyword">data</span>) p = p.right;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 二叉查找树的插入操作</strong><br>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><br><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> insert(int <span class="hljs-built_in">data</span>) &#123;<br>  <span class="hljs-keyword">if</span> (tree == <span class="hljs-built_in">null</span>) &#123;<br>    tree = <span class="hljs-literal">new</span> Node(<span class="hljs-built_in">data</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  Node p = tree;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-built_in">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> &gt; p.<span class="hljs-built_in">data</span>) &#123;<br>      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-built_in">null</span>) &#123;<br>        p.right = <span class="hljs-literal">new</span> Node(<span class="hljs-built_in">data</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.right;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span><br>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-built_in">null</span>) &#123;<br>        p.left = <span class="hljs-literal">new</span> Node(<span class="hljs-built_in">data</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.left;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h4><p><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</strong><br><strong>查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-24fb39feac68ae2a9211a753c972771a-unknown_filename.32-bb53aa.png" alt="unknown_filename.32"><br>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p>我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？<br>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，<strong>如何求一棵包含 n 个节点的完全二叉树的高度？</strong><br>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。<br><strong>平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。</strong></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。</p><h4 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h4><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-cca968c669ec908aeeec646ad8dca686-unknown_filename.33-98f2a5.png" alt="unknown_filename.33"><br>很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p><p>AVL树不存在变色的问题，只有左旋转、右旋转这两种操作。</p><h4 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h4><p>新加入的就是红节点</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653204996&idx=2&sn=ecf932d2db8cb6e4fcb841a2b6a5bfba&chksm=8c99c0debbee49c86dc8e82a2d195389a93e81d8e5ca8af7d4dd2eec5c7fe209038c91444964&scene=21#wechat_redirect">漫话</a><br>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。<br>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-f9050ec7b157d7e1bc0c2528f1dcd1dd-unknown_filename.36-72b8f0.png" alt="unknown_filename.36"></li></ul><p><strong>为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</strong><br>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。<br>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。<br>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 logn，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。</p><hr><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。<br>于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。<br>我们用递推公式将它表示出来就是这样的：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>=<span class="hljs-built_in">f</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span> 其中，<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)&#x3D;1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h4><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件<br> 第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)&#x3D;1，这就是递归的终止条件。</li></ol><h4 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h4><p>写递归代码最关键的是写出递推公式，找到终止条件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Recursion</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求和</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">summation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num + summation(num - <span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求二进制</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">summation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num</span>)</span> &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            summation(num / <span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">int</span> i = num % <span class="hljs-number">2</span>;<br>            sb.append(i);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(sb.toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求n的阶乘</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> n * f(n - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong><br>人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正和它的胃口。<br>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p><p><strong>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</strong><br>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong><br>不要陷入思维误区。</p><h4 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h4><p><strong>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险</strong>。</p><p>那么，如何避免出现堆栈溢出呢？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 全局变量，表示递归的深度。</span><br><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  ++depth；<br>  <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">throw</span> exception;<br>  <br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p><a href="https://segmentfault.com/a/1190000015944750">爬楼梯</a></p><blockquote><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。求出一共有多少种走法。<br>比如，每次走1级台阶，一共走10步，这是其中一种走法。<br>再比如，每次走2级台阶，一共走5步，这是另一种走法。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>int <span class="hljs-built_in">f</span>(int n) &#123;<br>  if (n == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br>  if (n == <span class="hljs-number">2</span>) return <span class="hljs-number">2</span>;<br>  return <span class="hljs-built_in">f</span>(n-<span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-bfc3eaa6c0d6a52a2cc6a9e58afc5587-unknown_filename.8-e2fb3e.png" alt="unknown_filename.8"><br>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来<code>保存已经求解过的 f(k)</code>。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">public int <span class="hljs-built_in">f</span>(int <span class="hljs-keyword">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">n</span> == 1) <span class="hljs-keyword">return</span> 1;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">n</span> == 2) <span class="hljs-keyword">return</span> 2;<br>  <br>  <span class="hljs-comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span><br>  <span class="hljs-keyword">if</span> (hasSolvedList.containsKey(<span class="hljs-keyword">n</span>)) &#123;<br>    <span class="hljs-keyword">return</span> hasSolvedList.<span class="hljs-built_in">get</span>(<span class="hljs-keyword">n</span>);<br>  &#125;<br>  <br>  int <span class="hljs-keyword">ret</span> = <span class="hljs-built_in">f</span>(<span class="hljs-keyword">n</span>-1) + <span class="hljs-built_in">f</span>(<span class="hljs-keyword">n</span>-2);<br>  hasSolvedList.put(<span class="hljs-keyword">n</span>, <span class="hljs-keyword">ret</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h4><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题</p><p>电影院修改</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-keyword">int</span> f(<span class="hljs-keyword">int</span> n) &#123;<br>  <span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  for (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span><span class="hljs-comment">; i &lt;= n; ++i) &#123;</span><br>    <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">ret</span> + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  &#125;<br>  return <span class="hljs-keyword">ret</span><span class="hljs-comment">;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>爬楼梯修改</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> getWays3(<span class="hljs-type">int</span> n) &#123;<br>       <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <br>       // a保存倒数第二个子状态数据，b保存倒数第一个子状态数据， <span class="hljs-keyword">temp</span> 保存当前状态的数据<br>       <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a + b;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>           <span class="hljs-keyword">temp</span> = a + b;<br>           a = b;<br>           b = <span class="hljs-keyword">temp</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">temp</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h4 id="如何找到“最终推荐人”？"><a href="#如何找到“最终推荐人”？" class="headerlink" title="如何找到“最终推荐人”？"></a>如何找到“最终推荐人”？</h4><p>推荐注册返佣金的这个功能我想你应该不陌生吧？现在很多 App 都有这个功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">long</span> <span class="hljs-title">findRootReferrerId</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> actorId</span>)</span> &#123;<br>  Long referrerId = <span class="hljs-keyword">select</span> referrer_id <span class="hljs-keyword">from</span> [table] <span class="hljs-keyword">where</span> actor_id = actorId;<br>  <span class="hljs-keyword">if</span> (referrerId == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> actorId;<br>  <span class="hljs-keyword">return</span> findRootReferrerId(referrerId);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。<br>第一，如果递归很深，可能会有堆栈溢出的问题。<br>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。</p><p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">ListNode head</span>) &#123;<br>     <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">ListNode</span>&gt; nodesSeen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>     <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">if</span> (nodesSeen.<span class="hljs-title function_">contains</span>(head)) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             nodesSeen.<span class="hljs-title function_">add</span>(head);<br>         &#125;<br>         head = head.<span class="hljs-property">next</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>调试递归</strong><br>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。<br>调试递归:</p><ol><li>打印日志发现，递归值。</li><li>结合条件断点进行调试。</li></ol><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>底层必须依赖数组，并且还要求数据是有序的。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-b6bf9679b06824b205a40d2b8f81ad1a-unknown_filename.22-fb6282.png" alt="unknown_filename.22"><br>这是一个等比数列。其中 n&#x2F;2k&#x3D;1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n&#x2F;2k&#x3D;1，我们可以求得 k&#x3D;log2n，所以时间复杂度就是 O(logn)。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] == k) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> b = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (a &lt;= b) &#123;<br>        <span class="hljs-keyword">int</span> m = a + (b - a) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (k &lt; arr[m]) &#123;<br>            b = m<span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(k &gt; arr[m])</span> </span>&#123;<br>            a = m + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>二分查找除了用循环来实现，还可以用递归来实现</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 二分查找的递归实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, val)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (a[mid] == value) &#123;<br>    <span class="hljs-keyword">return</span> mid;<br>  &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(a[mid] &lt; value)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(a, mid+<span class="hljs-number">1</span>, high, value)</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(a, low, mid<span class="hljs-number">-1</span>, value)</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h4><p><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组</strong>。<br>数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。<br><strong>其次，二分查找针对的是有序数据。</strong><br>数据必须是有序的。如果数据没有序，我们需要先排序<br>如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。<br>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？ 二叉树！<br><strong>再次，数据量太小不适合二分查找。</strong><br>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。<br><strong>最后，数据量太大也不适合二分查找。</strong><br>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><h4 id="二分查找变形"><a href="#二分查找变形" class="headerlink" title="二分查找变形"></a>二分查找变形</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-c1d6cb5ff6dfd01437c1ffcea0da30d8-unknown_filename.23-428743.png" alt="unknown_filename.23"></p><p><strong>变体一：查找第一个值等于给定值的元素</strong><br>如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-afb95d03b8f2db09a02d2e556a6b293e-unknown_filename.24-1812bf.png" alt="unknown_filename.24"><br>如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4] 比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。<br>尽管 a[7] 也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(a[mid] &lt; value)</span> </span>&#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>变体二：查找最后一个值等于给定值的元素</strong><br>前面的问题是查找第一个值等于给定值的元素，我现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>public <span class="hljs-built_in">int</span> bsearch(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>) &#123;<br>  <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> high = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>  while (low &lt;= high) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &gt; <span class="hljs-built_in">value</span>) &#123;<br>      high = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &lt; <span class="hljs-built_in">value</span>) &#123;<br>      low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      <span class="hljs-built_in">if</span> ((<span class="hljs-built_in">mid</span> == <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) || (a[<span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>] != <span class="hljs-built_in">value</span>)) return <span class="hljs-built_in">mid</span>;<br>      else low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>变体三：查找第一个大于等于给定值的元素</strong><br>在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> bsearch(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>) &#123;<br>  <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> high = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>  while (low &lt;= high) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &gt;= <span class="hljs-built_in">value</span>) &#123;<br>      <span class="hljs-built_in">if</span> ((<span class="hljs-built_in">mid</span> == <span class="hljs-number">0</span>) || (a[<span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">value</span>)) return <span class="hljs-built_in">mid</span>;<br>      else high = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>变体四：查找最后一个小于等于给定值的元素</strong><br>我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> bsearch7(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>) &#123;<br>  <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> high = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>  while (low &lt;= high) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &gt; <span class="hljs-built_in">value</span>) &#123;<br>      high = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      <span class="hljs-built_in">if</span> ((<span class="hljs-built_in">mid</span> == <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) || (a[<span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>] &gt; <span class="hljs-built_in">value</span>)) return <span class="hljs-built_in">mid</span>;<br>      else low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="跳表（Skip-list"><a href="#跳表（Skip-list" class="headerlink" title="跳表（Skip list)"></a>跳表（Skip list)</h4><p>还可以优化链表，空间换时间，加索引<br>因为<strong>二分查找底层依赖的是数组随机访问的特性</strong>，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？<br>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速的插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？</p><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-8a66b846201e0dd5c84b8dd43783efe7-unknown_filename.25-659e04.png" alt="unknown_filename.25"><br>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-527ef8ed60841f9cf804782e64bbbc88-unknown_filename.26-b88b50.png" alt="unknown_filename.26"></p><p><strong>这种链表加多级索引的结构，就是跳表</strong></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-bfed5278e366a402fff717fada9f8067-unknown_filename.9-5afd9f.png" alt="unknown_filename.9"></p><p>我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><p><strong>排序算法的内存消耗</strong><br><code>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。冒泡、插入、选择，都是原地排序算法</code>。</p><p><strong>排序算法的稳定性</strong><br>针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。<br>经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。</p><p>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</p><ul><li>稳定排序有：插入排序，基数排序，归并排序 ，冒泡排序 ，基数排序。</li><li>不稳定的排序算法有：快速排序，希尔排序，简单选择排序，堆排序。</li></ul><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>稳定、原地排序<br>我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-88a3aa0c2067bab8a02383193d65e4c5-unknown_filename.10-e098a8.png" alt="unknown_filename.10"><br>实际上，刚讲的冒泡过程还可以优化。<strong>当某次冒泡操作已经没有数据交换时，说明已经达到完全有序</strong>，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-35b76771b8d43bda5b82e3d56ae1e3f2-unknown_filename.11-680e28.png" alt="unknown_filename.11"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 冒泡排序，a表示数组，n表示数组大小</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br> <br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-comment">// 提前退出冒泡循环的标志位</span><br>    <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; ++j) &#123; <span class="hljs-comment">//-i：比较元素减少，-1：避免角标越界  </span><br>      <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 交换</span><br>        <span class="hljs-type">int</span> tmp = a[j];<br>        a[j] = a[j+<span class="hljs-number">1</span>];<br>        a[j+<span class="hljs-number">1</span>] = tmp;<br>        flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 表示有数据交换      </span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 没有数据交换，提前退出</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>稳定、原地排序<br>基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-28beb1ac33817bd7859a4ed3badb1552-unknown_filename.12-cfd905.png" alt="unknown_filename.12"><br>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><p><strong>插入排序具体是如何借助上面的思想来实现排序的呢？</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-cdd8391de3b255c586fbaa8e68ec2771-unknown_filename.13-6e755c.png" alt="unknown_filename.13"><br>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-c0a44b5a6e54ede043bb2545918e3fb8-unknown_filename.14-c40e99.png" alt="unknown_filename.14"><br>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。<br>当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 插入排序，a表示数组，n表示数组大小</span><br><span class="hljs-comment">//int[] a = &#123;5,4,6,1,3,2&#125;;</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-comment">//待插入元素</span><br>            <span class="hljs-type">int</span> value = a[i];<br>            <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 查找插入的位置</span><br>            <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (a[j] &gt; value) &#123;<span class="hljs-comment">//5&gt;4</span><br>                    <span class="hljs-comment">// 4的位置改成5,数据移动，将大于temp的往后移动一位</span><br>                    a[j + <span class="hljs-number">1</span>] = a[j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            a[j + <span class="hljs-number">1</span>] = value; <span class="hljs-comment">// 插入数据</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</strong><br>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：冒泡排序中数据的交换操作：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">冒泡排序中数据的交换操作：<br>if (a<span class="hljs-comment">[j]</span> &gt; a<span class="hljs-comment">[j+1]</span>) &#123; // 交换<br>   int tmp = a<span class="hljs-comment">[j]</span>;<br>   a<span class="hljs-comment">[j]</span> = a<span class="hljs-comment">[j+1]</span>;<br>   a<span class="hljs-comment">[j+1]</span> = tmp;<br>   flag = true;<br>&#125;<br><br>插入排序中数据的移动操作：<br>if (a<span class="hljs-comment">[j]</span> &gt; value) &#123;<br>  a<span class="hljs-comment">[j+1]</span> = a<span class="hljs-comment">[j]</span>;  // 数据移动<br>&#125; else &#123;<br>  break;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3* K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><p><strong>基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止</strong><br>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-94687aaf1caac16dc5a797c2c46aa17a-unknown_filename.15-fecc40.png" alt="unknown_filename.15"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-922ca6645fa9e501b2cecd88624323b8-unknown_filename.16-dfd58c.jpeg" alt="unknown_filename.16"></p><p>那选择排序是稳定的排序算法吗？<br>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> selectSort(<span class="hljs-built_in">int</span>[] <span class="hljs-built_in">array</span>) &#123;<br>    <span class="hljs-built_in">int</span> min;<br>    <span class="hljs-built_in">int</span> tmp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.length; i++) &#123;<br>        min = <span class="hljs-built_in">array</span>[i];<br>        <span class="hljs-comment">//里面for第一次出来0，并且排在最前面，然后从i=1开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &lt; <span class="hljs-built_in">array</span>.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[j] &lt; min) &#123;<br>                min = <span class="hljs-built_in">array</span>[j];<span class="hljs-comment">//记录最小值  3</span><br>                tmp = <span class="hljs-built_in">array</span>[i];<span class="hljs-comment">//9</span><br>                <span class="hljs-built_in">array</span>[i] = min;<span class="hljs-comment">//3</span><br>                <span class="hljs-built_in">array</span>[j] = tmp;<span class="hljs-comment">//9</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : <span class="hljs-built_in">array</span>) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n2)，比较高，适合小规模数据的排序。今天，我讲两种时间复杂度为 <strong>O(nlogn)</strong> 的排序算法，归并排序和快速排序。这两种排序算法适合大规模的数据排序</p><p>稳定，但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。<br>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。</p><h4 id="归并排序的原理：分治法"><a href="#归并排序的原理：分治法" class="headerlink" title="归并排序的原理：分治法"></a>归并排序的原理：分治法</h4><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</p><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-52ad18a770a87d06b0a39105fc4ac5b0-unknown_filename.17-3bdc26.png" alt="unknown_filename.17"></p><p>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，<strong>将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</strong><br>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p><p><strong>分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突</strong>。</p><h4 id="如何用递归代码来实现归并排序"><a href="#如何用递归代码来实现归并排序" class="headerlink" title="如何用递归代码来实现归并排序"></a>如何用递归代码来实现归并排序</h4><p>写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">递推公式：<br><span class="hljs-function"><span class="hljs-title">merge_sort</span><span class="hljs-params">(p…r)</span></span> = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge_sort</span>(p…q), <span class="hljs-built_in">merge_sort</span>(q+<span class="hljs-number">1</span>…r))<br><br>终止条件：<br><span class="hljs-selector-tag">p</span> &gt;= r 不用再继续分解<br><br></code></pre></td></tr></table></figure><p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)&#x2F;2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            mergeSort(a, left, middle);<span class="hljs-comment">//左边归并排序，使得左子序列有序</span><br>            mergeSort(a, middle + <span class="hljs-number">1</span>, right);<span class="hljs-comment">//右边归并排序，使得右子序列有序</span><br>            merge(a, left, middle, right);<span class="hljs-comment">//将两个有序子数组合并操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> middle, <span class="hljs-type">int</span> right)</span> &#123;<span class="hljs-comment">//left0,mid0,right1</span><br>        <span class="hljs-comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br>        <span class="hljs-type">int</span>[] tmpArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightStart</span> <span class="hljs-operator">=</span> middle + <span class="hljs-number">1</span>;<span class="hljs-comment">//右序列指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftStart</span> <span class="hljs-operator">=</span> left;<span class="hljs-comment">//左序列指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> left;<span class="hljs-comment">//临时数组指针</span><br>        <span class="hljs-comment">//比较两个小数组相应下标位置的数组大小，小的先放进新数组</span><br>        <span class="hljs-keyword">while</span> (left &lt;= middle &amp;&amp; rightStart &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (a[left] &lt;= a[rightStart]) &#123;<br>                <span class="hljs-comment">//相当于tmpArray[third]=a[left];third++;left++三步合一步</span><br>                tmpArray[temp++] = a[left++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmpArray[temp++] = a[rightStart++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果左边还有数据需要拷贝，把左边数组剩下的拷贝到新数组</span><br>        <span class="hljs-keyword">while</span> (left &lt;= middle) &#123;<br>            tmpArray[temp++] = a[left++];<br>        &#125;<br>        <span class="hljs-comment">//如果右边还有数据......</span><br>        <span class="hljs-keyword">while</span> (rightStart &lt;= right) &#123;<br>            tmpArray[temp++] = a[rightStart++];<br>        &#125;<br>        <span class="hljs-comment">//将temp中的元素全部拷贝到原数组中</span><br>        <span class="hljs-keyword">while</span> (leftStart &lt;= right) &#123;<br>            a[leftStart] = tmpArray[leftStart++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MergeSort</span> <span class="hljs-variable">mergeSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MergeSort</span>();<br>        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>        mergeSort.mergeSort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : a) &#123;<br>            System.out.print(<span class="hljs-string">&quot; &quot;</span> + n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><p>快排是一种原地、不稳定的排序算法。<br>快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。<br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。利用分治法可将快速排序的分为三步：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-3da7dab2f05b2409df3272d033e36baa-unknown_filename.18-993f6a.png" alt="unknown_filename.18"></li></ol><p><strong>快速排序和归并排序对比</strong><br>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a.length &gt; <span class="hljs-number">0</span>) &#123;<br>            quickSort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 快速排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low  低位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 高位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> getMiddle(a, low, high);<br>            <span class="hljs-comment">//递归排比第一个基数小的数和大的数</span><br>            quickSort(a, <span class="hljs-number">0</span>, middle - <span class="hljs-number">1</span>);<br>            quickSort(a, middle + <span class="hljs-number">1</span>, high);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[low];<span class="hljs-comment">//基准元素</span><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<span class="hljs-comment">//第二次3，9</span><br>            <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= temp) &#123;<br>                high--;<br>            &#125;<br>            a[low] = a[high];<span class="hljs-comment">//将比基数小的数放到基数前面///用个数字想一下就明白了</span><br>            <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= temp) &#123;<br>                low++;<br>            &#125;<br>            a[high] = a[low];<span class="hljs-comment">//将比基数大的数放到基数后面</span><br>        &#125;<br>        a[low] = temp;<span class="hljs-comment">//插入到排序后正确的位置，low就是基数应该在的位置</span><br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="O-n-时间复杂度内求无序数组中的第-K-大元素"><a href="#O-n-时间复杂度内求无序数组中的第-K-大元素" class="headerlink" title="O(n) 时间复杂度内求无序数组中的第 K 大元素"></a>O(n) 时间复杂度内求无序数组中的第 K 大元素</h4><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。<br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p><p>如果 p+1&#x3D;K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-9af7c74d3b81e2ee04cf6f020f0a7ebd-unknown_filename.19-ccd461.png" alt="unknown_filename.19"></p><pre><code class="hljs">int kthLargest = leetCode.findKthLargest(new int[]&#123;4, 2, 5, 12, 3&#125;, 3);//倒数class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;        int len = nums.length;        int left = 0, right = len - 1;        int pivot = 0;        while (len - k != (pivot = partition(nums, left, right))) &#123;        //4所在的问题就是2，那就找到了        //第k大应该在第K位，找每个数字应该在的位置，正好第0个4就是第K位，就找到了            if (pivot &lt; len - k) &#123;//在后面                left = pivot + 1;                right = len - 1;            &#125; else &#123;                left = 0;                right = pivot - 1;            &#125;        &#125;        return nums[pivot];    &#125;    private int partition(int[] nums, int left, int right) &#123;        int pivot = nums[left];        while (left &lt; right) &#123;            while (left &lt; right &amp;&amp; nums[right] &gt;= pivot)                right--;            nums[left] = nums[right];            while (left &lt; right &amp;&amp; nums[left] &lt;= pivot)                left++;            nums[right] = nums[left];        &#125;        nums[left] = pivot;        return left;    &#125;&#125;</code></pre><p><strong>为什么上述解决思路的时间复杂度是 O(n)？</strong><br>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n&#x2F;2 的数组执行分区操作，需要遍历 n&#x2F;2 个元素。依次类推，分区遍历元素的个数分别为、n&#x2F;2、n&#x2F;4、n&#x2F;8、n&#x2F;16.……直到区间缩小为 1。<br>如果我们把每次分区遍历的元素个数加起来，就是：n+n&#x2F;2+n&#x2F;4+n&#x2F;8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p><h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><p>时间复杂度是 O(n) 的排序算法：桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作<strong>线性排序（Linear sort）</strong>。之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><p>按照惯例，我先给你出一道思考题：如何根据年龄给 100 万用户排序？ 你可能会说，我用上一节课讲的归并、快排就可以搞定啊！是的，它们也可以完成功能，但是时间复杂度最低也是 O(nlogn)。有没有更快的排序方法呢？让我们一起进入今天的内容！</p><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-a966114c395188070f806c2b8404f080-unknown_filename.20-6633a7.png" alt="unknown_filename.20"></p><p><a href="https://blog.csdn.net/afei__/article/details/82965834">https://blog.csdn.net/afei__/article/details/82965834</a></p><p><strong>桶排序的时间复杂度为什么是 O(n) 呢</strong><br>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k&#x3D;n&#x2F;m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k&#x3D;n&#x2F;m，所以整个桶排序的时间复杂度就是 O(n* log(n&#x2F;m))。当桶的个数 m 接近数据个数 n 时，log(n&#x2F;m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong><br>要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。<br><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><h3 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h3><p>我个人觉得，计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。<br>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？<br>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><p>计数排序的算法思想就是这么简单，<strong>跟桶排序非常类似，只是桶的大小粒度不一样</strong></p><p><a href="https://blog.csdn.net/csdnnews/article/details/8300577">漫画：什么是计数排序？</a><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-618f5ab76e27f0e944c2e5030cf58ee6-unknown_filename.35-fc61a8.png" alt="unknown_filename.35"></p><pre><code class="hljs">   public void countSort0(int[] array) &#123;        //找出最大值        int max = array[0];        for (int i = 1; i &lt; array.length; i++) &#123;            if (array[i] &gt; max) &#123;                max = array[i];            &#125;        &#125;//o(n)        //开辟内存空间，存储每个整数出现的次数        int[] counts = new int[1 + max];        //统计每个整数出现的次数        for (int i = 0; i &lt; array.length; i++) &#123;            counts[array[i]]++;        &#125;//o(n)        //根据整数的出现次数，对整数进行排序        int index = 0;        for (int i = 0; i &lt; counts.length; i++) &#123;            while (counts[i]-- &gt; 0) &#123;                array[index++] = i;            &#125;        &#125;//o(n)    &#125;</code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-3eda38f0cafd5a7b370ff5c556601822-unknown_filename.34-c322ef.png" alt="unknown_filename.34"></p><h3 id="如何实现一个通用的、高性能的排序函数？"><a href="#如何实现一个通用的、高性能的排序函数？" class="headerlink" title="如何实现一个通用的、高性能的排序函数？"></a>如何实现一个通用的、高性能的排序函数？</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.resources/2023/09/15/17-55-49-365392b696aa0ea1bf2b656b99e76b8b-unknown_filename.21-f48b53.png" alt="unknown_filename.21"><br>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。<br>Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。</p><p>我们知道，快排在最坏情况下的时间复杂度是 O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？</p><p>归并排序并不是原地排序算法，空间复杂度是 O(n)。所以，粗略点、夸张点讲，<strong>如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间</strong>，空间耗费就翻倍了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7-贪心、回溯、动态规划</title>
    <link href="/2025/12/e0e246b471a8.html"/>
    <url>/2025/12/e0e246b471a8.html</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。假设你女朋友的购物车中有 n 个（n&gt;100）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元），这样就可以极大限度地“薅羊毛”。作为程序员的你，能不能编个代码来帮她搞定呢？</p><p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。<br>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，<strong>后面阶段的状态可以通过前面阶段的状态推导出来</strong>。<br><strong>有重复子问题</strong></p><p><a href="https://segmentfault.com/a/1190000015944750">javascript - 动态规划入门（以爬楼梯为例） - 个人文章 - SegmentFault 思否</a></p><h2 id="方法二：备忘录算法"><a href="#方法二：备忘录算法" class="headerlink" title="方法二：备忘录算法"></a>方法二：备忘录算法</h2><blockquote><p>const map &#x3D; new Map();<br>function getWays(n) {</p><pre><code class="hljs">if (n &lt; 1) return 0;if (n == 1) return 1;if (n == 2) return 2;if (map.has(n)) &#123;    return map.get(n);&#125;const value = getWays(n-1) + getWays(n-2);map.set(n, value);return value; </code></pre><p>}</p></blockquote><p>因为map里最终会存放n-2个键值对，所以空间复杂度为<strong>O(n)</strong>,时间复杂度也为<strong>O(n)</strong></p><p>继续想一想这就是最优的解决方案了吗？</p><p>我们回到一开始的思路，我们是假定前面的楼梯已经走完，只考虑最后一步，所以才得出来f(n) &#x3D; f(n-1) + f(n-2)的递归式，这是一个置顶向下求解的式子<br>一般来说，按照正常的思路应该是一步一步往上走，应该是自底向上去求解才比较符合正常人的思维，我们来看看行不行的通</p><p><img src="https://segmentfault.com/img/bVbe23m?w=1258&h=226" alt="图片描述" title="图片描述"><br>这是一开始走的一个和两个楼梯的走法数,即之前说的<strong>初始状态</strong></p><p><img src="https://segmentfault.com/img/bVbe23E?w=1262&h=226" alt="图片描述" title="图片描述"><br>这是进行了一次迭代得出了3个楼梯的走法，f(3)只依赖于f(1) 和 f(2)</p><p>继续看下一步<br><img src="https://segmentfault.com/img/bVbe23Z?w=1270&h=226" alt="图片描述" title="图片描述"><br>这里又进行了一次迭代得出了4个楼梯的走法，f(4)只依赖于f(2) 和 f(3)</p><p>我们发现每次迭代只需要前两次迭代的数据，不用像备忘录一样去保存所有子状态的数据</p><h2 id="方法三：动态规划求解"><a href="#方法三：动态规划求解" class="headerlink" title="方法三：动态规划求解"></a>方法三：动态规划求解</h2><blockquote><p>function getWays(n) {</p><pre><code class="hljs">if (n &lt; 1) return 0;if (n == 1) return 1;if (n == 2) return 2;// a保存倒数第二个子状态数据，b保存倒数第一个子状态数据， temp 保存当前状态的数据let a = 1, b = 2;let temp = a + b;for (let i = 3; i &lt;= n; i++) &#123;    temp = a + b;    a = b;    b = temp; &#125;return temp; </code></pre><p>}</p></blockquote><p>这是我们可以再看看当前的时间复杂度和空间复杂度<br>当前时间复杂度仍为<strong>O(n)<strong>，但空间复杂度降为</strong>O(1)</strong><br>这就是理想的结果</p><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p>对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p><p>规律是不是不好找？那我们就举个例子、画个图看看。我们假设背包的最大承载重量是 9。我们有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3。如果我们把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%B4%AA%E5%BF%83%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.resources/2023/09/15/18-49-25-a08ed0f86c19774cf54b9cb123cab1a3-unknown_filename.2-d5ad89.png" alt="unknown_filename.2"><br>递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。<br><strong>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包</strong><br>从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxW中</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">5</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 备忘录，默认值false</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mem[i][cw]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 重复状态</span><br>  mem[i][cw] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 记录(i, cw)这个状态</span><br>  <span class="hljs-built_in">f</span>(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    <span class="hljs-built_in">f</span>(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>贪心、分治、回溯和动态规划<br>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，<strong>动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题</strong>。</p><p>然后，我讲了两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p><hr><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。最小生成树算法和最短路径算法我们后面会讲到，所以我们今天讲下霍夫曼编码，看看它是如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。</p><p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%B4%AA%E5%BF%83%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.resources/2023/09/15/18-49-25-538572391b17bb53f6f5f4012247cc97-unknown_filename.1-d3c267.png" alt="unknown_filename.1"><br>实际上，这个问题很简单，我估计你一下子就能想出来，没错，我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。</p><p>第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p><p>类比到刚刚的例子，限制值就是重量不能超过 100kg，期望值就是物品的总价值。这组数据就是 5 种豆子。我们从中选出一部分，满足重量不超过 100kg，并且总价值最大。</p><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法的核心就是试了再比，不行回退的思路。<br>回溯相当于穷举，使用合理的剪枝技巧减少穷举的数量</p><h3 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h3><p>我们有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。你可以看我画的图，第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%B4%AA%E5%BF%83%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.resources/2023/09/15/18-49-25-ab642f1824164aab1f95396480b13b2f-unknown_filename-b24ce5.png" alt="unknown_filename"><br>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。</p><pre><code class="hljs">  int[] result = new int[8];//全局或成员变量,下标表示行,值表示queen存储在哪一列    public void cal8queens(int row) &#123; // 调用方式：cal8queens(0);        if (row == 8) &#123; // 8个棋子都放置好了，打印结果            printQueens(result);            return; // 8行棋子都放好了，已经没法再往下递归了，所以就return        &#125;        for (int column = 0; column &lt; 8; ++column) &#123; // 每一行都有8中放法            if (isOk(row, column)) &#123; // 有些放法不满足要求                result[row] = column; // 第row行的棋子放到了column列                cal8queens(row + 1); // 考察下一行            &#125;        &#125;    &#125;    private boolean isOk(int row, int column) &#123;//判断row行column列放置是否合适        int leftup = column - 1, rightup = column + 1;        for (int i = row - 1; i &gt;= 0; --i) &#123; // 逐行往上考察每一行            if (result[i] == column) return false; // 第i行的column列有棋子吗？            if (leftup &gt;= 0) &#123; // 考察左上对角线：第i行leftup列有棋子吗？                if (result[i] == leftup) return false;            &#125;            if (rightup &lt; 8) &#123; // 考察右上对角线：第i行rightup列有棋子吗？                if (result[i] == rightup) return false;            &#125;            --leftup;            ++rightup;        &#125;        return true;    &#125;    private void printQueens(int[] result) &#123; // 打印出一个二维矩阵        for (int row = 0; row &lt; 8; ++row) &#123;            for (int column = 0; column &lt; 8; ++column) &#123;                if (result[row] == column) System.out.print(&quot;Q &quot;);                else System.out.print(&quot;* &quot;);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;</code></pre><h4 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h4><ol><li>穷举法的基本思想是根据题目的部分条件确定答案的大致范围，并在此范围内对所有可能的情况逐一验证，直到全部情况验证完毕。若某个情况验证符合题目的全部条件，则为本问题的一个解；若全部情况验证后都不符合题目的全部条件，则本题无解。穷举法也称为枚举法。</li></ol><ul><li>穷举法是一种针对于密码的破译方法。这种方法很像数学上的“完全归纳法”并在密码破译方面得到了广泛的应用。简单来说就是将密码进行逐个推算直到找出真正的密码为止。比如一个四位并且全部由数字组成其密码共有10000种组合，也就是说最多我们会尝试9999次才能找到真正的密码。利用这种方法我们可以运用计算机来进行逐个推算，也就是说用我们破解任何一个密码也都只是一个时间问题。</li></ul><h3 id="0-1-背包-1"><a href="#0-1-背包-1" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p><a href="https://time.geekbang.org/column/article/74287">链接</a><br>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？<br><strong>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</strong></p><p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。你可以看我写的具体的代码。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl">   public <span class="hljs-type">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">//存储背包中物品总重量的最大值</span><br><br>    <span class="hljs-comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span><br><span class="hljs-comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span><br><span class="hljs-comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span><br><span class="hljs-comment">// f(0, 0, a, 10, 100)</span><br>    public <span class="hljs-type">void</span> f(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> <span class="hljs-keyword">cw</span>, <span class="hljs-type">int</span>[] items, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> w) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">cw</span> == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">cw</span> &gt; maxW) maxW = <span class="hljs-keyword">cw</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        f(i + <span class="hljs-number">1</span>, <span class="hljs-keyword">cw</span>, items, n, w);<span class="hljs-comment">//当前物品不装进背包，第 11 行的递归调用表示不选择当前物品，直接考虑下一个（第 i+1 个），故 cw 不更新</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">cw</span> + items[i] &lt;= w) &#123;<span class="hljs-comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span><br>            f(i + <span class="hljs-number">1</span>, <span class="hljs-keyword">cw</span> + items[i], items, n, w);<span class="hljs-comment">//当前物品装进背包</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>0-1背包问题理解：假设三个物品，每个物品在考虑时有两种选择，1-放进包，0-不放。11行代码表示不放进包里。13行代码表示放进包里。三个物品遍历过程如下：<br>0 0 0 update maxW<br>0 0 1 update maxW<br>0 1 0 update maxW<br>0 1 1 update maxW<br>1 0 0 update maxW<br>1 0 1 update maxW<br>1 1 0 update maxW<br>1 1 1 update maxW</p><p><strong>看看下面的图</strong><br>算法复杂度2^n</p><p>回溯算法本质上就是枚举，优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5-链表题</title>
    <link href="/2025/12/f45f5449b6bd.html"/>
    <url>/2025/12/f45f5449b6bd.html</url>
    
    <content type="html"><![CDATA[<h1 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h1><p>常见的解决方法分为递归和迭代两种<br>我们知道迭代是从前往后依次处理，直到循环到链尾；而递归恰恰相反，首先一直迭代到链尾也就是递归基判断的准则，然后再逐层返回处理到开头。总结来说，<strong>链表翻转操作的顺序对于迭代来说是从链头往链尾，而对于递归是从链尾往链头</strong>。下面我会用详细的图文来剖析其中实现的细节。</p><p>递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。所以递归操作链表可以作为对递归算法的练习或者拿去和小伙伴装逼，但是考虑效率的话还是使用迭代算法更好。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代的方式是从链头开始处理，如下图给定一个存放5个数的链表。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-21-18-45-865347eb117077a2528dd445694087cf-20231121184546-f11c7e.png" alt="image.png"><br>首先对于链表设置两个指针：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-21-18-45-30abb3ae7d98ae023941b9698290dcab-20231121184554-f59c39.png" alt="image.png"></p><p>然后依次将旧链表上每一项添加在新链表的后面，然后新链表的头指针 NewH 移向新的链表头，如下图所示。此处需要注意，不可以上来立即将上图中 P-&gt;next 直接指向 NewH，<em>这样存放2的地址就会被丢弃</em>，后续链表保存的数据也随之无法访问。而是应该设置一个临时指针 tmp，先暂时指向 P-&gt;next 指向的地址空间，保存原链表后续数据。然后再让 P-&gt;next 指向 NewH，最后 P&#x3D;tmp 就可以取回原链表的数据了，所有循环访问也可以继续展开下去。</p><p>红线就是：p.next &#x3D; newHead;<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-14-19-2c1dd7519cf123d8d002c96281252501-20231122141941-b190ae.png" alt="image.png"></p><p>指针继续向后移动，直到P指针指向NULL停止迭代。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-21-18-46-cc7797813147647b73e7eb8ce0975950-20231121184613-dac2cf.png" alt="image.png"></p><p>最后一步：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-21-18-46-e256b1032b0a267f9acf93ff4a5f81e5-20231121184622-0bc08c.png" alt="image.png"></p><h3 id="非递归实现的程序"><a href="#非递归实现的程序" class="headerlink" title="非递归实现的程序"></a>非递归实现的程序</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;  <br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-comment">//链表为空或者仅1个数直接返回  </span><br>        <span class="hljs-keyword">return</span> head;  <br>    ListNode p = head, <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;         <span class="hljs-comment">//一直迭代到链尾  </span><br>        ListNode tmp = p.next;  <span class="hljs-comment">//暂存p下一个地址，防止变化指针指向后找不到后续的数  </span><br>        p.next = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;       <span class="hljs-comment">//p-&gt;next指向前一个空间，和下面换了一下位置  </span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = p;           <span class="hljs-comment">//新链表的头移动到p，扩长一步链表  </span><br>        p = tmp;              <span class="hljs-comment">//p指向原始链表p指向的下一个空间  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>4的 next 5的 next 指向4，4指向 null </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode reverseList(ListNode h) &#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span> || h.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-comment">//链表为空直接返回，而head.next为空是递归基</span><br>        <span class="hljs-keyword">return</span> h;<br>    ListNode newHead = reverseList(h.<span class="hljs-keyword">next</span>); <span class="hljs-comment">//一直循环到链尾 </span><br>    h.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = h;                     <span class="hljs-comment">//翻转链表的指向</span><br>    h.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;  <span class="hljs-comment">//记得赋值NULL，防止链表错乱，避免两个节点互为next死循环</span><br>    <span class="hljs-keyword">return</span> newHead;     <span class="hljs-comment">//不论当前节点是啥，都返回原本链表的最后一个节点-》也就是反转后的头节点</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>前面非递归方式是从前面数1开始往后依次处理，而递归方式则恰恰相反，<em>它先循环找到最后面指向的数5，然后从5开始处理依次翻转整个链表</em>。</p><h3 id="第一种解释"><a href="#第一种解释" class="headerlink" title="第一种解释"></a>第一种解释</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-21-20b2e5b5b1b435c1a9639e274a2d74a4-20231122152123-8e308d.png" alt="image.png|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-20-ee94dd95712d3faec50a2783bcda0ec2-20231122152014-35fb78.png" alt="image.png|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-20-92dad673470bfdc94254e1bccadacc7e-20231122152023-67e065.png" alt="image.png|600"></p><h3 id="第二种解释"><a href="#第二种解释" class="headerlink" title="第二种解释"></a>第二种解释</h3><p>首先指针H迭代到底如下图所示，并且设置一个新的指针作为翻转后的链表的头。由于整个链表翻转之后的头就是最后一个数，所以整个过程NewH指针一直指向存放5的地址空间。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-17-9b8ccfc65d9182a1d7bc900e6449623e-20231122151749-4d0dd0.png" alt="image.png"></p><p>然后 H 指针逐层返回的时候依次做下图的处理，将 H 指向的地址赋值给 H-&gt;next-&gt;next 指针，*4的 next 5的 next 指向4，4指向 null *</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-18-6ba1486d5d5e8b2c1e426050a24da191-20231122151832-5ab21e.png" alt="image.png"><br>　　<br>继续返回操作：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-18-ce7c0aae2245bf050448f8e9e30d8208-20231122151852-dd774a.png" alt="image.png"><br>　　<br>上图第一次如果没有将存放4空间的 next 指针赋值指向 NULL，第二次 H-&gt;next-&gt;next&#x3D;H，就会将存放5的地址空间覆盖为3，这样链表一切都大乱了。接着逐层返回下去，直到对存放1的地址空间处理。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-19-25245e1b97695e02e8f57c9d80176a6e-20231122151911-b9be7e.png" alt="image.png|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-19-ba164310bfd93cf155122b4d93cd6939-20231122151933-6ee83e.png" alt="image.png|600"></p><h3 id="第三种解释"><a href="#第三种解释" class="headerlink" title="第三种解释"></a>第三种解释</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-22-c9e23e64e89f9d91ca80939c839426b2-20231122152226-1c102b.png" alt="image.png|600"></p><h1 id="二、反转链表前-N-个节点"><a href="#二、反转链表前-N-个节点" class="headerlink" title="二、反转链表前 N 个节点"></a>二、反转链表前 N 个节点</h1><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 将链表的前 <span class="hljs-built_in">n</span> 个节点反转（<span class="hljs-built_in">n</span> &lt;= 链表长度）<br>ListNode reverseN(ListNode head, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-22-15-37-e2f7222f4525abaf783e9bd894a5cb42-20231122153726-50d605.png" alt="image.png|600"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ListNode successor = null; // 后驱节点<br><br>// 反转以<span class="hljs-built_in"> head</span> 为起点的 n 个节点，返回新的头结点<br>ListNode reverseN(ListNode<span class="hljs-built_in"> head</span>, int n) &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        // 记录第 n + <span class="hljs-number">1</span> 个节点<br>        successor =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>    &#125;<br>    // 以<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> 为起点，需要反转前 n - <span class="hljs-number">1</span> 个节点<br>    ListNode<span class="hljs-built_in"> last</span> = reverseN<span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>, n - <span class="hljs-number">1</span>);<br><br>   <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>    // 让反转之后的<span class="hljs-built_in"> head</span> 节点和后面的节点连起来<br>   <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = successor;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> last</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、反转链表的一部分"><a href="#三、反转链表的一部分" class="headerlink" title="三、反转链表的一部分"></a>三、反转链表的一部分</h1><p><a href="https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/#%E4%B8%80%E3%80%81%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8">递归魔法：反转单链表 | labuladong 的算法笔记</a><br><a href="https://labuladong.online/algo/data-structure/reverse-nodes-in-k-group/#%E4%B8%80%E3%80%81%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98">如何 K 个一组反转链表 | labuladong 的算法笔记</a></p><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>可以模拟两个数组的合并，就是归并排序，比较第一个的大小，将小的放到结果链表中，然后接着比较，直到两个链表全部比较结束<br>如果有一个链表为空，就直接把另一个链表的剩余元素全部加到结果链表中即可，然后退出循环，具体步骤如图所示<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-23-10-41-a04a9d2a46335147f01e947c70fec078-20231123104153-84a384.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists2</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;  <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">list3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);  <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr1</span> <span class="hljs-operator">=</span> list1;  <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr2</span> <span class="hljs-operator">=</span> list2;  <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr3</span> <span class="hljs-operator">=</span> list3;  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>        <span class="hljs-keyword">if</span> (ptr1.next == <span class="hljs-literal">null</span>) &#123;  <br>            ptr3.next = ptr2;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">if</span> (ptr2.next == <span class="hljs-literal">null</span>) &#123;  <br>            ptr3.next = ptr2;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;  <br>            ptr3.next = ptr1;  <br>            ptr3 = ptr3.next;  <br>            ptr1 = ptr1.next;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            ptr3.next = ptr2;  <br>            ptr3 = ptr3.next;  <br>            ptr2 = ptr2.next;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> list3;<br></code></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>第二种解法其实主要的实现方式和上述的也一样，只不过是实现的方式不一致，第一种方法需要新开辟一个空间，用于存放结果。<br>其实在每步骤的操作都是一样的，将首位相比较，小的链接到下一个元素上，所以就可以采用递归的方法，具体如图所示</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-23-10-39-9f474b85e0ad58e0445e1638a96e732a-20231123103932-2745bb.png" alt="image.png"></p><p>链表放入较小节点，不动，继续设置下一个, <strong>归并排序的递归思想</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">Merge</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<span class="hljs-comment">//注意鲁棒性  </span><br>    <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;  <br>    <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;  <span class="hljs-comment">//利用归并排序的递归思想，将两个链表的较小节点链接起来  </span><br>        list1.next = Merge(list1.next, list2);  <span class="hljs-comment">//如果list1当前节点小于list2当前节点，链表放入较小节点(不动，继续设置下一个)并将索引往后一个节点，与list2的原较大节点继续比较  </span><br>        <span class="hljs-keyword">return</span> list1;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        list2.next = Merge(list2.next, list1);  <span class="hljs-comment">//如果list2当前节点小于list1当前节点，链表放入较小节点并将索引往后一个节点，与list1的原较大节点继续比较  </span><br>        <span class="hljs-keyword">return</span> list2;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 . 相交链表"></a>160 . 相交链表</h1><p>两个链表的第一个公共节点</p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-26-11-15-807270a079915808a01d4b7b026230dd-20240226111535-515434.png" alt="image.png|600"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p>空间复杂度 O (1) 时间复杂度为 O (n) O </p><p>这里使用图解的方式，解释比较巧妙的一种实现。</p><p>根据题目意思<br>如果两个链表相交，那么相交点之后的长度是相同的</p><p>我们需要做的事情是，让两个链表从<em>同距离末尾同等距离的位置开始遍历</em>。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p><p>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历<br>如果 pA 到了末尾，则 pA &#x3D; headB 继续遍历<br>如果 pB 到了末尾，则 pB &#x3D; headA 继续遍历<br>比较长的链表指针指向较短链表 head 时，长度差就消除了<br>如此，只需要将最短链表遍历两次即可找到位置<br>听着可能有点绕，看图最直观，链表的题目最适合看图了</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-23-16-55-1415ba7bad4e481aec0dc30e6a4a1f33-20240223165510-bc6d8b.png" alt="image.png|600"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>        pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他理解"><a href="#其他理解" class="headerlink" title="其他理解"></a>其他理解</h2><p>pA 走过的路径为 A 链+B 链<br>pB走过的路径为B链+A链<br>pA 和 pB 走过的长度都相同，都是 A 链和 B 链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。</p><p>两个人速度一致，走过的路程一致。那么肯定会同一个时间点到达终点</p><p>其实就是<em>让2个指针走一样的距离，消除步行差</em>，那就一定可以一起走到相交点</p><p>若相交，链表 A： a+c, 链表 B : b+c.<br>a+c+b+c &#x3D; b+c+a+c 。则会在公共处 c 起点相遇。若不相交，a +b &#x3D; b+a 。因此相遇处是 NULL</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>先获得两个链表的长度，然后在较长的链表上先走若干步 (两链表长度之差)，接着同时在两个链表上遍历，找到的第一个相同的节点就是他们的第一个公共节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 52.两个链表的第一个公共节点(2)  </span><br><span class="hljs-comment"> * 长链表先走n步，第一个相同的就是公共节点  </span><br><span class="hljs-comment"> * 时间复杂度（m+n）空间复杂度（不需要栈了，小）  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findFirstCommonNode2</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;  <br>    <span class="hljs-comment">//统计链表A和链表B的长度  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> length(headA), lenB = length(headB);  <br>  <br>    <span class="hljs-comment">//如果节点长度不一样，节点多的先走，直到他们的长度一样为止  </span><br>    <span class="hljs-keyword">while</span> (lenA != lenB) &#123;  <br>        <span class="hljs-keyword">if</span> (lenA &gt; lenB) &#123;  <br>            <span class="hljs-comment">//如果链表A长，那么链表A先走  </span><br>            headA = headA.next;  <br>            lenA--;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//如果链表B长，那么链表B先走  </span><br>            headB = headB.next;  <br>            lenB--;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//然后开始比较，如果他俩不相等就一直往下走  </span><br>    <span class="hljs-keyword">while</span> (headA != headB) &#123;  <br>        headA = headA.next;  <br>        headB = headB.next;  <br>    &#125;  <br>    <span class="hljs-comment">//走到最后，最终会有两种可能，一种是headA为空，  </span><br>    <span class="hljs-comment">//也就是说他们俩不相交。还有一种可能就是headA  </span><br>    <span class="hljs-comment">//不为空，也就是说headA就是他们的交点  </span><br>    <span class="hljs-keyword">return</span> headA;  <br>&#125;<br><br><span class="hljs-comment">//统计链表的长度  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">(ListNode node)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;  <br>        node = node.next;  <br>        length++;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> length;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 234、回文链表 head = [1,2,2,1]  </span><br><span class="hljs-comment"> * 1.复制链表值到数组列表中。  </span><br><span class="hljs-comment"> * 2.使用双指针法判断是否为回文。  </span><br><span class="hljs-comment"> * 总的时间复杂度：O(2n)=O(n)  </span><br><span class="hljs-comment"> * 空间复杂度：O(n)  </span><br><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;  <br>    List&lt;Integer&gt; vals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();  <br>  <br>    <span class="hljs-comment">// 将链表的值复制到数组中  </span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">null</span>) &#123;  <br>        vals.add(currentNode.val);  <br>        currentNode = currentNode.next;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 使用双指针判断是否回文  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">back</span> <span class="hljs-operator">=</span> vals.size() - <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">while</span> (front &lt; back) &#123;  <br>        <span class="hljs-keyword">if</span> (!vals.get(front).equals(vals.get(back))) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        &#125;  <br>        front++;  <br>        back--;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4-二叉树</title>
    <link href="/2025/12/49ca49d8c5cf.html"/>
    <url>/2025/12/49ca49d8c5cf.html</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>树是无向、连通的无环图。</strong></p><blockquote><p>二叉树的提出其实主要就是为了提高查找效率，比如我们常用的 HashMap 在处理哈希冲突严重时，拉链过长导致查找效率降低，就引入了红黑树。<br>我们知道，二分查找可以缩短查找的时间，但是它要求查找的数据必须是有序的。每次查找、操作时都要维护一个有序的数据集，于是有了二叉查找树这个概念。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>二叉树即是每个节点最多包含左子节点与右子节点这两个节点的树形数据结构</li><li>满二叉树: 树中的每个节点仅包含 0 或 2 个节点。</li><li>完美二叉树（Perfect Binary Tree）: 二叉树中的每个叶节点都拥有两个子节点，并且具有相同的高度。</li><li><em>完全二叉树</em>: 除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点</li><li>Binary Search Tree（查找二叉树）</li></ol><p>查找二叉树（BST）是一种特殊的二叉树，其任何节点中的值都会大于或者等于其左子树中存储的值并且小于或者等于其右子树中存储的值。</p><blockquote><p>二叉查找树好的情况下是O(logN)，最坏情况下是O(N)，查找最大的次数是二叉树的高度。比如：将一个数组{1,2,3,4}依次插入树的时候，有建立树与没建立树对于数据的增删查改已经没有了任何帮助，反而增添了维护的成本，所以有了平衡二叉树。</p></blockquote><ol start="6"><li>平衡二叉树（AVL）<br> 平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡（旋转）。因此它的定义如下：</li></ol><blockquote><p>平衡二叉树要么是一棵空树<br>要么保证左右子树的高度之差不大于 1<br>子树也必须是一颗平衡二叉树</p></blockquote><p>7.红黑树<br>红黑是平衡二叉树的一种<br>和AVl区别：avl插入、删除操作，为了保持平衡需要旋转。适合用于插入与删除次数比较少，但查找多的情况。</p><p>红黑树：相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。</p><h3 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h3><p>1.判断根节点是否为空<br>2.递归获取左子树的深度<br>3.递归获取右子树的深度<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-d82ca8831c6bbe2dfe2d044de0a6dde4-unknown_filename.8-193dc8.png" alt="unknown_filename.8"></p><p>讲一下这里的递归原理：当遍历到C和E时，左子树node.getLeftChild()和右子树node.getRightChild()返回0+1，此时深度为1，当到B和D时，B和D的深度都为1，此时返回1+1&#x3D;2，同理，一步一步往回退，直到左右子树遍历一遍得到左右子树的深度然后进行比较返回最大的值+1就是整棵树的深度。深度是2<br>那么求二叉树的所有节点的个数，递归原理与此相同。</p><p><strong>深度优先</strong>遍历的非递归的通用做法是<strong>采用栈。按深度</strong><br><strong>广度优先</strong>遍历的非递归的通用做法是<strong>采用队列。按层遍历</strong></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-26-17-00-668736023ca043396c940f27c32dfe5c-17-36-30-668736023ca043396c940f27c32dfe5c-unknown_filename.15-e22bf1-2d0d6f.png" alt="unknown_filename.15|600"><br>都是12345</p><p>二叉搜索树，按中序遍历 (左根右)时是有序的，每个元素都应该比下一个元素小。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">public void <span class="hljs-built_in">preOrder</span>(TreeNode root) &#123;<br>     if (root == null) &#123;<br>         return;<br>     &#125;<br>     System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.print</span>(root.val);<br>     <span class="hljs-built_in">preOrder</span>(root.left);<br>     <span class="hljs-built_in">preOrder</span>(root.right);<br> &#125;<br>    <br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/456af5480cee">非递归遍历</a></p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="高度、深度、层"><a href="#高度、深度、层" class="headerlink" title="高度、深度、层"></a>高度、深度、层</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-b2d628d2e2c9c72a272c81423fd1cf78-unknown_filename.5-30c9d3.png" alt="unknown_filename.5"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-9980d7c417ac55883bd7346741561c5a-unknown_filename.4-5bedd7.png" alt="unknown_filename.4"><br>“高度”这个概念，其实就是<code>从下往上度量</code>，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。<br>“深度”这个概念在生活中是<code>从上往下度量</code>的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。<br>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="如何表示一棵二叉树"><a href="#如何表示一棵二叉树" class="headerlink" title="如何表示一棵二叉树"></a>如何表示一棵二叉树</h4><p>一种是基于指针或者引用的二叉链式存储法<br>一种是基于数组的顺序存储法。<br><strong>链式存储法</strong><br>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。<strong>大部分二叉树代码都是通过这种结构来实现的</strong>。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-3366dcd99ebcb6946e18577cd3b274ae-unknown_filename.2-c5c983.png" alt="unknown_filename.2"></p><p>基于数组的<strong>顺序存储法</strong><br>把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-c14b4f66b44fdfeb4fe0502ae9b924c2-unknown_filename.6-6ba1d6.png" alt="unknown_filename.6"></p><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>前序遍历、中序遍历和后序遍历<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-419bef62a53c1b1fe1f68822e75f3ddf-unknown_filename.3-41863a.png" alt="unknown_filename.3"></p><p>写递归代码的关键，就是看能不能写出递推公式，而<strong>写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A</strong>。所以，我们可以把前、中、后序遍历的递推公式都写出来。</p><p><strong>二叉树遍历的时间复杂度</strong><br>从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p><h3 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h3><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。<br>叉查找树最大的特点就是，<strong>支持动态数据集合的快速插入、删除、查找操作</strong>。不需要有序</p><p><strong>1. 二叉查找树的查找操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span> &#123;<br>  <span class="hljs-keyword">private</span> Node tree;<br><br>  <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tree;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>2. 二叉查找树的插入操作</strong><br>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>  <span class="hljs-keyword">if</span> (tree == <span class="hljs-literal">null</span>) &#123;<br>    tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tree;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;<br>      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-literal">null</span>) &#123;<br>        p.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.right;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span><br>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-literal">null</span>) &#123;<br>        p.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.left;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>来源：<a href="https://time.geekbang.org/column/article/68334"> 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？</a></p><h4 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h4><p>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p><p>看图2，<strong>查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-24fb39feac68ae2a9211a753c972771a-unknown_filename-b1329f.png" alt="unknown_filename"><br>图中第一种<em>二叉查找树</em>，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p>我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？</p><p>从我前面的例子、图，以及还有代码来看，不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，<strong>如何求一棵包含 n 个节点的完全二叉树的高度？</strong></p><p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p><p><strong>平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。</strong></p><h4 id="二叉查找树和散列表"><a href="#二叉查找树和散列表" class="headerlink" title="二叉查找树和散列表"></a>二叉查找树和散列表</h4><p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？</p><p>第一，<em>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列</em>。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h4><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-cca968c669ec908aeeec646ad8dca686-unknown_filename.7-670cea.png" alt="unknown_filename.7"><br>很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p><p>AVL树不存在变色的问题，只有左旋转、右旋转这两种操作。</p><h4 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h4><p>新加入的就是红节点</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653204996&idx=2&sn=ecf932d2db8cb6e4fcb841a2b6a5bfba&chksm=8c99c0debbee49c86dc8e82a2d195389a93e81d8e5ca8af7d4dd2eec5c7fe209038c91444964&scene=21#wechat_redirect">漫话红黑树</a><br>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。<br>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ol><li>结点是红色或黑色。</li><li>根结点是黑色。</li><li>每个叶子结点都是黑色的空结点（NIL结点）。</li><li>每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-25776fea3ce0a963baafda9628c9d857-unknown_filename.1-6fe514.png" alt="unknown_filename.1"></p><p>正是因为这些规则限制,才保证了红黑树的自平衡。红黑树<em>从根到叶子的最长路径不会超过最短路径的2倍</em>。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-de97b4abf67315f65d5961c100bac29a-unknown_filename.18-37a305.png" alt="unknown_filename.18"></p><p>调整的方法有两种:<strong>变色和旋转</strong>。而旋转又包含两种方式左旋转和右旋转</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-79d982e3e7882526e27e7d6142aebec8-unknown_filename.17-59997f.png" alt="unknown_filename.17"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-1832c72e9962575bec59158a7921afbe-unknown_filename.19-d62196.png" alt="unknown_filename.19"></p><p><strong>为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</strong></p><p>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。</p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。<br>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。</p><h3 id="递归树分析算法复杂度"><a href="#递归树分析算法复杂度" class="headerlink" title="递归树分析算法复杂度"></a>递归树分析算法复杂度</h3><p>借助递归树来分析递归算法的时间复杂度。<br><strong>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</strong><br>如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作<strong>递归树</strong>。</p><h4 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-56ff3e18852772169a9dcfe1f818ccf5-unknown_filename.12-e0986b.png" alt="unknown_filename.12"><br>每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。<br>现在，我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。<br>归并排序递归树是一棵满二叉树。我们前两节中讲到，满二叉树的高度大约是 log2​n，（第 K 层包含的节点个数就是 2^(K-1)）<br>所以，归并排序递归实现的时间复杂度就是 O(nlogn)。</p><p>接下来我会通过三个实际的递归算法，带你实战一下递归的复杂度分析。学完这节课之后，你应该能真正掌握递归代码的复杂度分析。</p><p><strong>实战一：分析快速排序的时间复杂度</strong><br>我们还是取 k 等于 9，也就是说，每次分区都很不平均，一个分区是另一个分区的 9 倍。如果我们把递归分解的过程画成递归树，就是下面这个样子：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-3ab160b4c7e2b15ae2e3d3f8d79edb1c-unknown_filename.11-5e2a14.png" alt="unknown_filename.11"><br>排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h∗n ，也就是说，时间复杂度就是 O(h∗n)。</p><p><strong>实战二：分析斐波那契数列的时间复杂度</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>int <span class="hljs-built_in">f</span>(int n) &#123;<br>  if (n == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br>  if (n == <span class="hljs-number">2</span>) return <span class="hljs-number">2</span>;<br>  return <span class="hljs-built_in">f</span>(n-<span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(n-<span class="hljs-number">2</span>);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-fb250e48401acc6876a16790429eff4e-unknown_filename.14-5cc5f9.png" alt="unknown_filename.14"><br>每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2^n。依次类推，第 k 层的时间消耗就是 2^k−1，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为 n，那这个总和就是 2^n−1。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-172ba5e33416357a8fadf20517cde378-unknown_filename.9-b66081.png" alt="unknown_filename.9"></p><p>这个算法的时间复杂度就介于上面之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。</p><p><strong>实战三：分析全排列的时间复杂度</strong></p><p>如何把 n 个数据的所有排列都找出来<br><strong>如果我们确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。</strong></p><blockquote><p>假设数组中存储的是1，2， 3…n。<br>f(1,2,…n) &#x3D; {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +…+{最后一位是n, f(n-1)}。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用方式：</span><br><span class="hljs-comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span><br><span class="hljs-comment">// k表示要处理的子数组的数据个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPermutations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      System.out.print(data[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> data[i];<br>    data[i] = data[k-<span class="hljs-number">1</span>];<br>    data[k-<span class="hljs-number">1</span>] = tmp;<br><br>    printPermutations(data, n, k - <span class="hljs-number">1</span>);<br><br>    tmp = data[i];<br>    data[i] = data[k-<span class="hljs-number">1</span>];<br>    data[k-<span class="hljs-number">1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-f5b1561f68e7b81d08a9630d56225775-unknown_filename.13-579649.png" alt="unknown_filename.13"></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-26-16-21-90b17ff2e644b785c9ebeefead2c407e-20240226162135-250c70.png" alt="image.png|600"></p><ul><li>如果树为空，则直接返回错</li><li>如果树不为空：层序遍历二叉树<br>2.1&gt;如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列；<br>2.1&gt;如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树；<br>2.2&gt;如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空，且则该节点之后的队列中的结点都为叶子节点，该树才是完全二叉树，否则就不是完全二叉树；</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>堆排序是利用堆这种数据结构而设计的一种排序算法，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。一般升序采用大顶堆，降序采用小顶堆。</li><li>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-1bbca372e5aa5e66f3414fa11e160840-unknown_filename.10-b068f1.jpeg" alt="unknown_filename.10"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HeapSort</span> <span class="hljs-variable">heapSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapSort</span>();<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">19</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">6</span>, <span class="hljs-number">35</span>, <span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-comment">//&#123;35, 8, 27, 6, 19, 14, 3, 12, 1, 0, 9, 10, 7&#125;</span><br>        System.out.println(<span class="hljs-string">&quot;Before heap:&quot;</span>);<br>        heapSort.printArray(array);<br><br>        heapSort.heapSort(array);<br><br>        System.out.println(<span class="hljs-string">&quot;After heap sort:&quot;</span>);<br>        heapSort.printArray(array);<br>    &#125;<br><br>    <span class="hljs-comment">//(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        buildMaxHeap(array);<span class="hljs-comment">//建立最大堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-comment">//最大的在0位置，那么开始沉降，这样每交换一次最大的值就丢到最后了</span><br>            exchangeElements(array, <span class="hljs-number">0</span>, i);<br>            <span class="hljs-comment">//继续获取0位置最大值，将第一次排序后到了最后面的最大值排除</span><br>            <span class="hljs-comment">//重新调整结构，使其满足堆，然后继续交换堆顶元素与当前末尾元素，</span><br>            <span class="hljs-comment">//反复执行调整+交换步骤，直到整个序列有序。</span><br>            maxHeap(array, i, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//(2)建立最大堆</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> (array.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//从一半开始，6</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> half; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            maxHeap(array, array.length, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> heapSize, <span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">//index堆头</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-comment">//三者找最大值</span><br>        <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;<br>            largest = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;<br>            largest = right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index != largest) &#123;<br>            exchangeElements(array, index, largest);<br>            <span class="hljs-comment">//继续构造下面的大堆</span><br>            maxHeap(array, heapSize, largest);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//（3）换位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchangeElements</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[index1];<br>        array[index1] = array[index2];<br>        array[index2] = temp;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&#123;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            System.out.print(array[i]);<br>            <span class="hljs-keyword">if</span> (i &lt; array.length - <span class="hljs-number">1</span>) &#123;<br>                System.out.print(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>如何实现搜索引擎的搜索关键词提示功能？</p><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。<br>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。最后构造出来的就是下面这个图中的样子。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BA%8C%E5%8F%89%E6%A0%91.resources/2023/09/15/17-36-30-b868f2d6faea9d0e508fdb92cc0f7ca5-unknown_filename.16-4d5fcf.png" alt="unknown_filename.16"><br>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p>如果要在一组字符串中，频繁地查询某些字符串，用 Trie 树会非常高效。构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。</p><p>每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p><p>刚刚我们在讲 Trie 树的实现的时候，讲到用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p>按照我们上面举的例子，数组长度为 26，每个元素是 8 字节，那每个节点就会额外需要 26* 8&#x3D;208 个字节。而且这还是只包含 26 个字符的情况。</p><p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</p><p>我们可以<code>稍微牺牲一点查询的效率</code>，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。用哪种数据结构呢？我们的选择其实有很多，比如有序数组、跳表、散列表、红黑树等。</p><p>假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，我们可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 Trie 树中插入一个字符串的时候，我们为了维护数组中数据的有序性，就会稍微慢了点。</p><p>一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。<br>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。<br>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。<br>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。<br>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p><p>实际上，Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3-二分、字符串</title>
    <link href="/2025/12/44b7a9053841.html"/>
    <url>/2025/12/44b7a9053841.html</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有点像分治，底层必须依赖数组，并且还要求数据是有序的。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-b6bf9679b06824b205a40d2b8f81ad1a-15-43-18-b6bf9679b06824b205a40d2b8f81ad1a-unknown_filename.41-c16e42-358281.png" alt="unknown_filename.41|600"></p><p>这是一个等比数列。其中 n&#x2F;2k&#x3D;1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O (k)。通过 n&#x2F;2k&#x3D;1，我们可以求得 k&#x3D;log2n，所以时间复杂度就是 O (logn)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] == k) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a &lt;= b) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a + (b - a) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (k &lt; arr[m]) &#123;<br>b = m-<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; arr[m]) &#123;<br>a = m + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>容易出错的 3 个地方</p><ol><li>循环退出条件<br> 注意是 low&lt;&#x3D;high，而不是 low&lt;high。</li><li>mid 的取值<br> 我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理<em>位运算要快得多</em>。</li><li>low 和 high 的更新<br> low&#x3D;mid+1，high&#x3D;mid-1。注意这里的 +1 和 -1，如果直接写成 low&#x3D;mid 或者 high&#x3D;mid，就可能会发生死循环。比如，当 high&#x3D;3，low&#x3D;3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。</li></ol><p>二分查找除了用循环来实现，还可以用递归来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分查找的递归实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> val)</span> &#123;<br>  <span class="hljs-keyword">return</span> bsearchInternally(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, val);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bsearchInternally</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> value)</span> &#123;<br>  <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span>  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (a[mid] == value) &#123;<br>    <span class="hljs-keyword">return</span> mid;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>    <span class="hljs-keyword">return</span> bsearchInternally(a, mid+<span class="hljs-number">1</span>, high, value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> bsearchInternally(a, low, mid-<span class="hljs-number">1</span>, value);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h4><p><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组</strong>。</p><p>数组按照下标随机访问数据的时间复杂度是 O (1)，而链表随机访问的时间复杂度是 O (n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p><strong>其次，二分查找针对的是有序数据。</strong></p><p>数据必须是有序的。<em>如果数据没有序，我们需要先排序</em><br>如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。<br>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？别急，等到二叉树那一节我会详细讲。</p><p><strong>再次，数据量太小不适合二分查找。</strong></p><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p><strong>最后，数据量太大也不适合二分查找。</strong></p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><h4 id="二分查找变形"><a href="#二分查找变形" class="headerlink" title="二分查找变形"></a>二分查找变形</h4><p>十个二分九个错</p><p>上一节讲的只是二分查找中最简单的一种情况，在不存在重复元素的有序数组中，查找值等于给定值的元素。最简单的二分查找写起来确实不难，但是，二分查找的变形问题就没那么好写了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-c1d6cb5ff6dfd01437c1ffcea0da30d8-15-43-18-c1d6cb5ff6dfd01437c1ffcea0da30d8-unknown_filename.42-9e87b0-992531.png" alt="unknown_filename.42|600"></p><p><strong>变体一：查找第一个值等于给定值的元素</strong></p><p>如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-afb95d03b8f2db09a02d2e556a6b293e-15-43-18-afb95d03b8f2db09a02d2e556a6b293e-unknown_filename.43-5d11ce-039b97.png" alt="unknown_filename.43|600"></p><p>如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4] 比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。<br>尽管 a[7] 也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(a[mid] &lt; value)</span> </span>&#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>变体二：查找最后一个值等于给定值的元素</strong></p><p>前面的问题是查找第一个值等于给定值的元素，我现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> bsearch(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>) &#123;<br>  <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> high = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>  while (low &lt;= high) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &gt; <span class="hljs-built_in">value</span>) &#123;<br>      high = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &lt; <span class="hljs-built_in">value</span>) &#123;<br>      low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      <span class="hljs-built_in">if</span> ((<span class="hljs-built_in">mid</span> == <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) || (a[<span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>] != <span class="hljs-built_in">value</span>)) return <span class="hljs-built_in">mid</span>;<br>      else low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变体三：查找第一个大于等于给定值的元素</strong></p><p>在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> bsearch(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>) &#123;<br>  <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> high = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>  while (low &lt;= high) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &gt;= <span class="hljs-built_in">value</span>) &#123;<br>      <span class="hljs-built_in">if</span> ((<span class="hljs-built_in">mid</span> == <span class="hljs-number">0</span>) || (a[<span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">value</span>)) return <span class="hljs-built_in">mid</span>;<br>      else high = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变体四：查找最后一个小于等于给定值的元素</strong></p><p>我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> bsearch7(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>) &#123;<br>  <span class="hljs-built_in">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> high = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>  while (low &lt;= high) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">if</span> (a[<span class="hljs-built_in">mid</span>] &gt; <span class="hljs-built_in">value</span>) &#123;<br>      high = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      <span class="hljs-built_in">if</span> ((<span class="hljs-built_in">mid</span> == <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) || (a[<span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>] &gt; <span class="hljs-built_in">value</span>)) return <span class="hljs-built_in">mid</span>;<br>      else low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跳表（Skip-list"><a href="#跳表（Skip-list" class="headerlink" title="跳表（Skip list)"></a>跳表（Skip list)</h4><p>因为<strong>二分查找底层依赖的是数组随机访问的特性</strong>，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？<br>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速的插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？</p><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O (n)。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-8a66b846201e0dd5c84b8dd43783efe7-15-43-18-8a66b846201e0dd5c84b8dd43783efe7-unknown_filename.45-0ec44c-041617.png" alt="unknown_filename.45|600"></p><p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-527ef8ed60841f9cf804782e64bbbc88-15-43-18-527ef8ed60841f9cf804782e64bbbc88-unknown_filename.44-39b955-3e038d.png" alt="unknown_filename.44|600"></p><p><strong>这种链表加多级索引的结构，就是跳表</strong></p><hr><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>我们用的最多的就是编程语言提供的字符串查找函数，比如 Java 中的 indexOf ()，Python 中的 find () 函数等，它们底层就是依赖接下来要讲的字符串匹配算法。<br>BF 算法和 RK 算法、BM 算法和 KMP 算法。</p><h3 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h3><p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作<strong>暴力匹配算法</strong>，也叫朴素匹配算法。</p><p>我们在字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p><p>BF 算法的思想可以用一句话来概括，那就是，我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的（<strong>看图</strong>）。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-a1e9b7f46b5056938f6b54a6f7d580e1-15-43-18-a1e9b7f46b5056938f6b54a6f7d580e1-unknown_filename.48-533903-81e7d8.png" alt="unknown_filename.48|600"></p><p>我们每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的最坏情况时间复杂度是 O (n* m)。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BF算法</span><br><span class="hljs-comment"> * 检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">bfFind</span><span class="hljs-params">(<span class="hljs-type">String</span> S, <span class="hljs-type">String</span> T)</span> </span>&#123;  <br>    <span class="hljs-type">char</span>[] arr1 = S.<span class="hljs-built_in">toCharArray</span>();  <br>    <span class="hljs-type">char</span>[] arr2 = T.<span class="hljs-built_in">toCharArray</span>();  <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;  <br>        <span class="hljs-keyword">if</span> (arr1[i] == arr2[j]) &#123;  <br>            i++;  <br>            j++;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//++操作，为什么-j，因为相同时ij都+过，其他情况j是0  </span><br>            i = i - j + <span class="hljs-number">1</span>;  <br>            j = <span class="hljs-number">0</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (j == arr2.length) <span class="hljs-keyword">return</span> i - j;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>尽管理论上，BF 算法的时间复杂度很高，是 O (n* m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。</p><ul><li>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。</li><li>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。</li></ul><h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>BF 算法的升级版。<br>BF 每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O (n* m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。</p><p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-4b16196e631ebc3ab77a51f3932e3ed0-15-43-18-4b16196e631ebc3ab77a51f3932e3ed0-unknown_filename.47-87011b-a92ead.png" alt="unknown_filename.47|600"><br>比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。<br>在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 a 到 z 这 26 个字符的字符串，计算哈希的时候，我们只需要把进位从 10 改成 26 就可以。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-fb423633e2c6ad038660f0d2c0e08e0a-15-43-18-fb423633e2c6ad038660f0d2c0e08e0a-unknown_filename.51-1b15da-3a3d87.png" alt="unknown_filename.51|600"><br>这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。我这有个个例子，你先找一下规律，再来看我后面的讲解。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-e445d0397b158b59bdd45a485a96373d-15-43-18-e445d0397b158b59bdd45a485a96373d-unknown_filename.49-c709b5-46a68a.png" alt="unknown_filename.49|600"><br>从这里例子中，我们很容易就能得出这样的规律：相邻两个子串 s[i-1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，我们可以使用 s[i-1] 的哈希值很快的计算出 s[i] 的哈希值。如果用公式表示的话，就是下面这个样子：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-22-18-37-efc72ce48fd6887206b9e8a22cde0a36-15-43-18-efc72ce48fd6887206b9e8a22cde0a36-unknown_filename.50-beb883-11e80a.png" alt="unknown_filename.50|600"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2-递归、排序</title>
    <link href="/2025/12/03d302ea1475.html"/>
    <url>/2025/12/03d302ea1475.html</url>
    
    <content type="html"><![CDATA[<p>如何在海量数据中快速查找某个数据？<br>建立索引，空间换时间，例如数据库，存储在硬盘<br>先思考后写；不要惧怕修改</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>先写一个的解决方法，不想多层，写完再想如何多个</strong></p><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。<br>于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。<br>我们用递推公式将它表示出来就是这样的：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>=<span class="hljs-built_in">f</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span> 其中，<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)&#x3D;1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h3><ol><li>一个问题的解可以分解为几个子问题的解</li><li><strong>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></li><li>存在递归终止条件<br> 第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)&#x3D;1，这就是递归的终止条件。</li></ol><h3 id="调试递归"><a href="#调试递归" class="headerlink" title="调试递归"></a>调试递归</h3><p>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。<br>调试递归:</p><ol><li>打印日志发现，递归值。</li><li>结合条件断点进行调试。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recursion</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 求和</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">summation</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> num + summation(num - <span class="hljs-number">1</span>);<br>&#125;  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 求二进制</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binary</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>summation(num / <span class="hljs-number">2</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">2</span>;<br>sb.append(i);<br>&#125;<br>System.out.println(sb.toString());<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 求n的阶乘</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> n * f(n - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>```    <br><br>### 如何编写递归代码？<br><br>写递归代码最关键的是写出递推公式，找到终止条件<br>爬楼梯<br>```java<br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong></p><p>人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正和它的胃口。<br>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p><p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong><br>不要陷入思维误区。</p><h4 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h4><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。<em>系统栈或者虚拟机栈空间一般都不大</em>。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><p>那么，如何避免出现堆栈溢出呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 全局变量，表示递归的深度。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  ++depth；<br>  <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">throw</span> exception;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-bfc3eaa6c0d6a52a2cc6a9e58afc5587-unknown_filename.46-7d7123.png" alt="unknown_filename.46"></p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来<code>保存已经求解过的 f(k)</code>。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HashMap</span> <span class="hljs-variable">hasSolvedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <br>  <span class="hljs-comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span><br>  <span class="hljs-keyword">if</span> (hasSolvedList.containsKey(n)) &#123;<br><span class="hljs-keyword">return</span> hasSolvedList.get(n);<br>  &#125;<br>  <br>  <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);<br>  hasSolvedList.put(n, ret);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p><h4 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h4><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题</p><p>电影院修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>ret = ret + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>爬楼梯修改</p><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h4 id="如何找到“最终推荐人”？"><a href="#如何找到“最终推荐人”？" class="headerlink" title="如何找到“最终推荐人”？"></a>如何找到“最终推荐人”？</h4><p>推荐注册返佣金的这个功能我想你应该不陌生吧？现在很多 App 都有这个功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">findRootReferrerId</span><span class="hljs-params">(<span class="hljs-type">long</span> actorId)</span> &#123;<br>  <span class="hljs-type">Long</span> <span class="hljs-variable">referrerId</span> <span class="hljs-operator">=</span> select referrer_id from [table] <span class="hljs-type">where</span> <span class="hljs-variable">actor_id</span> <span class="hljs-operator">=</span> actorId;<br>  <span class="hljs-keyword">if</span> (referrerId == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> actorId;<br>  <span class="hljs-keyword">return</span> findRootReferrerId(referrerId);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。<br>第一，如果递归很深，可能会有堆栈溢出的问题。<br>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。</p><p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。如何来检测环的存在呢？</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-23-14-12-365392b696aa0ea1bf2b656b99e76b8b-15-43-18-365392b696aa0ea1bf2b656b99e76b8b-unknown_filename.40-824308-4bde57.png" alt="unknown_filename.40|600"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="原地"><a href="#原地" class="headerlink" title="原地"></a>原地</h4><p><strong>排序算法的内存消耗</strong></p><p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。冒泡、插入、选择，都是原地排序算法。<br>&#x3D;&#x3D;不需要借助额外的存储空间&#x3D;&#x3D;</p><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>如果待排序的序列中存在值相等的元素，经过排序之后，&#x3D;&#x3D;相等元素之间原有的先后顺序不变&#x3D;&#x3D;。<br>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。<br>经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。</p><p>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</p><ul><li>稳定排序有：插入排序，基数排序，归并排序 ，冒泡排序 ，基数排序。</li><li>不稳定的排序算法有：快速排序，希尔排序，简单选择排序，堆排序。</li></ul><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>稳定、原地排序</p><p>我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-88a3aa0c2067bab8a02383193d65e4c5-unknown_filename.32-62c004.png" alt="unknown_filename.32"><br>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-35b76771b8d43bda5b82e3d56ae1e3f2-unknown_filename.31-cc45fa.png" alt="unknown_filename.31"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 冒泡排序，a表示数组，n表示数组大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br> <br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br><span class="hljs-comment">// 提前退出冒泡循环的标志位</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; ++j) &#123; <span class="hljs-comment">//-i：比较元素减少，-1：避免角标越界  </span><br>  <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 交换</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[j];<br>a[j] = a[j+<span class="hljs-number">1</span>];<br>a[j+<span class="hljs-number">1</span>] = tmp;<br>flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 表示有数据交换      </span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 没有数据交换，提前退出</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>稳定、原地排序</p><p>基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-28beb1ac33817bd7859a4ed3badb1552-unknown_filename.33-0edc59.png" alt="unknown_filename.33"></p><p>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><p>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。</p><p>当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入排序，a表示数组，n表示数组大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>  <span class="hljs-comment">//待插入元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> a[i];<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 查找插入的位置</span><br><span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>  <span class="hljs-keyword">if</span> (a[j] &gt; value) &#123;<br>a[j+<span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 数据移动，将大于temp的往后移动一位</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br>a[j+<span class="hljs-number">1</span>] = value; <span class="hljs-comment">// 插入数据</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡算法呢？</p><p>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：冒泡排序中数据的交换操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">冒泡排序中数据的交换操作：<br><span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 交换</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[j];<br>   a[j] = a[j+<span class="hljs-number">1</span>];<br>   a[j+<span class="hljs-number">1</span>] = tmp;<br>   flag = <span class="hljs-literal">true</span>;<br>&#125;<br><br>插入排序中数据的移动操作：<br><span class="hljs-keyword">if</span> (a[j] &gt; value) &#123;<br>  a[j+<span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 数据移动</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3* K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><h4 id="二分法插入排序"><a href="#二分法插入排序" class="headerlink" title="二分法插入排序"></a>二分法插入排序</h4><p>二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&gt;right，然后以左下标为标准，左及左后边全部后移，然后左位置前插入该数据。</p><p>二分法没有排序，只有查找。所以当找到要插入的位置时。移动必须从最后一个记录开始，向后移动一位，再移动倒数第2位，直到要插入的位置的记录移后一位。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-203dafa292948512933a9f0b15e8d9ce-unknown_filename.4-406681.jpeg" alt="unknown_filename.4"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br><span class="hljs-comment">// &#123;4, 6, 8, 7, 3, 5, 9, 1&#125;</span><br><span class="hljs-comment">// &#123;4, 6, 7, 8, 3, 5, 9, 1&#125;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<span class="hljs-comment">//7</span><br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<span class="hljs-comment">//2</span><br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//确定(找到)要插入的位置</span><br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><span class="hljs-comment">//先获取中间位置</span><br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (temp &lt; a[mid]) &#123;<br><span class="hljs-comment">//如果值比中间值小，让right左移到中间下标-1，舍弃右边</span><br>right = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//7  6</span><br><span class="hljs-comment">//如果值比中间值大,让left右移到中间下标+1，舍弃左边</span><br>left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= left; j--) &#123;<br><span class="hljs-comment">//以左下标为标准，左及左后边全部后移，然后左位置前插入该数据。</span><br>a[j + <span class="hljs-number">1</span>] = a[j];<br>&#125;<br><span class="hljs-keyword">if</span> (left != i) &#123;<span class="hljs-comment">//如果相等，不需要移动</span><br><span class="hljs-comment">//左位置插入该数据</span><br>a[left] = temp;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="希尔排序（O-n-1-3-）"><a href="#希尔排序（O-n-1-3-）" class="headerlink" title="希尔排序（O(n^1.3)）"></a>希尔排序（O(n^1.3)）</h4><ul><li>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。</li><li>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</li><li>先取一个小于 n 的整数 d1作为第一个增量，把数组的全部记录分组。所有距离为 d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量 d2&lt;d1重复上述的分组和排序，直至所取的增量 &#x3D;1 ( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-72bb0d61bd03b1917f2a63834fffacdf-unknown_filename.5-b77824.png" alt="unknown_filename.5"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heer</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a.length / <span class="hljs-number">2</span>;<span class="hljs-comment">//默认增量</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j + d &lt; a.length; j += d) &#123;<br><span class="hljs-comment">//i=0  j=0,4</span><br><span class="hljs-comment">//i=1  j=1,5</span><br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">if</span> (a[j] &gt; a[j + d]) &#123;<br>temp = a[j];<br>a[j] = a[j + d];<br>a[j + d] = temp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>d--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><p><strong>基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止</strong><br>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-94687aaf1caac16dc5a797c2c46aa17a-unknown_filename.35-214ec0.png" alt="unknown_filename.35"></p><p>那选择排序是稳定的排序算法吗？<br>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就<strong>不稳定</strong>了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br><span class="hljs-type">int</span> min;<br><span class="hljs-type">int</span> tmp;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>min = array[i];<br><span class="hljs-comment">//里面for第一次出来0，并且排在最前面，然后从i=1开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; array.length; j++) &#123;<br><span class="hljs-keyword">if</span> (array[j] &lt; min) &#123;<br>min = array[j];<span class="hljs-comment">//记录最小值  3</span><br>tmp = array[i];<span class="hljs-comment">//9</span><br>array[i] = min;<span class="hljs-comment">//3</span><br>array[j] = tmp;<span class="hljs-comment">//9</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : array) &#123;<br>System.out.println(num);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n2)，比较高，适合小规模数据的排序。今天，我讲两种时间复杂度为 <strong>O(nlogn)</strong> 的排序算法，归并排序和快速排序。这两种排序算法适合大规模的数据排序</p><p>稳定，但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是<em>归并排序不是原地排序算法</em>。<br>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。</p><h4 id="归并排序的原理：分治法"><a href="#归并排序的原理：分治法" class="headerlink" title="归并排序的原理：分治法"></a>归并排序的原理：分治法</h4><p>归并排序和快速排序都用到了分治思想，非常巧妙。<br>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-52ad18a770a87d06b0a39105fc4ac5b0-unknown_filename.36-0a9e62.png" alt="unknown_filename.36|600"></p><p>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，<strong>将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</strong><br>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p><p><strong>分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突</strong>。</p><h4 id="如何用递归代码来实现归并排序"><a href="#如何用递归代码来实现归并排序" class="headerlink" title="如何用递归代码来实现归并排序"></a>如何用递归代码来实现归并排序</h4><p>写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">递推公式：<br>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class="hljs-number">1</span>…r))<br><br>终止条件：<br>p &gt;= r 不用再继续分解<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br><span class="hljs-keyword">if</span> (left &lt; right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>mergeSort(a, left, middle);<span class="hljs-comment">//左边归并排序，使得左子序列有序</span><br>mergeSort(a, middle + <span class="hljs-number">1</span>, right);<span class="hljs-comment">//右边归并排序，使得右子序列有序</span><br>merge(a, left, middle, right);<span class="hljs-comment">//将两个有序子数组合并操作</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> middle, <span class="hljs-type">int</span> right)</span> &#123;<span class="hljs-comment">//left0,mid0,right1</span><br><span class="hljs-comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br><span class="hljs-type">int</span>[] tmpArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br><span class="hljs-type">int</span> <span class="hljs-variable">rightStart</span> <span class="hljs-operator">=</span> middle + <span class="hljs-number">1</span>;<span class="hljs-comment">//右序列指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">leftStart</span> <span class="hljs-operator">=</span> left;<span class="hljs-comment">//左序列指针，用来拷贝到原数组中</span><br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> left;<span class="hljs-comment">//临时数组指针</span><br><span class="hljs-comment">//比较两个小数组相应下标位置的数组大小，小的先放进新数组</span><br><span class="hljs-keyword">while</span> (left &lt;= middle &amp;&amp; rightStart &lt;= right) &#123;<br><span class="hljs-keyword">if</span> (a[left] &lt;= a[rightStart]) &#123;<br><span class="hljs-comment">//相当于tmpArray[third]=a[left];third++;left++三步合一步</span><br>tmpArray[temp++] = a[left++];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tmpArray[temp++] = a[rightStart++];<br>&#125;<br>&#125;<br><span class="hljs-comment">//如果左边还有数据需要拷贝，把左边数组剩下的拷贝到新数组</span><br><span class="hljs-keyword">while</span> (left &lt;= middle) &#123;<br>tmpArray[temp++] = a[left++];<br>&#125;<br><span class="hljs-comment">//如果右边还有数据......</span><br><span class="hljs-keyword">while</span> (rightStart &lt;= right) &#123;<br>tmpArray[temp++] = a[rightStart++];<br>&#125;<br><span class="hljs-comment">//将temp中的元素全部拷贝到原数组中</span><br><span class="hljs-keyword">while</span> (leftStart &lt;= right) &#123;<br>a[leftStart] = tmpArray[leftStart++];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">MergeSort</span> <span class="hljs-variable">mergeSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MergeSort</span>();<br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>mergeSort.mergeSort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : a) &#123;<br>System.out.print(<span class="hljs-string">&quot; &quot;</span> + n);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><p>快排是一种原地、不稳定的排序算法。</p><p>快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。</p><p>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。利用分治法可将快速排序的分为三步：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-3da7dab2f05b2409df3272d033e36baa-unknown_filename.37-8af3f6.png" alt="unknown_filename.37"></p><p><strong>快速排序和归并排序对比</strong></p><p>归并排序的处理过程是由下到上的，<em>先处理子问题，然后再合并</em>。而快排正好相反，它的处理过程是由上到下的，<em>先分区，然后再处理子问题</em>。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。<em>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br><span class="hljs-keyword">if</span> (a.length &gt; <span class="hljs-number">0</span>) &#123;<br>quickSort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快速排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> low  低位</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> high 高位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br><span class="hljs-keyword">if</span> (low &lt; high) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> getMiddle(a, low, high);<br><span class="hljs-comment">//递归排比第一个基数小的数和大的数</span><br>quickSort(a, <span class="hljs-number">0</span>, middle - <span class="hljs-number">1</span>);<br>quickSort(a, middle + <span class="hljs-number">1</span>, high);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取中间下标</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> low</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> high</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[low];<span class="hljs-comment">//基准元素</span><br><span class="hljs-keyword">while</span> (low &lt; high) &#123;<span class="hljs-comment">//第二次3，9</span><br><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= temp) &#123;<br>high--;<br>&#125;<br>a[low] = a[high];<span class="hljs-comment">//将比基数小的数放到基数前面///用个数字想一下就明白了</span><br><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= temp) &#123;<br>low++;<br>&#125;<br>a[high] = a[low];<span class="hljs-comment">//将比基数大的数放到基数后面</span><br>&#125;<br>a[low] = temp;<span class="hljs-comment">//插入到排序后正确的位置，low就是基数应该在的位置</span><br><span class="hljs-keyword">return</span> low;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无序数组中的第-K-大元素"><a href="#无序数组中的第-K-大元素" class="headerlink" title="无序数组中的第 K 大元素"></a>无序数组中的第 K 大元素</h4><p>O (n) 时间复杂度</p><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。<br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p><p>如果 p+1&#x3D;K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-9af7c74d3b81e2ee04cf6f020f0a7ebd-unknown_filename.38-85d022.png" alt="unknown_filename.38"></p><p>理解分治，小问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> leetCode.findKthLargest(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//倒数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (len - k != (pivot = partition(nums, left, right))) &#123;<br>        <span class="hljs-comment">//4所在的问题就是2，那就找到了</span><br>        <span class="hljs-comment">//第k大应该在第K位，找每个数字应该在的位置，正好第0个4就是第K位，就找到了</span><br>            <span class="hljs-keyword">if</span> (pivot &lt; len - k) &#123;<span class="hljs-comment">//在后面</span><br>                left = pivot + <span class="hljs-number">1</span>;<br>                right = len - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = <span class="hljs-number">0</span>;<br>                right = pivot - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[pivot];<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot)<br>                right--;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot)<br>                left++;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么上述解决思路的时间复杂度是 O(n)？</strong><br>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n&#x2F;2 的数组执行分区操作，需要遍历 n&#x2F;2 个元素。依次类推，分区遍历元素的个数分别为、n&#x2F;2、n&#x2F;4、n&#x2F;8、n&#x2F;16.……直到区间缩小为 1。<br>如果我们把每次分区遍历的元素个数加起来，就是：n+n&#x2F;2+n&#x2F;4+n&#x2F;8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p><h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><p>时间复杂度是 O(n) 的排序算法：桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作<strong>线性排序（Linear sort）</strong>。之所以能做到线性的时间复杂度，主要原因是，这三个算法是<em>非基于比较的排序算法，都不涉及元素之间的比较操作</em>。</p><p>按照惯例，我先给你出一道思考题：如何根据年龄给 100 万用户排序？ 你可能会说，我用上一节课讲的归并、快排就可以搞定啊！是的，它们也可以完成功能，但是时间复杂度最低也是 O(nlogn)。有没有更快的排序方法呢？让我们一起进入今天的内容！</p><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-a966114c395188070f806c2b8404f080-unknown_filename.39-c96548.png" alt="unknown_filename.39"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-9e16c2b843d8503d5929808bd51c7674-unknown_filename.54-cd7ba2.png" alt="unknown_filename.54"></p><p><strong>桶排序的时间复杂度为什么是 O(n) 呢</strong><br>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k&#x3D;n&#x2F;m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k&#x3D;n&#x2F;m，所以整个桶排序的时间复杂度就是 O(n* log(n&#x2F;m))。当桶的个数 m 接近数据个数 n 时，log(n&#x2F;m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong><br>要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p><h3 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h3><p>我个人觉得，计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p><p>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，<strong>所以我们可以分成 901 个桶</strong>，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><p>计数排序的算法思想就是这么简单，<strong>跟桶排序非常类似，只是桶的大小粒度不一样</strong></p><p><a href="https://time.geekbang.org/column/article/42038E">先行排序再看看</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-f69fa7784ae3b57bdf81620a3d6d6480-unknown_filename.53-a5429a.png" alt="unknown_filename.53"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-4c9ffb43539a77b7be0ff34feeba4224-unknown_filename.52-8b3456.png" alt="unknown_filename.52"></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-e80f1162c1ddcffd97aab4fd19733cb5-unknown_filename.56-df576b.png" alt="unknown_filename.56"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%80%92%E5%BD%92%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.resources/2023/09/18/15-43-18-a2e7ce3b2528b87b01d165cde486bf22-unknown_filename.55-78910a.png" alt="unknown_filename.55"></p><h3 id="如何实现一个通用的、高性能的排序函数？"><a href="#如何实现一个通用的、高性能的排序函数？" class="headerlink" title="如何实现一个通用的、高性能的排序函数？"></a>如何实现一个通用的、高性能的排序函数？</h3><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。<br>Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。</p><p>我们知道，快排在最坏情况下的时间复杂度是 O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？</p><p>归并排序并不是原地排序算法，空间复杂度是 O(n)。所以，粗略点、夸张点讲，<strong>如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间</strong>，空间耗费就翻倍了。</p><h4 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h4><p>为什么最坏情况下快速排序的时间复杂度是 O(n2) 呢？我们前面讲过，如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，<strong>这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。</strong><br>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p><ol><li>三数取中法</li><li>随机法</li></ol><p>在 qsort() 插入排序的算法实现中，也利用了这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1-数据结构</title>
    <link href="/2025/12/95e8b3e4a6a1.html"/>
    <url>/2025/12/95e8b3e4a6a1.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li>为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。</li><li>那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。</li><li>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构</li><li>“存储”需要的就是数据结构，“计算”需要的就是算法</li><li>基础的数据结构就是数组和链表， 而后面更加复杂的 树 队列 图 等等 都可以通过数组和链表等方式存储， 出现树 队列 图 等数据结构的原因 就是为了解决 部分问题处理过程中时间复杂度过高的问题， 所以数据结构就是为了算法而生的！</li></ul><h3 id="常用数据结构与算法"><a href="#常用数据结构与算法" class="headerlink" title="常用数据结构与算法"></a>常用数据结构与算法</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-913e0ababe43a2d57267df5c5f0832a7-unknown_filename.16-acba32.jpeg" alt="unknown_filename.16"></p><ul><li>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</li></ul><ul><li>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</li></ul><p>数据结构是相互之间存在一种或多种关系的数据元素的集合。逻辑结构有4种：<br>集合结构（数据元素之间仅以集合的方式体现，元素之间没有别的关系）<br>线性结构（数据元素之间存在一对一的关系）<br>树（数据元素之间为一对多或多对一的关系）<br>图（数据元素之间为多对多的关系）</p><ul><li>线性结构元素之间存在一对一的关系，线性表可通过顺序和链式两种方式来实现。顺序存储结构，是用一段地址连续的存储单元依次存储线性表的数据元素</li></ul><p>　　</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-7dd7adc15257de427fe01446db8a18c9-unknown_filename.13-c91c18.png" alt="unknown_filename.13"></p><ul><li>链式存储结构，用一组任意的存储单元来存储数据元素，不要求物理存储单元的连续性，由一系列结点组成，每个结点除了要存储数据外，还需存储指向后继结点或前驱结点的存储地址。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-d33758af2a9cf078da5ceb2d59a8f7a0-unknown_filename.24-c04d8a.png" alt="unknown_filename.24"></p><p><strong>Stack</strong></p><ol><li>栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。遵循后入先出（LIFO）原则。</li><li>pop() ：和peek()一样返回栈顶元素，但是要将栈顶元素移除掉<br> search() - 返回元素在堆栈中的位置</li></ol><p><strong>Queue</strong></p><ol><li>队列是元素的集合，其包含了两个基本操作：enqueue 操作可以用于将元素插入到队列中，而 dequeue 操作则是将元素从队列中移除。</li><li>遵循先入先出原则 (FIFO)。</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>所有代码的执行时间 T(n) 与每行代码的执行次数成正比。<br>T(n) &#x3D;O( f(n) )</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> cal(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br>  for (; i &lt;= <span class="hljs-built_in">n</span>; ++i) &#123;<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i;<br>  &#125;<br>  return <span class="hljs-built_in">sum</span>;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><ul><li>其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。当 n 无限大的时候，就可以忽略。</li><li>循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</li></ul><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ul><li><code>总的时间复杂度就等于量级最大的那段代码的时间复杂度</code></li><li>如果 T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么 T(n)&#x3D;T1(n)+T2(n)&#x3D;max(O(f(n)), O(g(n))) &#x3D;O(max(f(n), g(n))).</li><li>假设 T1 (n) &#x3D; O (n)，T2 (n) &#x3D; O (n2)，则 T1 (n) * T2 (n) &#x3D; O (n3)</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-6ea770ad3989b3998f2e62a572332352-unknown_filename.11-9ff0cb.png" alt="unknown_filename.11"></p><h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><p>int i &#x3D; 8; int j &#x3D; 6; int sum &#x3D; i + j;<br>只要<em>代码的执行时间不随 n 的增大而增长</em>，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中<em>不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1</em>)。<br>跟数据规模 n 没有关系，都可忽略</p><h4 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">; while (i &lt;= n)  &#123;   i = i * 2; &#125;</span><br></code></pre></td></tr></table></figure><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-594a537e65a8390b2d77b67e45fe7371-unknown_filename.8-75f05f.png" alt="unknown_filename.8"><br>2x&#x3D;n<br>x&#x3D;log2n</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">; while (i &lt;= n)  &#123;   i = i * 3; &#125;</span><br></code></pre></td></tr></table></figure><p>这段代码的时间复杂度为 O(log3n)。<br>但是实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)</p><p>O(nlogn)<br>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)</p><h4 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m* n)"></a>O(m+n)、O(m* n)</h4><p>代码的复杂度由两个数据的规模来决定</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-type">int</span> sum_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; m; ++i) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br><br>  <span class="hljs-type">int</span> sum_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; j &lt; n; ++j) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。针对这种情况，原来的加法法则就不正确了</p><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><ul><li>时间复杂度的全称是渐进时间复杂度，表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。</li><li>我们常见的空间复杂度就是 <strong>O(1)、O(n)、O(n2)</strong> ，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-8d830b4333fcfdf2d8f572f790be3594-unknown_filename.15-67aeaa.png" alt="unknown_filename.15|600"></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br>而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><h4 id="为什么数组从0开始"><a href="#为什么数组从0开始" class="headerlink" title="为什么数组从0开始"></a>为什么数组从0开始</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-f67fc8ab7ab08d935633ff708a7cd96b-unknown_filename.25-4f5e23.png" alt="unknown_filename.25"><br>一个数字4个字节<br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">a[i]_address = base_address + i * dat<span class="hljs-built_in">a_type</span>_size<br></code></pre></td></tr></table></figure><p>其中 base_address 是首地址，data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址。<br>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[k]</span>_address = base_address + (k-<span class="hljs-number">1</span>)*type_size<br></code></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。所以数组从0开始。</p><blockquote><p>一个错误：<br>在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。<br>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)（k在第几个位置）。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p></blockquote><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。<br>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，<em>它都会将空间自动扩容为 1.5 倍大小</em>。</p><p>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>从图中看到，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。<br>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将<strong>一组零散的内存</strong>块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-6f0bc75c9d512a528079f9e166b3677a-unknown_filename.12-386fc5.png" alt="unknown_filename.12"></p><p>针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-c1e8eee85c6083a1334765e29b16d960-unknown_filename.22-42278b.png" alt="unknown_filename.22"></p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-334df425b32ee7c046b18e7cb04204bb-unknown_filename.1-b72ed3.png" alt="unknown_filename.1"></p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。<br>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p><strong>LinkedHashMap</strong> 的实现原理，就会发现其中就用到了双向链表这种数据结构。（用空间换时间）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-f816f759f83844448032f157017f3975-unknown_filename.26-6c3292.png" alt="unknown_filename.26"></p><h4 id="数组和链表对比"><a href="#数组和链表对比" class="headerlink" title="数组和链表对比"></a>数组和链表对比</h4><p><strong>已知前驱节点</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-46b847c856e6e5194cb1311980456aa5-unknown_filename.3-6376cd.png" alt="unknown_filename.3"></p><p><strong>数组的缺点是大小固定，一经声明就要占用整块连续内存空间</strong>。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><h4 id="写链表代码技巧"><a href="#写链表代码技巧" class="headerlink" title="写链表代码技巧"></a>写链表代码技巧</h4><p><strong>技巧一：理解指针或引用的含义</strong></p><p>我们知道，有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。<br><strong>如果你用的是 Java 或者其他没有指针的语言也没关系，你把它理解成“引用”就可以了</strong>。</p><blockquote><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p></blockquote><p>在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next&#x3D;q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。<br>还有一个更复杂的，也是我们写链表代码经常会用到的：p-&gt;next&#x3D;p-&gt;next-&gt;next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。</p><p><strong>技巧二：利用哨兵简化实现难度</strong></p><p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。<br>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。<br>我画了一个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-0e21814681e3d95dfb9e3492b4fbb559-unknown_filename-3417d5.png" alt="unknown_filename"><br>利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。</p><p><strong>技巧四：重点留意边界条件处理</strong></p><p>我经常用来检查链表代码是否正确的边界条件有这样几个：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><p><strong>技巧五：举例画图，辅助思考</strong></p><p>举例法和画图法<br>比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-bbf04e8b5117e73f4453ee9e61b43542-unknown_filename.19-75a406.png" alt="unknown_filename.19"></p><p><strong>技巧六：多写多练，没有捷径</strong></p><p>我精选了 5 个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。<br>单链表反转<br>链表中环的检测<br>两个有序的链表合并<br>删除链表倒数第 n 个结点<br>求链表的中间结点<br>练习题LeetCode对应编号：206，141，21，19，876。大家可以去练习</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p><h4 id="实现一个栈"><a href="#实现一个栈" class="headerlink" title="实现一个栈"></a>实现一个栈</h4><p>栈既可以用数组来实现，也可以用链表来实现。<em>用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基于数组实现的顺序栈</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span> &#123;<br>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;           <span class="hljs-comment">//栈的大小</span><br><br>  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n];<br>    <span class="hljs-built_in">this</span>.n = n;<br>    <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 入栈操作</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(String item)</span> &#123;<br>    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span><br>    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span><br>    items[count] = item;<br>    ++count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 出栈操作</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 栈为空，则直接返回null</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> items[count-<span class="hljs-number">1</span>];<br>    --count;<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。<br>注意，这里存储数据需要一个大小为 n 的数组，<strong>并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉</strong>。<br>所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。空间复杂度分析是不是很简单？<br>时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><p>如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p><h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><p><strong>栈在函数调用中的应用</strong></p><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>   <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>; <br>   <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;<br>   <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>   ret = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>   res = a + ret;<br>   printf(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>   reuturn <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> &#123;<br>   <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>   sum = x + y;<br>   <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-3ec54c75ca742e6725e67f75b39184ac-unknown_filename.2-1037bb.png" alt="unknown_filename.2"></p><h4 id="内存中的堆栈"><a href="#内存中的堆栈" class="headerlink" title="内存中的堆栈"></a>内存中的堆栈</h4><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p><p>[[6.JVM]]<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进者先出，这就是典型的“队列”。队列跟栈一样，也是一种操作受限的线性表数据结构。<br>队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。</p><h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>我们刚才用数组来实现队列的时候，在 tail&#x3D;&#x3D;n 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。<br>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-bd925e9b56b5f4d8b230c0d0fc4be0d0-unknown_filename.20-e24e18.png" alt="unknown_filename.20"><br>图中这个队列的大小为 8，当前 head&#x3D;4，tail&#x3D;7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-4c1334184a85280e9b357bdce0dab1ae-unknown_filename.5-a3935a.png" alt="unknown_filename.5"></p><h4 id="实现循环队列"><a href="#实现循环队列" class="headerlink" title="实现循环队列"></a>实现循环队列</h4><p>要确定好队空和队满的判定条件。<br>在用数组实现的非循环队列中，队满的判断条件是 tail &#x3D;&#x3D; n，队空的判断条件是 head &#x3D;&#x3D; tail。那针对循环队列，<br>如何判断队空和队满呢？队列为空的判断条件仍然是 head &#x3D;&#x3D; tail。但队列满的判断条件就稍微有点复杂了。我画了一张队列满的图<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-5f94ecf987822bd2802daf0e000847af-unknown_filename.9-2b55ad.png" alt="unknown_filename.9"><br>就像我图中画的队满的情况，tail&#x3D;3，head&#x3D;4，n&#x3D;8，所以总结一下规律就是：(3+1)%8&#x3D;4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n&#x3D;head。<br>你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> &#123;<br>  <span class="hljs-comment">// 数组：items，数组大小：n</span><br>  <span class="hljs-keyword">private</span> String[] items;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 申请一个大小为capacity的数组</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class="hljs-comment">// 入队</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(String item)</span> &#123;<br>    <span class="hljs-comment">// 队列满了</span><br>    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    items[tail] = item;<br>    tail = (tail + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出队</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果head == tail 表示队列为空</span><br>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> items[head];<br>    head = (head + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h4><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p>上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！<br>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-bf6c81fec32657538288359a364f96f3-unknown_filename.21-a7e532.png" alt="unknown_filename.21"></p><p>前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环x队列比链式队列应用更加广泛的原因。在实战篇讲 Disruptor 的时候，我会再详细讲并发队列的应用。</p><p>ConcurrentLinkedQueue : 是一个适用于高并发场景下的队列，通过无锁的方式，实现<br>了高并发状态下的高性能<br><strong>CAS理论</strong>：compare and swap 比较并交换。该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值</p><p> <em>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</em></p><p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p><p>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>我们知道，树中的元素我们称为节点，图中的元素我们就叫作顶点（vertex）。从我画的图中可以看出来，图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作边（edge）。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-57fde4d899369ab60eb4bfb7a955e049-unknown_filename.7-dfcf5c.png" alt="unknown_filename.7"></p><p>如何存储微博、微信等社交网络中的好友关系？<br>我们就拿微信举例子吧。我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的<strong>度（degree），就是跟顶点相连接的边的条数</strong>。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-bad63fe33a968ffdab71d4997e4a0a65-unknown_filename.18-fe507b.png" alt="unknown_filename.18"></p><p>如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B 指向 A 的边。我们把这种边有方向的图叫作“<strong>有向图</strong>”。以此类推，<strong>我们把边没有方向的图就叫作“无向图”</strong>。</p><p>无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为入度（In-degree）和出度（Out-degree）。</p><p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p><p><strong>带权图（weighted graph）</strong>。在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-65ed79543f9edc84fcccf66e8fc0363a-unknown_filename.10-8b4b95.png" alt="unknown_filename.10"></p><p>掌握了图的概念之后，我们再来看下，如何在内存中存储图这种数据结构呢？</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-4a9af6f7051192e56b5ff34d2795c902-unknown_filename.4-e34d5f.png" alt="unknown_filename.4"><br>我们存储的是<strong>稀疏图</strong>（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p><h4 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-8b6bdb3ec5f9523c13718bb9f52574c0-unknown_filename.14-6c050e.png" alt="unknown_filename.14"></p><p>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。<br>邻接表存储起来比较节省空间，但是使用起来就比较耗时间。<br>我们可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。</p><p>实现无向图</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> &#123; <span class="hljs-comment">// 无向图</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> v; <span class="hljs-comment">// 顶点的个数</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v</span>)</span> &#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;<br>      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> s, <span class="hljs-built_in">int</span> t</span>)</span> &#123; <span class="hljs-comment">// 无向图一条边存两次</span><br>    adj[s].<span class="hljs-keyword">add</span>(t);<br>    adj[t].<span class="hljs-keyword">add</span>(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><strong>广度优先搜索（BFS）</strong></p><p>直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-b2863aa034a69f9036bce2c796a97a6b-unknown_filename.17-3aa5e4.png" alt="unknown_filename.17"></p><p><strong>深度优先搜索（DFS）</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.resources/2023/09/15/17-44-15-4fefd6039d1b5ace375660a1df20ec5f-unknown_filename.6-d912cd.png" alt="unknown_filename.6"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式3（行为模式）</title>
    <link href="/2025/12/b54530ecb59a.html"/>
    <url>/2025/12/b54530ecb59a.html</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式3（行为模式）"><a href="#设计模式3（行为模式）" class="headerlink" title="设计模式3（行为模式）"></a>设计模式3（行为模式）</h1><p>行为模式<br>这类模式负责<em>对象间的高效沟通和职责委派</em>。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%88%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/15/18-50-23-600c6e2c4ca0a428d53d70ef3e1799e8-unknown_filename.4-0af727.png" alt="unknown_filename.4"></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>用得少</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>特点是实现 Iterable 接口，通过 next 的方式获取集合元素，同时具备对元素的删除等操作</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式要解决的就是复杂功能应用之间的重复调用，在这中间添加一层中介者包装服务，对外提供简单、通用、易扩展的服务能力。<br>这种模式的设计满足了; 单一职责 和 开闭原则，也就符合了迪米特原则，即越少人知道越好。外部的人只需要按照需求进行调用，不需要知道具体的是如何实现的<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%88%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/15/18-50-23-4cce113690ec600cbda82a7435de1804-unknown_filename.5-0f2da6.png" alt="unknown_filename.5|474x0"></p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>（AsnycTask、Activity）<br>提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%88%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/15/18-50-23-8d6574d2eec7c286c86c1f218ae05dd3-unknown_filename-d9a9f2.jpeg" alt="unknown_filename|669x0"></p><p>使用场景</p><p>1)多个子类有公有的方法，并且逻辑基本相同时<br>2)重要、复杂的算法，可以把核心算法设计为模板方法<br>3)重构时，模板方法模式是一个经常使用的模式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractWork</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUp</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;起床啦！&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goToWork</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getOffWork</span>()</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * TemplateMethod，大家都拥有共同的执行步骤</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">void</span> <span class="hljs-title">newDay</span>()</span> &#123;<br>        getUp();<br>        goToWork();<br>        work();<br>        getOffWork();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StaffWork</span> <span class="hljs-title">extends</span> <span class="hljs-title">AbstractWork</span> &#123;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goToWork</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;员工做公交去上班&quot;</span>);<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;员工处理具体工作&quot;</span>);<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getOffWork</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;员工做公交下班&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>（Volley）<strong>替换if else</strong><br>它<em>定义了一些算法，分别封装起来。让它们之间可以互相替换，此模式让算法的变化</em>，不会影响到使用算法的调用者。<br>一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式避免在类中使用大量的条件语句。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%88%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/15/18-50-23-666891bdb847f6f46cf006bea500d375-unknown_filename.1-8455d4.jpeg" alt="unknown_filename.1|630x0"></p><p>strategy和concrete是继承关系，三角箭头实线<br>context和strategy是聚合关系，空心菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractStrategy</span> &#123;<br>    <span class="hljs-comment">//按距离来计算价格</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km)</span> &#123;<br>        <span class="hljs-keyword">return</span> km;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxiStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km)</span> &#123;<br>        <span class="hljs-keyword">return</span> km * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> AbstractStrategy strategy;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(AbstractStrategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calclatePrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km)</span> &#123;<br>        <span class="hljs-keyword">return</span> strategy.calculatePrice(km);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] strings)</span> &#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        calculator.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BusStrategy</span>());<br><span class="hljs-comment">//        calculator.setStrategy(new TaxiStrategy());</span><br>        System.out.println(<span class="hljs-string">&quot;公交车20km价格：&quot;</span> + calculator.calclatePrice(<span class="hljs-number">20</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>传统写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//PriceCalculator 类很明显的问题就是并不是单一职责，首先它承担计算公交车和地铁乘坐价格的职责，</span><br>    <span class="hljs-comment">//另一个问题就是通过if-else的形式来判断使用哪种计算形式。当我们增加一种出行方式时，如出租车，</span><br>    <span class="hljs-comment">//那么我们就需要在PriceCalculator 中增加一个方法来计算出租车出行的价格，并且在calculatePrice(int km, int type)函数增加一个判断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriceCalculator</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TAXI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUBWAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] strings)</span> &#123;<br>            <span class="hljs-type">PriceCalculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriceCalculator</span>();<br>            System.out.println(<span class="hljs-string">&quot;做20km公交票价：&quot;</span> + calculator.calculatePrice(<span class="hljs-number">20</span>, BUS));<br>            System.out.println(<span class="hljs-string">&quot;做20km地铁票价：&quot;</span> + calculator.calculatePrice(<span class="hljs-number">20</span>, SUBWAY));<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">busPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km)</span> &#123;<br>            <span class="hljs-keyword">return</span> km * <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">taxiPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km)</span> &#123;<br>            <span class="hljs-keyword">return</span> km * <span class="hljs-number">7</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 根据不同类型计算</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">int</span> km, <span class="hljs-type">int</span> type)</span> &#123;<br>            <span class="hljs-keyword">if</span> (type == BUS) &#123;<br>                <span class="hljs-keyword">return</span> busPrice(km);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == SUBWAY) &#123;<br>                <span class="hljs-keyword">return</span> taxiPrice(km);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都可得到通知并被自动更新。（android中的回调模式、listview的notifyDataChanged、rxjava）</p><p>观察者模式在android中的实际运用：回调模式</p><p>回调模式：实现了抽象类／接口的实例实现了父类的提供的抽象方法后，将该方法交还给父类来处理。<br>例如：通过 setOnClickListener() 方法，Button 持有 OnClickListener 的引用（这一过程没有在图上画出）；当用户点击时，Button 自动调用 OnClickListener 的 onClick() 方法。另外，如果把这张图中的概念抽象出来</p><p>（Button（view） -&gt; 被观察者、OnClickListener -&gt; 观察者、setOnClickListener() -&gt; 订阅，onClick() -&gt; 事件），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%88%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/15/18-50-23-56a18af8474f848c5ef75d4de803016c-unknown_filename.2-d498ea.jpeg" alt="unknown_filename.2|438x0"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverPattern</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>        <span class="hljs-comment">// 观察者状态</span><br>        <span class="hljs-keyword">private</span> String observerState;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span> &#123;<br>            <span class="hljs-comment">// 更新观察者状态，让它与目标状态一致</span><br>            observerState = state;<br>            System.out.println(<span class="hljs-string">&quot;ConcreteObserver State :&quot;</span> + observerState);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 抽象订阅者（目标者）</span><br><span class="hljs-comment"> * 被观察者</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>        <span class="hljs-comment">// 保存注册的观察者对象</span><br>        <span class="hljs-keyword">private</span> List&lt;Observer&gt; mObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//注册观察者对象</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>            mObservers.add(observer);<br>            System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//注销观察者对象</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>            mObservers.remove(observer);<br>        &#125;<br><br>        <span class="hljs-comment">// 通知所有注册的观察者对象</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nodifyObservers</span><span class="hljs-params">(String newState)</span> &#123;<br>            <span class="hljs-keyword">for</span> (Observer observer : mObservers) &#123;<br>                observer.update(newState);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String state;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> state;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span> &#123;<br>            state = newState;<br>            System.out.println(<span class="hljs-string">&quot;ConcreteSubject State:&quot;</span> + state);<br>            <span class="hljs-comment">//状态发生改变，通知观察者</span><br>            nodifyObservers(state);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ObserverPattern</span> <span class="hljs-variable">observerPattern</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverPattern</span>();<br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">concreteSubject</span> <span class="hljs-operator">=</span> observerPattern.<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-type">Observer</span> <span class="hljs-variable">observer1</span> <span class="hljs-operator">=</span> observerPattern.<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br>        <span class="hljs-type">Observer</span> <span class="hljs-variable">observer2</span> <span class="hljs-operator">=</span> observerPattern.<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br>        <span class="hljs-comment">// 将观察者对象注册到目标对象上</span><br>        concreteSubject.attach(observer1);<br>        concreteSubject.attach(observer2);<br>        <span class="hljs-comment">// 改变目标对象的状态</span><br>        concreteSubject.change(<span class="hljs-string">&quot;I change&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>安卓自己的观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Observable observable, Object o)</span> &#123;<br>        Message  message=(Message)o;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageObservable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.util.Observable &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerMessageObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>            addObserver(observer);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unRegisterMessageObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>            addObserver(observer);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(Message message)</span> &#123;<br>            setChanged();<br>            notifyObservers(message);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>（try-catch、有序广播、viewgroup 事件传递）<br>一个请求有多个对象来处理，这些对象是一条链，但具体由哪个对象来处理，根据条件判断来确定，如果不能处理会传递给该链中的下一个对象，直到有对象处理它为止</p><p>使用场景</p><ul><li>有<em>多个对象可以处理同一个请求</em>，具体哪个对象处理该请求待运行时刻再确定</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%88%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/15/18-50-23-50e09a1ec465bca3709314c67bf7b80e-unknown_filename.3-03b73a.jpeg" alt="unknown_filename.3|601x0"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chain</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Handler nextHandler;<br><br>        <span class="hljs-comment">// 当前领导能审批通过的最多天数</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> maxDay;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-type">int</span> maxDay)</span> &#123;<br>            <span class="hljs-built_in">this</span>.maxDay = maxDay;<br>        &#125;<br><br>        <span class="hljs-comment">//设置责任链中下一个处理请求的对象</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextHandler</span><span class="hljs-params">(Handler handler)</span> &#123;<br>            nextHandler = handler;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            <span class="hljs-keyword">if</span> (day &lt;= maxDay) &#123;<br>                reply(day);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nextHandler != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//审批权限不够，继续上报</span><br>                    nextHandler.handleRequest(day);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;没有更高的领导审批了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reply</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProjectManager</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            <span class="hljs-built_in">super</span>(day);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reply</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            System.out.println(day + <span class="hljs-string">&quot;天请假，项目经理直接审批通过&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepartmentManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DepartmentManager</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            <span class="hljs-built_in">super</span>(day);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reply</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            System.out.println(day + <span class="hljs-string">&quot;天请假，部门经理审批通过&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">GeneralManager</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            <span class="hljs-built_in">super</span>(day);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reply</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>            System.out.println(day + <span class="hljs-string">&quot;天请假，总经理直接审批通过&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] strings)</span> &#123;<br>        <span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>();<br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">projectManager</span> <span class="hljs-operator">=</span> chain.<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProjectManager</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">departmentManager</span> <span class="hljs-operator">=</span> chain.<span class="hljs-keyword">new</span> <span class="hljs-title class_">DepartmentManager</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Handler</span> <span class="hljs-variable">generalManager</span> <span class="hljs-operator">=</span> chain.<span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneralManager</span>(<span class="hljs-number">15</span>);<br>        <span class="hljs-comment">//创建职责链</span><br>        projectManager.setNextHandler(departmentManager);<br>        departmentManager.setNextHandler(generalManager);<br>        <span class="hljs-comment">//发起请假请求</span><br>        projectManager.handleRequest(<span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式2（结构型模式）</title>
    <link href="/2025/12/63a311243331.html"/>
    <url>/2025/12/63a311243331.html</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式2（结构型模式）"><a href="#设计模式2（结构型模式）" class="headerlink" title="设计模式2（结构型模式）"></a>设计模式2（结构型模式）</h1><p>结构型模式<br>这类模式介绍<em>如何将对象和类组装成较大的结构</em>，并同时保持结构的灵活和高效。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-bc927085a6f00fded5d9a6df0634add0-unknown_filename.4-3597cc.png" alt="unknown_filename.4|209x0"></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式的主要作用就是通过将抽象部分与实现部分分离，把多种可匹配的使用进行组合。说白了核心实现也就是在 <em>A 类中含有 B 类接口，通过构造函数传递 B 类的实现</em>，这个 B 类就是设计的桥。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-b925500bf6750546cc0e528275ecdd9d-unknown_filename.5-e4206c.png" alt="unknown_filename.5|600"></p><p>从上面的ifelse方式实现来看，这是两种不同类型的相互组合。那么就可以把<strong>支付方式和支付模式进行分离通过抽象类依赖实现类的方式进行桥接</strong>，通过这样的拆分后支付与模式其实是可以单独使用的，当需要组合时候只需要把模式传递给支付即可。<br>桥接模式的关键是选择的桥接点拆分，是否可以找到这样类似的相互组合，如果没有就不必要非得使用桥接模式。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> void test_pay() &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；微信支付、人脸方式。&quot;</span>);<br>    Pay wxPay = <span class="hljs-keyword">new</span> <span class="hljs-type">WxPay</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PayFaceMode</span>());<br>    wxPay.transfer(<span class="hljs-string">&quot;weixin_1092033111&quot;</span>, <span class="hljs-string">&quot;100000109893&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">BigDecimal</span>(<span class="hljs-number">100</span>));<br><br>    System.out.println(<span class="hljs-string">&quot;\r\n模拟测试场景；支付宝支付、指纹方式。&quot;</span>);<br>    Pay zfbPay = <span class="hljs-keyword">new</span> <span class="hljs-type">ZfbPay</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PayFingerprintMode</span>());<br>    zfbPay.transfer(<span class="hljs-string">&quot;jlu19dlxo111&quot;</span>,<span class="hljs-string">&quot;100000109894&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-type">BigDecimal</span>(<span class="hljs-number">100</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-830c5d571bf35ea69e8a79ddaf295f26-unknown_filename.6-1946e6.png" alt="unknown_filename.6"></p><h2 id="外观模式（门面模式）"><a href="#外观模式（门面模式）" class="headerlink" title="外观模式（门面模式）"></a>外观模式（门面模式）</h2><p>（context）<br>外观模式的主要目的在于 <strong>让外部减少与 子系统内部的多个模块的交互</strong>，从而让外部能够更简单得使用子系统。它负责把客户端的请求转发给子系统内部的各个模块进行处理。<br>简单点理解就是，通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以通过调用外观类的方法来调用内部子系统中所有方法。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-a2c083493ee185d0ab0efda1a1894592-unknown_filename.2-65a723.jpeg" alt="unknown_filename.2|639x0"></p><p>facade和module是合成关系</p><ul><li>由于 Facade 类封装了各个模块交互的过程，如果今后内部模块调用关系发生了变化，只需要修改 Facade 实现就可以了。</li><li>Facade实现是可以被多个客户端调用的</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ModuleA</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFuncA</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;This is Function From 改变了&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ModuleB</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFuncB</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;This is Function From ModuleB&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> &#123;<br>    <span class="hljs-keyword">private</span> ModuleA moduleA = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> ModuleB moduleB = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> ModuleC moduleC = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Facade mFacade = <span class="hljs-literal">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Facade</span>()</span>&#123;<br>        moduleA = <span class="hljs-keyword">new</span> ModuleA();<br>        moduleB = <span class="hljs-keyword">new</span> ModuleB();<br>        moduleC = <span class="hljs-keyword">new</span> ModuleC();<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Facade <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(mFacade == <span class="hljs-literal">null</span>) &#123;<br>            mFacade = <span class="hljs-keyword">new</span> Facade();<br>        &#125;<br>        <span class="hljs-keyword">return</span> mFacade;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOperation</span>()</span> &#123;<br>        moduleA.testFuncA();<br>        moduleB.testFuncB();<br>        moduleC.testFuncC();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String arg[]</span>)</span> &#123;<br>        Facade.getInstance().testOperation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>（string）</p><p>享元的目的是为了减少不必要的内存消耗，将多个对象的访问集中起来，不必为每个访问者创建一个单独的对象，以此来降低内存的消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyWeight</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;<br>        <span class="hljs-keyword">private</span> String myChar;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyString</span><span class="hljs-params">(String myChar)</span> &#123;<br>            <span class="hljs-built_in">this</span>.myChar = myChar;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(myChar);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCharacterFactory</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Map&lt;String, MyString&gt; pool;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCharacterFatory</span><span class="hljs-params">()</span> &#123;<br>            pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> MyString <span class="hljs-title function_">getMyCharacte</span><span class="hljs-params">(String strig)</span> &#123;<br>            <span class="hljs-type">MyString</span> <span class="hljs-variable">myString</span> <span class="hljs-operator">=</span> pool.get(strig);<br>            <span class="hljs-keyword">if</span> (myString == <span class="hljs-literal">null</span>) &#123;<br>                myString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyString</span>(strig);<br>                pool.put(strig, myString);<br>            &#125;<br>            <span class="hljs-keyword">return</span> myString;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyCharacterFactory</span> <span class="hljs-variable">myCharacterFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCharacterFactory</span>();<br>        <span class="hljs-type">MyString</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> myCharacterFactory.getMyCharacte(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">MyString</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> myCharacterFactory.getMyCharacte(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-type">MyString</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> myCharacterFactory.getMyCharacte(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">MyString</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> myCharacterFactory.getMyCharacte(<span class="hljs-string">&quot;d&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (a == a1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;true&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>通过代理对象访问目标对象.这样做的好处是：<em>可以在目标对象实现的基础上，扩展目标对象的功能。或者交给另一个类去做事情</em>。<br>代理对象拦截真正对象的方法调用，在真正的对象调用前／后实现自己的逻辑调用<br>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。</p><p>动态代理的用途与装饰模式很相似，就是为了对某个对象进行增强，还有交给另一个去做事。所有使用装饰者模式的案例都可以使用动态代理来替换。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-782e0ca884abd8b94d3639ab8f375b0c-unknown_filename-6f695e.jpeg" alt="unknown_filename|708x0"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* subject（抽象主题角色）：</span><br><span class="hljs-comment">* 真实主题与代理主题的共同接口。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellBook</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ReaISubject（真实主题角色）：</span><br><span class="hljs-comment">* 定义了代理角色所代表的真实对象。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellBook</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;出版社卖书&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Proxy（代理主题角色）：</span><br><span class="hljs-comment">* 含有对真实主题角色的引用，代理角色通常在将客</span><br><span class="hljs-comment">* 户端调用传递给真实主题对象之前或者之后执行某些</span><br><span class="hljs-comment">* 操作，而不是单纯返回真实的对象。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellBook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (realSubject == <span class="hljs-literal">null</span>) &#123;<br>            realSubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        &#125;<br>        sale();<br>        realSubject.sellBook();<br>        give();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sale</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打折&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">give</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;送优惠券&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//静态代理（我们自己静态定义的代理类)</span><br>        <span class="hljs-type">ProxySubject</span> <span class="hljs-variable">proxySubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySubject</span>();<br>        proxySubject.sellBook();<br><br>        <span class="hljs-comment">//动态代理(通过程序动态生成代理类，该代理类不是我们自己定义的。而是由程序自动生成)</span><br>        <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        <span class="hljs-type">MyHandler</span> <span class="hljs-variable">myHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHandler</span>();<br>        myHandler.setProxySubject(realSubject);<br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),<br>                realSubject.getClass().getInterfaces(), myHandler);<br>        subject.sellBook();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProxySubject</span><span class="hljs-params">(RealSubject realSubject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.realSubject = realSubject;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy  　指代我们所代理的那个真实对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method   指代的是我们所要调用真实对象的某个方法的Method对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args   　指代的是调用真实对象某个方法时接受的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        sale();<br>        proxy = method.invoke(realSubject, args);<br>        give();<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sale</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打折&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">give</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;送优惠券&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><strong>将对象组合成树形结构</strong>，使得使用者可以用 <strong>一致的方式</strong> 处理单个对象和对象的组合。<br>客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br>![[Pasted image 20250902154220.png]]</p><p>文件系统</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 抽象组件</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileSystemComponent</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 叶子节点：文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String) : FileSystemComponent &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;File: <span class="hljs-variable">$name</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 容器节点：文件夹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Folder</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String) : FileSystemComponent &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> children = mutableListOf&lt;FileSystemComponent&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(component: <span class="hljs-type">FileSystemComponent</span>)</span></span> &#123;<br>        children.add(component)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Folder: <span class="hljs-variable">$name</span>&quot;</span>)<br>        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> children) &#123;<br>            child.show()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> root = Folder(<span class="hljs-string">&quot;root&quot;</span>)<br>    <span class="hljs-keyword">val</span> docs = Folder(<span class="hljs-string">&quot;docs&quot;</span>)<br>    <span class="hljs-keyword">val</span> img = Folder(<span class="hljs-string">&quot;images&quot;</span>)<br><br>    <span class="hljs-keyword">val</span> file1 = File(<span class="hljs-string">&quot;resume.doc&quot;</span>)<br>    <span class="hljs-keyword">val</span> file2 = File(<span class="hljs-string">&quot;cover.jpg&quot;</span>)<br><br>    docs.add(file1)<br>    img.add(file2)<br>    root.add(docs)<br>    root.add(img)<br><br>    root.show()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>(Collections 工具类、I&#x2F;O、context)</p><p>👉 <strong>在不修改原有类的情况下，动态地给对象添加功能</strong>。用“包装”的方式扩展对象的功能，比继承更灵活。<br>![[Pasted image 20250902154525.png]]</p><p>咖啡加料</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 抽象组件</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>: String<br>&#125;<br><br><span class="hljs-comment">// 具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCoffee</span> : <span class="hljs-type">Coffee</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span> = <span class="hljs-number">5.0</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Simple Coffee&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 抽象装饰类</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeDecorator</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coffee: Coffee) : Coffee &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span> = coffee.cost()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span> = coffee.description()<br>&#125;<br><br><span class="hljs-comment">// 具体装饰类：加牛奶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkDecorator</span>(coffee: Coffee) : CoffeeDecorator(coffee) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">super</span>.cost() + <span class="hljs-number">2.0</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">super</span>.description() + <span class="hljs-string">&quot;, Milk&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 具体装饰类：加糖</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarDecorator</span>(coffee: Coffee) : CoffeeDecorator(coffee) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">super</span>.cost() + <span class="hljs-number">1.0</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">super</span>.description() + <span class="hljs-string">&quot;, Sugar&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> coffee: Coffee = SimpleCoffee()<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;coffee.description()&#125;</span> = <span class="hljs-subst">$&#123;coffee.cost()&#125;</span>&quot;</span>)<br><br>    coffee = MilkDecorator(coffee)<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;coffee.description()&#125;</span> = <span class="hljs-subst">$&#123;coffee.cost()&#125;</span>&quot;</span>)<br><br>    coffee = SugarDecorator(coffee)<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;coffee.description()&#125;</span> = <span class="hljs-subst">$&#123;coffee.cost()&#125;</span>&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Simple Coffee &#x3D; 5.0<br>Simple Coffee, Milk &#x3D; 7.0<br>Simple Coffee, Milk, Sugar &#x3D; 8.0</p><ul><li><strong>组合模式</strong>：关注 <strong>整体与部分的层级结构</strong>（树形结构）。</li><li><strong>装饰模式</strong>：关注 <strong>给对象动态地附加新功能</strong>（链式包装）。</li></ul><h2 id="适配器（adapter）模式"><a href="#适配器（adapter）模式" class="headerlink" title="适配器（adapter）模式"></a>适配器（adapter）模式</h2><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。<br>适配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在。</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-e54a10f9974ee4bcf0f199276497caf6-unknown_filename.8-0c3535.png" alt="unknown_filename.8|196x0"></p><p>原理：通过继承来实现适配器功能。</p><p>类适配器使用对象继承的方式，是静态的定义方式<br>对于类适配器，适配器可以重定义Adaptee的部分行为，使Adaptee有了sampleOperation2（）<br>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得 到 Adaptee<br>对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和 Adaptee的子类一起工作 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span>()</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sampleOperation1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-title">implements</span> <span class="hljs-title">Target</span> &#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sampleOperation2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Adapter adapter = <span class="hljs-keyword">new</span> Adapter();<br>        adapter.sampleOperation1();<br>        adapter.sampleOperation2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。</p><p>对象适配器使用对象组合的方式，是动态组合的方式</p><p>对于对象适配器，一个适配器（adaptee）可以把多种不同的源适配到同一个目标</p><p>对于对象适配器，要重定义Adaptee的行为比较困难</p><p>对于对象适配器，需要额外的引用来间接得到Adaptee。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/15-44-41-8be3a871128050ebfb9589126324114d-unknown_filename.7-7564b7.png" alt="unknown_filename.7|332x0"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span>()</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sampleOperation1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-title">implements</span> <span class="hljs-title">Target</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Adaptee mAdaptee;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span>(<span class="hljs-params">Adaptee adaptee</span>)</span> &#123;<br>        mAdaptee = adaptee;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span>()</span> &#123;<br>        mAdaptee.sampleOperation1();<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sampleOperation2&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Adapter adapter =<span class="hljs-keyword">new</span> Adapter(<span class="hljs-keyword">new</span> Adaptee());<br>        adapter.sampleOperation1();<br>        adapter.sampleOperation2();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>适配器模式不并是那种会让架构变得更合理的模式，更多的时候它只是充当救火队员的角色，帮助解决由于前期架构设计不合理导致的接口不匹配的问题。更好的做法是在设计的时候就尽量把以后可能出现的情况多考虑一些，例如这个例子，ServerFirst没有PlayerCount 方法，可以写一个适配器对象，实现PlayerCount 接口，新接口中调用旧接口的方法</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/9400141">Java设计模式透析之 —— 适配器(Adapter)_adpter注解 java-CSDN博客</a></p><h2 id="委托模式（没有这种模式）"><a href="#委托模式（没有这种模式）" class="headerlink" title="委托模式（没有这种模式）"></a>委托模式（没有这种模式）</h2><p>委托（Delegate）是 Kotlin 的一种语言特性，用于更加优雅地实现代理模式。</p><p>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟 mixin。</p><h3 id="简单的-Java例子"><a href="#简单的-Java例子" class="headerlink" title="简单的 Java例子"></a>简单的 Java例子</h3><p>在这个例子里，类模拟打印机Printer拥有针式打印机RealPrinter的实例，Printer拥有的方法print()将处理转交给RealPrinter的方法print()。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealPrinter</span> &#123; <span class="hljs-comment">// the &quot;delegate&quot;</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>() &#123;<br>       System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;something&quot;</span>);<br>     &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123; <span class="hljs-comment">// the &quot;delegator&quot;</span><br>     RealPrinter p = <span class="hljs-keyword">new</span> RealPrinter(); <span class="hljs-comment">// create the delegate</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>() &#123;<br>       p.<span class="hljs-keyword">print</span>(); <span class="hljs-comment">// delegation</span><br>     &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>     <span class="hljs-comment">// to the outside world it looks like Printer actually prints.</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>         Printer printer = <span class="hljs-keyword">new</span> Printer();<br>         printer.<span class="hljs-keyword">print</span>();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂的-Java-例子"><a href="#复杂的-Java-例子" class="headerlink" title="复杂的 Java 例子"></a>复杂的 Java 例子</h3><p>通过使用接口，委托可以做到类型安全并且更加灵活。在这个例子里，类别C可以委托类别A或类别B，类别C拥有方法使自己可以在类别A或类别B间选择。因为类别A或类别B必须实现接口I规定的方法，所以在这里委托是类型安全的。这个例子显示出委托的缺点是需要更多的代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">I</span> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>;<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span>()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">implements</span> <span class="hljs-title">I</span> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span> &#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;A: doing f()&quot;</span>); &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span>()</span> &#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;A: doing g()&quot;</span>); &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">implements</span> <span class="hljs-title">I</span> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span> &#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;B: doing f()&quot;</span>); &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span>()</span> &#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;B: doing g()&quot;</span>); &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-title">implements</span> <span class="hljs-title">I</span> &#123;<br>     <span class="hljs-comment">// delegation</span><br>     I i = <span class="hljs-keyword">new</span> A();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span> &#123; i.f(); &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span>()</span> &#123; i.g(); &#125;<br>     <span class="hljs-comment">// normal attributes</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toA</span>()</span> &#123; i = <span class="hljs-keyword">new</span> A(); &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toB</span>()</span> &#123; i = <span class="hljs-keyword">new</span> B(); &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>         C c = <span class="hljs-keyword">new</span> C();<br>         c.f();     <span class="hljs-comment">// output: A: doing f()</span><br>         c.g();     <span class="hljs-comment">// output: A: doing g()</span><br>         c.toB();<br>         c.f();     <span class="hljs-comment">// output: B: doing f()</span><br>         c.g();     <span class="hljs-comment">// output: B: doing g()</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式1（创建型模式）</title>
    <link href="/2025/12/5d0dd2c5d5a9.html"/>
    <url>/2025/12/5d0dd2c5d5a9.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="六原则一法则"><a href="#六原则一法则" class="headerlink" title="六原则一法则"></a>六原则一法则</h2><p>- 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）<br>职责越单一影响到外层模块的可能性就越小，这样出错的概率也就越低。</p><p>- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） </p><p>- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） </p><p>- 里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） </p><p>- 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） </p><p>- 合成聚合复用原则：优先使用聚合或合成关系复用代码。</p><p>通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，因为继承将父类的实现暴漏给子类了，父类发生该改变，子类也不得不发生改变。</p><p>- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/09-52-31-41188b3cfb9c5267a5d92cae47123d9f-unknown_filename.1-7b6952.png" alt="unknown_filename.1|379"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/09-52-31-3c35ce4d4e86119c03b1cce08a834b24-unknown_filename-c9e7a1.png" alt="unknown_filename|379"></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 </p><h2 id="项目中用到哪些模式"><a href="#项目中用到哪些模式" class="headerlink" title="项目中用到哪些模式"></a>项目中用到哪些模式</h2><ul><li>单例、建造者、外观、责任链（桥统一）、策略（桥重构）、模板方法</li><li>首先这个业务，使用责任链模式，肯定是不合适的，因为弹窗之间的耦合性很低，并没有什么明确的上下游关系</li><li>做之前先想想技术方案、以后的扩展，多思考<br>[[6-桥统一重构技术文档]]</li></ul><p>设计模式运用好的文章：应用策略和责任链<br><a href="https://juejin.cn/post/6999875193082478600?utm_source=gold_browser_extension#comment">https://juejin.cn/post/6999875193082478600?utm_source&#x3D;gold_browser_extension</a><br><a href="https://juejin.cn/post/6999914854618234888?utm_source=gold_browser_extension">https://juejin.cn/post/6999914854618234888?utm_source=gold_browser_extension</a></p><p>在拿到原始需求时，不要上来就肝代码，而是 <strong>对需求进行拆解、分析、假设和思考</strong>。</p><h2 id="哪些源码用到了设计模式"><a href="#哪些源码用到了设计模式" class="headerlink" title="哪些源码用到了设计模式"></a>哪些源码用到了设计模式</h2><p>责任链模式：try-catch、有序广播、viewgroup事件传递；<br>建造者模式：AlertDialog<br>装饰模式：Collections工具类、I&#x2F;O、context；<br>观察者模式：android中的回调模式、listview的notifyDataChanged、rxjava；<br>外观模式：context；<br>模板方法模式：AsnycTask、Activity；<br>策略：动画中的时间插值器，recycleview中不同的apdater、Volley</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>创建型：<strong>怎么创建对象</strong>    工厂、建造者、单例<br>结构型：描述如何<strong>将类或对象结合在一起形成更大的结构</strong>    享元、外观、组合、代理<br>行为型：对在不同的对象之间<strong>划分责任和算法的抽象化</strong>     策略、责任链、观察者、模版方法</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/09-52-31-43d33b35f2e7c07d5ced7b4ab607b8a5-unknown_filename.6-304f2c.png" alt="unknown_filename.6"></p><h1 id="创建型模型"><a href="#创建型模型" class="headerlink" title="创建型模型"></a>创建型模型</h1><p>这类模式提供创建对象的机制，能够提升已有代码的灵活性和可复用性。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>保证一个类在内存中的对象唯一性。<br>1，不允许其他程序用new创建该类对象。<br>2，在该类创建一个本类实例。<br>3，对外提供一个方法让其他程序可以获取该对象。<br>好处：<br>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销<br>由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间</p><p>饿汉（直接就创建）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HungurySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final HungurySingleton mHungurySingleton = <span class="hljs-keyword">new</span> HungurySingleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungurySingleton</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Singleton is create&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungurySingleton <span class="hljs-title">getHungurySingleton</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> mHungurySingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>懒汉（一开始赖的创建）</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class LazySingleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> <span class="hljs-class">LazySingleton instance;</span><br>   <span class="hljs-keyword"> private</span> LazySingleton() &#123;<br>    &#125;<br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> LazySingleton getInstance() &#123;<br>        // 第一次调用的时候会被初始化<br>       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>LazySingleton();<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>懒汉安全</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class LazySafetySingleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> <span class="hljs-class">LazySafetySingleton instance;</span>  <br>   <span class="hljs-keyword"> private</span> LazySafetySingleton ()&#123;<br>    &#125;<br><br>   //方法中声明synchronized关键字<br>  <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> synchronized LazySafetySingleton getInstance() &#123;<br>    <span class="hljs-built_in"> if </span>(instance == null) &#123;  <br>        <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>LazySafetySingleton();  <br>     &#125;  <br>    <span class="hljs-built_in"> return </span>instance;  <br>   &#125;<br><br>   //同步代码块实现<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>假设没有关键字 volatile 的情况下，两个线程 A、B，都是第一次调用该单例方法，线程 A 先执行 instance &#x3D; new Instance()，该构造方法编译后生成多条字节码指令，由于 JAVA 的指令重排序，可能会先执行 instance 的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后 instance 便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程 B 进入，就会看到一个不为空的但是不完整（没有完成初始化）的 Instance 对象，所以需要加入 volatile 关键字，禁止指令重排序优化，从而安全的实现单例。</p><p>在Java中，一个对象的初始化可以分为三个步骤（以Instance类为例）：</p><ol><li>分配内存空间</li><li>初始化对象（调用构造函数）</li><li>将instance引用指向分配的内存地址</li></ol><p>但是，由于指令重排序（JVM为了优化性能，可能会改变指令的执行顺序），步骤2和步骤3可能会被重排序，导致顺序变成：</p><ol><li>分配内存空间</li><li>将instance引用指向分配的内存地址（此时instance已经不为null了，但对象还没有被初始化）</li><li>初始化对象</li></ol><p>加入同步为了解决多线程安全问题。加入双重判断是为了解决效率问题。 </p><p>不写if语句的话，每次都会判断同步锁，这样写的话只在第一次判断并创建对象。以后在不会执行if里的代码了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DclSingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">DclSingleton</span> <span class="hljs-variable">mInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DclSingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DclSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 避免不必要的同步</span><br>        <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 同步</span><br>            <span class="hljs-keyword">synchronized</span> (DclSingleton.class) &#123;<br>                <span class="hljs-comment">// 在第一次调用时初始化</span><br>                <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-literal">null</span>) &#123;<br>                    mInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DclSingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h3><p>（推荐）<br>静态内部类的优点是：<em>外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存</em>。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs smali">   <span class="hljs-keyword"> public</span> class Singleton&#123;<br>       <span class="hljs-keyword"> private</span> Singleton()&#123;<br>        &#125;<br>       <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> Singleton getInstance()&#123;<br>            // 6行<br>           <span class="hljs-built_in"> return </span>SingletonHelper.instance;<br>        &#125;<br><br>        // 9行<br>       <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> class SingletonHelper&#123;<br>           <span class="hljs-keyword"> private</span><span class="hljs-keyword"> final</span><span class="hljs-keyword"> static</span> InnerHolder<span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>InnerHolder();<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么线程安全</p><ol><li><p><strong>类加载是线程安全的</strong><br> 在 JVM 中，类的加载和初始化过程由 ClassLoader 完成，并且 <strong>同一个类只会被加载一次</strong>。<br> JVM 保证了类初始化的线程安全性（即使多个线程同时触发类的初始化，也会被同步，只有一个线程执行，其他线程阻塞等待）。</p></li><li><p><strong>内部类 SingletonHelper 的初始化时机</strong></p><ul><li>外部类 <code>Singleton</code> 加载时，并不会立刻加载 <code>SingletonHelper</code>。</li><li>当调用 <code>getInstance()</code> 时，才会触发 <code>SingletonHelper</code> 的类加载，从而初始化 <code>instance</code>。</li><li>由于 JVM 保证类初始化的线程安全，所以 <code>instance</code> 只会被安全地创建一次。</li></ul></li></ol><h3 id="枚举单例-推荐"><a href="#枚举单例-推荐" class="headerlink" title="枚举单例 推荐"></a>枚举单例 推荐</h3><p>枚举单利不能反射调用，安全，别的容易被 hook<br>我们知道，枚举在 Java 中与普通的类是一样的，可以有自己的属性，还可以有自己的方法，<strong>最重要的是，枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例（包括反序列化）</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> EnumSingleton &#123;<br>     <span class="hljs-comment">//定义一个枚举的元素，它就是 Singleton 的一个实例</span><br>    INSTANCE;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing</span>()</span> &#123;  <br>         <span class="hljs-comment">// do something...</span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>反编译成 java 代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumSingleton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;EnumSingleton&gt; &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  EnumSingleton  ENUMSINGLETON;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton ENUM$VALUES\[];<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  EnumSingleton[] values ();<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  EnumSingleton <span class="hljs-title function_">valueOf</span> <span class="hljs-params">(String s)</span>;<br>        <span class="hljs-keyword">static</span> &#123;<br>            ENUM$VALUES = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumSingleton</span>[] &#123;<br>                ENUMSINGLETON<br>            &#125;);<br>        &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反编译后，可以看到单例枚举类是一个 final 类，且创建该对象的实例是在一个 static 静态语句块中进行的，根据 JVM 的类加载机制，静态语句块只会在类被加载时执行一次，所以可以线程安全。另外因为单例枚举类反编译后实际上是一个被 final 修饰的类，所以他不能被继承，也就不能创建子类对象。</p><p>总结<br>饿汉：无法对instance实例进行延迟加载</p><p>懒汉：多线程并发情况下无法保证实例的唯一性</p><p>懒汉线程安全：使用synchronized导致性能缺陷</p><p>DCL：JVM即使编译器的指令重排序</p><p>静态内部类／枚举：延迟加载／线程安全／性能优势</p><h2 id="Buidler-（建造者）模式"><a href="#Buidler-（建造者）模式" class="headerlink" title="Buidler （建造者）模式"></a>Buidler （建造者）模式</h2><p>一种创建型的设计模式，通常用来将一个复杂的对象的构造过程分离, 让使用者可以根据需要选择创建过程。另外, 当这个复杂的对象的构造包含很多可选参数时, 也可以使用建造者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlerDialog</span> &#123;<br><br>    <span class="hljs-keyword">private</span>  String title;<br>    <span class="hljs-keyword">private</span>  String message;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlerDialog</span><span class="hljs-params">(Builder builder)</span> &#123;<br><span class="hljs-comment">//        View.inflate()</span><br>        <span class="hljs-built_in">this</span>.title = builder.title;<br>        <span class="hljs-built_in">this</span>.message = builder.message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span>  String title;<br>        <span class="hljs-keyword">private</span>  String message;<br><br>        <span class="hljs-keyword">public</span>  Builder <span class="hljs-title function_">setTitle</span><span class="hljs-params">(String title)</span> &#123;<br>            <span class="hljs-built_in">this</span>.title = title;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span>   Builder <span class="hljs-title function_">setMessage</span><span class="hljs-params">(String message)</span> &#123;<br>            <span class="hljs-built_in">this</span>.message = message;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span>  AlerDialog <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlerDialog</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AlerDialog</span>.Builder().setTitle(<span class="hljs-string">&quot;&quot;</span>).setMessage(<span class="hljs-string">&quot;&quot;</span>).build();<br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式主要解决的问题就是创建重复对象，而这部分对象内容本身比较复杂，生成过程可能从库或者RPC接口中获取数据的耗时较长，因此采用克隆的方式节省时间。<br>在原型模式中所需要的非常重要的手段就是克隆，在需要用到克隆的类中都需要实现implementsCloneable接口<br>不常用</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂类可以<em>根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法</em>，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>工厂类可以根据条件生成不同的子类实例，并且这些对象需要具有共同的接口。<br>工厂方法模式（Factory Method）分为3种：</p><h3 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h3><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/09-52-31-c5f7ca52681bb5deadd5649e7e496f86-unknown_filename.4-ac925e.png" alt="unknown_filename.4|657x0"></p><p>我们以一个例子来讲解：发送短信和发送邮件（具有共同的接口：发送）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sender</span> &#123;  <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 发送邮件或者短消息的共同接口</span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sender</span><span class="hljs-params">()</span>;  <br>&#125;  <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 发送邮件的实现类</span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sender</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sender</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;this is mailsender!&quot;</span>);  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 发送短信的实现类</span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SMSSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sender</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sender</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// TODO Auto-generated method stub  </span><br>        System.out.println(<span class="hljs-string">&quot;this is sms sender!&quot;</span>);  <br>    &#125;  <br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendFactory</span> &#123;  <br>    <span class="hljs-keyword">public</span> Sender <span class="hljs-title function_">produce</span><span class="hljs-params">(String type)</span>&#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;mial&quot;</span>.equals(type)) &#123;  <br>            <span class="hljs-comment">//根据类型生产对象  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MailSender</span>();  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;sms&quot;</span>.equals(type)) &#123;  <br>            <span class="hljs-comment">//根据类型生产对象  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SMSSender</span>();  <br>        &#125;<span class="hljs-keyword">else</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;类型输入错误&quot;</span>);  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><br><br></code></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>这是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/09-52-31-83f664be006f199d962b6e438fccf23b-unknown_filename.2-1e3244.png" alt="unknown_filename.2|678x0"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendFactory</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> Sender <span class="hljs-title function_">produceMail</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MailSender</span>();  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> Sender <span class="hljs-title function_">produceSms</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsSender</span>();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryTest</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">SendFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendFactory</span>();  <br>        <span class="hljs-type">Sender</span> <span class="hljs-variable">sender</span> <span class="hljs-operator">=</span> factory.produceMail();  <br>        sender.Send();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态工厂模式"><a href="#静态工厂模式" class="headerlink" title="静态工厂模式"></a>静态工厂模式</h3><p>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendFactory</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sender <span class="hljs-title function_">produceMail</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MailSender</span>();  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sender <span class="hljs-title function_">produceSms</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsSender</span>();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryTest</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <br>        <span class="hljs-type">Sender</span> <span class="hljs-variable">sender</span> <span class="hljs-operator">=</span> SendFactory.produceMail();  <br>        sender.Send();  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>工厂模式适用于：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>（Abstract Factory）</p><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89.resources/2023/09/18/09-52-31-951f3dbdc68a9ca1afea39f2265b0fa6-unknown_filename.3-76d123.png" alt="unknown_filename.3|724x0"></p><p>这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sender</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Send</span><span class="hljs-params">()</span>;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sender</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Send</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;this is mailsender!&quot;</span>);  <br>    &#125;  <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sender</span> &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Send</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;this is sms sender!&quot;</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-comment">//工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMailFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Provider</span> &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Sender <span class="hljs-title function_">produce</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MailSender</span>();  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendSmsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Provider</span>&#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Sender <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsSender</span>();  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Provider</span> &#123;  <br>    <span class="hljs-keyword">public</span> Sender <span class="hljs-title function_">produce</span><span class="hljs-params">()</span>;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Provider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendMailFactory</span>();  <br>        <span class="hljs-type">Sender</span> <span class="hljs-variable">sender</span> <span class="hljs-operator">=</span> provider.produce();  <br>        sender.Send();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>简单工厂</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FragmentFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Fragment&gt; mFragments = <span class="hljs-keyword">new</span> <span class="hljs-type">HashMap</span>&lt;Integer, Fragment&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fragment createFragment(int position) &#123;<br>        Fragment fragment = <span class="hljs-literal">null</span>;<br>        fragment = mFragments.<span class="hljs-keyword">get</span>(position);  <span class="hljs-comment">//在集合中取出来Fragment</span><br>        <span class="hljs-keyword">if</span> (fragment == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//如果再集合中没有取出来 需要重新创建</span><br>            <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) &#123;<br>                fragment = <span class="hljs-keyword">new</span> <span class="hljs-type">HomeFragment</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>                fragment = <span class="hljs-keyword">new</span> <span class="hljs-type">AppFragment</span>();<br>            &#125; <br>            <span class="hljs-keyword">if</span> (fragment != <span class="hljs-literal">null</span>) &#123;<br>                mFragments.put(position, fragment);<span class="hljs-comment">// 把创建好的Fragment存放到集合中缓存起来</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fragment;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UML类图基本图示法</title>
    <link href="/2025/12/752b114701e5.html"/>
    <url>/2025/12/752b114701e5.html</url>
    
    <content type="html"><![CDATA[<h1 id="UML类图基本图示法"><a href="#UML类图基本图示法" class="headerlink" title="UML类图基本图示法"></a>UML类图基本图示法</h1><h2 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-20-b3bb93510af29df46231a9777701c1e8-20230919142045-7c11c8.png" alt="image.png"></p><p>继承（Is-A）三角箭头<br>实现关系，使用带空心（三角形）箭头的虚线表示<br>泛化关系，使用带空心箭头的实线表示</p><p>关联（Has-A）菱形箭头<br>合成（复合）关系，使用带空心（棱形）箭头的实线表示</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>&#123;<br><br>    <span class="hljs-comment">//鸟有两只翅膀</span><br><br>    <span class="hljs-keyword">private</span> Wing LeftWing;<br><br>    <span class="hljs-keyword">private</span> Wing RightWing;<span class="hljs-comment">//在鸟Bird类中，初始化时，同时实例化翅膀，这样鸟死掉时（鸟实例销毁），翅膀也会跟着死掉（翅膀实例也销毁）</span><br><br>    <span class="hljs-keyword">public</span> Bird()  &#123;<br><br>        LeftWing = <span class="hljs-keyword">new</span> <span class="hljs-type">Wing</span>();<br><br>        RightWing = <span class="hljs-keyword">new</span> <span class="hljs-type">Wing</span>();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>聚合关系，使用带空心箭头的实线表示（鸟群）</p><p>关联关系，使用一根实线表示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Penguin</span> : <span class="hljs-symbol">Bird</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Climate climate; <span class="hljs-comment">//引用了气候对象，但是并没有实例化，实例会从外部传入</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>依赖（Use-A）<br>依赖关系，使用带箭头的虚线表示</p><p>&#x2F;&#x2F;注意动物是抽象类</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>    <span class="hljs-comment">//空气类和水类作为形参出现</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Metabolism</span> <span class="hljs-params">(Oxygen oxygen, Water water)</span>    </span>&#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>UML类图是在面向对象的程序设计中，用来直观描述类与类之间、类与接口之间的关系的图，在面向对象软件的设计与搭建阶段起着关键作用。下图为一幅示例UML类图，其展示了UML类图中的基本图示。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-22-b54a4e9c7ee0499c4d1724fdc8f21ad7-20230919142213-b64ad7.png" alt="image.png"></p><h2 id="二、类与接口的表示方法"><a href="#二、类与接口的表示方法" class="headerlink" title="二、类与接口的表示方法"></a>二、类与接口的表示方法</h2><p>在类图示例中，总共有两种主体：类和接口。在UML类图中，有固定的类和接口的表达方式，如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-22-971f95b397a2d1a486b2da91261b8e2e-20230919142235-74a764.png" alt="image.png"></p><h2 id="三、类与类、类与接口之间的关系"><a href="#三、类与类、类与接口之间的关系" class="headerlink" title="三、类与类、类与接口之间的关系"></a>三、类与类、类与接口之间的关系</h2><p>基本的关系总共有六种：继承、实现接口、关联、聚合、复合、依赖。UML类图通过使用不同的连接线对这6种关系进行区分。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-22-fe10b228c065ac263057dabad6b1b70a-20230919142253-6b89f5.png" alt="image.png"></p><p>不同关系的连接线样式</p><h3 id="1、继承关系"><a href="#1、继承关系" class="headerlink" title="1、继承关系"></a>1、继承关系</h3><p>类A继承类B，意思是说类B是类A的更高一层抽象，此时它们的关系可以通过继承关系表示。就如同鸟和动物的关系，动物是鸟的更高一层抽象，此时我们说鸟继承自动物，于是可以如下表示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-23-a29d2e6f7b9f2428c6509f859f9ac39e-20230919142309-1add10.png" alt="image.png"></p><p>实装到代码即会是如下形式：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span><br><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Bird</span> : <span class="hljs-symbol">Animal</span> //鸟继承动物<br><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、接口实现关系"><a href="#2、接口实现关系" class="headerlink" title="2、接口实现关系"></a>2、接口实现关系</h3><p>类A中实现了接口B中的所有方法，我们称类A与B为接口实现关系。以大雁类和飞翔接口为例，因为并不是所有鸟类都会飞，所以飞翔被抽象成接口，只有会飞的鸟才需要实现它，因此大雁类需要实现飞翔这个接口，它们就是接口实现关系，如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-24-118c8ba309799f77356b5eca7b2c1f1c-20230919142441-fcea46.png" alt="image.png"></p><p>实装到代码即会是如下形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFly</span> <span class="hljs-comment">//飞翔接口</span><br><br>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>()</span>;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">WideGoose</span> : <span class="hljs-title">IFly</span> <span class="hljs-comment">//大雁实现飞翔接口，当然还继承了鸟类，此处未表示</span><br><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、关联关系"><a href="#3、关联关系" class="headerlink" title="3、关联关系"></a>3、关联关系</h3><p>当类A需要从类B那得到信息或者调用类B的的方法时，我们称类A与类B为关联关系。比如企鹅迁徙时需要得知气候信息，故企鹅类与气候类会有关联关系，如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-24-793f574c0e1aabd715a5a2ed8ddbb216-20230919142424-e06ed3.png" alt="image.png"></p><p>实装到代码就是这个样子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Penguin</span> : <span class="hljs-symbol">Bird</span><br><br>&#123;<br><br><span class="hljs-keyword">private</span> Climate climate; <span class="hljs-comment">//引用了气候对象，但是并没有实例化，实例会从外部传入</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、聚合关系"><a href="#4、聚合关系" class="headerlink" title="4、聚合关系"></a>4、聚合关系</h3><p>当类A由多个类B聚合而成，我们称它们满足聚合关系。以大雁类和雁群类为例，雁群由多只大雁组成，这就是聚合。“_聚合是一种弱的拥有‘关系’，体现就是A对象可以包含B对象，但B对象不是A对象的一部分”_——《设计模式解析》（第二版）。同样以大雁举例，大雁不会因为离开雁群就不能独自存在下去，即大雁可以脱离雁群独立存在，不会因为雁群的解散就死亡，这就是雁群对于大雁的弱的拥有关系。这与后面的“复合关系”是形成鲜明对比的，聚合关系如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-25-567f05fce4436f9cfecbedf2eff23b34-20230919142525-243d3f.png" alt="image.png"></p><p>实装到代码是这个样子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">WideGooseAggregate</span><br><br>&#123;<br><br><span class="hljs-comment">//大雁数组对象，注意并不是在雁群类中进行大雁的实例化，因为雁群解散（即销毁雁群实例）时，大雁不应该跟着死亡（即大雁实例们不应该被销毁）</span><br><br><span class="hljs-keyword">private</span> WideGoose[] arraryWideGoose;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5、复合关系"><a href="#5、复合关系" class="headerlink" title="5、复合关系"></a>5、复合关系</h3><p>复合关系可以看成聚合关系的加强版。_“复合时一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样”_——《设计模式解析》（第二版） 。拿鸟和翅膀的关系举例，鸟和翅膀的生命周期是相同的（鸟死了，翅膀也会失去生命力），所以鸟和翅膀是复合关系，同时一只鸟具有两只翅膀，这也可以通过在复合连接线两端添加被称为“基数”的数字表现出来，如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-25-67f5612012be8e8be0e39996a31fb1b6-20230919142540-c94d69.png" alt="image.png"></p><p>实装到代码就是这个样子：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span><br><span class="hljs-title class_"></span><br><span class="hljs-title class_"></span>&#123;<br><br><span class="hljs-comment">//鸟有两只翅膀</span><br><br><span class="hljs-keyword">private</span> Wing LeftWing;<br><br><span class="hljs-keyword">private</span> Wing RightWing;<span class="hljs-comment">//在鸟Bird类中，初始化时，同时实例化翅膀，这样鸟死掉时（鸟实例销毁），翅膀也会跟着死掉（翅膀实例也销毁）</span><br><br><span class="hljs-keyword">public</span> Bird()<br><br>&#123;<br><br>LeftWing = <span class="hljs-keyword">new</span> <span class="hljs-type">Wing</span>();<br><br>RightWing = <span class="hljs-keyword">new</span> <span class="hljs-type">Wing</span>();<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、依赖关系"><a href="#6、依赖关系" class="headerlink" title="6、依赖关系"></a>6、依赖关系</h3><p>“动物几大特征，比如有新陈代谢，能繁殖。而动物要有生命力，需要氧气、水以及食物等。也就是说，动物依赖于氧气和水。它们之间是依赖关系（Dependency）”——《大话设计模式》。一般来说，当类A关联类B，类B的引用一般会在类A中作为全局变量出现；而类A依赖类B，类B一般会在类A的方法中作为形参出现。依赖关系如下图所示：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-09-19-14-25-9c3b64f3f9a32c21c51d798944b8c2b5-20230919142553-557c11.png" alt="image.png"></p><p>表现为代码，就是下面这个样子：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//注意动物是抽象类</span><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"></span>&#123;<br><br><span class="hljs-comment">//空气类和水类作为形参出现</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Metabolism</span> <span class="hljs-params">(Oxygen oxygen, Water water)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin单例模式</title>
    <link href="/2025/12/d4f705fbdba4.html"/>
    <url>/2025/12/d4f705fbdba4.html</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类有且仅有一个实例,并且自行实例化向整个系统提供.保证全局只有一个实例对象</p><h2 id="饿汉式-在使用之前就创建好了"><a href="#饿汉式-在使用之前就创建好了" class="headerlink" title="饿汉式 - 在使用之前就创建好了"></a>饿汉式 - 在使用之前就创建好了</h2><p>使用kotlin的关键字 object 就可以 - static类块里初始化,只加载一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">object Singleton&#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    fun <span class="hljs-title function_">log</span><span class="hljs-params">()</span>:Int&#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">beans</span> <span class="hljs-operator">=</span> bean + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> beans<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Android Studio -&gt; Tools -&gt; Kotlin -&gt; show Kotlin bytecode -&gt; Decompile<br>反编译后看原理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> bean;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBean</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> bean;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">log</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">beans</span> <span class="hljs-operator">=</span> bean + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> beans;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;    <span class="hljs-comment">// 在类块中初始化</span><br>      <span class="hljs-type">Singleton</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>      INSTANCE = var0;<br>      bean = <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒汉式-在使用时才创建"><a href="#懒汉式-在使用时才创建" class="headerlink" title="懒汉式 - 在使用时才创建"></a>懒汉式 - 在使用时才创建</h2><p>线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span><span class="hljs-params">()</span>&#123;<br>    companion object&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> singleton : Singleton? = <span class="hljs-literal">null</span><br>            <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">if</span> (field == <span class="hljs-literal">null</span>)<br>                    field = Singleton()<br>                <span class="hljs-keyword">return</span> field;<br>            &#125;<br>        fun <span class="hljs-title function_">get</span><span class="hljs-params">()</span> : Singleton? &#123;<br>            <span class="hljs-keyword">return</span> singleton<br>        &#125;<br>    &#125;<br>        fun <span class="hljs-title function_">log</span><span class="hljs-params">()</span>&#123;<br>        BookLogger.i(<span class="hljs-string">&quot;Singleton&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译为java为: 如果在单例对象创建之前,同时有两个线程要使用对象,那判断对象为null,就有可能同时创建了两个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton.<span class="hljs-type">Companion</span> <span class="hljs-variable">Companion</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>.Companion((DefaultConstructorMarker)<span class="hljs-literal">null</span>);<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">(DefaultConstructorMarker $constructor\_marker)</span> &#123;<br>      <span class="hljs-built_in">this</span>();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Companion</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">if</span> (Singleton.singleton == <span class="hljs-literal">null</span>) &#123;<br>            Singleton.singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>((DefaultConstructorMarker)<span class="hljs-literal">null</span>);<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> Singleton.singleton;<br>      &#125;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSingleton</span><span class="hljs-params">(Singleton var1)</span> &#123;<br>         Singleton.singleton = var1;<br>      &#125;<br><br>      <span class="hljs-meta">@Nullable</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> (([Singleton.Companion)<span class="hljs-built_in">this</span>).getSingleton();<br>      &#125;<br><br><br>      <span class="hljs-keyword">private</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">(DefaultConstructorMarker $constructor\_marker)</span> &#123;<br>         <span class="hljs-built_in">this</span>();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程安全-方案一-直接给get方法加锁"><a href="#线程安全-方案一-直接给get方法加锁" class="headerlink" title="线程安全 - 方案一: 直接给get方法加锁"></a>线程安全 - 方案一: 直接给get方法加锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span><span class="hljs-params">()</span>&#123;<br>    companion object &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> singleton : Singleton? = <span class="hljs-literal">null</span><br>            <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">if</span> (field == <span class="hljs-literal">null</span>)<br>                    field = Singleton()<br>                <span class="hljs-keyword">return</span> field;<br>            &#125;<br>        <span class="hljs-meta">@Synchronized</span><br>        fun <span class="hljs-title function_">get</span><span class="hljs-params">()</span> : Singleton? &#123;<br>            <span class="hljs-keyword">return</span> singleton<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析:只给get()方法加锁,若在构造方法里对对象进行「a++」 类似操作,可能在某个线程只创建对象,分配了内存,还没完成数据操作,另一个线程就拿到了对象「a」,可能会出现数据错误,可以使用<strong>volatile</strong>关键字限制代码指令重排解决;并且对get()方法加锁,每个线程需要拿到锁,才能对对象进行操作,比较耗时.</p><h2 id="线程安全-方案二-DCL-double-check-lock"><a href="#线程安全-方案二-DCL-double-check-lock" class="headerlink" title="线程安全 - 方案二:DCL (double check lock)"></a>线程安全 - 方案二:DCL (double check lock)</h2><p>方案一每次调用该方法的时候都得获取锁，但是如果这个单例已经被初始化了，其实按道理就不需要申请同步锁了，直接返回这个单例类实例即可,使用kotlin的by lazy函数,<em>指定SYNCHRONIZED线程安全模式</em>,这种方式可以保证「在第一次使用这个属性时执行初始化代码,并保存属性,后续访问的时候直接返回,不再执行初始化代码块」.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span><span class="hljs-params">()</span>&#123;<br>    companion object &#123;<br>        val Instance by <span class="hljs-title function_">lazy</span><span class="hljs-params">(mode = LazyThreadSafetyMode.SYNCHRONIZED)</span> &#123;<br>            Singleton()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译成java代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lazy Instance$delegate;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton.<span class="hljs-type">Companion</span> <span class="hljs-variable">Companion</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>.Companion((DefaultConstructorMarker)<span class="hljs-literal">null</span>);<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;<br>      Instance$delegate = LazyKt.lazy(LazyThreadSafetyMode.SYNCHRONIZED, (Function0)<span class="hljs-literal">null</span>.INSTANCE);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">(DefaultConstructorMarker $constructor_marker)</span> &#123;<br>      <span class="hljs-built_in">this</span>();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Companion</span> &#123;<br>      <span class="hljs-meta">@NotNull</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">Lazy</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> Singleton.Instance$delegate;<br>         Singleton.<span class="hljs-type">Companion</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> Singleton.Companion;<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-keyword">return</span> (Singleton)var1.getValue();<br>      &#125;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-comment">// $FF: synthetic method</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">(DefaultConstructorMarker $constructor_marker)</span> &#123;<br>         <span class="hljs-built_in">this</span>();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类块中初始化,使用 kotlin 的函数 LazyKt.lazy,设置 LazyThreadSafetyMode. SYNCHRONIZED 模式,LazyKt.lazy 点进去的函数为 -&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> actual fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =<br>    when (mode) &#123;<br>        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)<br>        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)<br>        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>根据mode参数,下一步之行SynchronizedLazyImpl(initializer),继续进入 -&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> actual fun &lt;T&gt; lazy(lock: Any?, initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer, lock)<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedLazyImpl</span>&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = <span class="hljs-literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> initializer: (() -&gt; T)? = initializer<br>    <span class="hljs-meta">@Volatile</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _value: Any? = UNINITIALIZED_VALUE<br>    <span class="hljs-comment">// final field is required to enable safe publication of constructed instance</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">val</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> lock ?: <span class="hljs-built_in">this</span><br><br><br>    override val value: T<br>        <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">val</span> <span class="hljs-variable">_v1</span> <span class="hljs-operator">=</span> _value<br>            <span class="hljs-title function_">if</span> <span class="hljs-params">(_v1 !== UNINITIALIZED_VALUE)</span> &#123;<br>                <span class="hljs-meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span><br>                <span class="hljs-keyword">return</span> _v1 as T<br>            &#125;<br><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>                <span class="hljs-type">val</span> <span class="hljs-variable">_v2</span> <span class="hljs-operator">=</span> _value<br>                <span class="hljs-title function_">if</span> <span class="hljs-params">(_v2 !== UNINITIALIZED_VALUE)</span> &#123;<br>                    <span class="hljs-meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span> (_v2 as T)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">val</span> <span class="hljs-variable">typedValue</span> <span class="hljs-operator">=</span> initializer!!()<br>                    _value = <span class="hljs-type">typedValue</span><br>                    <span class="hljs-variable">initializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span><br>                    typedValue<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>    override fun <span class="hljs-title function_">isInitialized</span><span class="hljs-params">()</span>: Boolean = _value !== UNINITIALIZED_VALUE<br><br><br>    override fun <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>: String = <span class="hljs-keyword">if</span> (isInitialized()) value.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Lazy value not initialized yet.&quot;</span><br><br><br>    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">writeReplace</span><span class="hljs-params">()</span>: Any = InitializedLazyImpl(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>梳理上段代码可见,在 get 对象时,先判断_v1是否存在, !&#x3D;&#x3D; 判断对象指向内存地址是否存在,直接判断是否是同一个对象,而不是对象值是否一致,如果对象没有内存地址,则对 lock 对象加锁进行初始化,同时 _value 声明为 Volatile 类型,保证多线程数据一致性.</p><p>补充volatile关键字原理<br>volatile关键字是Java中的一个类型修饰符,通过禁止编译器、CPU指令重排序和部分happens-before 规则,解决了有序性问题;通过缓存一致性协议保证每个线程获得最新值,保证每个线程拿到的参数为最新值.</p><h2 id="静态内部类去创建单例"><a href="#静态内部类去创建单例" class="headerlink" title="静态内部类去创建单例"></a>静态内部类去创建单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span><span class="hljs-params">()</span>&#123;<br>    companion object &#123;<br>        fun <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>= SingletonHolder.ins<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> object SingletonHolder&#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> Singleton()<br>    &#125;<br>    fun <span class="hljs-title function_">logOO</span><span class="hljs-params">()</span>:String&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OO&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">class</span> Singleton &#123;<br>    INSTANCE;<br><br>    fun <span class="hljs-title function_">doSomeThing</span><span class="hljs-params">()</span> &#123;<br>        println(<span class="hljs-string">&quot;do some thing&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>反编译成java代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumSingleton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;EnumSingleton&gt; &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  EnumSingleton  ENUMSINGLETON;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton ENUM$VALUES\[];<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  EnumSingleton[] values ();<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  EnumSingleton <span class="hljs-title function_">valueOf</span> <span class="hljs-params">(String s)</span>;<br>        <span class="hljs-keyword">static</span> &#123;<br>            ENUM$VALUES = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumSingleton</span>[] &#123;<br>                ENUMSINGLETON<br>            &#125;);<br>        &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反编译后，可以看到单例枚举类是一个final类，且创建该对象的实例是在一个static静态语句块中进行的，根据JVM的类加载机制，静态语句块只会在类被加载时执行一次，所以可以线程安全。另外因为单例枚举类反编译后实际上是一个被final修饰的类，所以他不能被继承，也就不能创建子类对象。</p><p>1、采用反射方式来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;<br>    <span class="hljs-type">MediaTypeEnum</span> <span class="hljs-variable">mp3</span> <span class="hljs-operator">=</span> MediaTypeEnum.MP3;<br>    <span class="hljs-comment">// 反射方式,获取实例</span><br>    <span class="hljs-type">MediaTypeEnum</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> mp3.getClass().getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class).newInstance(); <span class="hljs-comment">// 但是会报错</span><br>    System.out.println(instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>会报错:<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E4%BA%AB.resources/2023/09/15/18-51-01-e9d0783e51c44b95c8313d8843d2c8fd-unknown_filename-f7f4b4.png" alt="unknown_filename|1888x0"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E4%BA%AB.resources/2023/09/15/18-51-01-5ab951fd732f5e2f0e63fbcf9d0b0df9-unknown_filename.1-c98593.png" alt="unknown_filename.1|1739x0"><br>我们在此处的报错信息打开，发现newInstance()方法直接不让enum类型利用反射来创建实例。所以利用反射方式来破坏单例模式不可能。</p><p>2、实现java.lang.Cloneable接口，调用clone方法来创建：<br>MediaTypeEnum mp3 &#x3D; MediaTypeEnum.MP3;<br>&#x2F;&#x2F; 克隆方式<br>Object clone &#x3D; mp3.clone();<br>仍会报错<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E4%BA%AB.resources/2023/09/15/18-51-01-eb545616d552d1dd1f01c0e15950fe3b-unknown_filename.2-cf03b3.png" alt="unknown_filename.2|1628x0"></p><p>我们调用enum枚举的时候实际上调用的是父类：java.lang.Enum里面的clone()。但是Enum的clone()也是直接抛出异常，如下。所以clone()方式也是不行的。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E4%BA%AB.resources/2023/09/15/18-51-01-deda3adc504d9dea1ab1955ea9e1fc97-unknown_filename.3-fc68f0.png" alt="unknown_filename.3|1787x0"></p><p>3、采用实现java.io.Serializable接口，反序列化方式：<br>在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象，不存在创建对象的可能。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，所以此方式也行不通。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Kotlin%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E4%BA%AB.resources/2023/09/15/18-51-01-b0b57998b02000a9ba3d597bb150aafe-unknown_filename.4-bd61d8.png" alt="unknown_filename.4|1492x0"><br>综上,enum不允许通过反射创建实例,不允许通过clone()创建,也不允许通过反序列化的方式创建对象,所以可以避免反射攻击.</p><p>对比:</p><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>饿汉式</td><td>在类加载时就初始化,保证只进行了一次初始化,线程安全,实现简单</td><td>在类加载时就初始化,会存在资源浪费</td></tr><tr><td>懒汉式</td><td>方法调用时才创建对象,节省资源</td><td>线程不安全,多线程情况下存在创建多个实例的风险</td></tr><tr><td>懒汉式<br>-直接加锁</td><td>线程安全</td><td>每个线程获取对象都需要先获得锁,再执行方法,耗时</td></tr><tr><td>懒汉式(推荐)<br>-DCL</td><td>节省内存空间,并且线程安全</td><td>需要1-2次是否初始化的判断</td></tr><tr><td>静态内部类(推荐)</td><td>节省内存空间,并且线程安全</td><td>创建了一个新的类去调用</td></tr><tr><td>枚举</td><td>节省内存空间,并且线程安全,可以避免反射攻击</td><td>在类加载时就初始化,会存在资源浪费</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鸿蒙应用开发者认证考试(答案)</title>
    <link href="/2025/12/7ad65b9563af.html"/>
    <url>/2025/12/7ad65b9563af.html</url>
    
    <content type="html"><![CDATA[<p>高亮是易错题，掌握下面内容既可通过鸿蒙应用开发者基础认证和鸿蒙应用开发者高级认证考试</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-19-14-05-38c782a1f7f1d0be50b58569eee5b345-20240119140524-c07b11.png" alt="image.png|400"></p><hr><p>main_pages.json存放页面page路径配置信息。（正确）</p><p>1.在stage模型中，下列配置文件属于AppScope文件夹的是？（C）</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">A. main_pages.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B. </span>module.<span class="hljs-keyword">json5</span><br><span class="hljs-keyword"></span>C. app.<span class="hljs-keyword">json5(build-profile.json5)</span><br><span class="hljs-keyword"></span>D. package.<span class="hljs-keyword">json</span><br></code></pre></td></tr></table></figure><p>2.&#x3D;&#x3D;module.json5配置文件中，包含了以下哪些信息&#x3D;&#x3D;？（A B D）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. ability的相关配置信息<br><span class="hljs-selector-tag">B</span>. 模块名<br>C. 应用的版本号(app/oh-package<span class="hljs-selector-class">.json5</span>)<br>D. 模块类型<br></code></pre></td></tr></table></figure><p>entry下的module.json5中包含以下哪些信息：（BCD）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. 应用包名和版本号信息<br><span class="hljs-selector-tag">B</span>. Ability的配置信息<br>C. 设备类型信息<br>D. 应用权限申请列表<br></code></pre></td></tr></table></figure><p>以下关于ArkTS声明式开发范式的基本组成说明正确的是(ABCDEF)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> 装饰器：用来装饰类、结构体、方法以及变量，赋予其特殊的含义，例如<span class="hljs-operator">@</span><span class="hljs-variable">Entry</span>表示这是个入口组件。<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> 自定义组件：可复用的 <span class="hljs-variable">UI</span> 单元，可组合其它组件。<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-variable">UI</span>描述：声明式的方法来描述<span class="hljs-variable">UI</span>的结构，例如<span class="hljs-variable">build</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>方法中的代码块。<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> 内置组件：<span class="hljs-variable">ArkTS</span>中默认内置的基本组件和布局组件，开发者可以直接调用，如<span class="hljs-built_in">Column</span>、<span class="hljs-built_in">Text</span>、<span class="hljs-variable">Divider</span>、<span class="hljs-built_in">Button</span>等。<br><span class="hljs-built_in">E</span><span class="hljs-operator">.</span> 属性方法：用于组件属性的配置，统一通过属性方法进行设置，如<span class="hljs-variable">fontSize</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>、<span class="hljs-variable">width</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>、<span class="hljs-variable">height</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>、<span class="hljs-variable">color</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> 等。<br><span class="hljs-variable">F</span><span class="hljs-operator">.</span> 事件方法：用于添加组件对事件的响应逻辑，统一通过事件方法进行设置，如跟随在<span class="hljs-built_in">Button</span>后面的<span class="hljs-variable">onClick</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>。<br></code></pre></td></tr></table></figure><p>下面哪个组件不能包含子组件：(D)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Row</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Button</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Text</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-variable">LoadingProgress</span><br></code></pre></td></tr></table></figure><hr><p>1.循环渲染ForEach可以从数据源中迭代获取数据，并为每个数组项创建相应的组件。（正确）</p><p>&#x3D;&#x3D;所有使用@Component修饰的自定义组件都支持onPageShow，onBackPress和onPageHide生命周期函数。   false&#x3D;&#x3D;</p><blockquote><p>需要注意的是，部分生命周期回调函数&#x3D;&#x3D;仅对@Entry修饰的自定义组件生效&#x3D;&#x3D;，它们分别是：onPageShow、onPageHide、onBackPress，对@component是无效的</p></blockquote><p>每调用一次router.pushUrl()方法，默认情况下，页面栈数量会加1，页面栈支持的最大页面数量为32。    true</p><p>每一个自定义组件都有自己的生命周期   true</p><p>1.用哪一种装饰器修饰的struct表示该结构体具有组件化能力？（A）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@Component</span><br>B. <span class="hljs-meta">@Entry</span><br>C. <span class="hljs-meta">@Builder</span><br>D. <span class="hljs-meta">@Preview</span><br></code></pre></td></tr></table></figure><p>2.&#x3D;&#x3D;用哪一种装饰器修饰的自定义组件可作为页面入口组件&#x3D;&#x3D;？（B）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@Component</span><br>B. <span class="hljs-meta">@Entry</span><br>C. <span class="hljs-meta">@Builder</span><br>D. <span class="hljs-meta">@Preview</span><br></code></pre></td></tr></table></figure><p>1.下面哪些函数是自定义组件的生命周期函数？（A B C D E）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-variable">aboutToAppear</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-variable">aboutToDisappear</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-variable">onPageShow</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-variable">onPageHide</span><br><span class="hljs-built_in">E</span><span class="hljs-operator">.</span> <span class="hljs-variable">onBackPress</span><br></code></pre></td></tr></table></figure><p>Row组件中有两个Text组件，如果使用justifyContent对齐方式，下面哪个属性可以实现左右两端对齐：   FlexAlign.SpaceBetween</p><p>1.一个应用只能有一个UIAbility。（错误）</p><p>2.创建的Empty Ability模板工程，初始会生成一个UIAbility文件。（正确）</p><p>3.&#x3D;&#x3D;每调用一次router.pushUrl()方法，页面路由栈数量均会加1。（错误）&#x3D;&#x3D;,应该是第32个就不行了</p><p>1.API9及以上，router.pushUrl()方法的mode参数&#x3D;&#x3D;可以配置为以下哪几种跳转页面使用的模式&#x3D;&#x3D;？（A B）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. Standard<br><span class="hljs-selector-tag">B</span>. Single<br>C. Specified<br></code></pre></td></tr></table></figure><p>下面哪些是Ability的生命周期回调函数？（ABEF）</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">A. <span class="hljs-keyword">on</span>Create<br>B. <span class="hljs-keyword">on</span>Destroy<br>C. <span class="hljs-keyword">on</span>PageShow<br>D. <span class="hljs-keyword">on</span>PageHide<br>E. <span class="hljs-keyword">on</span>Foreground<br>F. <span class="hljs-keyword">on</span>Background<br></code></pre></td></tr></table></figure><p>3.UIAbility有哪几种的启动模式？（A B C）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. multiton<br><span class="hljs-selector-tag">B</span>. singleton<br>C. specified<br></code></pre></td></tr></table></figure><hr><p>List容器可以沿水平方向排列，也可以沿垂直方向排列。（正确）</p><p>当Tabs组件的参数barPosition为BarPosition.End时，页签位于页面底部。（错误）还得看_vertical的值_</p><p>Resource是资源引用类型，用于设置组件属性的值，可以定义组件的颜色、文本大小、组件大小等属性。（正确）</p><p>Tabs组件仅可包含子组件TabsContent，每一个页签对应一个内容视图即TabContet组件。   true</p><p>下面哪一个事件方法可以获取到List滑动的偏移量 :onScroll</p><p>关于Resource是资源引用类型描述错误的是：(C)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">A. Resource是资源引用类型，用于设置组件属性的值。<br>B. 通过<span class="hljs-string">&quot;<span class="hljs-variable">$r</span>(&#x27;app.type.name&#x27;)&quot;</span>的形式引用应用资源，app代表是应用内resources目录中定义的资源，<span class="hljs-built_in">type</span>代表资源类型（或资源的存放位置）。<br>C. Resource支持所有的数据类型。<br>D. 系统可以根据当前配置加载合适的Resource资源，例如，开发者可以根据屏幕尺寸呈现不同的布局效果，或根据语言设置提供不同的字符串。<br></code></pre></td></tr></table></figure><p>关于Button组件，下面哪个样式是胶囊型按钮：A</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-variable">ButtonType</span><span class="hljs-operator">.</span><span class="hljs-variable">Capsule</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-variable">ButtonType</span><span class="hljs-operator">.</span><span class="hljs-built_in">Normal</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-variable">ButtonType</span><span class="hljs-operator">.</span><span class="hljs-built_in">Circle</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> 以上都不是<br></code></pre></td></tr></table></figure><p>3.下面哪个组件层次结构是错误的？（C）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-built_in">List</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">ListItem</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Column</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Column</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">List</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">ListItem</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Row</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">GridItem</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">GridItem</span><br></code></pre></td></tr></table></figure><p>下面哪些组件层次结构是正确的。(ABE)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Text</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Span</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Column</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Image</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Image</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Text</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Image</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Text</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Span</span><br><span class="hljs-built_in">E</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Column</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Row</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">Button</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;关于ForEach(arr, itemGenerator, index)组件的描述正确的是&#x3D;&#x3D;：(BCD)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">A. <span class="hljs-keyword">ForEach</span>中可以循环遍历逻辑代码，例如console.<span class="hljs-built_in">info</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>B. 第一个参数必须是数组，提供循环渲染的数据源。<br>C. 第二个参数生成子组件的lambda函数，为数据源中的每个数组项生成子组件。<br>D. 第三个参数为匿名函数，用于给定数组项生成唯一且稳定的键值。<br></code></pre></td></tr></table></figure><p>针对包含文本元素的组件，例如Text、Button、TextInput等，可以使用下列哪些属性：(ABCDE)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-variable">fontColor</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-variable">fontSize</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-variable">fontStyle</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-variable">fontWeight</span><br><span class="hljs-built_in">E</span><span class="hljs-operator">.</span> <span class="hljs-variable">fontFamily</span><br></code></pre></td></tr></table></figure><p>下面哪些容器组件是可以滚动的（ABD）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-variable">Scroll</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-built_in">List</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Row</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Grid</span><br><span class="hljs-built_in">E</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Column</span><br></code></pre></td></tr></table></figure><p>Row容器的主轴是水平方向，交叉轴是垂直方向，其参数类型为VerticalAlign （垂直对齐），VerticalAlign 定义了以下几种类型？（A B E）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Top</span><br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Bottom</span><br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-variable">Start</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-built_in">End</span><br><span class="hljs-built_in">E</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Center</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;关于容器组件Row和Column，下面说法错误的是&#x3D;&#x3D;： (D)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Column</span>容器的主轴是垂直方向，交叉轴是水平方向；<span class="hljs-built_in">Row</span>容器的主轴是水平方向，交叉轴是垂直方向。<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> 主轴和交叉轴始终是相互垂直的，<span class="hljs-built_in">Row</span>和<span class="hljs-built_in">Column</span>主轴的方向不一样。<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Column</span>的子组件在主轴方向上的对齐使用<span class="hljs-variable">justifyContent</span>属性来设置，其参数类型是<span class="hljs-variable">FlexAlign</span>。<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> <span class="hljs-built_in">Row</span>的子组件在交叉轴方向上的对齐方式使用<span class="hljs-variable">alignItems</span>属性来设置，其参数类型为<span class="hljs-variable">HorizontalAlign</span>。<span class="hljs-operator">**</span>（其参数类型为<span class="hljs-variable">VerticalAlign</span>）<span class="hljs-operator">**</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;关于Tabs组件和TabContent组件，下列描述正确的是&#x3D;&#x3D;(ABCD)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. TabContent组件不支持设置通用宽度属性，其宽度等于Tabs组件的barWidth属性。<br><span class="hljs-selector-tag">B</span>. TabContent组件不支持设置通用高度属性，其高度由父组件Tabs高度与TabBar组件高度决定。<br>C. TabsController用于控制Tabs组件进行页签切换，不支持一个TabsController控制多个Tabs组件。<br>D. TabContent组件的tabBar属性支持使用<span class="hljs-keyword">@Builder</span>构造器生成的组件。<br></code></pre></td></tr></table></figure><p>3.关于Tabs组件页签的位置设置，下面描述正确的是？（A B C D）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">A. 当barPosition为<span class="hljs-keyword">Start</span>（默认值），vertical属性为<span class="hljs-literal">false</span>时（默认值），页签位于容器顶部。<br>B. 当barPosition为<span class="hljs-keyword">Start</span>（默认值） ，vertical属性为<span class="hljs-literal">true</span>时，页签位于容器左侧。<br>C. 当barPosition为<span class="hljs-keyword">End</span> ，vertical属性为<span class="hljs-literal">false</span>（默认值）时，页签位于容器底部。<br>D. 当barPosition为<span class="hljs-keyword">End</span> ，vertical属性为<span class="hljs-literal">true</span>时，页签位于容器右侧。<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-17-16-08-4625b9217a000ec270a338a012bea0f6-20240117160842-a2f2b5.png" alt="image.png|500"></p><hr><p>[[ArkTS#状态管理]]</p><p>1.@State修饰的属性不允许在本地进行初始化。（错误）</p><p>2.@CustomDialog装饰器用于装饰自定义弹窗组件，使得弹窗可以自定义内容及样式。（正确）</p><p>3.将Video组件的controls属性设置为false时，不会显示控制视频播放的控制栏。（正确）</p><p>4.@Prop修饰的属性值发生变化时，此状态变化不会传递到其父组件。（正确）</p><p>5.@Link变量不能在组件内部进行初始化。（正确）</p><p>2.&#x3D;&#x3D;下列哪种组合方式可以实现子组件从父子组件单向状态同步&#x3D;&#x3D;。（C）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@State</span>和<span class="hljs-meta">@Link</span><br>B. <span class="hljs-meta">@Provide</span>和<span class="hljs-meta">@Consume</span><br>C. <span class="hljs-meta">@State</span>和<span class="hljs-meta">@Prop</span><br>D. <span class="hljs-meta">@Observed</span>和<span class="hljs-meta">@ObjectLink</span><br></code></pre></td></tr></table></figure><p>1.&#x3D;&#x3D;下列哪些状态装饰器修饰的属性必须在本地进行初始化&#x3D;&#x3D;。（A D）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@State</span><br>B. <span class="hljs-meta">@Prop</span><br>C. <span class="hljs-meta">@Link</span><br>D. <span class="hljs-meta">@Provide</span><br>E. <span class="hljs-meta">@Consume</span><br></code></pre></td></tr></table></figure><p>2.下面哪些装饰器可以用于管理自定义组件中变量的状态？（C D）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@Component</span><br>B. <span class="hljs-meta">@Entry</span><br>C. <span class="hljs-meta">@State</span><br>D. <span class="hljs-meta">@Link</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;下列哪种组合方式不能实现子组件从父子组件之间双向数据同步&#x3D;&#x3D;。(D)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@State</span>和<span class="hljs-meta">@Link</span><br>B. <span class="hljs-meta">@Provide</span>和<span class="hljs-meta">@Consume</span><br>C. <span class="hljs-meta">@Observed</span>和<span class="hljs-meta">@ObjectLink</span><br>D. <span class="hljs-meta">@State</span>和<span class="hljs-meta">@Prop</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;关于@State状态数据特征，下列描述错误的是：(C)&#x3D;&#x3D;</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@State</span>装饰的变量是组件内部的状态数据，当这些状态数据被修改时，将会调用所在组件的build方法进行UI刷新。<br>B. 标记为<span class="hljs-meta">@State</span>的属性是私有变量，只能在组件内访问。<br>C. <span class="hljs-meta">@State</span>变量可以不用给定初始值。<br>D. 子组件<span class="hljs-meta">@Link</span>装饰的变量可以和父组件的<span class="hljs-meta">@State</span>变量建立双向数据绑定。<br></code></pre></td></tr></table></figure><hr><p>2.&#x3D;&#x3D;ArkUI提供了下面哪些弹窗功能&#x3D;&#x3D;。（A B C D E）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. AlertDialog<br><span class="hljs-selector-tag">B</span>. TextPickerDialog<br>C. DatePickerDialog<br>D. <span class="hljs-keyword">@CustomDialog</span><br>E. TimePickerDialog<br></code></pre></td></tr></table></figure><p>1.属性动画中产生动画的属性可以在任意位置声明。（错误）<br>2.属性动画中改变属性时需触发UI状态更新。（正确）<br><a href="https://juejin.cn/post/7270536928758841400">HarmonyOS ArkUI 属性动画入门详解 - 掘金</a></p><blockquote><p>animation属性作用域。animation自身也是组件的一个属性，其作用域为animation之前。即<strong>产生属性动画的属性须在animation之前声明</strong>，其后声明的将不会产生属性动画</p></blockquote><p>1.属性animation可以在哪些组件中使用？（C）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. 只能基础组件<br><span class="hljs-selector-tag">B</span>. 只能容器组件<br>C. 基础组件和容器组件<br>D. 以上都不对<br></code></pre></td></tr></table></figure><p>3.下面哪种情况不会回调onFinish函数？（C）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>. delay设置为 <span class="hljs-number">0</span><br><span class="hljs-attribute">B</span>. tempo设置为 <span class="hljs-number">1</span><br><span class="hljs-attribute">C</span>. iterations 设置为 -<span class="hljs-number">1</span><br><span class="hljs-attribute">D</span>. playMode设置为 PlayMode.Reverse<br></code></pre></td></tr></table></figure><p>4.&#x3D;&#x3D;属性动画中关于animation参数说法错误的是&#x3D;&#x3D;？（B）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>. 参数tempo默认值为<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">B</span>. 参数delay不能大于duration<br><span class="hljs-attribute">C</span>. 参数curve可以不设置<br><span class="hljs-attribute">D</span>. 参数iterations可以不设置<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2.属性动画中animation的参数有哪些？（A B C D）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. playMode<br><span class="hljs-selector-tag">B</span>. curve<br>C. delay<br>D. onFinish<br></code></pre></td></tr></table></figure><p>关于Video组件的回调事件，下列说法错误的是：A</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">A. <span class="hljs-keyword">on</span>Start视频播放时触发该事件，可以在这里获取视频时长。<br>B. <span class="hljs-keyword">on</span>Finish视频播放结束时触发该事件。<br>C. <span class="hljs-keyword">on</span>Prepared视频准备完成时触发该事件。<br>D. <span class="hljs-keyword">on</span>Update播放进度变化时触发该事件，单位为s，更新时间间隔为<span class="hljs-number">250</span>ms。<br></code></pre></td></tr></table></figure><hr><p>1.在http模块中，多个请求可以使用同一个httpRequest对象，httpRequest对象可以复用。（错误）<br>2.使用http模块发起网络请求后，可以使用destroy方法中断网络请求。（正确）<br>3.Web组件onConfirm(callback: (event?: { url: string; message: string; result: JsResult }) &#x3D;&gt; boolean)事件，返回false时候触发网页默认弹窗。（正确）<br>&#x3D;&#x3D;使用http模块发起网络请求时，必须要使用on(‘headersReceive’）订阅请求头，请求才会成功。    false&#x3D;&#x3D;<br>Web组件对于所有的网页都可以使用zoom(factor: number)方法进行缩放。    false<br>&#x3D;&#x3D;发起网络数据请求需要导入以下哪个模块&#x3D;&#x3D;？   import http from  @ohos.net.http</p><p>3.&#x3D;&#x3D;下列关于Web组件的属性，描述错误的是&#x3D;&#x3D;？（C）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">A. 设置是否开启应用中文件系统的访问，默认启用。<span class="hljs-variable">$rawfile</span>(filepath/filename)中rawfile路径的文件不受该属性影响而限制访问。<br>B. imageAccess设置是否允许自动加载图片资源，默认允许。<br>C. javaScriptAccess设置是否允许执行JavaScript脚本，默认不允许执行。<br>D. zoomAccess设置是否支持手势缩放，默认允许执行缩放。<br></code></pre></td></tr></table></figure><p>4.&#x3D;&#x3D;关于请求返回的响应码ResponseCode&#x3D;&#x3D;，下列描述错误的是？（D）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>. ResponseCode.OK的值为<span class="hljs-number">200</span>，表示请求成功。一般用于GET与POST请求。<br><span class="hljs-attribute">B</span>. ResponseCode.NOT_FOUND的值为<span class="hljs-number">404</span>，表示服务器无法根据客户端的请求找到资源（网页）。<br><span class="hljs-attribute">C</span>. ResponseCode.INTERNAL_ERROR的值为<span class="hljs-number">500</span>，表示服务器内部错误，无法完成请求。<br><span class="hljs-attribute">D</span>. ResponseCode.GONE的值为<span class="hljs-number">404</span>，表示客户端请求的资源已经不存在。<br></code></pre></td></tr></table></figure><p>1.&#x3D;&#x3D;Web组件支持下列哪些属性或事件&#x3D;&#x3D;？（A B D）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">A. <span class="hljs-title function_ invoke__">fileAccess</span>(<span class="hljs-attr">fileAccess</span>: <span class="hljs-keyword">boolean</span>)<br>B. <span class="hljs-title function_ invoke__">javaScriptAccess</span>(<span class="hljs-attr">javaScriptAccess</span>: <span class="hljs-keyword">boolean</span>)<br>C. <span class="hljs-title function_ invoke__">on</span>(<span class="hljs-attr">type</span>: ‘headerReceive’, <span class="hljs-attr">callback</span>: AsyncCallback): <span class="hljs-keyword">void</span><br>D. <span class="hljs-title function_ invoke__">onConfirm</span>(<span class="hljs-attr">callback</span>: (event?: &#123; <span class="hljs-attr">url</span>: <span class="hljs-keyword">string</span>; <span class="hljs-attr">message</span>: <span class="hljs-keyword">string</span>; <span class="hljs-attr">result</span>: JsResult &#125;) =&gt; <span class="hljs-keyword">boolean</span>)<br>E. <span class="hljs-title function_ invoke__">destroy</span>(): <span class="hljs-keyword">void</span><br></code></pre></td></tr></table></figure><p>2.关于http模块描述正确的是？（A B C D）</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">A. <span class="hljs-keyword">http</span>请求支持<span class="hljs-built_in">get</span>、<span class="hljs-built_in">post</span>、<span class="hljs-built_in">put</span>等常用的请求方式。<br>B. 可以使用<span class="hljs-keyword">on</span>(‘<span class="hljs-title">headersReceive</span>’)订阅请求响应头。<br>C. <span class="hljs-built_in">post</span>请求的参数可以在extraData中指定。<br>D. 执行createHttp成功后，返回一个httpRequest对象，里面包括request、destroy、<span class="hljs-keyword">on</span>和<span class="hljs-title">off</span>方法。<br></code></pre></td></tr></table></figure><hr><p>1.首选项是关系型数据库。（错误）</p><p>2.应用中涉及到Student信息，如包含姓名，性别，年龄，身高等信息可以用首选项来存储。（错误）</p><p>3.同一应用或进程中每个文件仅存在一个Preferences实例。（正确）</p><p>&#x3D;&#x3D;首选项key的最大长度限制大小为（）字节？ 80&#x3D;&#x3D;</p><blockquote><p>什么是首选项</p></blockquote><p>首选项为应用提供Key-Value键值型的数据存储能力，支持应用持久化轻量级数据，并对其进行增删改查等。该存储对象中的数据会被缓存在内存中，因此它可以获得更快的存取速度<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-17-15-30-fdb8538d914456838adfdba7c83dddd6-2024-01-17-14-54-fdb8538d914456838adfdba7c83dddd6-20240117145457-c985ed-a7c0bb.png" alt="image.png|1000|1000"></p><p>3.&#x3D;&#x3D;下面哪个接口不是首选项提供的API接口&#x3D;&#x3D;？（B）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">A</span>. <span class="hljs-built_in">get</span>()<br><span class="hljs-selector-tag">B</span>. <span class="hljs-built_in">update</span>()<br>C. <span class="hljs-built_in">put</span>()<br>D. <span class="hljs-built_in">flush</span>()<br></code></pre></td></tr></table></figure><p>1.HarmonyOS提供的数据管理的方式都有哪些？（A B C D）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. 首选项<br><span class="hljs-selector-tag">B</span>. 分布式数据服务<br>C. 关系数据库<br>D. 分布式数据对象<br></code></pre></td></tr></table></figure><p>2.下面说法正确的有？（B C D）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> 首选项遵循<span class="hljs-variable">ACID</span>特性<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> 首选项以<span class="hljs-built_in">Key</span><span class="hljs-operator">-</span><span class="hljs-variable">Value</span>形式存取数据<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> 首选项存储数据数量建议不超过<span class="hljs-number">1</span>万条<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> 首选项的<span class="hljs-variable">key</span>为<span class="hljs-built_in">String</span>类型<br></code></pre></td></tr></table></figure><hr><p>1.构造进度条模板通知，name字段当前需要固定配置为_downloadTemplate_。（正确）</p><p>2.给通知设置分发时间，需要设置showDeliveryTime为false。（错误）</p><p>3.OpenHarmony提供后台代理提醒功能，在应用退居后台或退出后，计时和提醒通知功能被系统后台代理接管。（正确）</p><p>1.&#x3D;&#x3D;将通道设置为下面哪个类型，可以显示横幅通知&#x3D;&#x3D;？（A）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">A. SlotType<span class="hljs-selector-class">.SOCIAL_COMMUNICATION</span><br>B. SlotType<span class="hljs-selector-class">.SERVICE_INFORMATION</span><br>C. SlotType<span class="hljs-selector-class">.CONTENT_INFORMATION</span><br>D. SlotType.OTHER_TYPES<br></code></pre></td></tr></table></figure><p>2.下列哪个是从API 9 开始支持的后台代理提醒功能模块。（A）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">A. <span class="hljs-meta">@ohos</span>.reminderAgentManager<br>B. <span class="hljs-meta">@ohos</span>.reminderManager<br>C. <span class="hljs-meta">@ohos</span>.reminderAgent<br>D. <span class="hljs-meta">@ohos</span>.notificationManager<br></code></pre></td></tr></table></figure><p>1.下面哪些方法可以移除通知？（A B）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. cancel<br><span class="hljs-selector-tag">B</span>. cancelAll<br>C. removeSlot<br></code></pre></td></tr></table></figure><p>2.后台代理提醒业务分为哪几种类型。（A B C）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. 倒计时类<br><span class="hljs-selector-tag">B</span>. 日历类<br>C. 闹钟类<br>D. 日程类<br></code></pre></td></tr></table></figure><hr><p>1.元服务发布的国家与地区仅限于“中国大陆” （正确）</p><p>2.编译打包的软件包存放在项目目录build &gt; outputs &gt; default下 （正确）</p><p>1.创建应用时，应用包名需要和app.json5或者config.json文件中哪个字段保持一致？ （C）</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">A. <span class="hljs-keyword">package</span><br><span class="hljs-title">B. name</span><br>C. bundleName<br></code></pre></td></tr></table></figure><p>4.上传发布软件包时，软件包的格式是什么？（B）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">A. <span class="hljs-string">.zip</span><br>B. <span class="hljs-string">.app</span><br>C. <span class="hljs-string">.apk</span><br>D. <span class="hljs-string">.hap</span><br></code></pre></td></tr></table></figure><p>5.发布后的应用可以在哪里获取？（A）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. 华为应用市场<br><span class="hljs-selector-tag">B</span>. 华为服务中心<br>C. 华为生态市场<br></code></pre></td></tr></table></figure><p>3.lottie使用loadAnimation方法加载动画。（正确）</p><p>1.通过ohpm安装lottie后，在哪个文件中会生成相关的配置信息？（B）</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">A. module.<span class="hljs-keyword">json5</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B. </span>oh-package.<span class="hljs-keyword">json5</span><br><span class="hljs-keyword"></span>C. app.<span class="hljs-keyword">json5</span><br><span class="hljs-keyword"></span>D. main_page.<span class="hljs-keyword">json</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667369405083047">&lt;HarmonyOS主题课&gt;三方库-华为开发者学堂</a></p><p>2.lottie订阅事件的API为？（C）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">A</span>. lottie<span class="hljs-selector-class">.setSpeed</span>()<br><span class="hljs-selector-tag">B</span>. lottie<span class="hljs-selector-class">.setDirection</span>()<br>C. animationItem<span class="hljs-selector-class">.addEventListener</span>()<br>D. animationItem<span class="hljs-selector-class">.removeEventListener</span>()<br></code></pre></td></tr></table></figure><p>1.下列属于lottie提供的动画控制API的是？（A B C D）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">A</span>. lottie<span class="hljs-selector-class">.play</span>()<br><span class="hljs-selector-tag">B</span>. lottie<span class="hljs-selector-class">.pause</span>()<br>C. lottie<span class="hljs-selector-class">.stop</span>()<br>D. lottie<span class="hljs-selector-class">.goToAndPlay</span>()<br></code></pre></td></tr></table></figure><hr><p>1.HarmonyOS云开发可以在一个项目中同时实现端侧和云侧功能的开发。（正确）</p><p>2.进行端云一体开发时，开发者需要精通前端、后端不同的开发语言。（错误）</p><p>1.开发者在DevEco Studio中，可以通过什么形式进行HarmonyOS云开发？（B）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. IDE插件<br><span class="hljs-selector-tag">B</span>. 工程模板<br>C. 命令行工具<br>D. 可视化工具<br></code></pre></td></tr></table></figure><p>2.HarmonyOS云开发当前支持最低API版本是多少？（D）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>. API <span class="hljs-number">6</span><br><span class="hljs-attribute">B</span>. API <span class="hljs-number">7</span><br><span class="hljs-attribute">C</span>. API <span class="hljs-number">8</span><br><span class="hljs-attribute">D</span>. API <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>1.HarmonyOS云开发工程结构分哪些部分？（A B C）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><span class="hljs-operator">.</span> 端开发工程（<span class="hljs-built_in">Application</span>）<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span> 云开发工程（<span class="hljs-variable">CloudProgram</span>）<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span> 端侧公共库（<span class="hljs-variable">External</span> <span class="hljs-variable">Libraries</span>）<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span> 公共资源库（<span class="hljs-variable">Resource</span>）<br><br></code></pre></td></tr></table></figure><p>2.HarmonyOS云开发工程创建后，会自动开通哪些服务？（A B C D）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>. 云函数<br><span class="hljs-selector-tag">B</span>. 云数据库<br>C. 云存储<br>D. 认证服务<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>鸿蒙</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HarmonyOS NEXT调研</title>
    <link href="/2025/12/74099e05cdbe.html"/>
    <url>/2025/12/74099e05cdbe.html</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近日华为举行了2023年华为开发者大会（HDC.Together），除了发布HarmonyOS 4、全新升级的鸿蒙开发套件外，华为还带来了HarmonyOS NEXT开发者预览版。</p><p>HarmonyOS NEXT 在 2023 年 8 月 6 日开始面向合作企业开发者开放，2024 年第一季度面向所有开发者开放，也就是明年开始，更新后的鸿蒙，<strong>会使用全自研内核，去掉了传统的 AOSP 代码，仅支持鸿蒙内核和鸿蒙系统的应用，减少了 40% 的冗余代码，使系统的流畅度、能效、纯净安全特性大为提升</strong>。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-09-59-8f373934effd700d4858caa73e58ffdb-20231113095934-7499c4.png" alt="image.png"><br>HarmonyOS NEXT基于OpenHarmony开发，从数码博主“WHYLAB”上手体验来看，HarmonyOS NEXT不再兼容安卓应用，如果打开安卓APK文件，会提示“无法打开此文件”。</p><p>值得注意的是，HarmonyOS NEXT系统底座全线自研，砍掉传统的AOSP代码，仅支持鸿蒙内核和鸿蒙系统的应用。</p><p><strong>官网</strong></p><p><a href="https://developer.harmonyos.com/">https://developer.harmonyos.com/</a></p><h1 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h1><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-get-started-0000001504769321-V3">基本语法</a><br><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/video-tutorials-0000001443535745-V3">视频教程</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-09-59-84949712fa10d604e6d76b81d798dec2-20231113095958-093387.png" alt="image.png"></p><p>ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在<a href="https://www.typescriptlang.org/">TypeScript</a>（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。</p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/ZDNwDTIJxUjb1JBI.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p>声明式的语法更像 Flutter 和 Compose，然后链式写法和组件命名又有点像客户端写法</p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/izDTqZ55dxOXVs15.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/7gxOC8QP15pOC8Cf.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h2 id="DevEco-Studio"><a href="#DevEco-Studio" class="headerlink" title="DevEco Studio"></a>DevEco Studio</h2><p><a href="https://developer.harmonyos.com/cn/develop/deveco-studio/">https://developer.harmonyos.com/cn/develop/deveco-studio/</a></p><h2 id="ArkUI"><a href="#ArkUI" class="headerlink" title="ArkUI"></a>ArkUI</h2><p>ArkUI是一套构建HarmonyOS应用界面的声明式UI开发框架。它使用极简的UI信息语法、丰富的UI组件、以及实时界面预览工具，帮助您提升HarmonyOS应用界面开发效率30%。您只需使用一套TS&#x2F;JS API，就能在多个HarmonyOS设备上提供生动而流畅的用户界面体验。<br><a href="https://developer.harmonyos.com/cn/develop/arkUI/">https://developer.harmonyos.com/cn/develop/arkUI/</a></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/AlO9mhlr37N0YoyH.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/RWEtcLmkzmkj5CZd.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/QrYRrdlcH7i3tYu7.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/fUENN5SYMZwclFYo.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><h2 id="ArkCompiler"><a href="#ArkCompiler" class="headerlink" title="ArkCompiler"></a>ArkCompiler</h2><p>ArkCompiler是华为自研的统一编程平台，包含编译器、工具链、运行时等关键部件，支持高级语言在多种芯片平台的编译与运行，并支撑应用和服务运行在手机、个人电脑、平板、电视、汽车和智能穿戴等多种设备上的需求。</p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/DYz2FeHZk4fZgSPE.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/yYO7w39JQsaeF70q.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/oJJPorcURPkAVN6d.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ohos-building-overview-0000001263360495">https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ohos-building-overview-0000001263360495</a></p><p><strong>鸿蒙工程目录及配置文件说明</strong></p><p>基于Hvigor构建体系，DevEco Studio定义了OpenHarmony的工程范式，下面是Hvigor构建体系的工程目录结构示意图：</p><p><img src="https://yach-doc-shimo.zhiyinlou.com/uploader/f/wlCTel5aLhTqADQl.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTk4NDA2MDUsImZpbGVHVUlEIjoiemRreUJMR3dXZUZXN01BNiIsImlhdCI6MTY5OTg0MDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozNDM0NTMzfQ.qKciJ0e9kTw9vU6O4LBFrgAhOoepAEq7yOBAeaBsj28"></p><h1 id="网上讨论"><a href="#网上讨论" class="headerlink" title="网上讨论"></a>网上讨论</h1><p><a href="https://www.zhihu.com/question/616067090">https://www.zhihu.com/question/616067090</a><br><a href="https://juejin.cn/post/7264237761158643773#comment">https://juejin.cn/post/7264237761158643773#comment</a></p><ol><li>鸿蒙和OpenHarmony都在不断更新，不论是手机上的鸿蒙还是OpenHarmony都在持续改进和完善。</li><li>鸿蒙生态建设中需兼容AOSP并进行生态切换，这是一个核心问题，虽然可能有一些困难，但也并非不可克服。</li><li>开发套件的完善是鸿蒙生态建设的重要一环，通过引入ArkUI开发框架和ArkTs语言等工具，实现一次开发多端部署已经在往实际可用的方向发展。</li><li>生态切换将是一个艰难的过程，涉及到生态兼容、开发工作的延续性等问题。<strong>相关工作正在进行中，但结果仍然不确定</strong>。</li></ol><p>总体来说，有乐观的，也有悲观的，鸿蒙生态建设正在不断推进中，相关成果逐渐显现。然而，生态切换和生态兼容仍然面临一定的困难，如果HarmonyOS NEXT不支持apk，也没有转编译的工具，那就需要学习新语言、新UI框架，从头开发一套新的软件，这样的话成本很高，未来的发展和成果仍待观察。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/v27_Nq6r3pxjwLw1bgWneg">开始有鸿蒙开发岗了，是开卷？还是开嘲讽？</a> [[Obsidian-Highlights]]</p></li><li><p>需要从零到一去将成熟的生态复制到鸿蒙上，这的的确确是一个大工程，而且现在可能的更多的不是技术的问题，更多的是工作量的问题，所以要想促成这个事情，必定伴随着大量资金的入驻，如果鸿蒙开发比 Android 开发髙一倍的工资，你会不心动？所以这有定向的资金扶持，如果小公司都开始去适配鸿蒙，那一定是银行贷款在这方面更容易</p></li><li><p>TS 编程语言的的确确可以拉拢一波前端开发者，但它是一个彻头彻尾的黑盒了，除了那少得可怜的官方文档，就没有任何机会了解底层的具体实现</p></li><li><p>鸿蒙到底会发展到哪一步，最终还是得看会注入多少资本以及上层的态度有多坚决，这个时候，仅靠华为文档投入其中，那大概就是充当一个痛苦的适配踩坑先锋大头兵，也许能乘风得到来自资本的丰厚打赏。也许你可以深入其中，在跨平台方向取得一丝成果。也许不管你选择怎么做，AI 就是能把你替换了。但有资金入场的地方，就有机会去分一杯羹，如何做，这是个值得思考的问题。</p></li><li><p>鸿蒙系统的软件用js开发，所以它就是微信小程序，就是浏览器套壳，所以运行效率也低，还不如java。能说出这种言论的人，说明你比普通群众对软件行业多了一点了解，但也仅仅是一点。解释一下：js执行效率低，这句话没毛病，但前提是js运行在类似浏览器的web环境中，通过解释器解释执行，但鸿蒙系统的js(arkts)代码显然不是运行在web环境中，而是先通过编译器编译成字节码或者机器码，最终运行机器码，所以鸿蒙软件的运行效率并不低，&#x3D;&#x3D;鸿蒙的软件界面也是通过c++的底层原生渲染的，而不是通过webview内核渲染&#x3D;&#x3D;。所以所谓的鸿蒙软件是微信小程序，是浏览器套壳的言论完全是无稽之谈。</p></li></ul><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p><strong>技术储备</strong>，但个人不太会深度学习，除非政策严格以鸿蒙系统作为应用上架要求。项目里有大量的三方SDK跟不上，还是生态问题</p><p>清华大学、上海交通大学、哈尔滨工业大学等在内的21所985高校均已开设了关于华为鸿蒙系统的课程，为了的就是培养相关的人才。从开设的课程看，主要内容为HarmonyOS原理与应用开发课程、基于HarmonyOS的Web编程技术课程、融合鸿蒙技术的智能系统新工科课程等。</p><p>鸿蒙老老实实耕耘几年了，手机量多这么高了，厂商也愿意开发</p><p>主要私活也可以整呀</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>鸿蒙</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FA模型（过时）</title>
    <link href="/2025/12/ba1a233fba5a.html"/>
    <url>/2025/12/ba1a233fba5a.html</url>
    
    <content type="html"><![CDATA[<p>**FA（Feature Ability）模型</p><p>[[ArkTS#Stage 模型]]</p><h2 id="鸿蒙整体架构"><a href="#鸿蒙整体架构" class="headerlink" title="鸿蒙整体架构"></a>鸿蒙整体架构</h2><p>用户程序的开发本质上就是开发Abilit<br> Ability框架在API 8及更早版本使用FA模型。FA模型中Ability分为PageAbility、ServiceAbility、DataAbility、FormAbility几种类型。其中：</p><ul><li>PageAbility是具备ArkUI实现的Ability，是用户具体可见并可以交互的Ability实例。</li><li>ServiceAbility也是Ability一种，但是没有UI，提供其他Ability调用自定义的服务，在后台运行。</li><li>DataAbility也是没有UI的Ability，提供其他Ability进行数据的增删查服务，在后台运行。</li><li>FormAbility是卡片Ability，是一种界面展示形式。</li></ul><h3 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a>进程线程模型</h3><ul><li>应用独享独立进程，Ability独享独立线程，应用进程在Ability第一次启动时创建，并为启动的Ability创建线程，应用启动后再启动应用内其他Ability，会为每一个Ability创建相应的线程。每个Ability绑定一个独立的JSRuntime实例，因此Ability之间是隔离的。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-15-49-6e01925c8997b30c81b986558cc7da73-2023-11-13-11-34-6e01925c8997b30c81b986558cc7da73-20231113113425-80cebc-168851.png" alt="image.png"></li></ul><h3 id="PageAbility"><a href="#PageAbility" class="headerlink" title="PageAbility"></a>PageAbility</h3><table><thead><tr><th align="left">接口名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onShow()</td><td align="left">Ability由后台不可见状态切换到前台可见状态调用onShow方法，此时用户在屏幕可以看到该Ability</td></tr><tr><td align="left">onHide()</td><td align="left">Ability由前台切换到后台不可见状态时调用onHide方法，此时用户在屏幕看不到该Ability。</td></tr><tr><td align="left">onDestroy()</td><td align="left">应用退出，销毁Ability对象前调用onDestroy方法，开发者可以在该方法里做一些回收资源、清空缓存等应用退出前的准备工作。</td></tr><tr><td align="left">onCreate()</td><td align="left">Ability第一次启动创建Ability时调用onCreate方法，开发者可以在该方法里做一些应用初始化工作。</td></tr><tr><td align="left">onInactive()</td><td align="left">Ability失去焦点时调用onInactive方法，Ability在进入后台状态时会先失去焦点，再进入后台。</td></tr><tr><td align="left">onActive()</td><td align="left">Ability切换到前台，并且已经获取焦点时调用onActive方法。</td></tr></tbody></table><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-15-49-be275cc5bc50ded1dde5cc45fd8e649c-2023-11-13-11-39-be275cc5bc50ded1dde5cc45fd8e649c-20231113113921-74f4d4-e3afe8.png" alt="image.png"></p><h4 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h4><p>ability支持单实例和多实例两种启动模式。</p><p>在config.json中通过launchType配置项，可以配置具体的启动模式，其中：</p><table><thead><tr><th align="left">启动模式</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">standard</td><td align="left">多实例</td><td align="left">每次startAbility都会启动一个新的实例</td></tr><tr><td align="left">singleton</td><td align="left">单实例</td><td align="left">系统中只存在唯一一个实例，startAbility时，如果已存在，则复用系统中的唯一一个实例</td></tr></tbody></table><h3 id="FA-模型目录（过时）"><a href="#FA-模型目录（过时）" class="headerlink" title="FA 模型目录（过时）"></a>FA 模型目录（过时）</h3><p><strong>entry：</strong><br>HarmonyOS 工程模块，编译构建生成一个 Hap 包。<br><strong>src &gt; main &gt; ets</strong><br>：用于存放 ets 源码。<br><strong>src &gt; main &gt; ets &gt; MainAbility</strong><br>：应用&#x2F;服务的入口。<br><strong>src &gt; main &gt; ets &gt; MainAbility &gt; pages</strong><br>：MainAbility 包含的页面。<br><strong>src &gt; main &gt; ets &gt; MainAbility &gt; app. ets</strong><br>：承载 Ability 生命周期。<br><strong>src &gt; main &gt; resources：</strong><br>用于存放应用&#x2F;服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。<br><strong>src &gt; main &gt; config. json</strong><br>：模块配置文件，主要包含 HAP 包的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。<br><strong>entry &gt;build-profile. json5：</strong><br>当前的模块信息、编译信息配置项，包括 buildOption、targets 配置等。<br><strong>entry &gt;hvigorfile. js</strong><br>：模块级编译构建任务脚本。</p><p><strong>mate10 手机版本</strong>：getprop hw_sc. build. os. apiversion  6<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-11-21-ad64c5890cd4db9ae1525bd91cfb780b-2023-11-13-11-21-ad64c5890cd4db9ae1525bd91cfb780b-20231113112106-435b10-73ddb1.png" alt="image.png"></p><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-definition-0000001090840664">原子化服务工程</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>鸿蒙</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DevEco Studio</title>
    <link href="/2025/12/aaff073e7d00.html"/>
    <url>/2025/12/aaff073e7d00.html</url>
    
    <content type="html"><![CDATA[<h2 id="DevEco-Studio"><a href="#DevEco-Studio" class="headerlink" title="DevEco Studio"></a>DevEco Studio</h2><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ide_versions_overview-0000001356521213">DevEco Studio使用指南必读-编译构建-DevEco Studio使用指南(OpenHarmony)-工具-HarmonyOS应用开发</a></p><p>HUAWEI DevEco Studio是基于IntelliJ IDEA Community开源版本打造</p><p>DevEco Studio同时支持HarmonyOS和OpenHarmony应用&#x2F;服务开发，但在部分功能（如编程语言、模拟器、签名等）的使用上存在差别<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-10-20-f5a272af9dcd830b3645909173e481a4-20231113102026-85e88b.png" alt="image.png"></p><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ohos-editor-usage-tips-0000001263360493">编辑器使用技巧-应用&#x2F;服务开发-DevEco Studio使用指南(OpenHarmony)-工具-HarmonyOS应用开发</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>鸿蒙</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArkUI</title>
    <link href="/2025/12/cfae37396604.html"/>
    <url>/2025/12/cfae37396604.html</url>
    
    <content type="html"><![CDATA[<h1 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h1><p>开发者文章：<br><a href="https://juejin.cn/post/7272309869246890042">鸿蒙布局第二篇–详细介绍ArkUI中的相对布局，网格布局和轮播组件 - 掘金</a><br><a href="https://www.arkui.club/chapter1/1_2_language.html#_1-2-6-%E6%8E%A5%E5%8F%A3">1.2：OpenHarmony开发语言简介 | 《ArkUI实战》</a></p><p>demo:<br>看demo学的更快</p><p><a href="https://gitee.com/harmonyos/samples/tree/master">HarmonyOS&#x2F;Samples - 码云 - 开源中国</a><br><a href="https://gitee.com/harmonyos/codelabs#https://gitee.com/harmonyos/codelabs/tree/master/MultiShopping">Codelabs: 分享知识与见解，一起探索HarmonyOS的独特魅力。</a><br><a href="https://juejin.cn/post/7325338405408555060?utm_source=gold_browser_extension">再次吐槽鸿蒙 - 掘金</a></p><p>activity等同于使用@Entry和@Component修饰的页面组件。页面同样有生命周期和启动模式等概念<br>只使用@Compoent注解的组件可以理解为view,组件（Component）是界面搭建与显示的最小单位</p><p><strong>方舟开发框架（简称：ArkUI</strong>），是一套构建HarmonyOS应用界面的UI开发框架，它提供了极简的UI语法与包括UI组件、动画机制、事件交互等在内的UI开发基础设施，以满足应用开发者的可视化界面开发需求。</p><hr><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在声明式UI中，所有的页面都是由自定义组件构成，在实际的开发过程中，需要遵守以下流程保证整体的布局效果：</p><ul><li>确定页面的布局结构。</li><li>分析页面中的元素构成。</li><li>选用适合的布局容器组件或属性控制页面中各个元素的位置和大小约束。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-14-10-03-d214530dbb8ad12da6889af1aba793b0-2023-11-13-16-20-d214530dbb8ad12da6889af1aba793b0-20231113162002-d2adc2-4d14ea.png" alt="image.png"></p><p>通过<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-universal-attributes-layout-constraints-0000001427744784-V3">displayPriority</a>属性来控制页面的显示和隐藏</p><h4 id="布局选择"><a href="#布局选择" class="headerlink" title="布局选择"></a>布局选择</h4><table><thead><tr><th align="left">布局</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-layout-development-linear-0000001504125349-V3">线性布局</a>（Row、Column）</td><td align="left">如果布局内子元素超过1个，且能够以某种方式线性排列时优先考虑此布局。</td></tr><tr><td align="left"><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-layout-development-stack-layout-0000001454605342-V3">层叠布局</a>（Stack）</td><td align="left">组件需要有堆叠效果时优先考虑此布局，层叠布局的堆叠效果不会占用或影响其他同容器内子组件的布局空间。例如<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-container-panel-0000001427744836-V3">Panel</a>作为子组件弹出时将其他组件覆盖更为合理，则优先考虑在外层使用堆叠布局。</td></tr><tr><td align="left"><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-layout-development-flex-layout-0000001504525013-V3">弹性布局</a>（Flex）</td><td align="left">弹性布局是与线性布局类似的布局方式。<em>区别在于弹性布局默认能够使子组件压缩或拉伸</em>。在子组件需要计算拉伸或压缩比例时优先使用此布局，可使得多个容器内子组件能有更好的视觉上的填充容器效果。&#x3D;&#x3D;在平板或者大屏用&#x3D;&#x3D;</td></tr><tr><td align="left"><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-layout-development-relative-layout-0000001455042516-V3">相对布局</a>（RelativeContainer）</td><td align="left">相对布局是在二维空间中的布局方式，不需要遵循线性布局的规则，布局方式更为自由。通过在子组件上设置锚点规则（AlignRules）使子组件能够将自己在横轴、纵轴中的位置与容器或容器内其他子组件的位置对齐。设置的锚点规则可以天然支持子元素压缩、拉伸，堆叠或形成多行效果。在页面元素分布复杂或通过线性布局会使容器嵌套层数过深时推荐使用。</td></tr><tr><td align="left"><a href="https://juejin.cn/post/7320231441706188800">鸿蒙HarmonyOS实战-ArkUI组件（Flex） - 掘金</a></td><td align="left"></td></tr></tbody></table><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-17-10-58-08ba6f2f527bdf27e2167ba76b019a10-20240117105843-51dead.png?x-oss-process=image/resize,h_800,m_lfit" alt="image.png"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-17-11-12-4232ba69f8bc127e0287d1252247eb98-20240117111232-a17a04.png" alt="image.png|400"></p><h4 id="布局位置"><a href="#布局位置" class="headerlink" title="布局位置"></a>布局位置</h4><p>position、offset等属性影响了布局容器相对于自身或其他组件的位置。</p><table><thead><tr><th align="left">定位能力</th><th align="left">使用场景</th><th align="left">实现方式</th></tr></thead><tbody><tr><td align="left">绝对定位</td><td align="left">对于不同尺寸的设备，使用绝对定位的适应性会比较差，在屏幕的适配上有缺陷。</td><td align="left">使用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-universal-attributes-location-0000001427584824-V3">position</a>实现绝对定位，设置元素左上角相对于父容器左上角偏移位置。在布局容器中，设置该属性不影响父容器布局，仅在绘制时进行位置调整。</td></tr><tr><td align="left">相对定位</td><td align="left">相对定位不脱离文档流，即原位置依然保留，不影响元素本身的特性，仅相对于原位置进行偏移。</td><td align="left">使用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-universal-attributes-location-0000001427584824-V3">offset</a>可以实现相对定位，设置元素相对于自身的偏移量。设置该属性，不影响父容器布局，仅在绘制时进行位置调整。</td></tr></tbody></table><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><p>对于支持子组件配置的组件，例如容器组件，<em>在”{ … }”里为组件添加子组件的UI描述</em>。Column、Row、Stack、Grid、List等组件都是容器组件。</p><ul><li>以下是简单的Column示例：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Column() &#123;<br>    Text(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>        .fontSize(<span class="hljs-number">100</span>)<br>    Divider()<br>    Text(<span class="hljs-keyword">this</span>.myText)<br>        .fontSize(<span class="hljs-number">100</span>)<br>        .fontColor(Color.Red)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="row、column"><a href="#row、column" class="headerlink" title="row、column"></a>row、column</h4><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-layout-development-linear-0000001504125349-V3">线性布局（Row&#x2F;Column）-快速入门-入门-HarmonyOS应用开发</a></p><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>justifyContent</td><td>设置子组件在主轴方向上的对齐格式。</td></tr><tr><td>alignItems</td><td>设置子组件在交叉轴方向上的对齐格式。</td></tr></tbody></table><ul><li>子组件在主轴方向上的对齐使用justifyContent属性来设置，其参数类型是<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/ts-appendix-enums-0000001281201130#ZH-CN_TOPIC_0000001281201130__flexalign">FlexAlign</a>。FlexAlign定义了以下几种类型：Start、SpaceBetween、SpaceAround、SpaceEvenly等等</li><li>Column和Row容器的接口都有一个可选参数space，表示子组件在主轴方向上的间距。</li></ul><h4 id="RelativeContainer"><a href="#RelativeContainer" class="headerlink" title="RelativeContainer"></a>RelativeContainer</h4><p>锚点设置是指设置子元素相对于父元素或兄弟元素的位置依赖关系。在水平方向上，可以设置<strong>left、middle、right</strong>的锚点。在竖直方向上，可以设置<strong>top、center、bottom</strong>的锚点。为了明确定义锚点，必须为RelativeContainer及其子元素设置ID，用于指定锚点信息。ID默认为__container__，其余子元素的ID通过id属性设置。未设置ID的子元素在RelativeContainer中不会显示</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-15-16-22-ab3f016a9ffd6786a11b2393f080c7f7-20231115162213-2cc45e.png" alt="image.png"></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><a href="https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997?ha_linker=eyJ0cyI6MTY5OTkzMjk2MjEyMSwiaWQiOiI1OWE1Yjg4OWU4NWZjOTExOTc5ODNmMzUwYmU0MzU5YyJ9">&lt;HarmonyOS第一课&gt;从简单的页面开始-华为开发者学堂</a><br><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/ui-ts-performance-improvement-recommendation-0000001477981001-V3#ZH-CN_TOPIC_0000001477981001__%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%87%92%E5%8A%A0%E8%BD%BD">性能提升的推荐方法-基于ArkTS的声明式开发范式-UI开发-开发-HarmonyOS应用开发</a></p><p>List是很常用的滚动类容器组件，一般和子组件ListItem一起使用，List列表中的每一个列表项对应一个ListItem组件。<br>使用<em>ForEach</em>组件<br>最后一个：<strong>keyGenerator</strong>：匿名参数，用于给定数组项生成唯一且稳定的键值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@Entry<br>@Component<br>struct ListDemo &#123;<br>  private arr: number<span class="hljs-selector-attr">[]</span> = <span class="hljs-selector-attr">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><br>  <span class="hljs-built_in">build</span>() &#123;<br>    <span class="hljs-built_in">Column</span>() &#123;<br>      <span class="hljs-built_in">List</span>(&#123; space: <span class="hljs-number">10</span> &#125;) &#123;<br>        <span class="hljs-built_in">ForEach</span>(this<span class="hljs-selector-class">.arr</span>, (item: number) =&gt; &#123;<br>          <span class="hljs-built_in">ListItem</span>() &#123;<br>            <span class="hljs-built_in">Text</span>(`$&#123;item&#125;`)<br>              <span class="hljs-selector-class">.width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>              <span class="hljs-selector-class">.height</span>(<span class="hljs-number">100</span>)<br>              <span class="hljs-selector-class">.fontSize</span>(<span class="hljs-number">20</span>)<br>              <span class="hljs-selector-class">.fontColor</span>(Color.White)<br>              <span class="hljs-selector-class">.textAlign</span>(TextAlign.Center)<br>              <span class="hljs-selector-class">.borderRadius</span>(<span class="hljs-number">10</span>)<br>              <span class="hljs-selector-class">.backgroundColor</span>(<span class="hljs-number">0</span>x007DFF)<br>          &#125;<br>        &#125;, item =&gt; item)<br>      &#125;<br>    &#125;<br>    <span class="hljs-selector-class">.padding</span>(<span class="hljs-number">12</span>)<br>    <span class="hljs-selector-class">.height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    <span class="hljs-selector-class">.backgroundColor</span>(<span class="hljs-number">0</span>xF1F3F5)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-17-10-17-193fb9790d8de794a3ed3bfadc18bc87-20231117101736-70d010.png" alt="image.png"><br>在单个网格单元中，rowStart和rowEnd属性表示指定当前元素起始行号和终点行号，columnStart和columnEnd属性表示指定当前元素的起始列号和终点列号。<br>所以“0”按键横跨第一列和第二列，只要将“0”对应GridItem的columnStart和columnEnd设为1和2，将“&#x3D;”对应GridItem的的rowStart和rowEnd设为5和6即可。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">GridItem</span>() &#123;<br>  Text(key)<br>    ...<br>&#125;<br><span class="hljs-selector-class">.columnStart</span>(<span class="hljs-number">1</span>)<br><span class="hljs-selector-class">.columnEnd</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">GridItem</span>() &#123;<br>  Text(key)<br>    ...<br>&#125;<br><span class="hljs-selector-class">.rowStart</span>(<span class="hljs-number">5</span>)<br><span class="hljs-selector-class">.rowEnd</span>(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h4 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h4><p><a href="https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997?ha_linker=eyJ0cyI6MTY5OTkzMjk2MjEyMSwiaWQiOiI1OWE1Yjg4OWU4NWZjOTExOTc5ODNmMzUwYmU0MzU5YyJ9">&lt;HarmonyOS第一课&gt;从简单的页面开始-华为开发者学堂</a></p><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><p><a href="https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667360160710997?ha_linker=eyJ0cyI6MTY5OTkzMjk2MjEyMSwiaWQiOiI1OWE1Yjg4OWU4NWZjOTExOTc5ODNmMzUwYmU0MzU5YyJ9">&lt;HarmonyOS第一课&gt;从简单的页面开始-华为开发者学堂</a></p><p>Text组件用于在界面上展示一段文本信息，可以包含子组件Span。<br>fontSize：设置文本尺寸，Length为number类型时，使用fp单位</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Image</span><span class="hljs-params">(<span class="hljs-variable">$r</span>(<span class="hljs-string">&quot;app.media.image2&quot;</span>)</span></span>)<br>  <span class="hljs-selector-class">.objectFit</span>(ImageFit.Cover)<br>  <span class="hljs-selector-class">.backgroundColor</span>(<span class="hljs-number">0</span>xCCCCCC)<br>  <span class="hljs-selector-class">.width</span>(<span class="hljs-number">100</span>)<br>  <span class="hljs-selector-class">.height</span>(<span class="hljs-number">100</span>)<br><span class="hljs-function"><span class="hljs-title">Image</span><span class="hljs-params">(<span class="hljs-string">&#x27;https://www.example.com/xxx.png&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>为了成功加载网络图片，您需要在module.json5文件中申明网络访问权限。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;module&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;requestPermissions&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>           <span class="hljs-punctuation">&#123;</span><br>             <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ohos.permission.INTERNET&quot;</span><br>           <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在Button组件通过“$r(‘app.type.name’)”的形式引用应用资源。app代表应用内resources目录中定义的资源；type代表资源类型（或资源的存放位置），可以取“color”、“float”、“string”、“plural”、“media”；name代表资源命名，由开发者定义资源时确定。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Button</span><span class="hljs-params">(<span class="hljs-variable">$r</span>(<span class="hljs-string">&#x27;app.string.login_text&#x27;</span>)</span></span>, &#123; type: ButtonType<span class="hljs-selector-class">.Capsule</span> &#125;)<br>  <span class="hljs-selector-class">.width</span>(<span class="hljs-variable">$r</span>(<span class="hljs-string">&#x27;app.float.button_width&#x27;</span>))<br>  <span class="hljs-selector-class">.height</span>(<span class="hljs-variable">$r</span>(<span class="hljs-string">&#x27;app.float.button_height&#x27;</span>))<br>  <span class="hljs-selector-class">.fontSize</span>(<span class="hljs-variable">$r</span>(<span class="hljs-string">&#x27;app.float.login_fontSize&#x27;</span>))<br>  <span class="hljs-selector-class">.backgroundColor</span>(<span class="hljs-variable">$r</span>(<span class="hljs-string">&#x27;app.color.button_color&#x27;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>自适应拉伸<br>    在线性布局下，常用空白填充组件<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-basic-components-blank-0000001428061724-V3">Blank</a>，在容器主轴方向自动填充空白空间，达到自适应拉伸效果。Row和Column作为容器，只需要添加宽高为百分比，当屏幕宽高发生变化时，会产生自适应效果。</p></blockquote><h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-apis-router-0000001333321105">@ohos.router (页面路由)-UI界面-接口参考（ArkTS及JS API）-手机、平板、智慧屏和智能穿戴开发-ArkTS API参考-HarmonyOS应用开发</a></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.router&#x27;</span><br></code></pre></td></tr></table></figure><p>router.push   跳转到应用内的指定页面。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">router.<span class="hljs-title function_ invoke__">push</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;pages/routerpage2&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">data1</span>: <span class="hljs-string">&#x27;message&#x27;</span>,<br>    <span class="hljs-attr">data2</span>: &#123;<br>      <span class="hljs-attr">data3</span>: [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>]<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>router.replace  用应用内的某个页面替换当前页面，并销毁被替换的页面。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">router.<span class="hljs-title function_ invoke__">replace</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;pages/detail&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">data1</span>: <span class="hljs-string">&#x27;message&#x27;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>router.back</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">router.<span class="hljs-built_in">back</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;pages/detail&#x27;</span>&#125;);<br>router.clear();<br><span class="hljs-keyword">var</span> size = router.getLength();<br></code></pre></td></tr></table></figure><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>Swiper</p><h3 id="图片目录"><a href="#图片目录" class="headerlink" title="图片目录"></a>图片目录</h3><p>对于很大一部分程序员用户来说，会比较纠结这些问题：图片的大小尺寸定义为多大尺寸比较合理？应该放在什么标准的dpi中才能得到更好的适配效果？在HarmonyOS中，程序员可不必将时间和精力过多花费在此。在放置图片的media目录下也没有按照dpi来进行区分。</p><h3 id="VP、PX、FP"><a href="#VP、PX、FP" class="headerlink" title="VP、PX、FP"></a>VP、PX、FP</h3><p> 1vp 约等于 160dpi 屏幕密度设备上的 1px。在不同密度的设备之间，HarmonyOS 会针对性的转换设备间对应的实际像素值。<br> <br> px：像素的单位，1px代表手机屏幕上的一个像素点。比如常见的手机分辨率有320×480,480×800，1080×1920等，这些数值的单位都是px；由于px在不同手机上的大小不同，差别较大，<strong>适配性太差，不建议使用</strong></p><p>fp，font-size pixels，字体像素单位，其大小规范默认情况下与vp相同，但如果开发者在设置中修改了字体显示大小，就会在vp的基础上乘以scale系数。即默认情况下 1 fp &#x3D; 1vp，如果设置了字体显示大小，则会根据实际情况自动设置 1fp &#x3D; 1vp * scale。</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>鸿蒙</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArkTS</title>
    <link href="/2025/12/0ccc710c28c2.html"/>
    <url>/2025/12/0ccc710c28c2.html</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript语法"><a href="#TypeScript语法" class="headerlink" title="TypeScript语法"></a>TypeScript语法</h1><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-get-started-0000001504769321-V3">基本语法</a></p><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/video-tutorials-0000001443535745-V3">视频教程</a><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-13-11-28-84949712fa10d604e6d76b81d798dec2-2023-11-13-09-59-84949712fa10d604e6d76b81d798dec2-20231113095958-093387-8b310b.png" alt="image.png"></p><p>ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在<a href="https://www.typescriptlang.org/">TypeScript</a>（简称TS，Microsoft）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>let 、const、var<br><strong>作用域</strong>： <code>var</code>是函数作用域，这意味着如果你在函数内部使用 <code>var</code> 声明一个变量，那么这个变量在整个函数内部都可以访问。而 <code>let</code> 是块级作用域，只能在声明它的块或子块中访问。<br>使用 let 可以减少由于编程错误或误解引起的bug数量，并且强制执行更强大、更易理解、更可预测的编程模式。</p><p>TypeScript 提供了 <code>string</code> 关键字来表示字符串类型，使用单引号（<code>&#39;</code>）或双引号（<code>&quot;</code>）来表示字符串类型，也可以使用反引号（**&#96;**）来定义多行文本和内嵌表达式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">//元组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span><br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// Error</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br>notSure = <span class="hljs-string">&#x27;maybe a string instead&#x27;</span>;<br>notSure = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is function is void&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可选参数</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span><span class="hljs-params">(firstName: <span class="hljs-keyword">string</span>, lastName?: <span class="hljs-keyword">string</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastName)<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> firstName;<br>&#125;<br><br><span class="hljs-keyword">let</span> result1 = buildName(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-keyword">let</span> result2 = buildName(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>); <br></code></pre></td></tr></table></figure><p><strong>箭头函数</strong><br>ES6版本的TypeScript提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，它省略了function关键字。箭头函数的定义如下，其函数是一个语句块：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">( [param1, parma2,…param n] )=&gt; &#123;<br>    <span class="hljs-comment">// 代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arrowFun = <span class="hljs-function">(<span class="hljs-params"> [param1, parma2,…param n] </span>)=&gt;</span> &#123;<br>    <span class="hljs-comment">// 代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类：和Java类似，有new、extends、this、public、private、protected</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getPersonInfo</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> and age is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>for..of和for..in均可迭代一个列表，但是用于迭代的值却不同：for..in迭代的是对象的键，而for..of则迭代的是对象的值。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> list = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i <span class="hljs-keyword">in</span> list) &#123;<br>    console.<span class="hljs-built_in">log</span>(i); // <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i of list) &#123;<br>    console.<span class="hljs-built_in">log</span>(i); // <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）<br>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsData</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">imagesUrl</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">NewsFile</span>&gt;;<br>  <span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title: <span class="hljs-built_in">string</span>, content: <span class="hljs-built_in">string</span>, imagesUrl: <span class="hljs-built_in">Array</span>&lt;NewsFile&gt;, source: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = content;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imagesUrl</span> = imagesUrl;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">source</span> = source;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NewsData</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../common/bean/NewsData&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="ArkTS"><a href="#ArkTS" class="headerlink" title="ArkTS"></a>ArkTS</h1><h2 id="基本UI描述"><a href="#基本UI描述" class="headerlink" title="基本UI描述"></a>基本UI描述</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/uploader/f/2023-11-14-11-25-d82ae865b1ec93ed1f401397c3afc45c-2023-11-14-11-24-d82ae865b1ec93ed1f401397c3afc45c-2023-11-13-11-28-d82ae865b1ec93ed1f401397c3afc45c-7gxOC8QP15pOC8Cf-672f0c-acd3af-8486b4.png"></p><ul><li>装饰器：用来装饰类、结构体、方法以及变量，赋予其特殊的含义，如上述示例中 @Entry 、 @Component 、 @State 都是装饰器。具体而言， @Component 表示这是个自定义组件； @Entry 则表示这是个入口组件； @State 表示组件中的状态变量，这个状态变化会引起 UI 变更。</li><li>自定义组件：可复用的 UI 单元，可组合其它组件，如上述被 @Component 装饰的 struct Hello。</li></ul><p>ArkTS通过装饰器@Component和@Entry装饰struct关键字声明的数据结构，构成一个自定义组件。自定义组件中提供了一个build函数，开发者需在该函数内以链式调用的方式进行基本的UI描述，UI描述的方法请参考UI描述规范。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>*<strong>struct</strong>：自定义组件可以基于struct实现，不能有继承关系，对于struct的实例化，可以省略new。</li><li>*<strong>装饰器</strong>：装饰器给被装饰的对象赋予某一种能力，其不仅可以装饰类或结构体，还可以装饰类的属性。多个装饰器可以叠加到目标元素上，定义在同一行中或者分开多行，推荐分开多行定义。<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Entry</span><br><span class="hljs-variable">@Component</span><br>struct MyComponent &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li>@Component：装饰struct，结构体在装饰后具有基于组件的能力，需要实现build方法来创建UI。</li><li>@Entry： 装饰struct，组件被装饰后作为页面的入口，页面加载时将被渲染显示</li><li>@Preview：装饰struct， 用@Preview装饰的自定义组件可以在DevEco Studio的预览器上进行实时预览，加载页面时，将创建并显示@Preview装饰的自定义组件。</li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ets-state-mgmt-concepts-0000001169868220">基本概念-状态管理-ArkTS语法（声明式UI）-学习ArkTS语言-开发基础知识-入门-HarmonyOS应用开发</a><br>ArkTS提供了多维度的状态管理机制，在UI开发框架中，和UI相关联的数据，不仅可以在组件内使用，还可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，也可以是全局范围内的传递。另外，从数据的传递形式来看，可分为<strong>只读的单向传递和可变更的双向传递</strong></p><h3 id="页面级变量的状态管理"><a href="#页面级变量的状态管理" class="headerlink" title="页面级变量的状态管理"></a>页面级变量的状态管理</h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ets-state-mgmt-page-level-0000001149818711">页面级变量的状态管理-状态管理-ArkTS语法（声明式UI）-学习ArkTS语言-开发基础知识-入门-HarmonyOS应用开发</a></p><h4 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h4><p>@State装饰的变量是组件内部的状态数据，<strong>当这些状态数据被修改时，将会调用所在组件的build方法进行UI刷新</strong>。</p><ul><li>支持多种类型数据：支持class、number、boolean、string强类型数据的值类型和引用类型，<strong>不支持object和any</strong>。</li><li>内部私有：标记为@State的属性是私有变量，只能在组件内访问</li><li>需要本地初始化：必须为所有@State变量分配初始值</li></ul><h4 id="Prop"><a href="#Prop" class="headerlink" title="@Prop"></a>@Prop</h4><p>@Prop与@State有相同的语义，但初始化方式不同。@Prop装饰的变量必须使用其父组件提供的@State变量进行初始化，允许组件内部修改@Prop变量，<strong>但变量的更改不会通知给父组件，父组件变量的更改会同步到@prop装饰的变量，即@Prop属于单向数据绑定</strong>。<br>@Prop状态数据具有以下特征：</p><ul><li>支持简单类型：仅支持number、string、boolean等简单数据类型；</li><li>私有：仅支持组件内访问；</li><li>支持多个实例：一个组件中可以定义多个标有@Prop的属性；</li><li>创建自定义组件时将值传递给@Prop变量进行初始化：在创建组件的新实例时，必须初始化所有@Prop变量，<strong>不支持在组件内部进行初始化</strong>。</li></ul><p>&#x3D;&#x3D;实现子组件从父子组件单向状态同步 : @State和@Prop&#x3D;&#x3D;</p><h4 id="Link"><a href="#Link" class="headerlink" title="@Link"></a>@Link</h4><p>@Link装饰的变量可以和父组件的@State变量建立双向数据绑定，@Link变量不能在组件内部进行初始化。<br>我们对于视图更新，可以使用<code>@State</code> 标记变量，但是<code>@State</code>不能进行跨文件使用。这个时候<code>@Link</code>的实现就弥补了<code>@State</code>的不足。使用<code>@Link</code>的话。子组件中被<code>@Link</code>装饰的变量与其父组件中对应的数据源建立双向数据绑定。</p><p>&#x3D;&#x3D;子组件@Link装饰的变量可以和父组件的@State变量建立双向数据绑定。&#x3D;&#x3D;</p><h4 id="Observed和ObjectLink数据管理"><a href="#Observed和ObjectLink数据管理" class="headerlink" title="@Observed和ObjectLink数据管理"></a>@Observed和ObjectLink数据管理</h4><p>当开发者只想针对父组件中某个数据对象的部分信息进行同步时，使用@Link就不能满足要求。如果这些部分信息是一个类对象，就可以使用@ObjectLink配合@Observed来实现，如下图所示。</p><ul><li>@Observed用于类，@ObjectLink用于变量。</li><li>@ObjectLink装饰的变量类型必须为类（class type）。<ul><li>类要被@Observed装饰器所装饰。</li><li>不支持简单类型参数，可以使用@Prop进行单向同步。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// xxx.ets</span><br><span class="hljs-comment">// 父组件ViewB中的类对象ClassA与子组件ViewA保持数据同步时，可以使用@ObjectLink和@Observed，绑定该数据对象的父组件和其他子组件同步更新</span><br><span class="hljs-selector-tag">var</span> nextID: number = <span class="hljs-number">0</span><br><br>@Observed<br>class ClassA &#123;<br>  public name: string<br>  public c: number<br>  public id: number<br><br>  <span class="hljs-built_in">constructor</span>(c: number, name: string = <span class="hljs-string">&#x27;OK&#x27;</span>) &#123;<br>    this<span class="hljs-selector-class">.name</span> = name<br>    this<span class="hljs-selector-class">.c</span> = c<br>    this<span class="hljs-selector-class">.id</span> = nextID++<br>  &#125;<br>&#125;<br><br>@Component<br>struct ViewA &#123;<br>  <span class="hljs-selector-tag">label</span>: string = <span class="hljs-string">&#x27;ViewA1&#x27;</span><br>  @ObjectLink <span class="hljs-selector-tag">a</span>: ClassA<br><br>  <span class="hljs-built_in">build</span>() &#123;<br>    <span class="hljs-built_in">Row</span>() &#123;<br>      <span class="hljs-built_in">Button</span>(`ViewA <span class="hljs-selector-attr">[$&#123;this.label&#125;]</span> this<span class="hljs-selector-class">.a</span>.c= $&#123;this<span class="hljs-selector-class">.a</span>.c&#125; +<span class="hljs-number">1</span>`)<br>        <span class="hljs-selector-class">.onClick</span>(() =&gt; &#123;<br>          this<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span> += <span class="hljs-number">1</span><br>        &#125;)<br>    &#125;<span class="hljs-selector-class">.margin</span>(&#123; <span class="hljs-attribute">top</span>: <span class="hljs-number">10</span> &#125;)<br>  &#125;<br>&#125;<br><br>@Entry<br>@Component<br>struct ViewB &#123;<br>  @State arrA: ClassA<span class="hljs-selector-attr">[]</span> = <span class="hljs-selector-attr">[new ClassA(0), new ClassA(0)]</span><br><br>  <span class="hljs-built_in">build</span>() &#123;<br>    <span class="hljs-built_in">Column</span>() &#123;<br>      <span class="hljs-built_in">ForEach</span>(this<span class="hljs-selector-class">.arrA</span>, (item) =&gt; &#123;<br>        <span class="hljs-built_in">ViewA</span>(&#123; <span class="hljs-selector-tag">label</span>: `#$&#123;item.id&#125;`, <span class="hljs-selector-tag">a</span>: item &#125;)<br>      &#125;, (item) =&gt; item<span class="hljs-selector-class">.id</span><span class="hljs-selector-class">.toString</span>())<br>      <span class="hljs-built_in">ViewA</span>(&#123; <span class="hljs-selector-tag">label</span>: `this<span class="hljs-selector-class">.arrA</span><span class="hljs-selector-attr">[first]</span>`, <span class="hljs-selector-tag">a</span>: this<span class="hljs-selector-class">.arrA</span><span class="hljs-selector-attr">[0]</span> &#125;)<br>      <span class="hljs-built_in">ViewA</span>(&#123; <span class="hljs-selector-tag">label</span>: `this<span class="hljs-selector-class">.arrA</span><span class="hljs-selector-attr">[last]</span>`, <span class="hljs-selector-tag">a</span>: this<span class="hljs-selector-class">.arrA</span><span class="hljs-selector-attr">[this.arrA.length - 1]</span> &#125;)<br><br>      <span class="hljs-built_in">Button</span>(`ViewB: reset array`)<br>        <span class="hljs-selector-class">.margin</span>(&#123; <span class="hljs-attribute">top</span>: <span class="hljs-number">10</span> &#125;)<br>        <span class="hljs-selector-class">.onClick</span>(() =&gt; &#123;<br>          this<span class="hljs-selector-class">.arrA</span> = <span class="hljs-selector-attr">[new ClassA(0), new ClassA(0)]</span><br>        &#125;)<br>      <span class="hljs-built_in">Button</span>(`ViewB: push`)<br>        <span class="hljs-selector-class">.margin</span>(&#123; <span class="hljs-attribute">top</span>: <span class="hljs-number">10</span> &#125;)<br>        <span class="hljs-selector-class">.onClick</span>(() =&gt; &#123;<br>          this<span class="hljs-selector-class">.arrA</span><span class="hljs-selector-class">.push</span>(new <span class="hljs-built_in">ClassA</span>(<span class="hljs-number">0</span>))<br>        &#125;)<br>      <span class="hljs-built_in">Button</span>(`ViewB: shift`)<br>        <span class="hljs-selector-class">.margin</span>(&#123; <span class="hljs-attribute">top</span>: <span class="hljs-number">10</span> &#125;)<br>        <span class="hljs-selector-class">.onClick</span>(() =&gt; &#123;<br>          this<span class="hljs-selector-class">.arrA</span><span class="hljs-selector-class">.shift</span>()<br>        &#125;)<br>    &#125;<span class="hljs-selector-class">.width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Consume和-Provide"><a href="#Consume和-Provide" class="headerlink" title="@Consume和@Provide"></a>@Consume和@Provide</h4><p>@Provide作为数据的提供方，可以更新其子孙节点的数据，并触发页面渲染。@Consume在感知到@Provide数据的更新后，会触发当前自定义组件的重新渲染。</p><h3 id="应用级变量的状态管理"><a href="#应用级变量的状态管理" class="headerlink" title="应用级变量的状态管理"></a>应用级变量的状态管理</h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ets-state-mgmt-application-level-0000001119769576">应用级变量的状态管理-状态管理-ArkTS语法（声明式UI）-学习ArkTS语言-开发基础知识-入门-HarmonyOS应用开发</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>鸿蒙</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长链接NIO</title>
    <link href="/2025/12/c8542bc6f406.html"/>
    <url>/2025/12/c8542bc6f406.html</url>
    
    <content type="html"><![CDATA[<h1 id="长链接NIO"><a href="#长链接NIO" class="headerlink" title="长链接NIO"></a>长链接NIO</h1><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>所有需要客户端被动接收信息的功能模块,都可以用推送实现，比如A想给B发消息，A调服务器接口，服务器只是存数据，它调推送的接口，推送去去找B。推送用的是xmpp协议， 是一种基于TCP&#x2F;IP的协议, 这种协议更适合消息发送</p><ol><li>socket 套接字, 发送和接收网络请求</li><li>长连接 keep-alive, 服务器基于长连接找到设备,发送消息</li><li>心跳包 , 客户端会定时(30秒一次)向服务器发送一段极短的数据,作为心跳包, 服务器定时收到心跳,证明客户端或者,才会发消息.否则将消息保存起来,等客户端活了之后(重新连接),重新发送.</li><li>网络状态变化<br> 手机网络和WIFI网络切换、网络断开和连上等情况有网络状态的变化，也会使长连接变为无效连接，需要监听响应的网络状态变化事件，重新建立Push长连接。</li></ol><h3 id="关于心跳"><a href="#关于心跳" class="headerlink" title="关于心跳"></a>关于心跳</h3><ol><li>客户端网络空闲5秒没有进行写操作是，进行发送一次ping心跳给服务端；</li><li>客户端如果在下一个发送ping心跳周期来临时，还没有收到服务端ping的心跳应答，则失败心跳计数器加1；</li><li>每当客户端收到服务端的ping心跳应答后，失败心跳计数器清零；</li><li>如果连续超过3次没有收到服务端的心跳回复，则断开当前连接，在5秒后进行重连操作，直到重连成功，否则每隔5秒又会进行重连；(不对吧)。死链check 时间应该是心跳间隔 + 心跳消息超时</li></ol><p><strong>长连接会不会耗流量？</strong><br>维持长连接并不是连接在那儿就一直消耗流量，只是隔段时间进行“心跳”来保持连接，而一次心跳流量是可以做得很小的。总之，长连接的方式一方面实时性好，另一方面，比轮询更少的消耗流量。项目是5秒发一次</p><p><strong>心跳包和轮询的区别</strong><br>轮询是为了获取数据，而心跳是为了保活TCP连接。<br>轮询得越频繁，获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系。<br>轮询比心跳能耗更高，因为一次轮询需要经过TCP三次握手，四次挥手，<strong>单次心跳不需要建立和断开TCP连接。</strong></p><h3 id="I-O-是什么？"><a href="#I-O-是什么？" class="headerlink" title="I&#x2F;O 是什么？"></a>I&#x2F;O 是什么？</h3><p>程序内部和外部进⾏行数据交互的过程，就叫输入输出。<br>程序内部是谁？内存<br>程序外部是谁？<br>⼀般来说是两类：本地文件和网络。<br>也有别的情况，比如你和别的程序做交互，和你交互的程序也属于外部，但一般来说，就是文件和网络这么两种。</p><p>从文件里或者从网络上读数据到内存里，就叫输入；<br>从内存里写到文件里或者发送到网络上，就叫输出<br>Java I&#x2F;O 作⽤用只有一个：和外界做数据交互</p><h3 id="常见的IO"><a href="#常见的IO" class="headerlink" title="常见的IO"></a>常见的IO</h3><p>答：字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer，如果字符流就得有刷新动作。</p><ol><li>打印流：将各种数据类型的数据原样打印，PrintStream  、PrintWriter</li><li>对象流：它的写方法是ObjectOutputStream，读方法是ObjectInputStream。它主要操作的是对象，而对象中也能封装数据，所以它也具备操作基本数据类型的方法。被它操作的对象必须是实现了序列化的对象也就是Serializable接口，但是输入流还多支持一种Externalizable 接口的对象。持久化</li><li>DataStream：可以用于操作基本数据类型的数据的流对象：DataInputStream与DataOutputStream，它主要的特点就是操作基本数据类型，特色方法writeUTF、readUTF</li><li>字节数组流：ByteArrayInputStream 、ByteArrayOutputStream，因为这两个流对象都操作的数组，并没有使用系统资源。所以，不用进行close关闭，而且关闭也是无效的。</li><li>文件流：FileReader<br> 字符流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;buf.txt&quot;</span>);<br>      <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>     <br>      <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;buf_copy.txt&quot;</span>);<br>      <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fw);<br>     <br>      <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//第一种</span><br>      <span class="hljs-keyword">while</span> ((line = bufr.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>          bufw.write(line);<br>          bufw.newLine();<br>          bufw.flush();<br>      &#125;<br>      <br>      字节流<br>        <span class="hljs-type">FileInputSteam</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputSteam</span>(<span class="hljs-number">1.</span>jpg);<br><span class="hljs-type">FileOnputSteam</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOnputSteam</span>(<span class="hljs-number">2.</span>jpg);<br>btey[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">//第二种</span><br><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>((len=fis.read(b))!=-<span class="hljs-number">1</span>)&#123;<br>  fos.writer(b,<span class="hljs-number">0</span>,len);<br>&#125;<br><br>第三种<br>  <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:\\0.mp3&quot;</span>);<br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;c:\\2.mp3&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bufos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>     <br><span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span>((ch=bufis.read())!=-<span class="hljs-number">1</span>)&#123;<br>   bufos.write(ch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="NIO-vs-IO区别"><a href="#NIO-vs-IO区别" class="headerlink" title="NIO vs IO区别"></a>NIO vs IO区别</h3><p>NIO vs IO之间的理念上面的区别（NIO将阻塞交给了后台线程执行）</p><ol><li>IO是面向流的，NIO是面向缓冲区的<br> Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；NIO则能前后移动流中的数据，因为是面向缓冲区的</li><li>IO流是阻塞的 NIO流是不阻塞的<br> Java IO的各种流是阻塞的。这意味着，<strong>当一个线程调用read() 或 write()时，该线程被阻塞</strong>，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了<br> Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</li></ol><p>IO是阻塞式的，NIO是非阻塞式的，<em>所有数据都是用缓冲区进行处理的。在读取数据时，它是直接读到缓冲区中；在写入数据时，它也是写入到缓冲区中</em>。任何时候访问 NIO 中的数据，我们都是通过缓冲区进行读写操作。</p><ul><li>看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</li><li>同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。<br>  你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。<br>  很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E9%95%BF%E9%93%BE%E6%8E%A5NIO.resources/2023/09/15/18-24-49-da347c30cc788aa7a969ae07c7f7de92-unknown_filename-dcf950.png" alt="unknown_filename"></p><hr><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p><strong>有一个接口监听。监听里有建立连接，收到消息，完成等各种回调，收到后解析</strong></p><ul><li>Netty是一个异步非阻塞的事件驱动型的网络应用程序框架。是一个高性能、方便开发的NIO框架，使用它可以简单快速地开发网络应用程序，比如客户端和服务端的协议。Netty大大简化了网络编程比如TCP和UDP的 Socket的开发。</li><li><strong>IO是阻塞式的，NIO是非阻塞式的，所有数据都是用缓冲区进行处理的。在读取数据时，它是直接读到缓冲区中；在写入数据时，它也是写入到缓冲区中。任何时候访问 NIO 中的数据，我们都是通过缓冲区进行读写操作。</strong></li><li>当客户端与服务器建立起连接后，ChannelHandler的方法是被网络event（这里的event是广义的）触发的，由ChannelHandler直接处理输入输出数据，并传递到管道中的下一个ChannelHandler中。</li><li>通过Channel或者ChannelHandlerContext发生的请求&#x2F;响应event 就是在管道中ChannelHandler传递。</li></ul><h4 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h4><ul><li>ChannelInboundHandler对从客户端发往服务器的报文进行处理，一般用来执行解码、读取客户端数据、进行业务处理等；ChannelOutboundHandler对从服务器发往客户端的报文进行处理，一般用来进行编码、发送报文到客户端。</li><li>一般就是继承ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter，因为Adapter把定制(custom) ChannelHandler的麻烦减小到了最低，Adapter本身已经实现了基础的数据处理逻辑（例如将event转发到下一个handler），你可以只重写那些你想要特别实现的方法。</li><li>和NIO一样，读取数据时，它是直接读到缓冲区中；在写入数据时，它也是写入到缓冲区中。在TCP&#x2F;IP中，NETTY会把读到的数据放到ByteBuf的数据结构中。所以这里读取在ByteBuf的信息，得到服务器返回的内容。</li><li>ChannelPipeline作为放置ChannelHandler的容器，采用了J2EE的 拦截过滤模式，用户可以定义管道中的ChannelHandler以哪种规则去拦截并处理事件以及在管道中的ChannelHandler之间如何通信。每个Channel都有它自己的Pipeline，当一个新的Channel被创建时会自动被分配到一个Pipeline中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Netty&quot;</span>;<br><span class="hljs-keyword">private</span> INettyClient.OnConnectStatusListener statusListener;<br><span class="hljs-keyword">private</span> List&lt;INettyClient.OnDataReceiveListener&gt; listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//channelActive()方法将会在连接被建立并且准备进行通信时被调用。</span><br>        Log.d(TAG, <span class="hljs-string">&quot;channel active&quot;</span>);<br>        <span class="hljs-built_in">super</span>.channelActive(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span><br>            <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//channelRead()方法是在数据被接收的时候调用。</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        <span class="hljs-type">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.readableBytes()];<br>        buf.readBytes(req);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(req, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">//verify(String body)方法对服务器返回的数据进行校验，并取出数据部分。</span><br><span class="hljs-comment">//具体校验的方法需要与后台同事进行协议。</span><br>        body = verify(body);<br><br>        Log.d(TAG, <span class="hljs-string">&quot;verify : &quot;</span> + body);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != body)<br>            parseJson(body);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span><br>            <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//exceptionCaught()事件处理方法是当出现Throwable对象才会被调用，</span><br><span class="hljs-comment">//即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。</span><br><span class="hljs-comment">//在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。</span><br>        ctx.close();<br>        Log.e(TAG, <span class="hljs-string">&quot;Unexpected exception from downstream : &quot;</span><br>                + cause.getMessage());<br>        <span class="hljs-keyword">if</span> (statusListener != <span class="hljs-literal">null</span>)<span class="hljs-comment">//连接异常时触发onDisconnected()</span><br>            statusListener.onDisconnected();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireChannelReadComplete();<br>        LogUtils.d(TAG, <span class="hljs-string">&quot;channelReadComplete&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">//对数据进行解析，拿出区分不同请求的 flag字段，再根据不同的flag字段去触发相对应的监听器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseJson</span><span class="hljs-params">(String json)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(json);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">msgType</span> <span class="hljs-operator">=</span> jObject.getInt(Constant.FLAG_MT);<br>            Log.d(TAG, <span class="hljs-string">&quot;parseJson message type: &quot;</span> + msgType + <span class="hljs-string">&quot;  json: &quot;</span> + json);<br>            callListeners(msgType, json);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LogUtils.e(TAG, <span class="hljs-string">&quot;parseJson exception: &quot;</span> + e.getMessage());<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//遍历监听器List，触发拥有正确msgType 的OnDataReceiveListener，</span><br><span class="hljs-comment">//回调 void onDataReceive(int mt, String json);方法</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callListeners</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> msgType , <span class="hljs-keyword">final</span> String json)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> INettyClient.OnDataReceiveListener listener : listeners)<br>            <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper()).post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//主线程中进行</span><br>                        listener.onDataReceive(mt, json);<br>                    &#125;<br>                &#125;);<br>    &#125;<br><br><span class="hljs-comment">//绑定OnDataReceiveListener </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addDataReceiveListener</span><span class="hljs-params">(INettyClient.OnDataReceiveListener listener)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!listeners.contains(listener))<br>            listeners.add(listener);<br>    &#125;<br><span class="hljs-comment">//绑定OnConnectStatusListener</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConnectStatusListener</span><span class="hljs-params">(INettyClient.OnConnectStatusListener listener)</span> &#123;   <br>         statusListener = listener;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上，就是一个供Android客户端使用的</p><p><code>ChannelHandler</code>，可以通过实现具体的<code>OnDataReceiveListener</code>来异步地获得服务器返回的 数据。NettyClient的实现 以上仅仅是展示了如何处理服务器返回的数据。建立连接、发送消息以及心跳包的功能还没进行封装。<br>在2.接口的定义 里面已经定义好了NettyClient应该具备哪些行为，现在进行具体的实现。 主要的实现思路是：</p><ol><li>构建Bootstrap，其中包括设置好ChannelHandler来处理将来接收到的数据（详见<a href="http://www.jianshu.com/p/db74e673e43c">Android开发之使用Netty进行Socket编程（二）</a> ）。由Boostrap建立连接。通过<code>channel.writeAndFlush(constructMessage(sendMsg)).sync()</code>发送消息。这些工作都在子线程完成。</li><li>在子线程 建立连接并向服务器发送请求，这里采用了<code>HanlderThread</code>+<code>Handler</code>的方案。通过<code>Looper</code>依次从<code>Handler</code>的队列中获取信息，逐个进行处理，保证安全，不会出现混乱。</li><li>心跳包的发送通过<code>handleMessage(Message msg)</code>中的死循环进行不间断地发送。</li><li><code>NettyClientHandler</code>的实现中我们已经知道，当Netty异常时会触发<code>statusListener.onDisconnected();</code>，NettyClient中，onDisconnected()方法会进行重连操作。 接收到服务器返回的消息时，会在主线程中触发<code>onDataReceiveListener .onDataReceive(mt, json);</code>。<br>  5. 外部通过单例模式进行调用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云直播</title>
    <link href="/2025/12/bb401256a963.html"/>
    <url>/2025/12/bb401256a963.html</url>
    
    <content type="html"><![CDATA[<h1 id="腾讯云直播"><a href="#腾讯云直播" class="headerlink" title="腾讯云直播"></a>腾讯云直播</h1><p><strong>注意</strong></p><ul><li><p>使用云直播服务，至少需要2个域名，一个作为推流域名，一个作为播放域名，推流和播放不能使用相同的域名，备案的域名。添加成功后，系统会为您自动分配一个 CNAME 域名，但 CNAME 域名不能直接访问，您需要在域名服务提供商处完成 CNAME 配置，配置生效后，即可享受云直播服务。</p></li><li><p>增值计费项为直播转码、直播录制、直播截图、直播鉴黄和移动直播连麦费用，这五项为标准直播的增值功能，您可以按需使用，根据您的实际使用情况进行付费。</p></li><li><p>播放地址StreamName 要与推流地址 StreamName 一致才能播放对应的流。<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-3006306da6f6de30e34161b38d341a87-unknown_filename.3-dedd29.png" alt="unknown_filename.3"></p></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-f989198a2b3080e553a82f61b4413f30-unknown_filename.6-dea111.png" alt="unknown_filename.6"><br>云点播录制</p><p><strong>CNAME</strong><br>即别名记录。这种记录允许您将多个名字映射到另外一个域名。从一个域名到另一个域名<br>简单来说，A记录就是把一个域名解析到一个IP地址，而CNAME记录就是把域名解析到另外一个域名。比如<a href="http://www.baidu.com，这个二级域名解析到的是一个服务器的IP地址，比如8.8.8.8，而CNAME是将新域名，比如：a.www.baidu.com解析到另外一个域名，比如：www.baidu.com。">www.baidu.com，这个二级域名解析到的是一个服务器的IP地址，比如8.8.8.8，而CNAME是将新域名，比如：a.www.baidu.com解析到另外一个域名，比如：www.baidu.com。</a><br>CNAME在CDN中的应用<br>子域名<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-2ed57c23e0833e289697a1f6d1e2917f-unknown_filename.4-6ea66a.png" alt="unknown_filename.4"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-bef0d97f8c30f16d295563c7c879b9ff-unknown_filename.5-8c5b29.png" alt="unknown_filename.5"></p><p><strong>直播转码功能（包含视频转码和音频转码）</strong><br>指将直播现场推送出来的原始流，在云端转换为不同编码格式、不同分辨率、不同码率的转码流推送给观众，以满足不同网络环境、不同终端设备等各种场景下的播放需求。<br>将原始视频流中打上官方自定义水印</p><p><strong>demo图</strong></p><p><a href="https://github.com/tencentyun/MLVBSDK/tree/master/Android/Demo">https://github.com/tencentyun/MLVBSDK/tree/master/Android/Demo</a></p><p><strong>推流失败问题排查</strong><br>创建房间失败[获取推流地址失败]</p><p><a href="https://cloud.tencent.com/document/product/267/7972">https://cloud.tencent.com/document/product/267/7972</a></p><p>在所有检查开始之前，您务必要先检查一下地址是否正确，因为这里出错概率最高，腾讯云的直播地址分推流地址和播放地址两种，我们要首先排除误拿<strong>推流地址来播放</strong>的错误。</p><p><strong>创建直播间失败的原因</strong><br>需要绑定已备案域名才能进行播放。现在没有配置所以接口在获取推拉流地址时返回失败。绑定域名可以进入 <a href="https://console.cloud.tencent.com/live/domainmanage">https://console.cloud.tencent.com/live/domainmanage</a> 进操作<br>①、没有购买连麦套餐；②、没有域名备案</p><p>获取直播推流地址向后台请求用于直播推流用的推流地址<br>接口名：get_anchor_url</p><p>“小直播”需要搭建自己的后台，开通对象存储服务（COS）对象存储服务主要用于小直播 App 中的直播封面图片和个人头像存储。<br><a href="https://cloud.tencent.com/document/product/454/15187">https://cloud.tencent.com/document/product/454/15187</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-b1a7d49924f7668d367f0978402fa1f2-unknown_filename.1-761e5b.png" alt="unknown_filename.1"></p><p>码率、分辨率自适应<br>设置场景化配置后，SDK 内部会根据场景自动选择相关的配置参数，所以我们这里把内部的config获取出来，赋值到外部。</p><p><strong>TRTC SDK</strong> 实现一个既支持视频连麦，又支持上万人高并发观看的在线直播功能</p><p><strong>常见的直播协议</strong><br>目前常见的直播协议有三种：RTMP、 FLV 和 HLS。</p><ul><li><strong>RTMP</strong>：RTMP 协议比较全能，既可以用来推送又可以用来直播，其核心理念是将大块的视频帧和音频帧拆分，然后以小数据包的形式在互联网上进行传输，而且支持加密，因此隐私性相对比较理想，但拆包组包的过程比较复杂，所以在海量并发时也容易出现一些不可预期的稳定性问题。</li><li><strong>FLV</strong>：FLV 协议由 Adobe 公司主推，格式极其简单，只是在大块的视频帧和音视频头部加入一些标记头信息，由于这种简洁，在延迟表现和大规模并发方面都很成熟，唯一的不足就是在手机浏览器上的支持非常有限，但是用作手机端 App 直播协议却异常合适。</li><li><strong>HLS</strong>：苹果推出的解决方案，将视频分成5秒 - 10秒的视频小分片，然后用 m3u8 索引表进行管理，由于客户端下载到的视频都是5秒 - 10秒的完整数据，故视频的流畅性很好，但也同样引入了很大的延迟（HLS 的一般延迟在10秒 - 30秒左右）。相比于 FLV， HLS 在 iPhone 和大部分 Android 手机浏览器上的支持非常给力，所以常用于 QQ 和微信朋友圈的 URL 分享。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-bb8c8786372e27d01a0d0a595bc39e32-unknown_filename.2-bfd1eb.png" alt="unknown_filename.2"></p><p>原始流与推流码率分辨率一致。<br>高清流建议使用码率：2000kbps，分辨率：1080p。<br>标清流建议使用码率：1000kbps，分辨率：720p。</p><p><strong>txTime 是否过期？</strong><br>有些客户担心自己的直播流量被人盗用，会将 txTime 设置得过于保守，例如从当前时间开始往后推5分钟。其实由于有 txSercet 签名的存在，txTime 的有效期不用设置得太短。相反，如果有效期设置得太短，当主播在直播过程中遭遇网络闪断时会因为推流 URL 过期而无法恢复推流。<br>txTime 建议设置为当前时间往后推12或者24小时为宜，也就是要长于一场普通直播的直播时间</p><p><strong>连麦互动</strong></p><p><a href="https://cloud.tencent.com/document/product/454/14606">https://cloud.tencent.com/document/product/454/14606</a><br>Step3. 购买连麦套餐包由于连麦功能会使用到高速专线来降低音视频传输延迟，这部分功能<strong>需要额外购买套餐包才能开通</strong>，否则移动直播的各端 SDK 只能使用云直播的普通服务（推流和拉流），并不能开启连麦功能。</p><p>由于连麦功能会使用到高速专线来降低音视频传输延迟，这部分功能需要<strong>额外购买套餐包</strong>才能开通，否则移动直播的各端 SDK 只能使用云直播的普通服务（推流和拉流），并不能开启连麦功能。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9B%B4%E6%92%AD.resources/2023/09/18/16-03-06-9329dadb1b9e6069e93d958380536896-unknown_filename-d56373.png" alt="unknown_filename"><br>MLVBLiveRoom：基于腾讯云直播（LVB）、云点播（VOD） 和即时通信（IM）三大 PAAS 服务组合而成</p><p><strong>常用类</strong><br>TXLivePusher 接口提供摄像头推流能力<br>TXLivePlayer 模块负责实现直播播放功能</p><p><strong>硬件加速</strong><br>硬件加速在1080p解码场景下效果显著，但细节之处并不如想象的那么美好：<br>(1) 只有 4.3 以上android系统才支持<br>(2) 兼容性我们目前还仅过了小米华为等常见机型，故这里的返回值您先不要太当真</p><p><strong>缓存策略</strong><br>自动、极速、流畅。<br>极速模式：时延会尽可能低、但抗网络抖动效果不佳；<br>流畅模式：时延较高、抗抖动能力较强</p><p><strong>权限检测相关</strong></p><pre><code class="hljs"> private boolean checkPublishPermission() &#123;        if (Build.VERSION.SDK_INT &gt;= 23) &#123;            List&lt;String&gt; permissions = new ArrayList&lt;&gt;();            if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;                permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);            &#125;            if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA)) &#123;                permissions.add(Manifest.permission.CAMERA);            &#125;            if (permissions.size() != 0) &#123;                ActivityCompat.requestPermissions(this,                        permissions.toArray(new String[0]),                        100);                return false;            &#125;        &#125;        return true;    &#125;</code></pre><p>硬件加速变更不需要重启推流，直接应用配置项即可</p><p>利用 QRCode 生成 Bitmap的工具函数<br>createQRCodeBitmap(String content, int widthPix, int heightPix)</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket</title>
    <link href="/2025/12/6c2523187470.html"/>
    <url>/2025/12/6c2523187470.html</url>
    
    <content type="html"><![CDATA[<h2 id="聊聊OkHttp实现WebSocket细节，包括鉴权和长连接保活及其原理！-承香墨影-博客园"><a href="#聊聊OkHttp实现WebSocket细节，包括鉴权和长连接保活及其原理！-承香墨影-博客园" class="headerlink" title="聊聊OkHttp实现WebSocket细节，包括鉴权和长连接保活及其原理！ - 承香墨影 - 博客园"></a><a href="https://www.cnblogs.com/plokmju/p/okhttp_weisocket.html">聊聊OkHttp实现WebSocket细节，包括鉴权和长连接保活及其原理！ - 承香墨影 - 博客园</a></h2><ul><li><p>今天介绍的 WebSocket，下层和 HTTP 一样也是基于 TCP 协议，这是一种轻量级网络通信协议，也属于应用层协议。</p></li><li><p>轮询的缺点也非常明显，大量空闲的时间，其实是在反复发送无效的请求，这显然是一种资源的损耗。</p></li><li><p>WebSocket 是真正意义上的全双工模式，也就是我们俗称的「长连接」。当完成握手连接后，客户端和服务端均可以主动的发起请求，回复响应，并且两边的传输都是相互独立的。</p></li><li><p>在建立连接前，客户端还需要知道服务端的地址，WebSocket 并没有另辟蹊径，而是沿用了 HTTP 的 URL 格式，但协议标识符变成了 “ws” 或者 “wss”，分别表示明文和加密的 WebSocket 协议，这一点和 HTTP 与 HTTPS 的关系类似。</p></li><li><p>以下是一些 WebSocket 的 URL 例子：</p></li><li><p><code>ws://cxmydev.com/some/path ws://cxmydev.com:8080/some/path wss://cxmydev.com:443?uid=xxx </code></p></li><li><p>而在连接建立后，WebSocket 采用二进制帧的形式传输数据，其中常用的包括用于数据传输的数据帧 MESSAGE 以及 3 个控制帧：</p></li><li><p>PING：主动保活的 PING 帧；</p></li><li><p>PONG：收到 PING 帧后回复；</p></li><li><p>CLOSE：主动关闭 WebSocket 连接；</p></li></ul><h2 id="WebSocket-的特性："><a href="#WebSocket-的特性：" class="headerlink" title="WebSocket 的特性："></a>WebSocket 的特性：</h2><ul><li>WebSocket 建立在 TCP 协议之上，对服务器端友好；</li><li>默认端口采用 80 或 443，握手阶段采用 HTTP 协议，不容易被防火墙屏蔽，能够通过各种 HTTP 代理服务器；</li><li>传输数据相比 HTTP 更轻量，少了 HTTP Header，性能开销更小，通信更高效；</li><li>通过 MESSAGE 帧发送数据，可以发送文本或者二进制数据，如果数据过大，会被分为多个 MESSAGE 帧发送；</li><li>WebSocket 沿用 HTTP 的 URL，&#x3D;&#x3D;协议标识符是 “ws” 或 “wss”&#x3D;&#x3D;。</li></ul><h2 id="WebSocket之OkHttp"><a href="#WebSocket之OkHttp" class="headerlink" title="WebSocket之OkHttp"></a>WebSocket之OkHttp</h2><h3 id="建立-WebSocket-连接"><a href="#建立-WebSocket-连接" class="headerlink" title="建立 WebSocket 连接"></a>建立 WebSocket 连接</h3><ul><li><p>借助 OkHttp 可以很轻易的实现 WebSocket，它的 OkHttpClient 中，提供了 <code>newWebSocket()</code> 方法，可以直接建立一个 WebSocket 连接并完成通信。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionWebSockt</span><span class="hljs-params">(hostName:<span class="hljs-type">String</span>,port:<span class="hljs-type">Int</span>)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> httpClient = OkHttpClient.Builder()<br>      .pingInterval(<span class="hljs-number">40</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 设置 PING 帧发送间隔</span><br>      .build()<br>  <span class="hljs-keyword">val</span> webSocketUrl = <span class="hljs-string">&quot;ws://<span class="hljs-subst">$&#123;hostName&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>&quot;</span><br>  <span class="hljs-keyword">val</span> request = Request.Builder()<br>      .url(webSocketUrl)<br>      .build()<br>  httpClient.newWebSocket(request, <span class="hljs-keyword">object</span>:WebSocketListener()&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>调用 <code>newWebSocket()</code> 后，就会开始 WebSocket 连接</p></li><li><p>WebSocketListener 是一个抽象类，其中定义了比较多的方法，借助这些方法回调，就可以完成对 WebSocket 的所有操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> mWebSocket : WebSocket? = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionWebSockt</span><span class="hljs-params">(hostName:<span class="hljs-type">String</span>,port:<span class="hljs-type">Int</span>)</span></span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  httpClient.newWebSocket(request, <span class="hljs-keyword">object</span>:WebSocketListener()&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onOpen(webSocket, response)<br>      <span class="hljs-comment">// WebSocket 连接建立</span><br>      mWebSocket = webSocket<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, text: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onMessage(webSocket, text)<br>      <span class="hljs-comment">// 收到服务端发送来的 String 类型消息</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosing</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosing(webSocket, code, reason)<br>      <span class="hljs-comment">// 收到服务端发来的 CLOSE 帧消息，准备关闭连接</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClosed</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, code: <span class="hljs-type">Int</span>, reason: <span class="hljs-type">String</span>)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onClosed(webSocket, code, reason)<br>      <span class="hljs-comment">// WebSocket 连接关闭</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(webSocket: <span class="hljs-type">WebSocket</span>, t: <span class="hljs-type">Throwable</span>, response: <span class="hljs-type">Response</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onFailure(webSocket, t, response)<br>      <span class="hljs-comment">// 出错了</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>send(text)：发送 String 类型的消息；</p></li><li><p>send(bytes)：发送二进制类型的消息；</p></li><li><p>close(code, reason)：主动关闭 WebSocket 连接；</p></li></ul><h2 id="Mock-WebSocket"><a href="#Mock-WebSocket" class="headerlink" title="Mock WebSocket"></a>Mock WebSocket</h2><ul><li>有时候为了方便我们测试，OkHttp 还提供了扩展的 MockWebSocket 服务，来模拟服务端。</li><li>MockWebSocket 需要添加额外的 Gradle 引用，最好和 OkHttp 版本保持一致：</li><li><code>api </code>‘com.squareup.okhttp3:okhttp:3.9.1’<code>api</code>‘com.squareup.okhttp3:mockwebserver:3.9.1’</li></ul><h2 id="WebSocket-保活"><a href="#WebSocket-保活" class="headerlink" title="WebSocket 保活"></a>WebSocket 保活</h2><ul><li>WebSocket 建立的连接就是我们所谓的长连接，每个连接对于服务器而言，都是资源。但服务器倾向于在一个连接长时间没有消息往来的时候，将其关闭。而 WebSocket 的保活，实际上就是定时向服务端发送一个空消息，来保证连接不会被服务端主动断开。</li><li>OkHttp 只需要简单的配置，就可以自动的间隔发送 PING 帧和数据。</li><li>在构造 OkHttpClient 的时候，通过 <code>pingInterval()</code> 设置 PING 帧发送的时间间隔，它的默认值为 0，所以不设置不发送。</li><li>val<code> httpClient = OkHttpClient.Builder() .pingInterval(</code></li><li>40<code>, TimeUnit.SECONDS) </code></li><li>&#x2F;&#x2F; 设置 PING 帧发送间隔<code>.build()</code></li><li>这里设置的时长，需要和服务端商议，通常建议最好设置一个小于 60s 的值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SurfaceView和视频</title>
    <link href="/2025/12/385f783fe040.html"/>
    <url>/2025/12/385f783fe040.html</url>
    
    <content type="html"><![CDATA[<h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><p><a href="https://blog.csdn.net/freekiteyu/article/details/79483406">一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系_android sufaceflinger 怎么和surface 交互的-CSDN博客</a></p><h2 id="SurfaceView-和View的区别"><a href="#SurfaceView-和View的区别" class="headerlink" title="SurfaceView 和View的区别"></a>SurfaceView 和View的区别</h2><p>view必须在UI的主线程中更新画面。如果更新时间过长，就会被你正在画的函数阻塞，那么将无法响应按键、触屏等消息。当使用SurfaceView由于是在新的线程中更新画面所以不会阻塞你的UI主线程。</p><ol><li>View适用于主动更新的情况，而SurfaceView则适用于被动更新的情况，比如频繁刷新界面。</li><li>View在主线程中对页面进行刷新，而SurfaceView则开启一个子线程来对页面进行刷新。</li><li>View在绘图时没有实现双缓冲机制，SurfaceView在底层机制中就实现了双缓冲机制</li></ol><h3 id="SurfaceView、TextureView"><a href="#SurfaceView、TextureView" class="headerlink" title="SurfaceView、TextureView"></a>SurfaceView、TextureView</h3><ul><li>SurfaceView的原理就是在<em>现有View的位置上创建一个新的Window</em>，内容的显示和渲染都在新的Window中。这使得SurfaceView的绘制和刷新可以在单独的线程中进行，从而大大提高效率。但是呢，由于SurfaceView的内容没有显示在View中而是显示在新建的Window中， 使得<em>SurfaceView的显示不受View的属性控制</em>，不能进行平移，缩放等变换，也不能放在其它RecyclerView或ScrollView中，一些View中的特性也无法使用。</li><li>TextureView是在4.0(API level 14)引入的，专门用来渲染像视频或OpenGL场景之类的数据。与SurfaceView相比，它不会创建新的窗口来显示内容。它是<em>将内容流直接投放到View中</em>，并且可以和其它普通View一样进行移动，旋转，缩放，动画等变化。TextureView必须在硬件加速的窗口中使用。好在现在的移动设备基本都有GPU进行硬件加速渲染（连我手里这款破旧的华为测试机都有(o)）。</li></ul><h3 id="SurfaceView、SurfaceHolder与Surface"><a href="#SurfaceView、SurfaceHolder与Surface" class="headerlink" title="SurfaceView、SurfaceHolder与Surface"></a>SurfaceView、SurfaceHolder与Surface</h3><ul><li>SurfaceView 的使用方法，大概是获取 SurfaceHolder 对象，监听 surface 创建，更新，销毁，创新一个新的线程，并在其中绘制并提交</li><li>TextureView 并没有独立的绘图表面，在使用过程中，需要添加监听 surfaceTexture 是否可用，再做相应的处理</li></ul><p>SurfaceView、SurfaceHolder、Surface的关系可以概括为以下几点：</p><ul><li>SurfaceView是拥有独立绘图层的特殊View</li><li>Surface是内存中的一段绘图缓冲区。</li><li>SurfaceView中具有两个Surface，也就是我们所说的双缓冲机制</li><li><strong>SurfaceHolder顾名思义就是Surface的持有者，SurfaceView就是通过过SurfaceHolder来对Surface进行管理控制的。并且SurfaceView.getHolder方法可以获取SurfaceView相应的SurfaceHolder。</strong></li><li>Surface是在SurfaceView所在的Window可见的时候创建的。可以使用SurfaceHolder.addCallback方法来监听Surface的创建与销毁的事件。</li></ul><h3 id="SurfaceView的使用"><a href="#SurfaceView的使用" class="headerlink" title="SurfaceView的使用"></a>SurfaceView的使用</h3><ul><li>需要实现 SurfaceHolder.Callback 接口</li><li>需要在 SurfaceHolder.Callback 的 <strong>surfaceCreated</strong> 方法中开启一个线程进行动画的逐帧的绘制。</li><li>需要在 SufaceHolder.Callback 的 surfaceDestroyed 方法中结束绘画的线程并调用 SurfaceHolder 的 removeCallbck 方法</li><li>绘画线程每一帧开始之前需要通过lockCanvas()方法获得Canvas对象</li><li>绘制完一帧的数据之后需要使用unlockCanvasAndPost()方法将画布内容进行提交</li></ul><h3 id="TextureView-的使用"><a href="#TextureView-的使用" class="headerlink" title="TextureView 的使用"></a>TextureView 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">myTexture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextureView</span>(<span class="hljs-built_in">this</span>);<br>myTexture.setSurfaceTextureListener(<span class="hljs-built_in">this</span>);<br>setContentView(myTexture);<br> <br> <span class="hljs-comment">//实现接口</span><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSurfaceTextureAvailable</span><span class="hljs-params">(SurfaceTexture surface, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>        Logger.d(<span class="hljs-string">&quot;player/texture create w=%d, h=%d&quot;</span>, width, height);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSurfaceTextureSizeChanged</span><span class="hljs-params">(SurfaceTexture surface, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onSurfaceTextureDestroyed</span><span class="hljs-params">(SurfaceTexture surface)</span> &#123;<br>        Logger.d(<span class="hljs-string">&quot;player/texture destroyed!&quot;</span>);<br>        <span class="hljs-keyword">if</span> (mSurface != <span class="hljs-literal">null</span>) &#123;<br>            mSurface.release();<br>            mSurface = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="播放器比较"><a href="#播放器比较" class="headerlink" title="播放器比较"></a>播放器比较</h1><p>amino：VideoPlayerView<br><strong>封装</strong>：VoiceController<br>单例初始化、开始、停止、暂停、恢复、seek、获取时长、销毁播放器封装，写了些播放状态的回调：完成、错误、播放进度</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span>()</span> &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != player) &#123;<br>           isPause = <span class="hljs-literal">false</span>;<br>           player.setPlayWhenReady(<span class="hljs-literal">true</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="VideoView与MediaPlayer"><a href="#VideoView与MediaPlayer" class="headerlink" title="VideoView与MediaPlayer"></a>VideoView与MediaPlayer</h3><p>VideoView使用MediaPlayer + SurfaceView，SurfaceView播放视频时，如果不进行设置，视频宽高总是等于定义的。</p><p>SurfaceView布局宽高，所以视频可能会被拉伸变形。而使用VideoView时，视频宽度等于VideoView布局宽，但是<strong>高是自适应的</strong>，自动调整宽高比到视频原始比例，所以不会有拉伸（就是按比例设置的）。</p><p><strong>VideoView不足、MediaPlayer</strong><br>原生VideoView只能播放mp4和3gp两种格式；<br><em>seekTo定位不准，只能定位到关键帧</em>；<br>VideoView不保存视频播放状态，需自行处理；<br>VideoView加载网络视频时，常见黑屏情况，因为VideoView每次都会重新加载。</p><h2 id="hls协议"><a href="#hls协议" class="headerlink" title="hls协议"></a>hls协议</h2><p>hls协议：由苹果公司提出的基于HTTP的流媒体网络传输协议，它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。</p><p>HLS协议规定：<br>视频的封装格式是TS。<br>视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。<br>除了TS视频文件本身，还定义了用来控制播放的m3u8文件（文本文件）<br>m3u8里有很多ts地址，其实就是<strong>分段来加载</strong>。</p><p>ExoPlayer、ijkplayer（FFmpeg）</p><h2 id="ExoPlayer"><a href="#ExoPlayer" class="headerlink" title="ExoPlayer"></a>ExoPlayer</h2><p>支持动态的自适应流 HTTP (DASH) 和 平滑流，任何目前 MediaPlayer 支持的视频格式（同时它还支持 HTTP 直播(HLS)，MP4，MP3，WebM，M4A，MPEG-TS 和 AAC）。<br>支持高级的 HLS 特性，例如正确处理 EXT-X-DISCONTINUITY 标签；<br>还有各种状态<br>支持自定义和扩展，ExoPlayer 专门为此设计；<br>更少的适配性问题。</p><h2 id="ijkplayer"><a href="#ijkplayer" class="headerlink" title="ijkplayer"></a>ijkplayer</h2><p>SurfaceView.getHolder()，然后添加callback，在surfaceCreated里去创建播放器，测量，监听处理<br>surfaceHolder的监听里添加mMediaPlayer.setDisplay(holder);<br>playerContainer是个 FrameLayout</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSurfaceView</span><span class="hljs-params">()</span> &#123;<br>        playerContainer.removeView(mSurfaceView);<br>        mSurfaceView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeSurfaceView</span>(getContext());<br>        <span class="hljs-type">SurfaceHolder</span> <span class="hljs-variable">surfaceHolder</span> <span class="hljs-operator">=</span> mSurfaceView.getHolder();<br>        surfaceHolder.addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SurfaceHolder</span>.Callback() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">surfaceCreated</span><span class="hljs-params">(SurfaceHolder holder)</span> &#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">surfaceChanged</span><span class="hljs-params">(SurfaceHolder holder, <span class="hljs-type">int</span> format, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> </span><br><span class="hljs-params">height)</span> &#123;<br>                <span class="hljs-keyword">if</span> (mMediaPlayer != <span class="hljs-literal">null</span>) &#123;<br>                    mMediaPlayer.setDisplay(holder);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">surfaceDestroyed</span><span class="hljs-params">(SurfaceHolder holder)</span> &#123;<br>            &#125;<br>        &#125;);<br><br>        surfaceHolder.setFormat(PixelFormat.RGBA_8888);<br>        <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LayoutParams</span>(<br>                ViewGroup.LayoutParams.MATCH_PARENT,<br>                ViewGroup.LayoutParams.MATCH_PARENT,<br>                Gravity.CENTER);<br>        playerContainer.addView(mSurfaceView, <span class="hljs-number">0</span>, params);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>addTextureView</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">mMediaPlayer.setSurface(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Surface</span>(surfaceTexture));<br></code></pre></td></tr></table></figure><p>全屏逻辑<br>先把当前的视频view移出掉，隐藏SystemBar，然后在根view通过全屏的LayoutParams再把这个视频viwe添加进去</p><h1 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h1><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/SurfaceView%E5%92%8C%E8%A7%86%E9%A2%91.resources/2023/09/18/09-57-08-ad2c5ee0ec451e44ec363b42f62b8cd0-1240-113da1.jpg" alt="1240"></p><p>音、视频的采集、 处理（美颜、滤镜）、编码（h264、AAC）、推流、拉流<br><em>直播可以通过 UDP 降低传输延迟</em>。</p><p>播放端<br>ijkplayer是基于FFmpeg的跨平台播放器，这个开源项目已经被多个 App 使用，其中映客、美拍和斗鱼使用了 ijkplayer（5700+️）</p><p>推送端<br>个人的话GitHub上有很多开源项目。商用的话可以选择各大厂商的SDK，网易直播云、七牛、阿里、腾讯、百度、新浪都有。<br>使用直播云的好处就是能快速上线App，功能十分齐全，可以播放器和推流端，服务器一套下来，有专业客服人员帮助集成到工程中，缺点就是流量费太贵了，具体可以了解下各大厂商的收费标准。</p><h2 id="软解和硬解"><a href="#软解和硬解" class="headerlink" title="软解和硬解"></a>软解和硬解</h2><p>视频解码工作从处理器那里分离出来，交给显卡去做，这就叫做“硬解码“，纯粹的“硬解码”在现阶段是不存在的，ＣＰＵ依然在发挥一部分作用，只不过硬解码时ＧＰＵ／ＶＰＵ已经成为运算的主力。</p><p>[[腾讯云直播]]</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>我们分别从摄像头 &#x2F; 录音设备采集数据，将数据送入编码器，分别编码出视轨 &#x2F; 音轨之后，再送入合成器（MediaRemuxer 或者类似 mp4v2、FFmpeg 之类的处理库），最终输出 MP4 文件。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/SurfaceView%E5%92%8C%E8%A7%86%E9%A2%91.resources/2023/09/18/09-57-08-7a14a4ea1edd35b00640957d167bb117-unknown_filename.1-99a74d.png" alt="unknown_filename.1"></p><p>对于目前的视频类 App 来说，还有各种各样的滤镜和美颜效果，实际上都可以基于 OpenGL 来实现。</p><h2 id="视频编辑"><a href="#视频编辑" class="headerlink" title="视频编辑"></a>视频编辑</h2><p>在当下视频类 App 中，你可以见到各种视频裁剪、视频编辑的功能，例如：<br>裁剪视频的一部分。<br>多个视频进行拼接。</p><p><strong>对于视频裁剪、拼接来说，Android 直接提供了 MediaExtractor</strong> 的接口，结合 seek 以及对应读取帧数据 readSampleData 的接口，我们可以直接获取对应时间戳的帧的内容，这样读取出来的是已经编码好的数据，因此无需重新编码，直接可以输入合成器再次合成为 MP4。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/SurfaceView%E5%92%8C%E8%A7%86%E9%A2%91.resources/2023/09/18/09-57-08-bf719ef4f05d166b08e4aa93691def99-unknown_filename.2-ecf1aa.png" alt="unknown_filename.2"><br>我们只需要 seek 到需要裁剪原视频的时间戳，然后一直读取 sampleData，送入 MediaMuxer 即可，这是视频裁剪最简单的实现方式。<br>上面是基础的视频裁剪流程，对于视频拼接，也是类似得到多段 H.264 数据之后，才一同送入合成器。<br>MediaPlayer 无法精准的seek</p><p><strong>视频特效滤镜</strong><br>播放的视频可能是作为视频编辑的一部分，在剪辑时需要实时预览视频特效。我们可以简单配置播放视频的 View 为一个 GLSurfaceView，有了 OpenGL 的环境，我们就可以在这上实现各种特效、滤镜的效果了。而<strong>对于视频编辑常见的快进、倒放之类的播放配置，MediaPlayer 也有直接的接口可以设置</strong>。一般的流程是下面这样的。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/SurfaceView%E5%92%8C%E8%A7%86%E9%A2%91.resources/2023/09/18/09-57-08-e10a1b911a85cc4817a2971b0b1f97a3-unknown_filename.3-80882d.png" alt="unknown_filename.3"><br>我们将解码之后的渲染交给 OpenGL，然后输出到编码器的 InputSurface 上，来实现整套编码流程。</p><p><strong>视频播放</strong></p><ol><li>需要播放的视频可能本身并不在本地，很多可能都是网络视频，有边下边播的需求。</li><li>播放的视频可能是作为视频编辑的一部分，在剪辑时需要实时预览视频特效。<br> 对于第二种场景，我们可以简单配置播放视频的 View 为一个 GLSurfaceView，有了 OpenGL 的环境，我们就可以在这上实现各种特效、滤镜的效果了。而对于视频编辑常见的快进、倒放之类的播放配置，MediaPlayer 也有直接的接口可以设置。</li></ol><p>虽然 MediaPlayer 也能实现在线视频播放，但实际使用下来，会有两个问题：</p><ul><li>通过设置 MediaPlayer 视频 URL 方式下载下来的视频，被放到了一个私有的位置，App 不容易直接访问，这样会导致我们没法做视频预加载，而且之前已经播放完、缓冲完的视频，也不能重复利用原有缓冲内容。</li><li>同视频剪辑直接使用 MediaExtractor 返回的数据问题一样，MediaPlayer 同样无法精确 seek，只能 seek 到有关键帧的地方。</li></ul><p>对于第一个问题，我们可以通过视频 URL 代理下载的方式来解决，通过本地使用 Local HTTP Server 的方式代理下载到一个指定的地方。现在开源社区已经有很成熟的项目实现，例如AndroidVideoCache。<br>而对于第二个问题来说，可以直接使用 Google 开源的ExoPlayer，简单又快捷，而且也能支持设置在线视频 URL。</p><h2 id="边下边播"><a href="#边下边播" class="headerlink" title="边下边播"></a>边下边播</h2><p>常见的网络边下边播视频的格式都是 MP4，但有些视频直接上传到服务器上的时候，我们会发现无论是使用 MediaPlayer 还是 ExoPlayer，似乎都只能等待到整个视频都下载完才能开始播放，没有达到边下边播的体验。<br>这个问题的原因实际上是因为 MP4 的格式导致的，具体来看，是跟 MP4格式中的 moov 有关。</p><p>MP4 格式中有一个叫作 moov 的地方存储这当前 MP4 文件的元信息，包括当前 MP4 文件的音轨视轨格式、视频长度、播放速率、视轨关键帧位置偏移量等重要信息，MP4 文件在线播放的时候，需要 moov 中的信息才能解码音轨视轨。</p><p>而上述问题发生的原因在于，当 moov 在 MP4 文件尾部的时候，播放器没有足够的信息来进行解码，因此视频变得需要直接下载完之后才能解码播放。因此，要实现 MP4 文件的边下边播，则需要将 moov 放到文件头部。目前来说，业界已经有非常成熟的工具，FFmpeg跟mp4v2都可以<strong>将一个 MP4 文件的 moov 提前放到文件头部</strong>。例如使用 FFmpeg，则是如下命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ffmpeg -i <span class="hljs-keyword">input</span>.mp4 -movflags faststart -acodec <span class="hljs-keyword">copy</span> -vcodec <span class="hljs-keyword">copy</span> output.mp4<br></code></pre></td></tr></table></figure><p>在视频播放的实践中，除了 MP4 格式来作为边下边播的格式以外，还有更多的场景需要使用其他格式，例如 m3u8、FLV 之类，业界在客户端中常见的实现包括ijkplayer、ExoPlayer，有兴趣的同学可以参考下它们的实现。</p><h2 id="AndroidVideoCache"><a href="#AndroidVideoCache" class="headerlink" title="AndroidVideoCache"></a>AndroidVideoCache</h2><p>AndroidVideoCache是一个音视频缓存库，用于支持VideoView&#x2F;MediaPlayer, ExoPlayer ,IJK等播放器的边下载边播放，按照github列出支持的特性如下：<br>视频文件缓存，预缓存（秒开处理），监控</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HttpProxyCacheServer proxy <span class="hljs-operator">=</span> getProxy()<span class="hljs-comment">;//注意不能传入本地路径，本地的你还传进来干嘛。</span><br>String proxyUrl <span class="hljs-operator">=</span> proxy.getProxyUrl(VIDEO_URL)<span class="hljs-comment">;</span><br>videoView.setVideoPath(proxyUrl)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>该项目的原理其实就是<strong>将流数据源url地址转化为本地的代理服务器url</strong><br><a href="http://127.0.0.1:LocalPort/url，然后它开一个服务器一边下载缓存视频，一边把缓存的数据正常返回给你的播放器，如果已经缓存过的这里会返回一个本地文件路径">http://127.0.0.1:LocalPort/url，然后它开一个服务器一边下载缓存视频，一边把缓存的数据正常返回给你的播放器，如果已经缓存过的这里会返回一个本地文件路径</a></p><p>您可以使用exoPlayer与AndroidVideoCache。查看分支中的sample应用exoPlayer。注意exoPlayer也支持缓存。</p><h1 id="视频知识"><a href="#视频知识" class="headerlink" title="视频知识"></a>视频知识</h1><h2 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h2><p><strong>编码 就是压缩，解码 就是解压缩</strong>。视频文件的本质其实就是图片的集合而已，当一段连续的图片不断的出现在人眼前(一般一个连贯的电影或者动画至少要求一秒24帧，也就是一秒内连续出现24张图片)，肉眼就会“欺骗性”的告诉大脑我们在看一个视频，而不是幻灯片。<br>假设一张像素为1280X720(清晰度，宽1280个像素点，高720个像素点)的图片，大小为约为1280X720X3 bytes,就是2.7MB。大家可以猜想一下为何我这里还需要乘以一个数字3.那么一段60秒钟的小电影，就需要60X24（24张图片）X2.7MB ，约为3.9GB了！<br>在播放器的客户端，不管是PC，手机也好，他们要显示在屏幕上的，必须是实实在在的图片啊，所以这些被压缩过的文件最终又必须被还原成图片格式，这就是解码，解压缩。</p><p><strong>H.264&#x2F;265都是编解码规范</strong></p><h2 id="MP4"><a href="#MP4" class="headerlink" title="MP4"></a>MP4</h2><p>呆坐了整整30s。那么对于这种“静态的场景”，视频压缩算法会只取这三十秒的前几帧作为基准帧图片，对其余的29s的帧，采取只保存“不同的部分”的策略，这样就不用保存这些差不多相同的图片，这种做法叫“去冗余”。大大减少了视频的体积。<br>mp4,rmvb,avi，他们应该被叫做容器文件(序列)。。。。因为一个容器里，不仅仅包括了视频(video)数据（轨道），还包括了(audio)音频数据，有的容器还内嵌字幕，那么就还有文字(Text)数据。<br>MP4 文件里面最重要的却是这个MetaData，它包含了很多关于视频的原始数据，比如视频的大小，视频的时长，还有一个索引表，这个索引表包含了不同轨道的起始位置。<br>举个简单的例子，有些电影包含粤语，国语两个声道。我们想换声道的时候会告诉播放器，我想听粤语，那么播放器会去索引表查找粤语的轨道起始位置，并且源源不断的读取粤语音轨的数据并播放出来。<br>直接看某一段视频，其实就是http的分段式下载RANGE的header</p><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p>对于我们来说，最常见的视频格式就是MP4格式，这是一个通用的容器格式。所谓容器格式，就意味内部要有对应的数据流用来承载内容。而且既然是一个视频，那必然有音轨和视轨，而音轨、视轨本身也有对应的格式。常见的音轨、视轨格式包括：</p><p>视轨：其中，目前大部分 Android 手机都支持 H.264 格式的直接硬件编码和解码；<strong>对于 H.265 来说，Android 5.0 以上的机器就支持直接硬件解码了，但是对于硬件编码，目前只有一部分高端芯片可以支持</strong>，例如高通的 8xx 系列、华为的 98x 系列。对于视轨编码来说，分辨率越大性能消耗也就越大，编码所需的时间就越长。<br>音轨：AAC<br>h265 体积差不多是同质量的 h264 的一半</p><h2 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h2><p>同一个压缩格式下，码率越高质量也就越好，码率越高越清晰，反之则画面粗糙而多马赛克<br>码率：影响体积，与体积成正比：码率越大，体积越大。清晰度正比<br>码率（码流率）&#x3D;采样率 x 位深度 x 声道<br>文件大小 &#x3D; 码率 x 时长<br>码率不是越大越好，码率超过一定数值，对图像的质量没有多大影响。太大体积也大，意味着更多的费用开支。<br>采样率（帧率）越高，就能越真实低保留【原始模拟的音视频细节】</p><h2 id="帧率（FPS）"><a href="#帧率（FPS）" class="headerlink" title="帧率（FPS）"></a>帧率（FPS）</h2><p>帧率就是在1秒钟时间里传输的图片的帧数<br>影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。<br>高于16的时候，就会认为是连贯的<br>帧率不要超过24</p><p><strong>分辨率</strong><br>影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>view</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2025/12/c0176dd9412b.html"/>
    <url>/2025/12/c0176dd9412b.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html.resources/2023-12-29-15-02-bb53b0480b65cf528294a9e41c4bb56c-unknown_filename.3-f0c740.jpeg" alt="unknown_filename.3"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">re.compile(&#x27;&lt;div.\*?author&quot;&gt;.\*?&lt;a.\*?&lt;img.\*?&gt;(.\*?)<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.\*?&lt;div.\*?&#x27;+&#x27;content&quot;&gt;(.\*?)<span class="hljs-comment">&lt;!--(.\*?)--&gt;</span>.\*?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>(.\*?)<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;stats.\*?class=&quot;</span><span class="hljs-attr">number</span>&quot;&gt;</span>(.\*?)<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#x27;,re.S)<br>pattern = re.compile(&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-image&quot;</span>&gt;</span>.\*?<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;(.\*?)&quot;</span><span class="hljs-attr">.</span>\*?/&gt;</span>&#x27;, re.S)<br></code></pre></td></tr></table></figure><h2 id="匹配数字"><a href="#匹配数字" class="headerlink" title="匹配数字"></a>匹配数字</h2><p>a &#x3D; ‘asdfasf1234567fasd555fas’<br>b &#x3D; re.findall(‘(\d+)’, a)</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81.html.resources/2023-12-29-15-02-a709b855c38a9e4e4fbd2abc6c554474-unknown_filename.1-7de6bc.png" alt="unknown_filename.1"></p><p>反盗链</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">self.user_agent</span> = <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#x27;</span><br><span class="hljs-comment"># 初始化 headers</span><br><span class="hljs-attr">self.headers</span> = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: self.user_agent&#125;<br></code></pre></td></tr></table></figure><p>如果不行，看有没有referer<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html.resources/2023-12-29-15-02-b480f572098dae99d4af405586fc67af-unknown_filename.2-00cb58.png" alt="unknown_filename.2"></p><p>1）.*? 是一个固定的搭配，.和*代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到.*? 的搭配。<br>2）(.*?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.*?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。<br>tem[0] 是一个段子的发布者，item[1] 是内容，item[2] 是发布时间, item[4] 是点赞数<br>3）re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。</p><p>match：匹配string 开头，成功返回Match object, 失败返回None，只匹配一个。<br>search：在string中进行搜索，成功返回Match object, 失败返回None, 只匹配一个。<br>findall：在string中查找所有 匹配成功的组, 即用括号括起来的部分。返回list对象，每个list item是由每个匹配的所有组组成的list。<br>finditer：在string中查找所有 匹配成功的字符串, 返回iterator，每个item是一个Match object。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>\d可以匹配一个数字，\w可以匹配一个字母或数字<br>.可以匹配任意字符，所以：’py.’可以匹配’pyc’、’pyo’、’py!’等等。<br>，用*表示任意个字符（包括0个），用+表示至少一个字符(没有空格)<br>用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：<br>\d{3}\s+\d{3,8}。<br>\d{3}表示匹配3个数字，例如’010’；<br>\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配’ ‘，’ ‘等；<br>\d{3,8}表示3-8个数字，例如’1234567’。<br>要匹配’010-12345’这样的号码呢？由于’-‘是特殊字符，在正则表达式中，要用’\‘转义，所以正则是\d{3}\-\d{3,8}。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html.resources/2023-12-29-15-02-0210e6228903668e0b0bd95d0b2155b9-unknown_filename-8c764e.png" alt="unknown_filename|728x0"></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>要做更精确地匹配，可以用[]表示范围<br>[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；<br>[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等；<br>[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；<br>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p><p>A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。<br>^表示行的开头，^\d表示必须以数字开头。<br>$表示行的结束，\d$表示必须以数字结束。<br>py也可以匹配’python’，但是加上^py$就变成了整行匹配，就只能匹配’py’了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs python">content = <span class="hljs-string">&#x27;333STR1666STR299&#x27;</span><br>regex = <span class="hljs-string">r&#x27;([A-Z]+(\d))&#x27;</span><br><span class="hljs-comment"># 最外边的括号去掉，即regex = r&#x27;[A-Z]+(\d)&#x27;，组的个数就会减少一个</span><br><span class="hljs-comment"># content的开头不符合正则，所以结果为None。</span><br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(regex, content))<br><span class="hljs-comment"># None</span><br><br><span class="hljs-comment"># 只会找一个匹配，match[0]是regex所代表的整个字符串，match[1]是第一个()中的内容，match[2]是第二对()中的内容。</span><br><span class="hljs-keyword">match</span> = re.search(regex, content)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nre.search() return value: &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">type</span>(<span class="hljs-keyword">match</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">match</span>.group(<span class="hljs-number">0</span>), <span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>), <span class="hljs-keyword">match</span>.group(<span class="hljs-number">2</span>))<br><span class="hljs-comment"># re.search() return value: &lt;type &#x27;_sre.SRE_Match&#x27;&gt;</span><br><span class="hljs-comment"># (&#x27;STR1&#x27;, &#x27;STR1&#x27;, &#x27;1&#x27;)</span><br><br>result1 = re.findall(regex, content)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nre.findall() return value: &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">type</span>(result1)))<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> result1:<br>    <span class="hljs-built_in">print</span>(m[<span class="hljs-number">0</span>], m[<span class="hljs-number">1</span>])<br><span class="hljs-comment"># re.findall() return value: &lt;type &#x27;list&#x27;&gt;</span><br><span class="hljs-comment"># (&#x27;STR1&#x27;, &#x27;1&#x27;)</span><br><span class="hljs-comment"># (&#x27;STR2&#x27;, &#x27;2&#x27;)</span><br><br>result2 = re.finditer(regex, content)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nre.finditer() return value: &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">type</span>(result2)))<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> result2:<br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>), m.group(<span class="hljs-number">1</span>), m.group(<span class="hljs-number">2</span>))  <span class="hljs-comment">#字符串</span><br><span class="hljs-comment"># re.finditer() return value: &lt;type &#x27;callable-iterator&#x27;&gt;</span><br><span class="hljs-comment"># (&#x27;STR1&#x27;, &#x27;STR1&#x27;, &#x27;1&#x27;)</span><br><span class="hljs-comment"># (&#x27;STR2&#x27;, &#x27;STR2&#x27;, &#x27;2&#x27;)</span><br><br><span class="hljs-comment"># 切分字符串</span><br><span class="hljs-built_in">print</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">, &#x27;</span><span class="hljs-number">0</span>10-<span class="hljs-number">12345</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string"># _sre.SRE_Match object at 0x1026e18b8&gt;</span><br><span class="hljs-string">print re.match(r&#x27;</span>^\d&#123;<span class="hljs-number">3</span>&#125;\-\d&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;<br><br>, <span class="hljs-string">&#x27;010 12345&#x27;</span>)<br><br><span class="hljs-built_in">print</span> re.split(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27;a b   c&#x27;</span>)<br><span class="hljs-built_in">print</span> re.split(<span class="hljs-string">r&#x27;[\s\,]+&#x27;</span>, <span class="hljs-string">&#x27;a,b, c  d&#x27;</span>)<br><span class="hljs-comment"># 空格或，或；+至少一个空格</span><br><span class="hljs-built_in">print</span> re.split(<span class="hljs-string">r&#x27;[\s\,\;]+&#x27;</span>, <span class="hljs-string">&#x27;a b;; c  d&#x27;</span>)<br><br><span class="hljs-comment"># 分组</span><br><span class="hljs-comment"># 用()表示的就是要提取的分组（Group）</span><br><span class="hljs-comment"># group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</span><br>m = re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">, &#x27;</span><span class="hljs-number">0</span>10-<span class="hljs-number">12345</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string">print m.group(0)</span><br><span class="hljs-string">print m.group(1)</span><br><span class="hljs-string">print m.group(2)</span><br><span class="hljs-string"></span><br><span class="hljs-string">t = &#x27;</span><span class="hljs-number">19</span>:05:<span class="hljs-number">30</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">m = re.match(</span><br><span class="hljs-string">    r&#x27;</span>^(<span class="hljs-number">0</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>]|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])\:(<span class="hljs-number">0</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">3</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])\:(<span class="hljs-number">0</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">3</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])<br><br>,<br>    t)<br><span class="hljs-built_in">print</span> m.groups()<br><br><span class="hljs-comment"># 识别日期：&#x27;^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])</span><br><br><br><span class="hljs-comment"># 对于&#x27;2-30&#x27;，&#x27;4-31&#x27;这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</span><br><br><span class="hljs-comment"># 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</span><br><span class="hljs-built_in">print</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;^(\d+)(0*)</span><br><span class="hljs-string"></span><br><span class="hljs-string">, &#x27;</span><span class="hljs-number">102300</span><span class="hljs-string">&#x27;).groups()</span><br><span class="hljs-string"># (&#x27;</span><span class="hljs-number">102300</span><span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string"># 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</span><br><span class="hljs-string"># 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</span><br><span class="hljs-string">print re.match(r&#x27;</span>^(\d+?)(<span class="hljs-number">0</span>*)<br><br>, <span class="hljs-string">&#x27;102300&#x27;</span>).groups()<br><span class="hljs-comment"># (&#x27;1023&#x27;, &#x27;00&#x27;)</span><br><br><span class="hljs-comment"># 预编译该正则表达式</span><br>re_telephone = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">)</span><br><span class="hljs-string"># 使用：</span><br><span class="hljs-string">print re_telephone.match(&#x27;</span><span class="hljs-number">0</span>10-<span class="hljs-number">12345</span><span class="hljs-string">&#x27;).groups()</span><br><span class="hljs-string"># (&#x27;</span><span class="hljs-number">0</span>10<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-number">12345</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string">print re_telephone.match(&#x27;</span><span class="hljs-number">0</span>10-<span class="hljs-number">8086</span><span class="hljs-string">&#x27;).groups()</span><br><span class="hljs-string"># (&#x27;</span><span class="hljs-number">0</span>10<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-number">8086</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string"># someone@gmail.com</span><br><span class="hljs-string"># &lt;Tom Paris&gt; tom@voyager.org</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 正则表达式中，“.”的作用是匹配除“\n”以外的任何字符，也就是说，</span><br><span class="hljs-string"># 它是在一行中进行匹配。这里的“行”是以“\n”进行区分的。a字符串有每行的末尾有一个“\n”，不过它不可见。</span><br><span class="hljs-string"># 如果不使用re.S参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始，不会跨行。而使用re.S参数以后，</span><br><span class="hljs-string"># 正则表达式会将这个字符串作为一个整体，将“\n”当做一个普通的字符加入到这个字符串中，在整体中进行匹配。</span><br><span class="hljs-string">a = &#x27;</span><span class="hljs-string">&#x27;&#x27;</span>asdfhellopass:<br>    <span class="hljs-number">123</span><br>    worldaf<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b = re.findall(&#x27;hello(.*?)world&#x27;, a)</span><br><span class="hljs-string">c = re.findall(&#x27;hello(.*?)world&#x27;, a, re.S)</span><br><span class="hljs-string">print &#x27;b is &#x27;, b</span><br><span class="hljs-string">print &#x27;c is &#x27;, c</span><br><span class="hljs-string"># b is  []</span><br><span class="hljs-string"># c is  [&#x27;pass:\n\t123\n\t&#x27;]</span><br><span class="hljs-string"></span><br><span class="hljs-string">text = &#x27;&#x27;</span><br><span class="hljs-string">file = open(&#x27;sina.html&#x27;)</span><br><span class="hljs-string">for line in file:</span><br><span class="hljs-string">    text = text + line</span><br><span class="hljs-string"></span><br><span class="hljs-string">file.close()</span><br><span class="hljs-string"></span><br><span class="hljs-string"># &#123;&#125;表示位数，[][]表示第一位第二位</span><br><span class="hljs-string"># ()是或者，几个（）就是几个元素的数组，没有会是&quot;&quot;，所以过滤了下</span><br><span class="hljs-string"># match和findall的区别</span><br><span class="hljs-string"># 1）.*? 是一个固定的搭配，.和*代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，</span><br><span class="hljs-string"># 也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。</span><br><span class="hljs-string"># 2）(.*?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，</span><br><span class="hljs-string"># item[0]就代表第一个(.*?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。</span><br><span class="hljs-string">pattern = re.compile(</span><br><span class="hljs-string">    &#x27;&lt;div class=&quot;author clearfix&quot;&gt;.*?&lt;a.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;div class=&quot;articleGender manIcon&quot;&gt;(.*?)&lt;/div&gt;.*?&lt;div class=&quot;content&quot;&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class=&quot;stats-vote&quot;&gt;&lt;i class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;&#x27;,</span><br><span class="hljs-string">    re.S)</span><br><span class="hljs-string">items = re.findall(pattern, text)</span><br><span class="hljs-string">for item in items:</span><br><span class="hljs-string">    print item</span><br><span class="hljs-string"></span><br><span class="hljs-string"># final_result = set()</span><br><span class="hljs-string"># for pair in result:</span><br><span class="hljs-string">#     if pair[0] not in final_result:</span><br><span class="hljs-string">#         final_result.add(pair[0])</span><br><span class="hljs-string">#         if pair[1] not in final_result:</span><br><span class="hljs-string">#             final_result.add(pair[1])</span><br><span class="hljs-string">#</span><br><span class="hljs-string"># final_result.remove(&#x27;&#x27;)</span><br><span class="hljs-string"># print(final_result)</span><br><span class="hljs-string">print items</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文字编码</title>
    <link href="/2025/12/6541df92357d.html"/>
    <url>/2025/12/6541df92357d.html</url>
    
    <content type="html"><![CDATA[<p>decode（’utf - 8’）解码 把其他编码转换成unicode编码<br>encode(’gbk’) 编码 把unicode编码转换成其他编码<br>”gbk”.decode(’gbk’).encode(’utf - 8’)<br>unicode &#x3D; 中文<br>gbk &#x3D; 英文<br>utf - 8 &#x3D; 日文<br>英文一 &gt; 中文一 &gt; 日文,unicode相当于转化器</p><p>在Python2里字符串只有两大阵营：<br>unicode和str<br>如果type(字符串)显示结果是str，其实指的是bytes字节码。<br>而其它各种我们所说的utf-8，gb2312等等也都是Unicode的不同实现方式。<br>encoding和decoding<br>绝对要记住的：<br>从unicode转换到str，这个叫encoding，编码。<br>从 str 转换到 unicode，这个叫 decoding，解码。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81.html.resources/2023-12-29-15-00-af18f5eb2d038b3a46f461aa038759bc-unknown_filename.2-5566ad.jpeg" alt="unknown_filename.2"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81.html.resources/2023-12-29-15-00-86f8ea6235e8a042fa6f7dc4605f0380-unknown_filename-b7f784.jpeg" alt="unknown_filename"><br>变成unicode的过程，叫<code>decoding</code>。不要记错。</p><h2 id="一定记住，全文都统一用str格式字符串"><a href="#一定记住，全文都统一用str格式字符串" class="headerlink" title="一定记住，全文都统一用str格式字符串"></a>一定记住，全文都统一用<code>str</code>格式字符串</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81.html.resources/2023-12-29-15-00-86f8ea6235e8a042fa6f7dc4605f0380-unknown_filename-b7f784.jpeg" alt="unknown_filename"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81.html.resources/2023-12-29-15-00-a709b855c38a9e4e4fbd2abc6c554474-unknown_filename.1-e2cd58.png" alt="unknown_filename.1"><br>用r.content</p><p>一般网页.decode(“utf-8”)解决问题</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import sys<br><br><span class="hljs-function"><span class="hljs-title">reload</span><span class="hljs-params">(sys)</span></span><br><br>sys<span class="hljs-selector-class">.setdefaultencoding</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-selector-tag">html</span><span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&quot;utf-8&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统</title>
    <link href="/2025/12/c554a1bfcf8b.html"/>
    <url>/2025/12/c554a1bfcf8b.html</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h3 id="分布式系统-1"><a href="#分布式系统-1" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>既然我们要打造自己的分布式爬虫平台，就要先知道什么是分布式系统，百度百科是这样定义的：</p><p><em>分布式系统（distributed system）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。内聚性是指每一个数据库分布节点高度自治，有本地的数据库管理系统。透明性是指每一个数据库分布节点对用户的应用来说都是透明的，看不出是本地还是远程。在分布式数据库系统中，用户感觉不到数据是分布的，即用户不须知道关系是否分割、有无副本、数据存于哪个站点以及事务在哪个站点上执行等。</em></p><p>这个定义不太好理解，看看书上怎么说。《分布式系统概念与设计》一书中对分布式系统做了如下定义：</p><p><em>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</em></p><p>《分布式系统原理和范型》一书中是这样定义分布式系统的：</p><p><em>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像是单个相关系统。</em></p><p>简单来说就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p><p>从分布式系统的概念中我们知道，各个主机之间通信和协调主要通过网络进行，所以，分布式系统中的计算机在空间上几乎没有任何限制，这些计算机可能被放在不同的机柜上，也可能被部署在不同的机房中，还可能在不同的城市中，对于大型的网站甚至可能分布在不同的国家。但是，无论空间上如何分布，一个标准的分布式系统应该具有以下几个主要特征：</p><p><strong>透明性</strong></p><p>系统资源被所有计算机共享。每台计算机的用户不仅可以使用本机的资源，还可以使用本分布式系统中其他计算机的资源。</p><p><strong>同一性</strong></p><p>系统中的若干台计算机可以互相协作来完成一个共同的任务，或者说一个程序可以分布在几台计算机上并行地运行。</p><p><strong>通信性</strong></p><p>系统中的计算机都可以通过通信来交换信息。</p><p>来源： <a href="https://www.cnblogs.com/tuohai666/p/8901370.html">https://www.cnblogs.com/tuohai666/p/8901370.html</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python用Django写restfulapi接口</title>
    <link href="/2025/12/755ae620edb1.html"/>
    <url>/2025/12/755ae620edb1.html</url>
    
    <content type="html"><![CDATA[<p>用Python如何写一个接口呢，首先得要有数据，可以用我们在网站上爬的数据，在上一篇文章中写了如何用Python爬虫，有兴趣的可以看看：</p><p><a href="https://www.cnblogs.com/sixrain/p/9120529.html">https://www.cnblogs.com/sixrain/p/9120529.html</a></p><p>大量的数据保存到数据库比较方便。我用的pymsql，pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前在python3.x中，PyMySQL取代了MySQLdb。</p><h2 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1.连接数据库"></a>1.连接数据库</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 连接数据库，需指定charset否则可能会报错</span><br>db = pymysql.connect(<span class="hljs-attribute">host</span>=<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-attribute">user</span>=<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-attribute">db</span>=<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;utf8mb4&quot;</span>)<br>cursor = db.cursor()  # 创建一个游标对象<br></code></pre></td></tr></table></figure><h2 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">cursor.execute(<span class="hljs-string">&quot;DROP TABLE IF EXISTS meizi_meizis&quot;</span>)  <span class="hljs-comment"># 如果表存在则删除</span><br>      <span class="hljs-comment"># 创建表sql语句</span><br>      createTab = <span class="hljs-string">&quot;&quot;&quot;create table meizi_meizis(</span><br><span class="hljs-string">              id int primary key auto_increment,</span><br><span class="hljs-string">              mid varchar(10) not null,</span><br><span class="hljs-string">              title varchar(50),</span><br><span class="hljs-string">              picname varchar(10),</span><br><span class="hljs-string">              page_url varchar(50),</span><br><span class="hljs-string">              img_url varchar(50)</span><br><span class="hljs-string">              );&quot;&quot;&quot;</span><br>      cursor.execute(createTab)  <span class="hljs-comment"># 执行创建数据表操作</span><br></code></pre></td></tr></table></figure><h2 id="3-爬取数据"><a href="#3-爬取数据" class="headerlink" title="3.爬取数据"></a>3.爬取数据</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs prolog">def html(self, href, title):<br>       lists = []<br>       meiziid = href.split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">-1</span>]<br>       html = self.request(href)<br>       max_span = <span class="hljs-symbol">BeautifulSoup</span>(html.text, <span class="hljs-string">&#x27;lxml&#x27;</span>).find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;pagenavi&#x27;</span>).find_all(<span class="hljs-string">&#x27;span&#x27;</span>)[<span class="hljs-number">-2</span>].get_text()<br>       for page in range(<span class="hljs-number">1</span>, int(max_span) + <span class="hljs-number">1</span>):<br>           meizi = &#123;&#125;<br>           page_url = href + <span class="hljs-string">&#x27;/&#x27;</span> + str(page)<br>           img_html = self.request(page_url)<br>           img_url = <span class="hljs-symbol">BeautifulSoup</span>(img_html.text, <span class="hljs-string">&#x27;lxml&#x27;</span>).find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;main-image&#x27;</span>).find(<span class="hljs-string">&#x27;img&#x27;</span>)[<span class="hljs-string">&#x27;src&#x27;</span>]<br>           picname = img_url[<span class="hljs-number">-9</span>:-<span class="hljs-number">4</span>]<br>           meizi[<span class="hljs-string">&#x27;meiziid&#x27;</span>] = meiziid<br>           meizi[<span class="hljs-string">&#x27;title&#x27;</span>] = title<br>           meizi[<span class="hljs-string">&#x27;picname&#x27;</span>] = picname<br>           meizi[<span class="hljs-string">&#x27;page_url&#x27;</span>] = page_url<br>           meizi[<span class="hljs-string">&#x27;img_url&#x27;</span>] = img_url<br>           lists.append(meizi)  # 保存到返回数组中<br>       return lists<br></code></pre></td></tr></table></figure><h2 id="4-保存到数据库"><a href="#4-保存到数据库" class="headerlink" title="4.保存到数据库"></a>4.保存到数据库</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">all_url</span>(self, url):<br>       html = self.<span class="hljs-built_in">request</span>(url)<br>       all_a = <span class="hljs-built_in">BeautifulSoup</span>(html.text, <span class="hljs-string">&#x27;lxml&#x27;</span>).<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;all&#x27;</span>).<span class="hljs-built_in">find_all</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>       for index, a in <span class="hljs-built_in">enumerate</span>(all_a):<br>           title = a.<span class="hljs-built_in">get_text</span>()<br>           href = a[<span class="hljs-string">&#x27;href&#x27;</span>]<br>           lists = self.<span class="hljs-built_in">html</span>(href, title)<br>           for i in lists:<br>               # <span class="hljs-built_in">print</span>(i[<span class="hljs-string">&#x27;meiziid&#x27;</span>], i[<span class="hljs-string">&#x27;title&#x27;</span>], i[<span class="hljs-string">&#x27;picname&#x27;</span>], i[<span class="hljs-string">&#x27;page_url&#x27;</span>], i[<span class="hljs-string">&#x27;img_url&#x27;</span>])<br>               # 插入数据到数据库sql语句，%s用作字符串占位<br>               sql = <span class="hljs-string">&quot;INSERT INTO `meizi_meizis`(`mid`,`title`,`picname`,`page_url`,`img_url`) VALUES(%s,%s,%s,%s,%s)&quot;</span><br>               try:<br>                   cursor.<span class="hljs-built_in">execute</span>(sql, (i[<span class="hljs-string">&#x27;meiziid&#x27;</span>], i[<span class="hljs-string">&#x27;title&#x27;</span>], i[<span class="hljs-string">&#x27;picname&#x27;</span>], i[<span class="hljs-string">&#x27;page_url&#x27;</span>], i[<span class="hljs-string">&#x27;img_url&#x27;</span>]))<br>                   db.<span class="hljs-built_in">commit</span>()<br>                   <span class="hljs-built_in">print</span>(i[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; is success&quot;</span>)<br>               except:<br>                   db.<span class="hljs-built_in">rollback</span>()<br>       db.<span class="hljs-built_in">close</span>()  # 关闭数据库<br></code></pre></td></tr></table></figure><h2 id="5-创建Web工程"><a href="#5-创建Web工程" class="headerlink" title="5.创建Web工程"></a>5.创建Web工程</h2><p>运行我们的爬虫，很快数据库表里就有数据了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/827512/201806/2024-01-03-18-10-9123cfe316b2d1c844aefe42984f01f7-827512-20180605104705648-902001749-02b5e1.png"></p><p>然后开始写接口。我是通过Django+rest_framework来写的。</p><p>Django 是用<a href="https://code.ziqiangxuetang.com/python/python-tutorial.html">Python</a>开发的一个免费开源的Web框架，可以用于快速搭建高性能，优雅的网站。Django 中提供了开发网站经常用到的模块，常见的代码都为你写好了，减少重复的代码。</p><h3 id="Django-目录结构"><a href="#Django-目录结构" class="headerlink" title="Django 目录结构"></a><strong>Django 目录结构</strong></h3><p><a href="https://code.ziqiangxuetang.com/django/django-views-urls.html" title="Django 视图与URL">urls.py</a></p><p>网址入口，关联到对应的views.py中的一个函数（或者generic类），访问网址就对应一个函数。</p><p><a href="https://code.ziqiangxuetang.com/django/django-views-urls.html" title="Django 视图与URL">views.py</a></p><p>处理用户发出的请求，从urls.py中对应过来, 通过渲染templates中的网页可以将显示内容，比如登陆后的用户名，用户请求的数据，输出到网页。</p><p><a href="https://code.ziqiangxuetang.com/django/django-models.html" title="Django 模型">models.py</a></p><p>与数据库操作相关，存入或读取数据时用到这个，当然用不到数据库的时候 你可以不使用。</p><p><a href="https://code.ziqiangxuetang.com/django/django-forms.html" title="Django 表单">forms.py</a></p><p>表单，用户在浏览器上输入数据提交，对数据的验证工作以及输入框的生成等工作，当然你也可以不使用。</p><p>templates 文件夹</p><p>views.py 中的函数渲染templates中的Html模板，得到动态内容的网页，当然可以用缓存来提高速度。</p><p><a href="https://code.ziqiangxuetang.com/django/django-admin.html" title="Django 后台">admin.py</a></p><p>后台，可以用很少量的代码就拥有一个强大的后台。</p><p><a href="https://code.ziqiangxuetang.com/django/django-settings.html" title="Django 配置">settings.py</a></p><p>Django 的设置，配置文件，比如 DEBUG 的开关，静态文件的位置等。</p><h3 id="Django-常用操作"><a href="#Django-常用操作" class="headerlink" title="Django 常用操作"></a><strong>Django 常用操作</strong></h3><p>1）新建一个 django project</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">django-<span class="hljs-literal">admin</span>.py startproject project_name<br></code></pre></td></tr></table></figure><p>2）新建 app</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> startapp app_name<br></code></pre></td></tr></table></figure><p>一般一个项目有多个app, 当然通用的app也可以在多个项目中使用。</p><p>还得在工程目录的settings.py文件在配置</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-type">INSTALLED_APPS</span> = [<br>    <span class="hljs-symbol">&#x27;django</span>.contrib.admin&#x27;,<br>    <span class="hljs-symbol">&#x27;django</span>.contrib.auth&#x27;,<br>    <span class="hljs-symbol">&#x27;django</span>.contrib.contenttypes&#x27;,<br>    <span class="hljs-symbol">&#x27;django</span>.contrib.sessions&#x27;,<br>    <span class="hljs-symbol">&#x27;django</span>.contrib.messages&#x27;,<br>    <span class="hljs-symbol">&#x27;django</span>.contrib.staticfiles&#x27;,<br>    <span class="hljs-symbol">&#x27;rest_framework&#x27;</span>,<br>    <br>    <span class="hljs-symbol">&#x27;meizi&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure><p>在app&#x2F;views.py下编写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">u&quot;你好&quot;</span>)<br></code></pre></td></tr></table></figure><p>在工程目录urls.py配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> learn <span class="hljs-keyword">import</span> views <span class="hljs-keyword">as</span> learn_views <br>urlpatterns = [<br>    url(<span class="hljs-string">r&#x27;^$&#x27;</span>, learn_views.index),  <br>]<br><br></code></pre></td></tr></table></figure><p>通过python manage.py runserver启动，就会看到我们输出的“你好”了</p><p>3）创建数据库表 或 更改数据库表或字段</p><p>在app下的models.py创建表</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(models.<span class="hljs-title class_">Model</span>):<br>    name = models.<span class="hljs-title class_">CharField</span>(max_length=<span class="hljs-number">30</span>)<br>    age = models.<span class="hljs-title class_">IntegerField</span>()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__unicode__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-comment"># 在Python3中使用 def __str__(self):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.name<br></code></pre></td></tr></table></figure><p>运行命令，就可以生成对应的表</p><p>Django 1.7.1及以上 用以下命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"># <span class="hljs-number">1</span>. 创建更改的文件<br><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> makemigrations<br># <span class="hljs-number">2</span>. 将生成的<span class="hljs-keyword">py</span>文件应用到数据库<br><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> migrate<br></code></pre></td></tr></table></figure><p>在views.py文件里就可以获取数据库的数据</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def create(request):<br>    # 新建一个对象的方法有以下几种：<br>    Person.objects.create(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;xiaoli&#x27;</span>, <span class="hljs-attribute">age</span>=18)<br>    # p = Person(<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;WZ&quot;</span>, <span class="hljs-attribute">age</span>=23)<br>    # p = Person(<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;TWZ&quot;</span>)<br>    # p.age = 23<br>    # p.save()<br>    # 这种方法是防止重复很好的方法，但是速度要相对慢些，返回一个元组，第一个为Person对象，<br>    # 第二个为<span class="hljs-literal">True</span>或<span class="hljs-literal">False</span>, 新建时返回的是<span class="hljs-literal">True</span>, 已经存在时返回<span class="hljs-literal">False</span><br>    # Person.objects.get_or_create(<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;WZT&quot;</span>, <span class="hljs-attribute">age</span>=23)<br>    s = Person.objects.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;xiaoli&#x27;</span>)<br>    return HttpResponse(str(s))<br></code></pre></td></tr></table></figure><h2 id="6-写接口"><a href="#6-写接口" class="headerlink" title="6.写接口"></a>6.写接口</h2><p>接口使用rest_framework，rest_framework是一套基于<a href="https://link.jianshu.com/?t=https://www.djangoproject.com">Django</a> 的 <a href="https://link.jianshu.com/?t=https://baike.baidu.com/item/rest/6330506?fr=aladdin">REST</a> 框架，是一个强大灵活的构建 Web API 的工具包。</p><p>写接口三步完成：连接数据库、取数据、数据输出</p><h3 id="1）连接数据库"><a href="#1）连接数据库" class="headerlink" title="1）连接数据库"></a>1）连接数据库</h3><p>在工程目录下的settings.py文件下配置</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">DATABASES = &#123;<br>    # <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>    #     <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.sqlite3&#x27;</span>,<br>    #     <span class="hljs-string">&#x27;NAME&#x27;</span>: os.path.<span class="hljs-keyword">join</span>(BASE_DIR, <span class="hljs-string">&#x27;db.sqlite3&#x27;</span>),<br>    # &#125;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,<br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>,<br>        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;123&#x27;</span>,<br>        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-number">3306</span>,<br>        # <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;character_set_database&#x27;</span>；<br>        # 修改字段字符编码<br>        # <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> spiders_weibo modify <span class="hljs-type">text</span> longtext charset utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<br>        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;<span class="hljs-string">&#x27;charset&#x27;</span>: <span class="hljs-string">&#x27;utf8mb4&#x27;</span>&#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）取数据"><a href="#2）取数据" class="headerlink" title="2）取数据"></a>2）取数据</h3><p>既然要取数据，那model肯定得和数据库的一致，我发现一个快捷的方式可以把数据库中的表生成对应的model，在项目目录下执行命令</p><p>python manage.py inspectdb</p><p>可以看到下图</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/827512/201806/2024-01-03-18-10-3941c53041ca20e3e11085e8bc87b2b9-827512-20180605103809526-1776036142-357db5.png"></p><p>取我们表的model拷贝到app下的models.py里</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Meizis(models.Model):<br>    mid = models.CharField(<span class="hljs-attribute">max_length</span>=10)<br>    title = models.CharField(<span class="hljs-attribute">max_length</span>=50, <span class="hljs-attribute">blank</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span>)<br>    picname = models.CharField(<span class="hljs-attribute">max_length</span>=10, <span class="hljs-attribute">blank</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span>)<br>    page_url = models.CharField(<span class="hljs-attribute">max_length</span>=50, <span class="hljs-attribute">blank</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span>)<br>    img_url = models.CharField(<span class="hljs-attribute">max_length</span>=50, <span class="hljs-attribute">blank</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span>)<br><br>    class Meta:<br>        managed = <span class="hljs-literal">False</span><br>        db_table = <span class="hljs-string">&#x27;meizi_meizis&#x27;</span><br></code></pre></td></tr></table></figure><p>创建一个序列化Serializer类</p><p>提供序列化和反序列化的途径，使之可以转化为，某种表现形式如json。我们可以借助serializer来实现，类似于Django表单（form）的运作方式。在app目录下，创建文件serializers.py。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MeiziSerializer</span>(serializers.ModelSerializer):<br>    <span class="hljs-meta"># ModelSerializer和Django中ModelForm功能相似</span><br>    <span class="hljs-meta"># Serializer和Django中Form功能相似</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        model = Meizis<br>        <span class="hljs-meta"># 和&quot;__all__&quot;等价</span><br>        fields = (<span class="hljs-string">&#x27;mid&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;picname&#x27;</span>, <span class="hljs-string">&#x27;page_url&#x27;</span>, <span class="hljs-string">&#x27;img_url&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>这样在views.py就可以来获取数据库的数据了</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">meizis = Meizis.objects.<span class="hljs-literal">all</span>()<br>serializer = MeiziSerializer(meizis, many=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">return</span> Response(serializer.<span class="hljs-built_in">data</span>)<br><br></code></pre></td></tr></table></figure><h3 id="3-数据输出客户端或前端"><a href="#3-数据输出客户端或前端" class="headerlink" title="3) 数据输出客户端或前端"></a>3) 数据输出客户端或前端</h3><p> REST框架提供了两种编写API视图的封装。</p><ul><li>@api_view装饰器，基于方法的视图。</li><li>继承APIView类，基于类的视图。</li></ul><p>request.data会自行处理输入的json请求<br>使用格式后缀明确的指向指定的格式，需要添加一个format关键字参数<br>http <a href="http://127.0.0.1:8000/getlist.json">http://127.0.0.1:8000/getlist.json</a> # JSON 后缀<br><a href="http://127.0.0.1:8000/getlist.api">http://127.0.0.1:8000/getlist.api</a> # 可视化 API 后缀<br><a href="http://127.0.0.1:8000/getlist/">http://127.0.0.1:8000/getlist/</a> code&#x3D;”print 123”post</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@api_view([<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>])</span><br>def getlist(request, format=None):<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>        meizis = Meizis.objects.all()<br>        serializer = MeiziSerializer(meizis, many=True)<br>        <span class="hljs-keyword">return</span> Response(serializer.<span class="hljs-keyword">data</span>)<br><br>    elif request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        serializer = MeiziSerializer(<span class="hljs-keyword">data</span>=request.<span class="hljs-keyword">data</span>)<br>        <span class="hljs-keyword">if</span> serializer.is_valid():<br>            serializer.save()<br>            <span class="hljs-keyword">return</span> Response(serializer.<span class="hljs-keyword">data</span>, status=status.HTTP_201_CREATED)<br>        <span class="hljs-keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)<br></code></pre></td></tr></table></figure><h3 id="4）分页"><a href="#4）分页" class="headerlink" title="4）分页"></a>4）分页</h3><p>最后别忘了在urls.py配置URL，通过浏览器就可以看到json数据了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/827512/201806/2024-01-03-18-10-51ebdc7244ef0fc1610f8f6e7b2f3615-827512-20180605105201595-1309487419-1812e7.png"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/827512/201806/2024-01-03-18-10-9092d06c97957cd052ecb5291694805c-827512-20180605105225823-1754220282-13e767.png"></p><p> 当然app也是可以调用我们的接口的</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/827512/201806/2024-01-03-18-10-75b031316ab050474eade5fb56afede6-827512-20180605105403515-217219056-b694cd.png"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/827512/201806/2024-01-03-18-10-ed96be0ad3044561d1e4334161cd6272-827512-20180605105445911-2109047059-453c50.jpeg"></p><h3 id="还有个问题"><a href="#还有个问题" class="headerlink" title="还有个问题"></a>还有个问题</h3><p>我们的数据有好几千条，一块返回来很不合理，所以需要分页，当然rest_framework框架提供了这个功能，post请求不支持，需要自己查数据库或者切片来进行返回。来看看rest_framework是如何来分页的。在models.py里创建一个类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">StandardResultSetPagination</span>(<span class="hljs-symbol">LimitOffsetPagination</span>):<br>    # 默认每页显示的条数<br>    <span class="hljs-symbol">default_limit</span> = <span class="hljs-symbol">20</span><br>    # <span class="hljs-symbol">url</span> 中传入的显示数据条数的参数<br>    <span class="hljs-symbol">limit_query_param</span> = &#x27;<span class="hljs-symbol">limit</span>&#x27;<br>    # <span class="hljs-symbol">url</span>中传入的数据位置的参数<br>    <span class="hljs-symbol">offset_query_param</span> = &#x27;<span class="hljs-symbol">offset</span>&#x27;<br>    # 最大每页显示条数<br>    <span class="hljs-symbol">max_limit</span> = <span class="hljs-symbol">None</span><br></code></pre></td></tr></table></figure><p>在serializers.py创建俩个类，为什么是俩个？因为我们有俩个接口，一个明细，一个列表，而列表是不需要把字段的所有数据都返回的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListSerialize</span>(serializers.ModelSerializer):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        <span class="hljs-type">model</span> = <span class="hljs-title">Meizis</span><br>        fields = (<span class="hljs-string">&#x27;mid&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListPicSerialize</span>(serializers.ModelSerializer):<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        <span class="hljs-type">model</span> = <span class="hljs-title">Meizis</span><br>        fields = <span class="hljs-string">&quot;__all__&quot;</span><br></code></pre></td></tr></table></figure><p>在views.py里编写</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@api_view</span>([<span class="hljs-string">&#x27;GET&#x27;</span>])<br>def <span class="hljs-built_in">getlist</span>(request, format=None):<br>    if request.method == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>        meizis = Meizis.objects.<span class="hljs-built_in">values</span>(<span class="hljs-string">&#x27;mid&#x27;</span>,<span class="hljs-string">&#x27;title&#x27;</span>).<span class="hljs-built_in">distinct</span>()<br>        # <span class="hljs-attribute">http</span>: <span class="hljs-comment">// 127.0.0.1:8000 / getlist?limit = 20</span><br>        # <span class="hljs-attribute">http</span>: <span class="hljs-comment">// 127.0.0.1:8000 / getlist?limit = 20 &amp; offset = 20</span><br>        # <span class="hljs-attribute">http</span>: <span class="hljs-comment">// 127.0.0.1:8000 / getlist?limit = 20 &amp; offset = 40</span><br>        # 根据url参数 获取分页数据<br>        obj = <span class="hljs-built_in">StandardResultSetPagination</span>()<br>        page_list = obj.<span class="hljs-built_in">paginate_queryset</span>(meizis, request)<br>        # 对数据序列化 普通序列化 显示的只是数据<br>        ser = <span class="hljs-built_in">ListSerialize</span>(instance=page_list, many=True)  # 多个many=True # instance：把对象序列化<br>        response = obj.<span class="hljs-built_in">get_paginated_response</span>(ser.data)<br>        return response<br><br><br><span class="hljs-variable">@api_view</span>([<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>])<br>def <span class="hljs-built_in">getlispic</span>(request, format=None):<br>    if request.method == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>        mid = request.GET[<span class="hljs-string">&#x27;mid&#x27;</span>]<br>        if mid is <span class="hljs-keyword">not</span> <span class="hljs-attribute">None</span>:<br>            # get是用来获取一个对象的，如果需要获取满足条件的一些数据，就要用到filter<br>            meizis = Meizis.objects.<span class="hljs-built_in">filter</span>(mid=mid)<br>            obj = <span class="hljs-built_in">StandardResultSetPagination</span>()<br>            page_list = obj.<span class="hljs-built_in">paginate_queryset</span>(meizis, request)<br>            ser = <span class="hljs-built_in">ListPicSerialize</span>(instance=page_list, many=True)<br>            response = obj.<span class="hljs-built_in">get_paginated_response</span>(ser.data)<br>            return response<br>        <span class="hljs-attribute">else</span>:<br>            return <span class="hljs-built_in">Response</span>(<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;请传mid&#x27;</span>))<br></code></pre></td></tr></table></figure><p>到这里就完成了接口的编写，都是对框架的简单使用，希望对大家有帮助。</p><p>GitHub地址，欢迎star</p><p>爬虫项目：<a href="https://github.com/peiniwan/Spider2">https://github.com/peiniwan/Spider2</a><a href="https://github.com/peiniwan/Spider2">  </a></p><p>Web项目：<a href="https://github.com/peiniwan/mysite">https://github.com/peiniwan/mysite</a> </p><p>APP项目：<a href="https://github.com/peiniwan/Ganhuo">https://github.com/peiniwan/Ganhuo</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础语法</title>
    <link href="/2025/12/01566d3167fc.html"/>
    <url>/2025/12/01566d3167fc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><pre><code class="hljs">print &#39;I\&#39;m \&quot;OK\&quot;!&#39; a = 123  # a是整数print aa = &#39;ABC&#39;  # a变为字符串print a a = 100if a &gt;= 0:  # 注意冒号    print aelse:    print -a# int转成string，函数int(string)# string转成int，函数str(number)print len(u&#39;ABC&#39;)print &#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)print &#39;Age: %s. Gender: %s&#39; % (25, True) classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]classmates.append(&#39;Adam&#39;)classmates.insert(1, &#39;Jack&#39;)classmates.pop()classmates.pop(1)classmates[1] = 123  # 类型可以不同# 相等的print classmatesprint classmates[len(classmates) - 1] == classmates[-1]print classmates[len(classmates) - 2] == classmates[-2] # tuple和list非常类似，但是tuple一旦初始化就不能修改，没有append()，insert()这样的方法# 可以正常地使用classmates[-1]，但不能赋值成另外的元素t = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)t = (1,);  # 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义t = (1, 2)print t # 如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else# 下面打印  teenagerage = 20if age &gt;= 6:    print &#39;teenager&#39;elif age &gt;= 18:    print &#39;adult&#39;else:    print &#39;kid&#39; sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:    sum = sum + xprint sumsum = 0for x in range(101):    sum = sum + xprint sum sum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print sum # 打印# name = raw_input(&#39;please enter your name: &#39;)# print &#39;hello,&#39;, name d = &#123;&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85&#125;print d[&#39;Michael&#39;]d[&#39;Adam&#39;] = 67print d[&#39;Adam&#39;]# 要避免key不存在的错误print &#39;Thomas&#39; in dprint d.get(&#39;Thomas&#39;)print d.get(&#39;Thomas&#39;, -1)d.pop(&#39;Bob&#39;)key = [1, 2, 3]# key的对象就不能变,而list是可变的，就不能作为key# d[key] = &#39;a list&#39;print d# 要创建一个set，需要提供一个list作为输入集合s1 = set([1, 2, 3])# 重复元素在set中自动被过滤s1 = set([1, 1, 2, 2, 3, 3])s1.add(4)s1.remove(4)s2 = set([2, 3, 4])# 交集、并集print s1 &amp; s2, s1 | s2 # 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]a.sort()print a# 对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。# 相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。a = &#39;abc&#39;b = a.replace(&#39;a&#39;, &#39;A&#39;)print a, b</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="hljs"># 函数# 比较函数print cmp(1, 2)# 数据类型转换print int(&#39;123&#39;)print int(12.34)str(1.23)unicode(100)bool(1)bool(&#39;&#39;)  # 定义函数，如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。# return None可以简写为return，函数执行完毕没有return语句时，自动return None。# 只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance实现def my_abs(x):    if not isinstance(x, (int, float)):        raise TypeError(&#39;bad operand type&#39;)    if x &gt;= 0:        return x    else:        return -x  a = my_abs  # 变量a指向abs函数print a(-1)  # 所以也可以通过a调用abs函数  # 空函数# 如果想定义一个什么事也不做的空函数，可以用pass语句# pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来# 缺少了pass，代码运行就会有语法错误。def nop():    pass  # 可以返回多个值,实际是返回tuple，这样写起来方便def move(x, y, step, angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny  x, y = move(100, 100, 60, math.pi / 6)print x, yr = move(100, 100, 60, math.pi / 6)print r  # 默认参数,必选参数在前，默认参数在后# 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。def power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s  print power(5), power(5, 3)  def enroll(name, gender, age=6, city=&#39;Beijing&#39;):    print &#39;name:&#39;, name    print &#39;gender:&#39;, gender    print &#39;age:&#39;, age    print &#39;city:&#39;, city  print  enroll(&#39;Sarah&#39;, &#39;F&#39;)print enroll(&#39;Bob&#39;, &#39;M&#39;, 7)# 当不按顺序提供部分默认参数时，需要把参数名写上print enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)  def add_end(L=[]):    L.append(&#39;END&#39;)    return L  print add_end()print add_end()  # [&#39;END&#39;, &#39;END&#39;]，不对  # 默认参数必须指向不变对象！,修改上面的例子,否则运行会有逻辑错误！def add_end(L=None):    if L is None:        L = []    L.append(&#39;END&#39;)    return L  # 可变参数，在参数前面加了一个*号def calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum  print calc(1, 2)print calc() # 如果已经有一个list或者tuple，要调用一个可变参数怎么办？nums = [1, 2, 3]print calc(nums[0], nums[1], nums[2])print calc(*nums)  # 关键字参数,可以扩展函数的功能# 比如，在person函数里，我们保证能接收到name和age这两个参数，# 但是，如果调用者愿意提供更多的参数，我们也能收到def person(name, age, **kw):    print &#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw  person(&#39;Michael&#39;, 30)# name: Michael age: 30 other: &#123;&#125;person(&#39;Bob&#39;, 35, city=&#39;Beijing&#39;)# name: Bob age: 35 other: &#123;&#39;city&#39;: &#39;Beijing&#39;&#125;person(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)# name: Adam age: 45 other: &#123;&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125; kw = &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;person(&#39;Jack&#39;, 24, city=kw[&#39;city&#39;], job=kw[&#39;job&#39;])person(&#39;Jack&#39;, 24, **kw)  # 参数组合# 在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用# 注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。def func(a, b, c=0, *args, **kw):    print &#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw  print func(1, 2)# a = 1 b = 2 c = 0 args = () kw = &#123;&#125;print func(1, 2, c=3)# a = 1 b = 2 c = 3 args = () kw = &#123;&#125;print func(1, 2, 3, &#39;a&#39;, &#39;b&#39;)# a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = &#123;&#125;print func(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x=99)# a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = &#123;&#39;x&#39;: 99&#125; # 要注意定义可变参数和关键字参数的语法：# *args是可变参数，args接收的是一个tuple；# **kw是关键字参数，kw接收的是一个dict。args = (1, 2, 3, 4)  # tuplekw = &#123;&#39;x&#39;: 99&#125;  # dictprint func(*args, **kw)  # a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#39;x&#39;: 99&#125; # 递归def fact(n):    if n == 1:        return 1    return n * fact(n - 1)  # 尾递归def fact(n):    return fact_iter(n, 1)  # 切片def fact_iter(num, product):    if num == 1:        return product    return fact_iter(num - 1, num * product)  L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]r = []n = 3for i in range(n):    r.append(L[i]) # 迭代print r# 切片（Slice）操作符,取前3个元素，用一行代码就可以完成print L[0:3]# 如果第一个索引是0，还可以省略print L[:3]# 取倒数第一个元素print L[-2:-1]# 取后俩个元素print L[-2:]# 原样复制一个list：print L[:]# tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：print (0, 1, 2, 3, 4, 5)[:3]print &#39;ABCDEFG&#39;[:3] # 只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代# 遍历keyd = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;for key in d:    print key# 遍历valuefor value in d.itervalues():    print value# 遍历key,valuefor k, v in d.iteritems():    print k, &#39;=&#39;, v for ch in &#39;ABC&#39;:    print ch from collections import Iterable print isinstance([1, 2, 3], Iterable)  # list是否可迭代print isinstance(&#39;abc&#39;, Iterable)  # str是否可迭代print isinstance(123, Iterable)  # 整数是否可迭代，falseprint isinstance(x, str)  # 判断一个变量是不是字符串 # 这样就可以在for循环中同时迭代索引和元素本身for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):    print i, value for x, y in [(1, 1), (2, 4), (3, 9)]:    print x, y # 列表生成式print range(1, 11)L = []# [1x1, 2x2, 3x3, ..., 10x10]for x in range(1, 11):    L.append(x * x)print [x * x for x in range(1, 11)]# 筛选出仅偶数的平方print [x * x for x in range(1, 11) if x % 2 == 0]# 两层循环，可以生成全排列print [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]# 列出当前目录下的所有文件和目录名print [d for d in os.listdir(&#39;.&#39;)]  # os.listdir可以列出文件和目录L = [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]# 一个list中所有的字符串变成小写print [s.lower() for s in L] # 生成器:如果列表元素可以按照某种算法推算出来，这样就不必创建完整的list，从而节省大量的空间# 和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generatorL = [x * x for x in range(10)]g = (x * x for x in range(10))print g.next()for n in g:    print n  # 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generatordef odd():    print &#39;step 1&#39;    yield 1    print &#39;step 2&#39;    yield 3    print &#39;step 3&#39;    yield 5  # 在执行过程中，遇到yield就中断，下次又继续执行# 基本上从来不会用next()来调用它，而是直接使用for循环来迭代o = odd()print o.next()print o.next()print o.next()  # 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！# 函数的名字也是变量def add(x, y, f):    return f(x) + f(y)  print(add(-5, 6, abs))  def f(x):    return x * x  # map()函数接收两个参数，一个是函数，一个是Iterable，# map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])print list(r)# for也能实现，太麻烦L = []for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:    L.append(f(n))print(L)print list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))  # reduce把结果继续和序列的下一个元素做累积计算# reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)def add(x, y):    return x + y  print reduce(add, [1, 3, 5, 7, 9]) \    # 求和运算可以直接用Python内建函数sum()，没必要动用reduce。  # print sum([1, 3, 5, 7, 9])  def fn(x, y):    return x * 10 + y  print reduce(fn, [1, 3, 5, 7, 9])  def char2num(s):    digits = &#123;&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9&#125;    return digits[s]  print reduce(fn, map(char2num, &#39;13579&#39;)) # 简化DIGITS = &#123;&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9&#125;  def str2int(s):    def fn(x, y):        return x * 10 + y     def char2num(s):        return DIGITS[s]     return reduce(fn, map(char2num, s))  # 用lambda函数进一步简化def char2num(s):    return DIGITS[s]  def str2int(s):    return reduce(lambda x, y: x * 10 + y, map(char2num, s))  print str2int(&#39;13579&#39;)  # filter()函数用于过滤序列# 根据返回值是True还是False决定保留还是丢弃该元素def is_odd(n):    return n % 2 == 1  print list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))  def not_empty(s):    return s and s.strip()  print list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;])) print sorted([36, 5, -12, 9, -21])print sorted([36, 5, -12, 9, -21], key=abs)print sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;])# 排序应该忽略大小写，按照字母序排序print sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)print sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)  def lazy_sum(*args):    def sum():        ax = 0        for n in args:            ax = ax + n        return ax     return sum  # 闭包，函数作为返回值# 返回的函数并没有立刻执行，而是直到调用了f()才执行。f1 = lazy_sum(1, 3, 5, 7, 9)f2 = lazy_sum(1, 3, 5, 7, 9)print f1() == f2()  # true,比较的值print f1 == f2  # false,引用不同，所以f1()和f2()的调用结果互不影响。  def count():    fs = []    for i in range(1, 4):        def f():            return i * i         fs.append(f)    return fs  # 全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。# 等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9# 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。f1, f2, f3 = count()  def count():    def f(j):        def g():            return j * j         return g     fs = []    for i in range(1, 4):        fs.append(f(i))  # f(i)立刻被执行，因此i的当前值被传入f()    return fs  f1, f2, f3 = count()  # 1，4，9 # 匿名函数# 冒号前面的x表示函数参数print list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))  # 匿名函数lambda x: x * x,实际上就是def f(x):    return x * x  # 可以把匿名函数赋值给一个变量，再利用变量来调用该函数# 也可以把匿名函数作为返回值返回f = lambda x: x * xprint f(4)  # 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，# 这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。def log(func):    def wrapper(*args, **kw):        print(&#39;call %s():&#39; % func.__name__)        return func(*args, **kw)     return wrapper  @logdef now():    print(&#39;2015-3-25&#39;)  print now() # 偏函数：当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，# 这个新函数可以固定住原函数的部分参数，从而在调用时更简单。int2 = functools.partial(int, base=2)  # 不需要我们自己定义def int3(x, base=2):    return int(x, base)  print int2(&#39;1000000&#39;)print int3(&#39;1000000&#39;) # 作者__author__ = &#39;Michael Liao&#39;  def _private_1(name):    return &#39;Hello, %s&#39; % name  def _private_2(name):    return &#39;Hi, %s&#39; % name  # 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用# 公开greeting()函数，而把内部逻辑用private函数隐藏起来def greeting(name):    if len(name) &gt; 3:        return _private_1(name)    else:        return _private_2(name)</code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre><code class="hljs"># 面向过程import loggingimport types std1 = &#123;&#39;name&#39;: &#39;Michael&#39;, &#39;score&#39;: 98&#125;std2 = &#123;&#39;name&#39;: &#39;Bob&#39;, &#39;score&#39;: 81&#125;  def print_score(std):    print(&#39;%s: %s&#39; % (std[&#39;name&#39;], std[&#39;score&#39;]))  # 面向对象class Student(object):     def __init__(self, name, score):        self.__name = name        self.score = score     # self指向创建的实例本身，可以不传    # 实现数据的封装    def print_score(self):        print(&#39;%s: %s&#39; % (self.__name, self.score))     def get_name(self):        return self.__name     def set_name(self, name):        self.__name = name  bart = Student(&#39;Bart Simpson&#39;, 59)lisa = Student(&#39;Lisa Simpson&#39;, 87)bart.print_score()lisa.print_score()print lisa.get_name(), lisa.score  class Animal(object):    def run(self):        print &#39;Animal is running...&#39;  class Dog(Animal):    def run(self):        print &#39;Dog is running...&#39;  class Cat(Animal):    def run(self):        print &#39;Cat is running...&#39;  # 多态def run_twice(animal):    if (isinstance(animal, Animal)):        animal.run()    else:        print &quot;类型错误&quot;  print run_twice(Cat())print run_twice(Student(&#39;Bart Simpson&#39;, 59)); # 对于class的继承关系来说，使用type()就很不方便。# 我们要判断class的类型，可以使用isinstance()函数。print type(&#39;abc&#39;) == types.StringTypeprint type(u&#39;abc&#39;) == types.UnicodeTypeprint type([]) == types.ListTypeprint type(str) == types.TypeType print  dir(&#39;ABC&#39;)  class Student(object):    pass  s = Student()s.name = &#39;Michael&#39;  # 动态给实例绑定一个属性print s.name  def set_age(self, age):  # 定义一个函数作为实例方法    self.age = age  from types import MethodType s.set_age = MethodType(set_age, s, Student)  # 给实例绑定一个方法s.set_age(25)  # 调用实例方法print s.age  # 测试结果s2 = Student()  # 创建新的实例  # print s2.set_age(25)  # 尝试调用方法,不能  def set_score(self, score):    self.score = score  # 为了给所有实例都绑定方法，可以给class绑定方法Student.set_score = MethodType(set_score, None, Student)  # 定义一个特殊的__slots__变量，来限制该class能添加的属性，但对子类不起作用class Student(object):    __slots__ = (&#39;name&#39;, &#39;age&#39;)  # 用tuple定义允许绑定的属性名称  s = Student()  # 创建新的实例s.name = &#39;Michael&#39;  # 绑定属性&#39;name&#39;s.age = 25  # 绑定属性&#39;age&#39;  # s.score = 99  # 不能绑定属性&#39;score&#39; # 该属性不是直接暴露的，而是通过getter和setter方法来实现class Student(object):     @property    def score(self):        return self._score     @score.setter    def score(self, value):        if not isinstance(value, int):            raise ValueError(&#39;score must be an integer!&#39;)        if value &lt; 0 or value &gt; 100:            raise ValueError(&#39;score must between 0 ~ 100!&#39;)        self._score = value  s = Student()s.score = 60  # OK，实际转化为s.set_score(60)s.score  # OK，实际转化为s.get_score()# s.score = 9999print s.score  # 实际转化为s.get_score()  # 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：class Student(object):     @property    def birth(self):        return self._birth     @birth.setter    def birth(self, value):        self._birth = value     @property    def age(self):        return 2014 - self._birth  # 可以多继承# class Dog(Mammal, RunnableMixin, CarnivorousMixin):#     pass  # 定制类# __str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串class Student(object):    def __init__(self, name):        self.name = name     def __str__(self):        return &#39;Student object (name=%s)&#39; % self.name     __repr__ = __str__  s = Student(&#39;Michael&#39;)print sprint Student(&#39;Michael&#39;)  # 要表现得像list那样按照下标取出元素，需要实现__getitem__()方法class Fib(object):    def __getitem__(self, n):        a, b = 1, 1        for x in range(n):            a, b = b, a + b        return a  f = Fib()  # print f(0), f(100) # 只有在没有找到属性的情况下，才调用__getattr__，已有的属性，不会在__getattr__中查找。class Student(object):     def __getattr__(self, attr):        if attr == &#39;age&#39;:            # return 25            return lambda: 25  # 可以retrun函数，调用方式不一样了        raise AttributeError(&#39;\&#39;Student\&#39; object has no attribute \&#39;%s\&#39;&#39; % attr)  s = Student()print s.age()  class Chain(object):     def __init__(self, path=&#39;&#39;):        self._path = path     def __getattr__(self, path):        return Chain(&#39;%s/%s&#39; % (self._path, path))     def __str__(self):        return self._path  print Chain().status.user.timeline.list  # 任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用(像方法一样)class Student(object):    def __init__(self, name):        self.name = name     def __call__(self):        print(&#39;My name is %s.&#39; % self.name)  s = Student(&#39;Michael&#39;)print s()  # 怎么判断一个变量是对象还是函数呢？# print callable(Student())# print callable([1, 2, 3]) def foo(s):    return 10 / int(s)  def bar(s):    return foo(s) * 2  # logging模块可以非常容易地记录错误信息def main():    try:        bar(&#39;0&#39;)    except StandardError, e:        logging.exception(e)        print &#39;Error!&#39;    finally:        print &#39;finally...&#39;  # 只要main()捕获到了，就可以处理print main()  # assert的意思是，表达式n != 0应该是True，否则，后面的代码就会出错。# 如果断言失败，assert语句本身就会抛出AssertionError：def foo(s):    n = int(s)    assert n != 0, &#39;n is zero!&#39;    return 10 / n  def main():    foo(&#39;0&#39;)  # 和assert比，logging不会抛出错误，而且可以输出到文件logging.basicConfig(level=logging.INFO)s = &#39;0&#39;n = int(s)logging.info(&#39;n = %d&#39; % n)print 10 / n</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><pre><code class="hljs"># 新线程执行的代码:# 主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程import threadingimport time  def loop():    print &#39;thread %s is running...&#39; % threading.current_thread().name    n = 0    while n &lt; 5:        n = n + 1        print &#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n)        time.sleep(1)    print &#39;thread %s ended.&#39; % threading.current_thread().name  print &#39;thread %s is running...&#39; % threading.current_thread().namet = threading.Thread(target=loop, name=&#39;LoopThread&#39;)t.start()t.join()print &#39;thread %s ended.&#39; % threading.current_thread().name # 线程间通讯问题(生产者消费者)# 假定这是你的银行存款:balance = 0  def change_it(n):    # 先存后取，结果应该为0:    global balance    balance = balance + n    balance = balance - n  # def run_thread(n):#     for i in range(100000):#         change_it(n) # 需要上锁lock = threading.Lock()  def run_thread(n):    for i in range(100000):        # 先要获取锁:        lock.acquire()        try:            # 放心地改吧:            change_it(n)        finally:            # 改完了一定要释放锁:            lock.release()  t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print balance # 创建全局ThreadLocal对象# 每个Thread对它都可以读写student属性，但互不影响。也不用加锁# ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，# 这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。local_school = threading.local()  def process_student():    print &#39;Hello, %s (in %s)&#39; % (local_school.student, threading.current_thread().name)  def process_thread(name):    # 绑定ThreadLocal的student:    local_school.student = name    process_student()  t1 = threading.Thread(target=process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)t2 = threading.Thread(target=process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)t1.start()t2.start()t1.join()t2.join()  # 协程# consumer函数是一个generator（生成器），把一个consumer传入produce后：# 首先调用c.next()启动生成器；# 然后，一旦生产了东西，通过c.send(n)切换到consumer执行；# consumer通过yield拿到消息，处理，又通过yield把结果传回； # produce拿到consumer处理的结果，继续生产下一条消息；# produce决定不生产了，通过c.close()关闭consumer，整个过程结束。# 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 def consumer():    r = &#39;&#39;    while True:        n = yield r        if not n:            return        print(&#39;[CONSUMER] Consuming %s...&#39; % n)        time.sleep(1)        r = &#39;200 OK&#39;  def produce(c):    c.next()    n = 0    while n &lt; 5:        n = n + 1        print(&#39;[PRODUCER] Producing %s...&#39; % n)        r = c.send(n)        print(&#39;[PRODUCER] Consumer return: %s&#39; % r)    c.close()  if __name__ == &#39;__main__&#39;:    c = consumer()    produce(c)</code></pre><h3 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h3><pre><code class="hljs"># os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中# 要读取二进制文件，比如图片、视频等等，用&#39;rb&#39;模式打开文件import codecsimport jsonimport osimport randomimport threadingimport time try:    f = open(&#39;D:\heihei.txt&#39;, &#39;r&#39;)    print f.read()    # 如果文件很小，read()一次性读取最方便；    # 如果不能确定文件大小，反复调用read(size)比较保险；    # 如果是配置文件，调用readlines()最方便    for line in f.readlines():        print(line.strip())  # 把末尾的&#39;\n&#39;删掉finally:    if f:        f.close() # 上面太繁琐引入了with语句来自动帮我们调用close()方法with open(&#39;D:\heihei.txt&#39;, &#39;r&#39;) as f:    print f.read() # 判断文件是否存在if os.path.isdir(f):    passelse:    os.makedirs(f)  # 直接读出unicode# with codecs.open(&#39;D:/gbk.txt&#39;, &#39;r&#39;, &#39;gbk&#39;) as f:#     f.read() # u&#39;\u6d4b\u8bd5&#39;  print os.name  # 操作系统名字print os.environprint os.getenv(&#39;PATH&#39;) # 查看当前目录的绝对路径:print os.path.abspath(&#39;.&#39;)# # 在某个目录下创建一个新目录，# # 首先把新目录的完整路径表示出来:# os.path.join(os.path.abspath(&#39;.&#39;), &#39;testdir&#39;)# # 然后创建一个目录:# os.mkdir(os.path.abspath(&#39;.&#39;) + &#39;/testdir&#39;)# # 删掉一个目录:# os.rmdir(os.path.abspath(&#39;.&#39;) + &#39;/testdir&#39;) # 分离路径和名字print os.path.split(&#39;/Users/michael/testdir/file.txt&#39;)# 可以轻松拿到扩展名print os.path.splitext(&#39;/path/to/file.txt&#39;) # 对文件重命名（需要有这个文件）# os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)# 删除文件# os.remove(&#39;test.py&#39;) # 列出当前目录下的所有目录print [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]# 列出所有的.py文件print [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1] == &#39;.py&#39;] try:    import cPickle as pickleexcept ImportError:    import pickle # 序列化d = dict(name=&#39;Bob&#39;, age=20, score=88)# 方法1：pickle.dumps()方法把任意对象序列化成一个str，然后，就可以把这个str写入文件s = pickle.dumps(d)# 反序列化d = pickle.loads(s)print d # 方法2：pickle.dump()直接把对象序列化后写入一个file-like Object：f = open(&#39;dump.txt&#39;, &#39;wb&#39;)pickle.dump(d, f)f.close()# 反序列化f = open(&#39;dump.txt&#39;, &#39;rb&#39;)d = pickle.load(f)f.close()print d # 字典转化成json,也有俩种方法d = dict(name=&#39;Bob&#39;, age=20, score=88)s = json.dumps(d)print json.loads(s)  # 对象序列号class Student(object):    def __init__(self, name, age, score):        self.name = name        self.age = age        self.score = score  s = Student(&#39;Bob&#39;, 20, 88)  def student2dict(std):    return &#123;        &#39;name&#39;: std.name,        &#39;age&#39;: std.age,        &#39;score&#39;: std.score    &#125;  # Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSONprint(json.dumps(s, default=student2dict))# 把任意class的实例变为dicts = json.dumps(s, default=lambda obj: obj.__dict__)print(s)  # 反序列化def dict2student(d):    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])  print(json.loads(s, object_hook=dict2student)) # 进程和线程# mac里这样创建# print &#39;Process (%s) start...&#39; % os.getpid()# pid = os.fork()  # 创建一个进程# if pid == 0:#     print &#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid())# else:#     print &#39;I (%s) just created a child process (%s).&#39; % (os.getpid(), pid) from multiprocessing import Process, Pool, Queue  # windows下，子进程要执行的代码def run_proc(name):    print &#39;Run child process %s (%s)...&#39; % (name, os.getpid())  # 如果要启动大量的子进程，可以用进程池的方式批量创建子进程if __name__ == &#39;__main__&#39;:    print &#39;Parent process %s.&#39; % os.getpid()    p = Process(target=run_proc, args=(&#39;test&#39;,))    print &#39;Process will start.&#39;    p.start()    p.join()    print &#39;Process end.&#39;  def long_time_task(name):    print &#39;Run task %s (%s)...&#39; % (name, os.getpid())    start = time.time()    time.sleep(random.random() * 3)    end = time.time()    print &#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start))  if __name__ == &#39;__main__&#39;:    print &#39;Parent process %s.&#39; % os.getpid()    p = Pool()    for i in range(5):        p.apply_async(long_time_task, args=(i,))    print &#39;Waiting for all subprocesses done...&#39;    p.close()    p.join()    print &#39;All subprocesses done.&#39;  # 进程间通信# 写数据进程执行的代码:def write(q):    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:        print &#39;Put %s to queue...&#39; % value        q.put(value)        time.sleep(random.random())  # 读数据进程执行的代码:def read(q):    while True:        value = q.get(True)        print &#39;Get %s from queue.&#39; % value  if __name__ == &#39;__main__&#39;:    # 父进程创建Queue，并传给各个子进程：    q = Queue()    pw = Process(target=write, args=(q,))    pr = Process(target=read, args=(q,))    # 启动子进程pw，写入:    pw.start()    # 启动子进程pr，读取:    pr.start()    # 等待pw结束:    pw.join()    # pr进程里是死循环，无法等待其结束，只能强行终止:    pr.terminate()</code></pre><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><pre><code class="hljs"># 客户端s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&#39;192.168.202.2&#39;, 9999))# 接收欢迎消息:print s.recv(1024)for data in [&#39;Michael&#39;, &#39;Tracy&#39;, &#39;Sarah&#39;]:    # 发送数据:    s.send(data)    print s.recv(1024)s.send(&#39;exit&#39;)s.close()  # tcp# 服务器要能够区分一个Socket连接是和哪个客户端绑定的。# 一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。# 创建一个socket:import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&#39;www.sina.com.cn&#39;, 80))# 发送数据:s.send(&#39;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&#39;)# 接收数据:buffer = []while True:    # 每次最多接收1k字节:    d = s.recv(1024)    if d:        buffer.append(d)    else:        breakdata = &#39;&#39;.join(buffer)# 关闭连接:s.close() header, html = data.split(&#39;\r\n\r\n&#39;, 1)print header# 把接收的数据写入文件:with open(&#39;sina.html&#39;, &#39;wb&#39;) as f:    f.write(html)# 服务端def tcplink(sock, addr):    print &#39;Accept new connection from %s:%s...&#39; % addr    sock.send(&#39;Welcome!&#39;)    while True:        data = sock.recv(1024)        time.sleep(1)        if data == &#39;exit&#39; or not data:            break        sock.send(&#39;Hello, %s!&#39; % data)    sock.close()    print &#39;Connection from %s:%s closed.&#39; % addr  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 监听端口:s.bind((&#39;192.168.202.2&#39;, 9999))s.listen(5)print &#39;Waiting for connection...&#39;while True:    # 接受一个新连接:    sock, addr = s.accept()    # 创建新线程来处理TCP连接:    t = threading.Thread(target=tcplink, args=(sock, addr))    t.start()</code></pre>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python写爬虫爬妹子</title>
    <link href="/2025/12/fcf34e3c7a6d.html"/>
    <url>/2025/12/fcf34e3c7a6d.html</url>
    
    <content type="html"><![CDATA[<p>最近学完Python，写了几个爬虫练练手，网上的教程有很多，但是有的已经不能爬了，主要是网站经常改，可是爬虫还是有通用的思路的，即下载数据、解析数据、保存数据。下面一一来讲。</p><h2 id="1-下载数据"><a href="#1-下载数据" class="headerlink" title="1.下载数据"></a>1.下载数据</h2><p>首先打开要爬的网站，分析URL，每打开一个网页看URL有什么变化，有可能带上上个网页的某个数据，例如xxID之类，那么我们就需要在上一个页面分析HTML，找到对应的数据。如果网页源码找不到，可能是ajax异步加载，去xhr里去找。</p><p> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/Python/attachments/2024-01-03-18-02-a78d237323852fca46d04d2a49e4e670-kkp4u-e848fc.png" alt="kkp4u"></p><p>有的网站做了反爬的处理，可以添加User-Agent ：判断浏览器</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">self.user_agent</span> = <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#x27;</span><br><span class="hljs-comment"># 初始化 headers</span><br><span class="hljs-attr">self.headers</span> = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: self.user_agent&#125;<br></code></pre></td></tr></table></figure><p>如果不行，在Chrome上按F12分析请求头、请求体，看需不需要添加别的信息，例如有的网址添加了referer：记住当前网页的来源，那么我们在请求的时候就可以带上。按Ctrl + Shift + C，可以定位元素在HTML上的位置</p><h4 id="动态网页"><a href="#动态网页" class="headerlink" title="动态网页"></a>动态网页</h4><p>有一些网页是动态网页，我们得到网页的时候，数据还没请求到呢，当然什么都提取不出来，用Python 解决这个问题只有两种途径：直接从JavaScript 代码里采集内容，或者用Python 的第三方库运行JavaScript，直接采集你在浏览器里看到的页面。</p><ol><li><p>找请求，看返回的内容，网页的内容可能就在这里。然后可以复制请求，复杂的网址中，有些乱七八糟的可以删除，有意义的部分保留。切记删除一小部分后先尝试能不能打开网页，如果成功再删减，直到不能删减。</p></li><li><p>Selenium：是一个强大的网络数据采集工具（但是速度慢），其最初是为网站自动化测试而开发的。近几年，它还被广泛用于获取精确的网站快照，因为它们可以直接运行在浏览器上。Selenium 库是一个在WebDriver 上调用的API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像BeautifulSoup对象一样用来查找页面元素，与页面上的元素进行交互（发送文本、点击等），以及执行其他动作来运行网络爬虫。</p></li></ol><p>PhantomJS：是一个“无头”（headless）浏览器。它会把网站加载到内存并执行页面上的JavaScript，但是它不会向用户展示网页的图形界面。把Selenium和PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，可以处理cookie、JavaScript、header，以及任何你需要做的事情。</p><h4 id="下载数据的模块有urllib、urllib2及Requests"><a href="#下载数据的模块有urllib、urllib2及Requests" class="headerlink" title="下载数据的模块有urllib、urllib2及Requests"></a>下载数据的模块有urllib、urllib2及Requests</h4><p>Requests相比其他俩个的话，支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自 动确定响应内容的编码，支持国际化的 URL 和 POST 数据自动编码，而且api相对来说也简单，但是requests直接使用不能异步调用，速度慢。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">html = requests.<span class="hljs-built_in">get</span>(url, <span class="hljs-attribute">headers</span>=headers)   #没错，就是这么简单<br></code></pre></td></tr></table></figure><p><strong>urllib2以我爬取淘宝的妹子例子来说明</strong>  </p><p> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/Python/attachments/2024-01-03-18-02-fc762aec546cc646ba7b1e0952d5f76c-hbzkj-cc156e.png" alt="hbzkj"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">user_agent = <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#x27;</span><br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: user_agent&#125;<br><span class="hljs-meta"># 注意：form data请求参数</span><br><span class="hljs-keyword">params</span> = <span class="hljs-string">&#x27;q&amp;viewFlag=A&amp;sortType=default&amp;searchStyle=&amp;searchRegion=city%3A&amp;searchFansNum=&amp;currentPage=1&amp;pageSize=100&#x27;</span><br><br><br><span class="hljs-function">def <span class="hljs-title">getHome</span>():</span><br><span class="hljs-function">    url</span> = <span class="hljs-string">&#x27;https://mm.taobao.com/tstar/search/tstar_model.do?_input_charset=utf-8&#x27;</span><br>    req = urllib2.Request(url, headers=headers)<br>    <span class="hljs-meta"># decode（’utf - 8’）解码   把其他编码转换成unicode编码</span><br>    <span class="hljs-meta"># encode(’gbk’) 编码  把unicode编码转换成其他编码</span><br>    <span class="hljs-meta"># ”gbk”.decode(’gbk’).encode(’utf - 8&#x27;)</span><br>    <span class="hljs-meta"># unicode = 中文</span><br>    <span class="hljs-meta"># gbk = 英文</span><br>    <span class="hljs-meta"># utf - 8 = 日文</span><br>    <span class="hljs-meta"># 英文一 &gt; 中文一 &gt; 日文,unicode相当于转化器</span><br>    html = urllib2.urlopen(req, data=<span class="hljs-keyword">params</span>).read().decode(<span class="hljs-string">&#x27;gbk&#x27;</span>).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-meta"># json转对象</span><br>    peoples = json.loads(html)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> peoples[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;searchDOList&#x27;</span>]:<br>        <span class="hljs-meta">#去下一个页面获取数据</span><br>        getUseInfo(i[<span class="hljs-string">&#x27;userId&#x27;</span>], i[<span class="hljs-string">&#x27;realName&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="2-解析数据"><a href="#2-解析数据" class="headerlink" title="2.解析数据"></a>2.解析数据</h2><p>解析数据也有很多方式，我只看了beautifulsoup和正则，这个例子是用正则来解析的</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">getUseInfo</span>(userId, realName):<br>    url = <span class="hljs-string">&#x27;https://mm.taobao.com/self/aiShow.htm?userId=&#x27;</span> + <span class="hljs-built_in">str</span>(userId)<br>    req = urllib2.<span class="hljs-built_in">Request</span>(url)<br>    html = urllib2.<span class="hljs-built_in">urlopen</span>(req).<span class="hljs-built_in">read</span>().<span class="hljs-built_in">decode</span>(<span class="hljs-string">&#x27;gbk&#x27;</span>).<span class="hljs-built_in">encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;&lt;img.*?src=(.*?)/&gt;&#x27;</span>, re.S)<br>    items = re.<span class="hljs-built_in">findall</span>(pattern, html)<br>    x = <span class="hljs-number">0</span><br>    for item in items:<br>        if re.<span class="hljs-built_in">match</span>(r<span class="hljs-string">&#x27;.*(.jpg&quot;)$&#x27;</span>, item.<span class="hljs-built_in">strip</span>()):<br>            tt = <span class="hljs-string">&#x27;http:&#x27;</span> + re.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&quot;&#x27;</span>, item.<span class="hljs-built_in">strip</span>())[<span class="hljs-number">1</span>]<br>            <span class="hljs-built_in">down_image</span>(tt, x, realName)<br>            x = x + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下载完毕&#x27;</span>)<br></code></pre></td></tr></table></figure><p>正则表达式说明</p><p>match：匹配string 开头，成功返回Match object, 失败返回None，只匹配一个。<br>search：在string中进行搜索，成功返回Match object, 失败返回None, 只匹配一个。<br>findall：在string中查找所有 匹配成功的组, 即用括号括起来的部分。返回list对象，每个list item是由每个匹配的所有组组成的list。</p><p>1）.<em>? 是一个固定的搭配，.和</em>代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配</p><p>2）(.<em>?)代表一个分组，如果有5个(.</em>?)就说明匹配了五个分组</p><p>3） 正则表达式中，“.”的作用是匹配除“\n”以外的任何字符，也就是说，它是在一行中进行匹配。这里的“行”是以“\n”进行区分的。HTML标签每行的末尾有一个“\n”，不过它不可见。 如果不使用re.S参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始，不会跨行。而使用re.S参数以后，正则表达式会将这个字符串作为一个整体，将“\n”当做一个普通的字符加入到这个字符串中，在整体中进行匹配。</p><h2 id="3-保存数据"><a href="#3-保存数据" class="headerlink" title="3.保存数据"></a>3.保存数据</h2><p>数据解析后可以保存到文件或数据库中，这个例子是保存到了文件中，很简单，就不做说明了，在下篇讲如何将数据保存到数据库</p><p><a href="https://www.cnblogs.com/sixrain/p/9138442.html">https://www.cnblogs.com/sixrain/p/9138442.html</a></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def down_image(url, filename, realName):<br>    req = urllib2.Request(url=url)<br>    <span class="hljs-built_in">folder</span> = <span class="hljs-string">&#x27;e:\\images\\%s&#x27;</span> % realName<br>    <span class="hljs-keyword">if</span> os.path.isdir(<span class="hljs-built_in">folder</span>):<br>        pass<br>    <span class="hljs-keyword">else</span>:<br>        os.makedirs(<span class="hljs-built_in">folder</span>)<br><br>    f = <span class="hljs-built_in">folder</span> + <span class="hljs-string">&#x27;\\%s.jpg&#x27;</span> % filename<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isfile(f):<br>        print f<br>        binary_data = urllib2.urlopen(req).<span class="hljs-built_in">read</span>()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(f, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> temp_file:<br>            temp_file.<span class="hljs-built_in">write</span>(binary_data)<br></code></pre></td></tr></table></figure><p>GitHub地址，还有其他网站爬虫，欢迎star：<br><a href="https://github.com/peiniwan/Spider2">https://github.com/peiniwan/Spider2</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.Hilt</title>
    <link href="/2025/12/06220d0f6b2a.html"/>
    <url>/2025/12/06220d0f6b2a.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6902009428633698312?searchId=20240129143412FC9A81D5E39DE2C0C6FB#heading-5">Jetpack新成员，一篇文章带你玩转Hilt和依赖注入 - 掘金</a><br><a href="https://developer.android.com/training/dependency-injection/hilt-multi-module?hl=zh-cn">在多模块应用中使用 Hilt  |  Android 开发者  |  Android Developers</a><br>[[6.依赖注入框架]]</p><p>加上@Inject 、@ApplicationContext</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@HiltViewModel</span>  <br>class MainViewModel <span class="hljs-variable">@Inject</span> <span class="hljs-built_in">constructor</span>(  <br>    val <span class="hljs-attribute">mainRepository</span>: MainRepository,  <br>    <span class="hljs-variable">@ApplicationContext</span> val <span class="hljs-attribute">context</span>: Context  <br>) : <span class="hljs-built_in">ViewModel</span>() &#123;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>为什么我们要使用依赖注入呢？解耦。</p><ol><li>我们程序里有些对象是全局共享的，比如线程池，或者 Retrofit 对象，这种东西我们通常会把它放在 Application 对象里，或者做成单例的</li><li>还有些对象是局部共享的，比如某个 Activity 会把一些显示用的数据共享给它内部的一些 View 和 Fragment。这一类情况我们的做法通常是获取外部 Activity 对象然后强转，再去拿它内部的对象</li><li>除了共享的对象，不共享的也可以用依赖注入的方式来进行初始化，因为依赖注入的作用除了对共享对象提供一致性支持，也可以让我们在创建任何对象的时候省一些思考和力气</li></ol><p>总之，如果一个组件可能会被被共享，或者不会被共享但可能会在多处使用，你都可以使用 Hilt 来把它配置成依赖注入的加载方式。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>相比于 Dagger2，Hilt 最明显的特征就是：1. 简单。2. 提供了 Android 专属的 API。</p><h3 id="Hilt-的简单用法"><a href="#Hilt-的简单用法" class="headerlink" title="Hilt 的简单用法"></a>Hilt 的简单用法</h3><p>Hilt 当中，你必须要自定义一个 Application 才行，否则 Hilt 将无法正常工作。<br>这里我们自定义一个 MyApplication 类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hilt 一共支持 6 个入口点，分别是：</p><ul><li>Application</li><li>Activity</li><li>Fragment</li><li>View</li><li>Service</li><li>BroadcastReceiver<br>有 Application 这个入口点是使用 @HiltAndroidApp 注解来声明的，这个我们刚才已经看过了。其他的所有入口点，都是用 @AndroidEntryPoint 注解来声明的。<br>Hilt 注入的字段是不可以声明成 private<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliver</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Truck is delivering cargo.&quot;</span>)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> truck: Truck<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        truck.deliver()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="带参数的依赖注入"><a href="#带参数的依赖注入" class="headerlink" title="带参数的依赖注入"></a>带参数的依赖注入</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-keyword">val</span> driver: Driver) &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliver</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Truck is delivering cargo. Driven by <span class="hljs-variable">$driver</span>&quot;</span>)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="接口的依赖注入"><a href="#接口的依赖注入" class="headerlink" title="接口的依赖注入"></a>接口的依赖注入</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> GasEngine @Inject <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> :</span> Engine <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    ...</span><br><span class="hljs-comment">&#125;</span><br><br><span class="hljs-keyword">class</span> ElectricEngine @Inject <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> :</span> Engine <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    ...</span><br><span class="hljs-comment">&#125;</span><br><br></code></pre></td></tr></table></figure><p>接下来我们需要新建一个抽象类，类名叫什么都可以，但是最好要和业务逻辑有相关性，因此我建议起名 EngineModule. kt，最后，在抽象函数上方加上 @Bind 注解，这样 Hilt 才能识别它。如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Module</span><br><span class="hljs-variable">@InstallIn</span>(<span class="hljs-attribute">ActivityComponent</span>::class)<br>abstract class EngineModule &#123;<br><br>    <span class="hljs-variable">@Binds</span><br>    abstract fun <span class="hljs-built_in">bindEngine</span>(<span class="hljs-attribute">gasEngine</span>: GasEngine): Engine<br><br>&#125;<br>class Truck <span class="hljs-variable">@Inject</span> <span class="hljs-built_in">constructor</span>(val <span class="hljs-attribute">driver</span>: Driver) &#123;<br>    <br>    <span class="hljs-variable">@Inject</span><br>    lateinit var <span class="hljs-attribute">engine</span>: Engine<br><br>    fun <span class="hljs-built_in">deliver</span>() &#123;<br>        <span class="hljs-selector-tag">engine</span><span class="hljs-selector-class">.start</span>()<br>        <span class="hljs-selector-tag">println</span>(<span class="hljs-string">&quot;Truck is delivering cargo. Driven by $driver&quot;</span>)<br>        <span class="hljs-selector-tag">engine</span><span class="hljs-selector-class">.shutdown</span>()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="给相同类型注入不同的实例"><a href="#给相同类型注入不同的实例" class="headerlink" title="给相同类型注入不同的实例"></a>给相同类型注入不同的实例</h3><p>Qualifier 注解。给相同类型的类或接口注入不同的实例。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Qualifier</span><br><span class="hljs-variable">@Retention</span>(AnnotationRetention.BINARY)<br>annotation class BindGasEngine<br><br><span class="hljs-variable">@Qualifier</span><br><span class="hljs-variable">@Retention</span>(AnnotationRetention.BINARY)<br>annotation class BindElectricEngine<br><br></code></pre></td></tr></table></figure><p>至于另外一个 @Retention，是用于声明注解的作用范围，选择 AnnotationRetention.BINARY 表示该注解在编译之后会得到保留，但是无法通过反射去访问这个注解。这应该是最合理的一个注解作用范围。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Module</span><br><span class="hljs-variable">@InstallIn</span>(<span class="hljs-attribute">ActivityComponent</span>::class)<br>abstract class EngineModule &#123;<br><br>    <span class="hljs-variable">@BindGasEngine</span><br>    <span class="hljs-variable">@Binds</span><br>    abstract fun <span class="hljs-built_in">bindGasEngine</span>(<span class="hljs-attribute">gasEngine</span>: GasEngine): Engine<br><br>    <span class="hljs-variable">@BindElectricEngine</span><br>    <span class="hljs-variable">@Binds</span><br>    abstract fun <span class="hljs-built_in">bindElectricEngine</span>(<span class="hljs-attribute">electricEngine</span>: ElectricEngine): Engine<br><br>&#125;<br><br>class Truck <span class="hljs-variable">@Inject</span> <span class="hljs-built_in">constructor</span>(val <span class="hljs-attribute">driver</span>: Driver) &#123;<br><br>    <span class="hljs-variable">@BindGasEngine</span><br>    <span class="hljs-variable">@Inject</span><br>    lateinit var <span class="hljs-attribute">gasEngine</span>: Engine<br><br>    <span class="hljs-variable">@BindElectricEngine</span><br>    <span class="hljs-variable">@Inject</span><br>    lateinit var <span class="hljs-attribute">electricEngine</span>: Engine<br><br>    fun <span class="hljs-built_in">deliver</span>() &#123;<br>        <span class="hljs-selector-tag">gasEngine</span><span class="hljs-selector-class">.start</span>()<br>        <span class="hljs-selector-tag">electricEngine</span><span class="hljs-selector-class">.start</span>()<br>        <span class="hljs-selector-tag">println</span>(<span class="hljs-string">&quot;Truck is delivering cargo. Driven by $driver&quot;</span>)<br>        <span class="hljs-selector-tag">gasEngine</span><span class="hljs-selector-class">.shutdown</span>()<br>        <span class="hljs-selector-tag">electricEngine</span><span class="hljs-selector-class">.shutdown</span>()<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="第三方类的依赖注入"><a href="#第三方类的依赖注入" class="headerlink" title="第三方类的依赖注入"></a>第三方类的依赖注入</h3><p>借助 @Module 注解，它的解决方案有点类似于刚才给接口类型提供依赖注入，但是并不完全一样。<br>记得要在 provideOkHttpClient() 函数的上方加上 @Provides 注解，这样 Hilt 才能识别它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkModule</span> &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideOkHttpClient</span><span class="hljs-params">()</span></span>: OkHttpClient &#123;<br>        <span class="hljs-keyword">return</span> OkHttpClient.Builder()<br>            .connectTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>            .readTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>            .writeTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>            .build()<br>    &#125;<br><br>  <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRetrofit</span><span class="hljs-params">(okHttpClient: <span class="hljs-type">OkHttpClient</span>)</span></span>: Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .addConverterFactory(GsonConverterFactory.create())<br>            .baseUrl(<span class="hljs-string">&quot;http://example.com/&quot;</span>)<br>            .client(okHttpClient)<br>            .build()<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> okHttpClient: OkHttpClient<br>    <br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> retrofit: Retrofit<br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hilt-内置组件和组件作用域"><a href="#Hilt-内置组件和组件作用域" class="headerlink" title="Hilt 内置组件和组件作用域"></a>Hilt 内置组件和组件作用域</h3><p>InstallIn，就是安装到的意思。那么 @InstallIn(ActivityComponent::class)，就是把这个模块安装到 Activity 组件当中。<br>Activity 中包含的 Fragment 和 View 也可以使用，但是除了 Activity、Fragment、View 之外的其他地方就无法使用了。<br><img src="http://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/20240315174504.png" alt="image.png|600"><br>比如我们提供的 Retrofit 和 OkHttpClient 的实例，理论上它们全局只需要一份就可以了，每次都创建不同的实例明显是一种不必要的浪费。<br>而更改这种默认行为其实也很简单，借助 @Singleton 注解即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ApplicationComponent::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkModule</span> &#123;<br><br>    <span class="hljs-meta">@Singleton</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideOkHttpClient</span><span class="hljs-params">()</span></span>: OkHttpClient &#123;<br>        <span class="hljs-keyword">return</span> OkHttpClient.Builder()<br>            .connectTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>            .readTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>            .writeTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>            .build()<br>    &#125;<br><br>    <span class="hljs-meta">@Singleton</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRetrofit</span><span class="hljs-params">(okHttpClient: <span class="hljs-type">OkHttpClient</span>)</span></span>: Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .addConverterFactory(GsonConverterFactory.create())<br>            .baseUrl(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br>            .client(okHttpClient)<br>            .build()<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>Hilt 一共提供了 7 种组件作用域注解，和刚才的 7 个内置组件分别是一一对应的，如下表所示。<br><img src="http://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/20240315174630.png" alt="image.png|600"><br>如果想要在全程序范围内共用某个对象的实例，那么就使用 @Singleton。如果想要在某个 Activity，以及它内部包含的 Fragment 和 View 中共用某个对象的实例，那么就使用 @ActivityScoped。以此类推。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Singleton</span><br>class Driver <span class="hljs-variable">@Inject</span> <span class="hljs-built_in">constructor</span>() &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就表示，Driver 在整个项目的全局范围内都会共享同一个实例，并且全局都可以对 Driver 类进行依赖注入。</p><p>而如果我们将注解改成 @ActivityScoped，那么就表示 Driver 在同一个 Activity 内部将会共享同一个实例，并且 Activity、Fragment、View 都可以对 Driver 类进行依赖注入。</p><p><img src="http://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/20240315174808.png" alt="image.png|600"><br>@Singleton 注解的箭头可以指向所有地方。而 @ServiceScoped 注解的箭头无处可指，所以只能限定在 Service 自身当中使用。@ActivityScoped 注解的箭头可以指向 Fragment、View 当中。</p><h3 id="预置-Qualifier"><a href="#预置-Qualifier" class="headerlink" title="预置 Qualifier"></a>预置 Qualifier</h3><p>这种写法 Hilt 会自动提供一个 Application 类型的 Context 给到 Truck 类当中，然后 Truck 类就可以使用这个 Context 去编写具体的业务逻辑了。</p><p>但是如果你说，我需要的并不是 Application 类型的 Context，而是 Activity 类型的 Context。也没有问题，Hilt 还预置了另外一种 Qualifier，我们使用 @ActivityContext 即可：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Singleton</span><br>class Driver <span class="hljs-variable">@Inject</span> <span class="hljs-built_in">constructor</span>(<span class="hljs-variable">@ApplicationContext</span> val <span class="hljs-attribute">context</span>: Context) &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关于预置 Qualifier 其实还有一个隐藏的小技巧，就是对于 Application 和 Activity 这两个类型，Hilt 也是给它们预置好了注入功能。也就是说，如果你的某个类依赖于 Application 或者 Activity，不需要想办法为这两个类提供依赖注入的实例，Hilt 自动就能识别它们。如下所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Driver</span> @<span class="hljs-symbol">Inject</span> <span class="hljs-symbol">constructor</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">application: <span class="hljs-symbol">Application</span></span>) &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Driver</span> @<span class="hljs-symbol">Inject</span> <span class="hljs-symbol">constructor</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">activity: <span class="hljs-symbol">Activity</span></span>) &#123;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>小窍门，因为 Application 全局只会存在一份实例，因此 Hilt 注入的 Application 实例其实就是你自定义的 MyApplication 实例，所以想办法做一下向下类型转换就可以了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn</span> (ApplicationComponent::<span class="hljs-keyword">class</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationModule</span> &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMyApplication</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span>: MyApplication &#123;<br>        <span class="hljs-keyword">return</span> application <span class="hljs-keyword">as</span> MyApplication<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="ViewModel-的依赖注入"><a href="#ViewModel-的依赖注入" class="headerlink" title="ViewModel 的依赖注入"></a>ViewModel 的依赖注入</h3><p>对于 ViewModel 这种常用 Jetpack 组件，Hilt 专门为其提供了一种独立的依赖注入方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencies &#123;<br>    ...<br>    implementation <span class="hljs-string">&#x27;androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha02&#x27;</span><br>    kapt <span class="hljs-string">&#x27;androidx.hilt:hilt-compiler:1.0.0-alpha02&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> <span class="hljs-meta">@ViewModelInject</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-keyword">val</span> repository: Repository) : ViewModel() &#123;<br>    ...<br>&#125;<br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">val</span> viewModel: MyViewModel <span class="hljs-keyword">by</span> lazy &#123; ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(MyViewModel::<span class="hljs-keyword">class</span>.java) &#125;<br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不支持的入口点怎么办？"><a href="#不支持的入口点怎么办？" class="headerlink" title="不支持的入口点怎么办？"></a>不支持的入口点怎么办？</h3><p>主要原因就是 ContentProvider 的生命周期问题。如果你比较了解 ContentProvider 的话，应该知道它的生命周期是比较特殊的，它在 Application 的 onCreate() 方法之前就能得到执行，因此很多人会利用这个特性去进行提前初始化，详见 Jetpack 新成员，App Startup 一篇就懂这篇文章。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContentProvider</span> : <span class="hljs-type">ContentProvider</span>() &#123;<br><br>    <span class="hljs-meta">@EntryPoint</span><br>    <span class="hljs-meta">@InstallIn(ApplicationComponent::class)</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyEntryPoint</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRetrofit</span><span class="hljs-params">()</span></span>: Retrofit<br>    &#125;<br>    ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最新版有两个不一样的地方，单例不再是 applicationComponent，改成 SingletonComponent 了，第二是 ViewModel 注入可以改成 HiltViewModel</p><ul><li>@Module 注解，表示这一个用于<em>提供依赖注入实例的模块，接口或第三方用</em></li><li>@Binds：接口，需要在<em>方法参数里面明确指明接口的实现类</em>。还要再定义个注解 Qualifier</li><li>@Provides：不需要在方法参数里面明确指明接口的实现类，由第三方框架实现，通常用于和第三方框架进行绑定 (Retrofit、Room 等等)</li></ul><p>首先 lateinit 是 Kotlin 中的关键字，和 Hilt 无关。这个关键字用于对变量延迟初始化，因为 Kotlin 默认在声明一个变量时就要对其进行初始化，而这里我们并不想手动初始化，所以要加上 lateinit。如果你是用 Java 开发的话，那么可以无视这个关键字。</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.依赖注入框架</title>
    <link href="/2025/12/c3381ea17c8e.html"/>
    <url>/2025/12/c3381ea17c8e.html</url>
    
    <content type="html"><![CDATA[<h1 id="依赖注入框架"><a href="#依赖注入框架" class="headerlink" title="依赖注入框架"></a>依赖注入框架</h1><p><strong>什么是依赖注入？</strong><br>如果类a里有个类b的实例，则b是a的依赖，如果B 的赋值不是写死在了类或构造函数中，而是<em>通过构造函数或其他函数的参数传入，这种赋值方式我们称之为依赖注入</em>。依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。如果只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。在 Android 上比较流行的有RoboGuice、Dagger 、Butter Knife等。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5koin_hilt.resources/2023/09/15/18-51-47-87c18c149faf42578d9ef0b8bd127c2e-unknown_filename.2-55c906.png" alt="unknown_filename.2|600"></p><h2 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h2><p>[[7.Hilt]]</p><h2 id="Koin"><a href="#Koin" class="headerlink" title="Koin"></a>Koin</h2><p>Koin 是为 Kotlin 开发者提供的一个实用型轻量级依赖注入框架，采用纯 Kotlin 语言编写而成，仅使用功能解析，无代理、无代码生成、无反射。</p><p><a href="https://insert-koin.io/">官网地址</a></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>依赖注入好处</strong><br>如果一个组件可能被共享，或者可能在多处被使用，你可以使用依赖注入来初始化它。<br>我们程序里有些对象是全局共享的，比如线程池，或者 Retrofit 对象，这种东西我们通常会把它放在 Application 对象里，或者做成单例的。<br>工具：Retrofit、Gson、OkHttp、Parser、ExecutorServic</p><ul><li>增加开发效率、省去重复的简单体力劳动<br>  首先new一个实例的过程是一个重复的简单体力劳动，依赖注入可以把new一个实例的工作做了，因此我们把主要精力集中在关键业务上、同时也能增加开发效率上。</li><li>代码更具可读性</li><li>省去写单例的方法</li><li><strong>解耦</strong>*(最关键)<br>  假如不用依赖注入的话，一个类的new代码是非常可能充斥在app的多个类中的，假如该类的构造函数发生变化，那这些涉及到的类都得进行修改。</li></ul><p><strong>和dagger相比</strong></p><ol><li>编译生成的代码少</li><li>编译时间少</li><li>上手简单</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>1.添加依赖</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// Add Jcenter to your repositories if needed</span><br><span class="hljs-keyword">repositories</span> &#123;<br>    jcenter()    <br>&#125;<br><span class="hljs-keyword">dependencies</span> &#123;<br>    <span class="hljs-comment">// Koin for Android</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;org.koin:koin-android:$koin_version&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.比如创建一个HelloRepository来提供一些数据：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloRepository</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">giveHello</span><span class="hljs-params">()</span></span>: String<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloRepositoryImpl</span>() : HelloRepository &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">giveHello</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Hello Koin&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.创建一个presenter类，用来使用这些数据：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimplePresenter</span>(<span class="hljs-keyword">val</span> repo: HelloRepository) &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;repo.giveHello()&#125;</span> from <span class="hljs-variable">$this</span>&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.编写Koin模块，使用该module函数声明模块。</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">val appModule = module &#123;<br><br>    // single<span class="hljs-built_in"> instance </span>of HelloRepository<br>    single&lt;HelloRepository&gt; &#123; HelloRepositoryImpl() &#125;<br><br>    // Simple Presenter Factory<br>    factory &#123; MySimplePresenter(get()) &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>factory每次Activity需要一个实例时都会创建一个新实例。<br>single 区别在于其提供的实例是单例的<br>get()这里的功能是直接检索实例（非延迟）</p></blockquote><p><strong>5.启动koin</strong><br>现在有了一个模块，只需要在Application里调用startKoin()函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>()&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        <span class="hljs-comment">// Start Koin</span><br>        startKoin&#123;<br>            androidLogger()<br>            androidContext(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MyApplication</span>)<br>            modules(appModule)<br>        &#125;<br>    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>6.注入依赖</strong><br>该MySimplePresenter组件将使用HelloRepository实例创建。用by inject()委托注入器注入它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimpleActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-comment">// Lazy injected MySimplePresenter</span><br>    <span class="hljs-keyword">val</span> firstPresenter: MySimplePresenter <span class="hljs-keyword">by</span> inject()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br><br>        <span class="hljs-comment">//...</span><br>    &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>该by inject()功能使我们能够在Android组件运行时（活动，片段，服务…）中检索Koin实例。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>[[1.Kotlin分享#内联函数]]</p><h4 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h4><ul><li>内联函数支持具体化的类型参数，使用 reified 修饰符来限定类型参数，可以在函数内部访问它，由于函数是内联的，所以不需要反射。</li><li>koin里有一个全局的容器，提供了应用所有所需实例的构造方式，那么当我们需要新建实例的时候，就可以直接从这个容器里面获取到它的构造方式然后拿到所需的依赖，构造出所需的实例就可以了。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">startKoin</span><span class="hljs-params">(this, appModule, logger = AndroidLogger(showDebug = BuildConfig.DEBUG)</span></span>)<br></code></pre></td></tr></table></figure><ul><li>Koin提供一个全局容器，将所有的依赖构造方式转换成 BeanDefinition 进行注册，这是一个HashSet，名字是 definitions。</li></ul><p>BeanDefinition</p><ul><li>name以及primaryType，这两个是get()关键字依赖检索所需的key。<ul><li>definition: Definition</T>，它的值代表了其构造方式来源于那个 module，对应前文的 appModule，通过它可以反向推导该实例需要哪些依赖。</li></ul></li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs smali">override fun &lt;T&gt; get(parameters: ParameterDefinition): Instance&lt;T&gt; &#123;<br>      val needCreation =<span class="hljs-built_in"> instance </span>== null<br>     <span class="hljs-built_in"> if </span>(needCreation) &#123;<br>         <span class="hljs-built_in"> instance </span>= create(parameters)<br>      &#125;<br>     <span class="hljs-built_in"> return </span>Instance(instance as T, needCreation)<br>  &#125;<br>  <br>  <br>      fun &lt;T&gt; create(parameters: ParameterDefinition): T &#123;<br>      try &#123;<br>          val parameterList = parameters()<br>          val<span class="hljs-built_in"> instance </span>= bean.definition.invoke(parameterList) as Any<br>         <span class="hljs-built_in"> instance </span>as T  //创建参数的实例<br>         <span class="hljs-built_in"> return </span>instance<br>      &#125; catch (e: Throwable) &#123;<br>            // ....<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>现在需要一个 MainViewModel 的实例，那么通过clazz为Class&lt;*MainViewMode*l&gt;的key在definitions中进行查找。</li><li>查到有一个 MainViewModel 的 BeanDefinition，通过注册过的 definition: Definition&lt;*T*&gt;找到其构造方式的位置（module）。</li><li>当通过 MainViewModel(get() 的构造方式去构造 MainViewModel 实例的时候，发现又有一个get&lt;*Repository*&gt;()，然后就是再重复前面的逻辑，一直到生成ViewModel实例为止。</li></ul><p><a href="https://github.com/peiniwan/mvvm">示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.冷流热流</title>
    <link href="/2025/12/3e0298e17d43.html"/>
    <url>/2025/12/3e0298e17d43.html</url>
    
    <content type="html"><![CDATA[<h2 id="冷流"><a href="#冷流" class="headerlink" title="冷流"></a>冷流</h2><ul><li><em>只有订阅者订阅时，才开始执行发射数据流的代码。并且冷流和订阅者只能是一对一的关系</em>，当有多个不同的订阅者时，消息是重新完整发送的。也就是说对冷流而言，有多个订阅者的时候，他们各自的事件是独立的。</li><li>冷数据流，<em>不消费则不生产数据</em>,这一点与LiveData不同：LiveData的发送端并不依赖于接收端。</li></ul><h2 id="热流"><a href="#热流" class="headerlink" title="热流"></a>热流</h2><ul><li><em>无论有没有订阅者订阅，事件始终都会发生</em>。当 热流有多个订阅者时，热流与订阅者们的关系是<em>一对多</em>的关系，可以与多个订阅者共享信息。（都收到）</li><li>冷流和订阅者只能是一对一的关系，当我们要实现一个流，多个订阅者的需求时(这在开发中是很常见的)，就需要热流了</li><li>SharedFlow即共享的Flow，可以实现一对多关系,SharedFlow是一种热流。</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">//ViewModel</span><br>val sharedFlow=MutableSharedFlow&lt;String&gt;()<br><br>viewModelScope.<span class="hljs-keyword">launch</span>&#123;<br>  sharedFlow.<span class="hljs-keyword">emit</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br>  sharedFlow.<span class="hljs-keyword">emit</span>(<span class="hljs-string">&quot;SharedFlow&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//Activity</span><br>lifecycleScope.<span class="hljs-keyword">launch</span>&#123;<br>viewMode.sharedFlow.collect &#123; <br>   <span class="hljs-keyword">print</span>(it)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h2><p>哪些场景下才使用SharedFlow<br>其实SharedFlow相比StateFlow更加灵活，由于它可以处理粘性和背压的问题，一个很常用的场景就是是用于事件的传递。就是类似EventBus那种消息总线。可以很方便很简单的实现一个基于SharedFlow的FlowBus。</p><p>另一种情况下就是用于管理页面的事件处理，比如根据值的状态弹出弹窗，吐司。由于SharedFlow可以自由的控制是否需要粘性，如果默认没有粘性的情况下，我们可以在页面销毁重建，或旋转屏幕的时候，保证不会触发到页面状态，如弹窗，吐司的触发。因为没有粘性内部没有值的保存，所以不会触发到页面状态。</p><p>这两种场景我已经在SharedFlow的单独介绍文章中有代码与演示，有兴趣的可以看看<a href="https://juejin.cn/post/7127454075666300965" title=" https://juejin.cn/post/7127454075666300965">这里</a>。</p><p><strong>SharedFlow 相同的值可以重复发，StateFlow 不行</strong></p><h2 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h2><p>StateFlow 与 LiveData 是最接近的，因为:</p><p>有初始值： StateFlow 初始化时必须传入初始值；<br>容量为 1： StateFlow 只会保存一个值；<br>重放为 1： StateFlow 会向新订阅者重放最新的值；<br>不支持 resetReplayCache() 重置重放缓存：</p><ol><li>它始终是有值的。</li><li>它的值是唯一的。</li><li>它允许被多个观察者共用 (因此是共享的数据流)。</li><li>它永远只会把最新的值重现给订阅者，这与活跃观察者的数量是无关的。</li></ol><p>构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">MutableStateFlow</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: MutableStateFlow&lt;T&gt; = StateFlowImpl(value ?: NULL)<br></code></pre></td></tr></table></figure><p>1.StateFlow构造函数较为简单，只需要传入一个默认值<br>2.StateFlow本质上是一个replay为 1，并且没有缓冲区的SharedFlow, 因此第一次订阅时会先获得默认值<br>3.StateFlow仅在值已更新，并且值发生了变化时才会返回，即如果更新后的值没有变化，也没会回调Collect方法，这点与LiveData不同</p><p><strong>stateIn将普通流转化成StateFlow</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">val result: StateFlow<span class="hljs-variable">&lt;Result&lt;UiState&gt;</span>&gt; = someFlow<br>.<span class="hljs-keyword">state</span>In(<br>scope = viewModelScope, <br>started = WhileSubscribed(<span class="hljs-number">5000</span>), <br>initialValue = Result.Loading<br>)<br></code></pre></td></tr></table></figure><p>需要传入一个默认值，同时之所以WhileSubscribed中传入了5000，是为了实现等待5秒后仍然没有订阅者存在就终止协程的功能，这个方法有以下功能</p><ul><li>防抖</li><li>用户将您的应用转至后台运行，5 秒钟后所有来自其他层的数据更新会停止，这样可以节省电量。</li><li>最新的数据仍然会被缓存，所以当用户切换回应用时，视图立即就可以得到数据进行渲染。</li><li>订阅将被重启，新数据会填充进来，当数据可用时更新视图。</li><li>在屏幕旋转时，因为重新订阅的时间在 5s 内，因此上游流不会中止</li></ul><p><strong>flowWithLifecycle</strong><br>我们都知道LiveData的监听是和Activity的生命周期绑定的，比如页面再后台就不会触发，而页面到前台才会触发。<br>StateFlow可不会这么和生命周期绑定，不过我们可以通过添加一个函数让StateFlow可以和生命周期绑定实现和LiveData一样的效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startObserve</span><span class="hljs-params">()</span></span> &#123;<br>lifecycleScope.launch &#123;<br>mViewModel.searchFlow<br>.flowWithLifecycle(<span class="hljs-keyword">this</span><span class="hljs-symbol">@Demo4Activity</span>.lifecycle)  <br><span class="hljs-comment">//相当于自动帮我们设置 lifecycle.repeatOnLifecycle</span><br>.collect &#123;<br>YYLogUtils.w(<span class="hljs-string">&quot;search-state-value <span class="hljs-variable">$it</span>&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果我就想当前Actiity不可见的情况下也能触发监听，那要怎么搞，也能做，我们StateFlow默认就不绑定生命周期的，我们把绑定生命周期的代码去掉即可</p><p><strong>StateFlow的数据防抖是双刃剑</strong>，所以我们需要看使用的场景是否需要此功能。</p><p>我们点击登录按钮，调用接口得到错误信息“密码错误”。通过StateFlow发送给Activity。Activity就会弹窗展示错误信息。那么第二次再点击登录按钮，StateFlow就会判断你的值还是“密码错误”，它就不给你发送了。这样就导致用户点击按钮没反应？还以为App挂了呢，所以此时我们就需要使用LiveData。</p><p>如果<strong>使用DataBinding的情况下，推荐使用LiveData</strong>。</p><p>除了这两种情况，其他情况下使用StateFlow平替LiveData是没什么问题的。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>使用带超时参数的 WhileSubscribed 策略暴露 Flow（可以防抖）<br>望等待 5 秒后没有订阅者则停止数据流，可以使用 whileSubscribed(5000)。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">MyViewModel</span>(...) : <span class="hljs-type">ViewModel</span>() &#123;</span><br><span class="hljs-class">val result = userId.mapLatest &#123; newUserId -&gt;</span><br><span class="hljs-class">repository.observeItem(<span class="hljs-title">newUserId</span>)</span><br><span class="hljs-class">&#125;.stateIn(</span><br><span class="hljs-class"><span class="hljs-title">scope</span> = <span class="hljs-title">viewModelScope</span>, </span><br><span class="hljs-class"><span class="hljs-title">started</span> = <span class="hljs-type">WhileSubscribed(5000)</span>, </span><br><span class="hljs-class"><span class="hljs-title">initialValue</span> = <span class="hljs-type">Result</span>.<span class="hljs-type">Loading</span></span><br><span class="hljs-class">)</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>接收<br>使用 repeatOnLifecycle 来收集数据更新</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-function"><span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span> &#123;<br>viewLifecycleOwner<span class="hljs-selector-class">.lifecycleScope</span><span class="hljs-selector-class">.launch</span> &#123;<br>viewLifecycleOwner<span class="hljs-selector-class">.lifecycle</span><span class="hljs-selector-class">.repeatOnLifecycle</span>(STARTED) &#123;<br>myViewModel<span class="hljs-selector-class">.myUiState</span><span class="hljs-selector-class">.collect</span> &#123; ... &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你的数据流比较复杂，同时不需要获取myFlow.value，需要配置新用户订阅重播无素的个数，或者需要发送重复的值，可以考虑使用SharedFlow</p><p>SharedFlow配置更为灵活，支持配置replay, 缓冲区大小等，StateFlow是SharedFlow的特化版本，replay固定为 1，缓冲区大小默认为 0</p><p><strong>replay</strong> 表示当新的订阅者Collect时，发送几个已经发送过的数据给它，默认为 0，即默认新订阅者不会获取以前的数据</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel 是 Kotlin 中实现跨协程数据传输的数据结构，类似于 Java 中的 BlockQueue 阻塞队列。不同之处在于 BlockQueue 会阻塞线程，而 Channel 是挂起线程</p><p><a href="https://juejin.cn/post/6844904153181847566#heading-0">Google 的建议</a> 是优先使用 Flow 而不是 Channel，主要原因是 Flow 会更自动地关闭数据流，而一旦 Channel 没有正常关闭，则容易造成资源泄漏。此外，Flow 相较于 Channel 提供了更明确的约束和操作符，更灵活。</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.Flow学习</title>
    <link href="/2025/12/323b10089345.html"/>
    <url>/2025/12/323b10089345.html</url>
    
    <content type="html"><![CDATA[<h2 id="LiveData的不足"><a href="#LiveData的不足" class="headerlink" title="LiveData的不足"></a>LiveData的不足</h2><p>LiveData结构简单，但是不够强大，它有以下不足</p><ol><li>LiveData<strong>不支持线程切换</strong>，所有数据转换都将在主线程上完成，有时需要频繁更改线程，面对复杂数据流时处理起来比较麻烦</li><li>LiveData的<strong>操作符不够强大</strong>,在处理复杂数据流时有些捉襟见肘</li><li>LiveData <strong>只能在主线程更新数据</strong>： 只能在主线程 setValue，即使 postValue 内部也是切换到主线程执行；</li><li>LiveData 数据重放问题： <strong>注册新的订阅者，会重新收到 LiveData 存储的数据</strong>，这在有些情况下不符合预期（可以使用自定义的 LiveData 子类 SingleLiveData 或 UnPeekLiveData 解决，此处不展开）；</li><li>LiveData 不防抖： <strong>重复 setValue 相同的值，订阅者会收到多次 onChanged() 回调</strong>（可以使用 distinctUntilChanged() 解决，此处不展开）；</li><li>LiveData <strong>不支持背压： 在数据生产速度 &gt; 数据消费速度时，LiveData 无法正常处理</strong>。比如在子线程大量 postValue 数据但主线程消费跟不上时，中间就会有一部分数据被忽略。</li><li>Flow可以跟LiveData结合使用，LiveData的生命周期<strong>在OnDestory前不会自动取消订阅</strong>，在一些UI相关场景没有问题，可以使用LiveData。Flow则更加强大，<strong>可以在onPause等时机中止上游流，节省资源</strong>。</li></ol><p>Flow,LiveData说白了都是观察者模式，在ViewModel中生产数据，在View中观察数据，Flow生产数据时不用切换线程，LiveData生产数据时会切换到主线程，这就是区别。</p><p>Flow 支持数据重放配置： Flow 的子类 SharedFlow 支持配置重放<br>replay：能够自定义对新订阅者重放数据的配置</p><h2 id="好文章"><a href="#好文章" class="headerlink" title="好文章"></a>好文章</h2><p><a href="https://juejin.cn/post/7034381227025465375#heading-2">Kotlin协程之Flow使用 - 掘金</a></p><p><a href="https://juejin.cn/post/6986265488275800072#comment">官方推荐取代LiveData，有必要吗</a></p><p><a href="https://juejin.cn/post/7077149853876224013#comment">有小伙伴说看不懂 LiveData、Flow、Channel，跟我走</a></p><p><a href="https://mp.weixin.qq.com/s/TRr_isgU7VVVuJ9rOMZUhw">Kotlin Flow响应式编程，基础知识入门-郭霖</a></p><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><p>用法：使用flow {…} 函数创建了一个冷数据流Flow，<strong>通过emit来发射数据，然后通过collect函数来收集这些数据</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">fun <span class="hljs-built_in">test</span>() &#123;<br>lifecycleScope<span class="hljs-selector-class">.launch</span> &#123;<br><span class="hljs-attribute">flow</span> &#123;<br>for (i in <span class="hljs-number">1</span>..<span class="hljs-number">3</span>) &#123;<br><span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">emit</span>(i)<br>&#125;<br>&#125;<span class="hljs-selector-class">.collect</span> &#123; value -&gt; Log<span class="hljs-selector-class">.d</span>(TAG, &quot;value :$&#123;value&#125;&quot;) &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><ul><li>flowOn只影响前面没有自己上下文的操作符。已经有上下文的操作符不受后面flowOn影响。</li><li>不管 flowOn 如何切换线程, collect 始终是运行在调用它的协程调度器上。</li><li><strong>flowOn 下一行开始生效</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun <span class="hljs-built_in">test</span>() &#123;<br>lifecycleScope<span class="hljs-selector-class">.launch</span> &#123;<br><span class="hljs-attribute">flow</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">3</span>) &#123;<br>Log<span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;flow :$&#123; currentCoroutineContext()&#125;&quot;</span>)<br><span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>) <span class="hljs-comment">// io</span><br><span class="hljs-built_in">emit</span>(i)<br>&#125;<br>&#125;<span class="hljs-selector-class">.flowOn</span>(Dispatchers.IO)<br><span class="hljs-selector-class">.map</span> &#123;<br>Log<span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;map :$&#123; currentCoroutineContext()&#125;&quot;</span>)  <span class="hljs-comment">//default</span><br>it<br>&#125;<span class="hljs-selector-class">.flowOn</span>(Dispatchers.Default)<br><span class="hljs-selector-class">.collect</span> &#123; value -&gt;<br>Log<span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;collect:$&#123; currentCoroutineContext()&#125; value :$&#123;value&#125;&quot;</span>) <span class="hljs-comment">//主线程</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h3><p><strong>过度操作符</strong>：又或者叫做流程操作符，用来区分流程执行到某一个阶段。比如：onStart&#x2F;onEach&#x2F;onCompletion。过渡操作符应用于上游流，并返回下游流。这些操作符也是冷操作符，就像流一样。这类操作符本身不是挂起函数。它运行的速度很快，返回新的转换流的定义。<br><del><strong>异常操作符</strong>：用来捕获处理流的异常。比如：catch,onErrorCollect(已废弃，建议用catch)。</del><br><strong>转换操作符</strong>：主要做一些数据转换操作。比如：transform&#x2F;map&#x2F;filter&#x2F;flatMapConcat等<br><strong>限制操作符</strong>：流触及相应限制的时候会将它的执行取消。比如：drop&#x2F;take等<br><strong>末端操作符</strong>：是在流上用于启动流收集挂起函数。&#x3D;&#x3D;collect 是最基础的末端操作符&#x3D;&#x3D;，但是还有另外一些更方便使用的末端操作符。例如：toList、toSet、first、single、reduce、fold等等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">val</span> flow1 = (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).asFlow()<br><span class="hljs-keyword">val</span> flow2 = flowOf(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>lifecycleScope.launch &#123;<br>flow2.zip(flow1) &#123; value1, value2 -&gt;<br><span class="hljs-string">&quot;<span class="hljs-variable">$value1</span> :<span class="hljs-variable">$value2</span>&quot;</span><br>&#125;.collect &#123; value -&gt;<br>Log.d(TAG, <span class="hljs-string">&quot;collect :<span class="hljs-subst">$&#123;value&#125;</span>&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>D&#x2F;carman: collect :1 :one<br>D&#x2F;carman: collect :2 :two<br>D&#x2F;carman: collect :3 :three</p><h3 id="直接使用Flow的局限性"><a href="#直接使用Flow的局限性" class="headerlink" title="直接使用Flow的局限性"></a>直接使用Flow的局限性</h3><p>虽然Flow可以将任意的对象转换成流的形式进行收集后计算结果。但是如果我们是直接使用Flow，它一次流的收集是我们已知需要计算的值，而且它<em>每次收集完以后就会立即销毁</em>。我们也不能在后续的使用中，发射新的值到该流中进行计算。</p><p><strong>为什么要使用 StateFlow 和 ShareFlow？</strong></p><p>[[5.冷流热流]]</p><blockquote><p>我们希望状态的变动都能通知到会有所动作的观察者。<br>StateFlow和ShareFlow也是Flow API的一部分，它们允许数据流以最优方式，发出状态更新并向多个使用方发出值。<br>与使用flow构建器构建的冷数据流不同，StateFlow是热数据流。<br>StateFlow是继承自SharedFlow，我们可以把StateFlow看作为SharedFlow一个更佳具体实现。</p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>有个需求：上游发射数据速度高于下游，如何提升发射效率？</p><p><strong>使用buffer操作符解决背压问题</strong></p><p>buffer原理简单来说：</p><blockquote><p>构造了新的协程执行flow闭包，上游数据会发送到Channel 缓冲区里，发送完成继续发送下一条<br>collect操作符监听缓冲区是否有数据，若有则收集成功<br>原理是基于ChannelFlow</p></blockquote><p>上游生产速度很快，下游消费速度慢，我们只关心最新数据，旧的数据没价值可以丢掉。 使用conflate操作符处理</p><p><a href="https://juejin.cn/post/7226933611265605669">这一次，让Kotlin Flow 操作符真正好用起来 - 掘金</a><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-24-10-45-89661bf174b38feaab7c59c5d577a830-20240124104527-5871ba.png" alt="image.png|1100"></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.Jetpack</title>
    <link href="/2025/12/531fc62857e4.html"/>
    <url>/2025/12/531fc62857e4.html</url>
    
    <content type="html"><![CDATA[<h2 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h2><p><a href="https://github.com/android/sunflower">谷歌demo</a><br>Jetpack 是谷歌提供的一套库、工具和指南，可帮助我们构建高质量的 APP。遵循 Jetpack 可以简化代码。</p><p><strong>Jetpack 核心组件介绍</strong></p><ul><li>LiveData</li><li>ViewModel</li><li>DataBinding</li><li>Lifecycles</li><li>Paging：分页库组件, 能够自动化加载页面初始化和分页 (向前分页, 向后分页)数据。</li><li>CameraX: 强大的基于生命周期的相机控制组件。轻松定制视频录制&amp;拍照功能。</li><li>Navigation</li><li>ViewPager2：支持了垂直，抖音切换</li><li>KTX：<br>   Kotlin 的扩展 API，有：<br>  扩展函数、扩展属性、Lambda、命名参数、参数默认值、协程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">view.viewTreeObserver.addOnPreDrawListener (<br>  object : ViewTreeObserver. OnPreDrawListener &#123;<br>    override fun <span class="hljs-title function_">onPreDraw</span> <span class="hljs-params">()</span>: Boolean &#123;<br>      viewTreeObserver.removeOnPreDrawListener (<span class="hljs-built_in">this</span>)<br>      actionToBeTriggered ()<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;&#125;);<br>    <br>    <br>view. doOnPreDraw &#123; actionToBeTriggered () &#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>fragment-ktxfragment-ktx 提供了一些针对 Fragment 的 Kotlin 扩展方法，<br>比如 ViewModel 的创建：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">        <span class="hljs-keyword">private</span> val homeViewModel : <span class="hljs-function">HomeViewModel <span class="hljs-keyword">by</span> <span class="hljs-title">viewModels</span> ()</span><br></code></pre></td></tr></table></figure><h2 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h2><p>ViewPager2内部使用 RecyclerView 加 LinearLayoutManager 实现竖直滚动。具体来说，ViewPager2对 RecyclerView 进行了次封装，以便更好地满足垂直滚动的需求。</p><p>ViewPager2使用 PagerSnapHelper 来辅助页面切换效果。PagerSnapHelper 通过计算距离和位置，阻止 RecyclerView 的 Fling 事件，使页面滑动到相邻页面。同时，它还提供了 findSnapView 和 findTargetSnapPosition 方法，用于辅助滑动到正确的位置。</p><p>ViewPager2使用 ScrollEventAdapter 将 RecyclerView 的滑动事件转换为其自己的页面滑动事件。这样，当用户在 ViewPager2上滑动时，它可以正确地处理和响应这些事件。</p><p>ViewPager2还使用了 PageTransformerAdapter，它将普通的页面滑动事件转换为特殊事件。这使得 ViewPager2能够支持多种页面切换效果，如淡入淡出、缩放等。</p><h2 id="pading3"><a href="#pading3" class="headerlink" title="pading3"></a>pading3</h2><p>这段代码是基于 Jetpack Compose 的 Paging 3 库编写的，用于创建一个可流式访问的分页数据流。  </p><p>Pager 是 Paging 3 库中的一个类，用于管理分页数据。它接受一个 PagingConfig 对象和一个 pagingSourceFactory 函数作为参数。  </p><p>PagingConfig 对象用于配置分页的行为和属性，其中包括：  </p><p>pageSize：每一页的数据大小。<br>initialLoadSize：初始加载的数据大小。<br>prefetchDistance：在达到列表末尾之前开始预取下一页的距离。<br>pagingSourceFactory 函数用于创建一个实现 PagingSource 接口的数据源。这里的 DailyPagingSource 是自定义的数据源，它接受 bannerList 和 refreshing 参数，并根据这些参数来获取分页数据。  </p><p>通过 flow 属性，我们可以将 Pager 对象转换为一个流，以便进行流式访问。然后使用 cachedIn () 函数，将流缓存在 viewModelScope 中，以便在组件重新合成时保留数据状态。  </p><p>综上所述，这段代码的作用是创建一个可流式访问的分页数据流，并将其缓存在 viewModelScope 中，以便在组件生命周期内保留数据状态。  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">val pageFlow = Pager <span class="hljs-params">(<span class="hljs-attr">config</span> = PagingConfig (<span class="hljs-attr">pageSize</span> = 10,  </span><br><span class="hljs-params">    <span class="hljs-attr">initialLoadSize</span> = 10,  </span><br><span class="hljs-params">    <span class="hljs-attr">prefetchDistance</span> = 1)</span>, pagingSourceFactory = &#123;  <br>    DailyPagingSource <span class="hljs-params">(bannerList, refreshing)</span>  <br>&#125;). flow.cachedIn <span class="hljs-params">(viewModelScope)</span><br></code></pre></td></tr></table></figure><h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p>数据库组件，对 sqlite 做了上层包装，无缝对接 LiveData。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-c472aca420de8048fa0235072178117c-unknown_filename.5-5fe015.png" alt="unknown_filename.5"></p><h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>强大的后台任务, 异步任务管理组件，使用场景：<strong>可延迟的，但需保证执行的后台任务库</strong>（向服务器发送日志、备份图片）。注意<strong>后台任务</strong>不是后台线程，所以该用线程还得用线程，可以和 workmanager 配合使用。它不同版本包装了 JobScheduler（23以后新的）和以前的广播+AlarmManager<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-fcf115459a973918ef2f621808bbfffa-unknown_filename-d6fc98.png" alt="unknown_filename"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-6ec15801a703f518686959a8277a89a7-unknown_filename.1-6cde7f.png" alt="unknown_filename.1"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-f23854ccb9496ddea602f5644b696961-unknown_filename.2-6fa95e.png" alt="unknown_filename.2"><br>后台优化思路<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-493925541a19f0768e86d5c03ef7ffa2-unknown_filename.3-b3aee8.png" alt="unknown_filename.3"></p><p><strong>Navigation</strong><br>APP 导航组件, 能够为 Activity, Fragment, Dialog, FloatWindow 提供导航</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;com. google. android. material. bottomnavigation. BottomNavigationView<br>     android:app:menu=<span class="hljs-string">&quot;@menu/bottom_nav_menu&quot;</span> /&gt;<br>    <br> &lt;fragment<br>     android:app:navGraph=<span class="hljs-string">&quot;@navigation/mobile_navigation&quot;</span> /&gt;  <span class="hljs-comment">//把创建好的 fragment 写上</span><br>     <br>          <span class="hljs-type">NavController</span> <span class="hljs-variable">navController</span> <span class="hljs-operator">=</span> Navigation.findNavController (<span class="hljs-built_in">this</span>, R.id. nav_host_fragment);<br>     NavigationUI.setupActionBarWithNavController (<span class="hljs-built_in">this</span>, navController, appBarConfiguration);<br>     NavigationUI.setupWithNavController (navView, navController);<br>    <br></code></pre></td></tr></table></figure><h2 id="data-binding"><a href="#data-binding" class="headerlink" title="data binding"></a>data binding</h2><p>双向绑定<br>当我们对输入框进行编辑，EditText 的 UI 发生了变更，但是 LiveData 内的数据却没有更新，当我们想要在 ViewModel 层请求登录的 API 接口时，我们就必须要去通过 editText. getText ()才能获取用户输入的密码。<br>于是我们希望，即使是 EditText 的内容发生了变更，但是 LiveData 内的数据也能和 EditText 保持内容的同步——这样我们就不需要让 ViewModel 层持有 View 层的引用，在请求接口时，直接从 LiveData 中取值即可：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-7f7b90a3cb9df735d7671f236e0e8a12-Image.4-14666a.png" alt="Image.4|700"></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.Kotlin 协程总结</title>
    <link href="/2025/12/7c96486907e7.html"/>
    <url>/2025/12/7c96486907e7.html</url>
    
    <content type="html"><![CDATA[<h2 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h2><p>协程就是一个线程。<br>协程原理：<br><a href="https://juejin.cn/post/7212311942613385253#heading-15">https://juejin.cn/post/7212311942613385253#heading-15</a> <br><a href="https://mp.weixin.qq.com/s/KOdJ4IHpa874nyJgOeqG7Q">速通协程，一步到位！</a></p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。<em>协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来</em>，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。其实就是协程自己加了回调</p><p>协程可以理解为协程各自在各自的线程上，且线程不同。其实<em>如果多个协程共用一个线程，其实它们之间也就没有线程并发</em>问题了</p><h2 id="为什么需要-Kotlin-协程"><a href="#为什么需要-Kotlin-协程" class="headerlink" title="为什么需要 Kotlin 协程"></a>为什么需要 Kotlin 协程</h2><p>提供方便的线程操作API，编写逻辑清晰且简洁的线程代码。<br>协程是Google在 Android 上进行异步编程的推荐解决方案。具有如下特点：</p><p>轻量：您可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。</p><p>内存泄漏更少：使用结构化并发机制在一个作用域内执行多项操作。<br>内置取消支持：取消操作会自动在运行中的整个协程层次结构内传播。<br>Jetpack 集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发</p><p>好文章：<a href="https://blog.csdn.net/poorkick/article/details/112131961?spm=1001.2014.3001.5501">https://blog.csdn.net/poorkick/article/details/112131961?spm=1001.2014.3001.5501</a></p><h2 id="什么时候用协程"><a href="#什么时候用协程" class="headerlink" title="什么时候用协程"></a>什么时候用协程</h2><p>当你需要切线程或者指定线程的时候。你要在后台执行任务<br>好处：有回调，像同步的方式写异步代码</p><ol><li>并发实现方便</li><li>没有回调嵌套发生, 代码结构清晰</li></ol><h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p><em>挂起函数在执行完成之后，协程会重新切回它原先的线程</em>。<br>挂起，挂起函数在执行完成之后一个稍后会被自动切回来的线程调度操作。</p><p>代码执行到 suspend 函数的时候会『挂起』，并且这个『挂起』是非阻塞式的，它不会阻塞你当前的线程<br>「切回来」就类似于协程会帮我再 post 一个 Runnable，让我剩下的代码继续回到主线程去执行。<br>这个函数实质上并没有发生挂起，那你这个 <em>suspend 关键字只有一个效果：就是限制这个函数只能在协程里被调用</em>，如果在非协程的代码中调用，就会编译不通过。</p><p>正确用法：给函数加上 suspend 关键字，然后在 withContext 把函数的内容包住就可以了。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Main) &#123;<br>  <span class="hljs-keyword">val</span> image = suspendingGetImage(imageId)  <span class="hljs-comment">// 获取图片</span><br>  avatarIv.setImageBitmap(image)           <span class="hljs-comment">// 显示出来</span><br>&#125;<br>  <br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendingGetImage</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span> = withContext(Dispatchers.IO) &#123; ...&#125;<br></code></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>先用 async 启动任务 → await () 等待结果<br>await() 不会阻塞主线程，只是会挂起协程，当requestData()执行完返回结果后，processData()的逻辑会恢复执行</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">val <span class="hljs-keyword">deferred</span> = <span class="hljs-keyword">async</span>(Dispatchers.IO) &#123;<br>    <span class="hljs-comment">// 子线程执行</span><br>    fetchDataFromNetwork()<br>&#125;<br><br>val result = <span class="hljs-keyword">deferred</span>.<span class="hljs-keyword">await</span>()<br>val posts = postsDeferred.<span class="hljs-keyword">await</span>()<br></code></pre></td></tr></table></figure><h2 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h2><p>这个函数可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动把线程切回去继续执行<br>withContext 会阻塞上下文线程</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val user = <span class="hljs-built_in">withContext</span>(Dispatchers.IO) &#123; <br><span class="hljs-built_in">fetchUser</span>()  <span class="hljs-comment">// 在 IO 线程执行</span><br>&#125;<br><span class="hljs-comment">// 自动切回调用者的线程（比如 Main）</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(user)</span></span><br>val posts = <span class="hljs-built_in">withContext</span>(Dispatchers.IO) &#123; <span class="hljs-built_in">fetchPosts</span>() &#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>await</code>**：多个任务并发执行，时间线里任务是平行的，等到结果再继续 → <strong>高效</strong>。</li><li><strong><code>withContext</code><strong>：切换到指定线程池，但代码是</strong>串行</strong>执行，一个任务完成再跑下一个 → <strong>更适合需要顺序和上下文切换的场景</strong>。</li></ul><h2 id="二种启动"><a href="#二种启动" class="headerlink" title="二种启动"></a>二种启动</h2><ul><li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 可启动新协程而不将结果返回给调用方。任何被视为“一劳永逸”的工作都可以使用 launch 来启动。    </li><li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 会启动一个新的协程，并允许您使用一个名为 await 的暂停函数返回结果。</li></ul><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>在 Kotlin 协程里，<code>launch</code> &#x2F; <code>async</code> 等构建器有一个参数 <code>start</code>，它决定了 <strong>协程的启动模式</strong>。<br>共有 <strong>4 种启动模式</strong>（<code>CoroutineStart</code> 枚举）：</p><p>🔹 1. <strong>DEFAULT</strong>（默认）</p><ul><li><strong>行为</strong>：立即调度协程执行（如果调度器允许的话），但在第一个挂起点之前都是同步执行的。</li><li><strong>特点</strong>：<ul><li>如果协程体里没有挂起点，可能会在当前线程立即执行。</li><li>是最常用的模式。</li></ul></li></ul><p><code>val job = launch(start = CoroutineStart.DEFAULT) &#123;     println(&quot;协程开始执行&quot;) &#125;</code></p><p>🔹 2. <strong>LAZY</strong></p><ul><li><strong>行为</strong>：协程不会自动执行，只有在以下情况才会启动：<ul><li>调用 <code>start()</code>    </li><li>调用 <code>join()</code></li><li>调用 <code>await()</code>（对于 <code>async</code> 协程）</li></ul></li><li><strong>特点</strong>：适合需要“按需执行”的任务。</li></ul><p><code>val job = launch(start = CoroutineStart.LAZY) &#123;     println(&quot;只有调用 job.start()/join() 时才会执行&quot;) &#125;  job.start() // 手动启动</code></p><p>🔹 3. <strong>ATOMIC</strong></p><ul><li><strong>行为</strong>：协程会立即执行，直到遇到第一个挂起点之前 <strong>不可被取消</strong>。</li><li><strong>特点</strong>：保证了协程至少能跑到第一个挂起点，不会在一开始就被取消掉。<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">val</span> <span class="hljs-variable"><span class="hljs-class">job</span></span> = <span class="hljs-function"><span class="hljs-title">launch</span>(<span class="hljs-variable">start</span> = <span class="hljs-variable">CoroutineStart.ATOMIC</span>) &#123;</span><br><span class="hljs-function">    <span class="hljs-title">println</span>(<span class="hljs-string">&quot;前半段一定会执行，直到第一个挂起点&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">delay</span>(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 这里开始才可以被取消</span></span><br><span class="hljs-function">    <span class="hljs-title">println</span>(<span class="hljs-string">&quot;挂起后才可以被取消&quot;</span>)</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>🔹 4. <strong>UNDISPATCHED</strong></p><ul><li><strong>行为</strong>：先在当前线程执行，遇到挂起点后再切换到指定调度器。</li><li><strong>特点</strong>：<ul><li>避免不必要的线程切换。</li><li>常用于启动时需要立即运行的任务。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    println(<span class="hljs-string">&quot;main thread = <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br><br>    launch(Dispatchers.IO, start = CoroutineStart.UNDISPATCHED) &#123;<br>        println(<span class="hljs-string">&quot;协程启动，线程 = <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>        delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 挂起点</span><br>        println(<span class="hljs-string">&quot;恢复后，线程 = <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br><br>    println(<span class="hljs-string">&quot;主线程继续执行&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>main thread &#x3D; main<br>协程启动，线程 &#x3D; main<br>主线程继续执行<br>恢复后，线程 &#x3D; DefaultDispatcher-worker-1</p><p>🔹 总结对比</p><table><thead><tr><th>启动模式</th><th>行为</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>DEFAULT</strong></td><td>立即调度执行（第一个挂起前可能同步执行）</td><td>默认推荐</td></tr><tr><td><strong>LAZY</strong></td><td>只有调用 <code>start()/join()/await()</code> 时才执行</td><td>按需启动</td></tr><tr><td><strong>ATOMIC</strong></td><td>立即执行，直到第一个挂起点前不可取消</td><td>保证起始逻辑一定执行</td></tr><tr><td><strong>UNDISPATCHED</strong></td><td>当前线程立即执行到第一个挂起点，再切换调度器</td><td>避免线程切换开销</td></tr></tbody></table><h2 id="串行并行"><a href="#串行并行" class="headerlink" title="串行并行"></a>串行并行</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-02-15-31-f3a0ffa7b6019db988a83b77f74413a5-20231102153132-1cbeac.png" alt="image.png|600"></p><h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a> 是协程的句柄。使用 launch 或 async 创建的每个协程都会返回一个 Job 实例，<strong>该实例唯一标识协程并管理其生命周期</strong>。您还可以将 Job 传递给 CoroutineScope 以进一步管理其生命周期 (关闭)</p><h2 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a>SupervisorJob</h2><p>用 SupervisorJob 替代 Job，SupervisorJob 与 Job 基本类似，<strong>区别在于不会被子协程的异常所影响</strong>。</p><h3 id="处理协程异常"><a href="#处理协程异常" class="headerlink" title="处理协程异常"></a>处理协程异常</h3><p><a href="https://blog.csdn.net/sunluyao_/article/details/106233575">如何优雅的处理协程的异常？</a><br> 不会影响其他，SupervisorJob 让协程自己处理异常。它不会将子协程的异常向上传播。不会影响到其他子协程，也不会导致父协程的取消，可以在子协程内部使用 <code>try/catch</code> 来捕获异常。</p><p> <strong>Job 会传播异常，所以 catch 代码块不会被调用</strong>。</p><ul><li>当一个子协程抛出异常时，这个异常会<strong>向上传播</strong>到父协程。</li><li>父协程会因此被取消（cancel），然后它再取消所有的其他子协程。<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">launch</span> &#123;<br>    <span class="hljs-variable">supervisorScope</span> &#123;<br>        <span class="hljs-variable">val</span> <span class="hljs-variable">task</span> = <span class="hljs-variable">async</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">methodThatThrowsException</span>()</span><br>        &#125;<br>        <span class="hljs-variable"><span class="hljs-keyword">try</span></span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">updateUI</span>(<span class="hljs-string">&quot;Ok $&#123;task.await()&#125;&quot;</span>)</span><br>        &#125; <span class="hljs-variable">catch</span> (<span class="hljs-variable">e</span>: <span class="hljs-variable">Throwable</span>) &#123;<br>            <span class="hljs-function"><span class="hljs-title">showError</span>(<span class="hljs-string">&quot;Erro! $&#123;e.message&#125;&quot;</span>)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-27-10-33-7bed385d8dfc63049957bd0f6cdab6bf-2023-11-02-15-31-7bed385d8dfc63049957bd0f6cdab6bf-20231102153105-ee1de2-8440a7.png" alt="image.png|800|600"></li></ul><h2 id="Coroutine（协程）"><a href="#Coroutine（协程）" class="headerlink" title="Coroutine（协程）"></a>Coroutine（协程）</h2><p>Coroutine Scope    &#x2F;ˈkəʊruːˌtiːn&#x2F; <br>CoroutineScope是<strong>协程作用域，其内部本身就含有一个CoroutineContext线程，默认是主线程</strong>。</p><p>而CoroutineContext则是在协程作用域中执行的线程切换。<br><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">CoroutineScope</a> 会跟踪它使用 launch 或 async 创建的所有协程。您可以随时调用 scope.cancel() 以取消正在进行的工作（即正在运行的协程）。</p><h3 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelScope<span class="hljs-operator">:</span> CoroutineScope by <span class="hljs-keyword">lazy</span> &#123;<br>        CoroutineScope(SupervisorJob() <span class="hljs-operator">+</span> Dispatchers.Main)<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Dispatchers"><a href="#Dispatchers" class="headerlink" title="Dispatchers"></a>Dispatchers</h3><ul><li>Dispatchers.Main：Android 中的主线程</li><li>Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求</li><li>Dispatchers.Default：适合 CPU 密集型的任务，比如计算</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们要保证不阻塞,同时又要是同步式写法，该怎样做呢？异步回调callback是一种不阻塞的方式，底层也是这种实现方式，只不过外层帮我们封装成现在的同步式写法了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 看起来是同步的代码</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserData</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> user = api.getUser() <span class="hljs-comment">// 看似阻塞的同步调用</span><br>    <span class="hljs-keyword">val</span> posts = api.getPosts(user.id) <span class="hljs-comment">// 另一个看似阻塞的调用</span><br>    showData(user, posts)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 近似底层实现（概念性伪代码）</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserData</span><span class="hljs-params">(callback: <span class="hljs-type">Continuation</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 状态机实现</span><br>    <span class="hljs-keyword">when</span>(callback.label) &#123;<br>        <span class="hljs-number">0</span> -&gt; &#123;<br>            <span class="hljs-comment">// 发起异步请求</span><br>            api.getUserAsync &#123; user -&gt;<br>                <span class="hljs-comment">// 请求完成后恢复协程</span><br>                callback.resume(user)<br>            &#125;<br>            callback.label = <span class="hljs-number">1</span> <span class="hljs-comment">//把 `label` 改为 `1`，表示下次从状态 1 开始执行。</span><br>        &#125;<br>        <span class="hljs-number">1</span> -&gt; &#123;<br>        <span class="hljs-comment">//从上一步拿到 `user`。调用 `api.getPostsAsync(user.id)` 获取用户的帖子。</span><br>            <span class="hljs-keyword">val</span> user = callback.result <span class="hljs-keyword">as</span> User<br>            api.getPostsAsync(user.id) &#123; posts -&gt;<br>                callback.resume(posts)<br>            &#125;<br>            callback.label = <span class="hljs-number">2</span><br>        &#125;<br>        <span class="hljs-number">2</span> -&gt; &#123;<br>            <span class="hljs-keyword">val</span> posts = callback.result <span class="hljs-keyword">as</span> List&lt;Post&gt;<br>            showData(user, posts)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用 <code>suspend</code> 关键字标记</li><li>编译器会将其转换为状态机</li><li>可以在不阻塞线程的情况下暂停执行</li><li>每个挂起点都是一个状态机状态</li></ul><p> callback.resume (posts)<br>​**​<code>resume(value)</code> → 异步任务完成时恢复协程，并传回结果。</p><h2 id="普通接口回调改成协程"><a href="#普通接口回调改成协程" class="headerlink" title="普通接口回调改成协程"></a>普通接口回调改成协程</h2><p>在 await 函数的挂起结束以后，它会调用 continuation 参数的 resumeWith 函数，来恢复执行 await 函数后面的代码。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-02-15-14-da635fd5d098d7b09773a389da90ca66-20231102151441-5b46bf.png" alt="image.png|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-02-15-14-9feb2c5557b78e9b8ca7195a7ee4f857-20231102151456-63b0a3.png" alt="image.png|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-02-15-15-c1d0fb9b56e09b5a885e9a01ad0b2dcb-20231102151508-7ff5af.png" alt="image.png|600"></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.Kotlin分享</title>
    <link href="/2025/12/ba263afa5d3e.html"/>
    <url>/2025/12/ba263afa5d3e.html</url>
    
    <content type="html"><![CDATA[<h2 id="为什么使用-kotlin"><a href="#为什么使用-kotlin" class="headerlink" title="为什么使用 kotlin"></a>为什么使用 kotlin</h2><h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 使用一行代码创建一个包含 getters、 setters、 `equals()`、 `hashCode()`、 `toString()` 以及 `copy()` </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> email: String, <span class="hljs-keyword">val</span> company: String)<br><br><span class="hljs-comment">// 或者使用 lambda 表达式来过滤列表：</span><br><br><span class="hljs-keyword">val</span> positiveNumbers = list.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;<br><br><span class="hljs-comment">// 想要单例？创建一个 object 就可以了：</span><br><span class="hljs-keyword">object</span> ThisIsASingleton &#123;<br>    <span class="hljs-keyword">val</span> companyName: String = <span class="hljs-string">&quot;JetBrains&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>[[Kotlin单例模式]]</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 彻底告别那些烦人的 NullPointerException</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> output: String<br>output = <span class="hljs-literal">null</span>   <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-comment">// Kotlin 可以保护你避免对可空类型进行误操作</span><br><br><span class="hljs-keyword">val</span> name: String? = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 可空类型</span><br>println(name.length())      <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-comment">// 并且如果类型检测正确，编译器会为你做自动类型转换</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateTotal</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Invoice)<br>        obj.calculateTotal()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h3><p>Kotlin 可以使用 JVM 上的任何现有库，100%兼容<br>Java 可直接调用 Kotlin 写的文件</p><h2 id="学习语法"><a href="#学习语法" class="headerlink" title="学习语法"></a>学习语法</h2><p><a href="https://www.kotlincn.net/docs/reference/basic-syntax.html">官网</a></p><p><a href="https://fabiomsr.github.io/from-java-to-kotlin/">和java对比</a></p><p>kmm 跨平台<br><a href="https://book.kotlincn.net/text/multiplatform.html">Kotlin 多平台 · Kotlin 官方文档 中文版</a></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>java 和 kotlin 互相调用时，不可空校验就在 java 上失效了，所以 <em>Java 调用 kotlin 时要判空</em>。<br>或者将类型定义成可空。<br>java 返回 null 给 kotlin 也可以定义定义可空类型，不要定义不可 null 类型</p><p><a href="https://blog.csdn.net/Goals1989/article/details/126964125">https://blog.csdn.net/Goals1989/article/details/126964125</a><br>=&#x3D; ：可以对基本数据类型以及 String 等类型进行内容比较，相当于 Java 中的 equals<br>=&#x3D;&#x3D; ：对引用的内存地址进行比较，相当于 Java 中的 &#x3D;&#x3D;</p><p>Elvis 操作符<br>可以通过 ?: 的操作来简化 if null 的操作</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pony"><br><span class="hljs-comment">// lesson.date 为空时使⽤用默认值</span><br><span class="hljs-meta">val</span> date = lesson.date?: <span class="hljs-string">&quot;⽇日期待定&quot;</span><br><span class="hljs-comment">// lesson.state 为空时提前返回函数</span><br><span class="hljs-meta">val</span> state = lesson.state?: <span class="hljs-keyword">return</span><br><span class="hljs-comment">// lesson.content 为空时抛出异常</span><br><span class="hljs-meta">val</span> content = lesson.content ?: throw <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;content</span><br><span class="hljs-string">expected&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>kotlin 默认不能空，变量类型后面跟? 号定义，表明这是一个可空类型</li><li>?. 代表着如果该类型为空的话就返回 null 不做后续的操作，如果不为空的话才会去访问对应的方法或者属性</li><li>!!. 代表着如果该类型为空的话就抛出 NullPointerException，如果不为空就去访问对应的方法或者属性，所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的 case 了，会像 java 代码一样抛出 NullPointerException。而且代码中一定不用出现下面这种代码，会让代码可读性很差而且，如果有空指针异常，我们也不能马上发现是哪空了：</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 不推荐这样的写法：链式的连续用!!.</span><br><span class="hljs-comment">* */</span><br>val <span class="hljs-keyword">user</span> = <span class="hljs-keyword">User</span>()<br><span class="hljs-keyword">user</span>!!.name!!.subSequence(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)!!.length<br><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">view</span> != <span class="hljs-keyword">null</span>) &#123;    <br>//<span class="hljs-keyword">view</span>.setBackgroundColor(Color.RED)    // 这样写不对，因为在多线程中也可能报错，需要在<span class="hljs-keyword">view</span>后加上？<br><span class="hljs-keyword">view</span>?.setBackgroundColor(Color.RED)  <br></code></pre></td></tr></table></figure><p>使用 <code>lateinit</code> 关键字修饰属性，您可以将属性的初始化推迟到稍后的时间点。这样，您可以声明一个非空的属性，但在构造函数中可以不进行初始化。然后，在稍后的某个时间点，通过对该属性进行赋值操作来完成初始化。搭配 byLazy 使用，否则别使用。</p><p>lateinit 关键字只能用于 <em>var（可变）属性</em>，并且只能用于非空类型。它通常用于在某些情况下延迟初始化属性，例如在依赖注入框架中。</p><p>如果想要带着 index 遍历集合的话：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"> for ((<span class="hljs-keyword">index</span>, <span class="hljs-keyword">element</span>) <span class="hljs-keyword">in</span> newList?.withIndex()!!) &#123;<br>               <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>==<span class="hljs-number">6</span>)&#123;<br>                   <span class="hljs-keyword">break</span><br>               &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>使⽤类名:: class 获取的是 Kotlin 的类型是 KClass<br>使⽤类名:: class. java 获取的是 Java 的类型<br>Kotlin 的顶层⽗父类是 Any ，对应 Java 当中的 Object ，但是比 Object 少了wait ()&#x2F;notify ()等函数</p><p>Unit<br>Kotlin 中的 Unit 对应 Java 中的 void<br>在 Java 中通过 「类名. this」 获取⽬标类引⽤<br>在 Kotlin 中通过「this@类名」获取目标类引⽤</p><p>if 不仅是是条件语句，也是表达式，可以接收参数，返回最后一行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">val mode = <span class="hljs-keyword">if</span> (args.isNotEmpty() &amp;&amp; args[0] == <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>           <span class="hljs-built_in">DEBUG</span><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in"> USER</span><br><span class="hljs-built_in"></span>       &#125;<br>    <br></code></pre></td></tr></table></figure><p><em>先执行 init 代码块逻辑，然后执行伴生对象的初始化块，最后是构造函数</em></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-comment">// 初始化代码块</span><br>        <span class="hljs-comment">// 在构造函数之前执行</span><br>        <span class="hljs-comment">// 初始化实例变量或执行其他实例相关的操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">init</span> &#123;<br>            <span class="hljs-comment">// 伴生对象的初始化代码块</span><br>            <span class="hljs-comment">// 在类的初始化块之后执行</span><br>            <span class="hljs-comment">// 初始化伴生对象的静态变量或执行其他静态操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>() &#123;<br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-comment">// 对象创建时执行的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>在 Kotlin 中，虽然伴生对象的行为类似于某些编程语言中的静态成员，但它们并不是真正的静态。Kotlin 中没有直接的静态成员概念，而是使用伴生对象来模拟类级别的静态成员。<br>虽然伴生对象的初始化块在概念上类似于静态初始化块，<em>但它们不是在类加载时执行的</em>。相反，它们在<em>首次访问伴生对象或通过创建对象时执行</em>。</p><p><code>companion object</code> 被编译为一个名为 <code>Companion</code> 的静态内部类，它包含伴生对象的成员变量和方法。<br>外部类加载后才会加载内部类，类似静态内部单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Companion</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">someProperty</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someFunction</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello from companion object&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Companion</span> <span class="hljs-variable">Companion</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Companion</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>kotlin 中内部类默认为静态内部类<br>[[3.内存泄漏简单问#延伸问题2 kotlin中的内部类与Java有什么不一样吗]]</p><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>在编译时，编译器会将 obj.extensionFunction () 转换为 MyClass.extensionFunction (obj) 的<strong>静态函数</strong>调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">fun <span class="hljs-title function_">toast</span><span class="hljs-params">(message: String, length: Int = Toast.LENGTH_SHORT)</span> &#123;<br>    Toast.makeText(<span class="hljs-built_in">this</span>, message, length).show()<br>&#125;<br><br>toast(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment">//扩展函数,我们就可以在每一个Activity中直接使用toast()函数了。</span><br>fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123;<br>    Toast.makeText(<span class="hljs-built_in">this</span>, message, duration).show()<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="常见操作符"><a href="#常见操作符" class="headerlink" title="常见操作符"></a>常见操作符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> listOf&lt;Int&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br><span class="hljs-type">val</span> <span class="hljs-variable">newList</span> <span class="hljs-operator">=</span> ArrayList&lt;Int&gt;();<br>list.forEach &#123;<br><span class="hljs-type">val</span> <span class="hljs-variable">newElement</span> <span class="hljs-operator">=</span> it * <span class="hljs-number">2</span> + <span class="hljs-number">3</span><br>newList.add(newElement)<br>&#125;<br><span class="hljs-comment">//和上面一样，上面麻烦，map可以对集合进行操作，返回一个修改过得集合</span><br><span class="hljs-type">val</span> <span class="hljs-variable">newList2</span> <span class="hljs-operator">=</span> list.map &#123; it * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> &#125;<br>newList2.forEach(::println)<br>newList2.map(::println)  <span class="hljs-comment">//和上面输出一样，但是又重新add了一个集合，不好,纯粹用于迭代的话会影响性能，实现里面还有一个数组</span><br><br><span class="hljs-comment">//提取开头指定数量或符合指定条件的子集  </span><br>list.takeWhile &#123; it &lt;= <span class="hljs-number">3</span> &#125;.forEach(::println)  <span class="hljs-comment">//小于的去掉</span><br>list.forEach &#123;<br><span class="hljs-keyword">if</span> (it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>println(it)<br>&#125;<br>&#125;<br>list.filter &#123; it.isEvent() &#125;.forEach(::println)<span class="hljs-comment">//过滤    </span><br>   <br></code></pre></td></tr></table></figure><p>take 是从集合中取前几个元素<br>takeLast 是从集合中取后几个元素<br>sortedBy 排序<br>过滤 list，符合过滤条件的就是过滤结果<br>filterNot 把符合条件的过滤掉，剩下的是结果。这个操作和 filter 相反<br>slice, 取集合中的某一部分<br><strong>takeIf</strong>: 避免在某些情况下使用冗长的 if-else 语</p><p>List 防止崩溃取值方式<br>getOrElse () 提供用于计算默认值的函数，如果集合中不存在索引，则返回默认值。<br>getOrNull () 返回 null 作为默认值。<br> joinToString 字符串拼接</p><p>kotlin 自带 copy 方法<br><strong>需要更新 State 时，借助 data class 的 copy 方法可以快捷地拷贝构造一个新实例。</strong></p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数不能直接传递或者赋给某个变量，需要函数类型实例化，有三种方式：</p><p><strong>使用已有声明的可调用引用</strong></p><ol><li>函数引用</li></ol><p><strong>使用函数字面值的代码块</strong><br>2. 匿名函数<br>3. lambda 表达式</p><p><a href="https://juejin.cn/post/6844904116842397710#heading-3">Kotlin 的高阶函数、匿名函数和 Lambda 表达式</a></p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是将函数用作参数或返回值的函数, 还可以把函数赋值给一个变量。</p><p>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -&gt; C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。参数类型列表可以为空，如 () -&gt; A，Unit 返回类型不可省略。</p><p>(Int) -&gt; String</p><p>函数类型表示法可以选择性地包含函数的参数名：(x: Int, y: Int) -&gt; Point。这些名称可用于表明参数的含义。<br>(Button, ClickEvent) -&gt; Unit<br>如需将函数类型指定为可空，请使用圆括号：((Int, Int) -&gt; Int)?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">fun <span class="hljs-title function_">a</span><span class="hljs-params">(funParam: (Int)</span> -&gt; String): String &#123;<br>    <span class="hljs-keyword">return</span> funParam(<span class="hljs-number">1</span>)<br>&#125;<br>    <br>fun <span class="hljs-title function_">b</span><span class="hljs-params">(param: Int)</span>: String &#123;<br>    <span class="hljs-keyword">return</span> param.toString()<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">a(::b)<br><span class="hljs-type">var</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> ::b<br><span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> <span class="hljs-comment">// 调用函数</span><br>d(<span class="hljs-number">1</span>) <span class="hljs-comment">// 实际上会调用 d.invoke(1)</span><br>(::b)(<span class="hljs-number">1</span>) <span class="hljs-comment">// 用对象 :: b 后面加上括号来实现 b() 的等价操作, 实际上会调用 (::b).invoke(1)</span><br>b.invoke(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>函数也是对象，对象是不能加个括号来调用的，但是函数类型的对象可以。为什么？因为这其实是个假的调用，它是 Kotlin 的语法糖，实际上你<em>对一个函数类型的对象加括号、加参数，它真正调用的是这个对象的 invoke ()</em> 函数</p><h3 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号"></a>双冒号</h3><p><strong>:: 创建一个函数引用或者一个类引用</strong></p><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><p>函数不能直接传递或者赋给某个变量，需要函数类型实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">fun <span class="hljs-title function_">isOdd</span><span class="hljs-params">(x: Int)</span> = x % <span class="hljs-number">2</span> != <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们可以很容易地直接调用它（isOdd (5)），但是我们也可以将其作为一个函数类型的值，例如将其传给另一个函数。为此，我们使用 :: 操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">numbers</span> <span class="hljs-operator">=</span> listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>println(numbers.filter( ::isOdd))<br><br></code></pre></td></tr></table></figure><p>这里 :: isOdd 是函数类型 (Int) -&gt; Boolean 的一个值。</p><p>在类外面，如果我们需要使用<em>类的成员函数或扩展函数</em>，它需要是限定的，例如 String:: toCharArray。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">val args: Array&lt;String&gt; = arrayOf(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>args.filter(String::isNotEmpty) <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfPrinter</span> &#123;<br>fun <span class="hljs-title function_">println</span><span class="hljs-params">(any: Any)</span> &#123;<br>kotlin.io.println(any)  <span class="hljs-comment">//重名了可以用包名调用</span><br>&#125;<br>&#125;<br><br><span class="hljs-type">val</span> <span class="hljs-variable">pdfPrinter</span> <span class="hljs-operator">=</span> PdfPrinter()<br>args.forEach(pdfPrinter::println)<br></code></pre></td></tr></table></figure><h4 id="类引用"><a href="#类引用" class="headerlink" title="类引用"></a>类引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> MyClass::class<br></code></pre></td></tr></table></figure><p>该引用是 KClass 类型的值<br>请注意，Kotlin 类引用与 Java 类引用不同。要获得 Java 类引用，请在 KClass 实例上使用 .java 属性。<br>平时写的类，其信息都可以在这个 KClass 来获取</p><h4 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">data <span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaItem</span>(val title: String, val url: String)<br><br><span class="hljs-keyword">var</span> items= mutableListOf&lt;MediaItem&gt;()<br>items<br>    .sortedBy &#123; it.title &#125;<br>    .map &#123; it.url &#125;<br>    .forEach &#123; print(it) &#125;<br><br>items<br>    .sortedBy(MediaItem::title)<br>    .map(MediaItem::url)<br>    .forEach(::println)<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>没有名字的函数<br><strong>要传一个函数类型的参数，或者把一个函数类型的对象赋值给变量，除了用双冒号来拿现成的函数使用</strong>，你还可以直接把这个函数挪过来写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">b</span><span class="hljs-params">(param: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br><span class="hljs-keyword">return</span> param.toString()<br>&#125;<br><span class="hljs-comment">// ❌ 无效语法 (不能给匿名函数命名)</span><br>a(<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">b</span><span class="hljs-params">(param: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>  <span class="hljs-keyword">return</span> param.toString()<br>&#125;);<br><span class="hljs-comment">// ❌ 无效语法 (不能给匿名函数命名)</span><br><span class="hljs-keyword">val</span> d = <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">b</span><span class="hljs-params">(param: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>  <span class="hljs-keyword">return</span> param.toString()<br>&#125;<br><br><span class="hljs-comment">//名字没意义,正确</span><br>a(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(param: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>  <span class="hljs-keyword">return</span> param.toString()<br>&#125;);<br><span class="hljs-keyword">val</span> d = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(param: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>  <span class="hljs-keyword">return</span> param.toString()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你在 Java 里设计一个回调的时候是这么设计的：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnClickListener</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setOnClickListener</span><span class="hljs-params">(OnClickListener listener)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>.listener = listener;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候是这么用的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">view<span class="hljs-selector-class">.setOnClickListener</span>(new OnClickListener() &#123;<br>  <span class="hljs-keyword">@Override</span><br>  void onClick(View v) &#123;<br>    <span class="hljs-built_in">switchToNextPage</span>();<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>kotlin 写法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setOnClickListener</span><span class="hljs-params">(onClick: (<span class="hljs-type">View</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>  <span class="hljs-keyword">this</span>.onClick = onClick<br>&#125;<br>view.setOnClickListener(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span>: <span class="hljs-built_in">Unit</span>) &#123;<br>  switchToNextPage()<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>Lambda 写法：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">view</span>.setOnClickListener(&#123; v: <span class="hljs-keyword">View</span> -&gt;<br>  switchToNextPage()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>简化匿名函数，代码更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">view.setOnClickListener(&#123; v: View -&gt;<br>switchToNextPage()<br>&#125;)<br><br><span class="hljs-comment">//如果 Lambda 是函数的最后一个参数，你可以把 Lambda 写在括号的外面：</span><br>view.setOnClickListener() &#123; v: View -&gt;<br>switchToNextPage()<br>&#125;<br><span class="hljs-comment">//而如果 Lambda 是函数唯一的参数，你还可以直接把括号去了：</span><br>view.setOnClickListener &#123; v: View -&gt;<br>switchToNextPage()<br>&#125;<br><span class="hljs-comment">//另外，如果这个 Lambda 是单参数的，它的这个参数也省略掉不写：</span><br><span class="hljs-comment">//根据上下文推导，根据最后一行代码来推断出返回值类型</span><br>view.setOnClickListener &#123;<br>switchToNextPage()<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda 表达式的完整语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">val sum: (Int, Int) -&gt; Int = &#123; x: Int, y: Int -&gt; x + y &#125;<br><span class="hljs-type">val</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> &#123; x: Int, y: Int -&gt; x + y &#125;<br></code></pre></td></tr></table></figure><p>多参数例子：<br>fold 函数：将所提供的操作应用于集合元素并返回累积的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">items</span> <span class="hljs-operator">=</span> listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// Lambdas 表达式是花括号括起来的代码块。</span><br>items.fold(<span class="hljs-number">0</span>, &#123; <br>    <span class="hljs-comment">// 如果一个 lambda 表达式有参数，前面是参数，后跟“-&gt;”</span><br>    acc: Int, i: Int -&gt; <br>    print(<span class="hljs-string">&quot;acc = $acc, i = $i, &quot;</span>) <br>    <span class="hljs-type">val</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> acc + i<br>    <span class="hljs-title function_">println</span><span class="hljs-params">(<span class="hljs-string">&quot;result = $result&quot;</span>)</span><br>    <span class="hljs-comment">// lambda 表达式中的最后一个表达式是返回值：</span><br>    result<br>&#125;)<br><br><span class="hljs-comment">// lambda 表达式的参数类型是可选的，如果能够推断出来的话：</span><br><span class="hljs-type">val</span> <span class="hljs-variable">joinedToString</span> <span class="hljs-operator">=</span> items.fold(<span class="hljs-string">&quot;Elements:&quot;</span>, &#123; acc, i -&gt; acc + <span class="hljs-string">&quot; &quot;</span> + i &#125;)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>acc = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>, result = <span class="hljs-number">1</span><br>acc = <span class="hljs-number">1</span>, i = <span class="hljs-number">2</span>, result = <span class="hljs-number">3</span><br>acc = <span class="hljs-number">3</span>, i = <span class="hljs-number">3</span>, result = <span class="hljs-number">6</span><br>acc = <span class="hljs-number">6</span>, i = <span class="hljs-number">4</span>, result = <span class="hljs-number">10</span><br>acc = <span class="hljs-number">10</span>, i = <span class="hljs-number">5</span>, result = <span class="hljs-number">15</span><br>joinedToString = Elements: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>实现接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> onVideoStartCallBack: (() -&gt; <span class="hljs-built_in">Unit</span>)? = <span class="hljs-literal">null</span><br><br>onVideoStartCallBack?.invoke()<br><br>videioView.onVideoStartCallBack = &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>函数里实现接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> UploaderListHelper &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startTaskUpload</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>, startCallBack: ((<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)?)</span></span> &#123;<br>        startCallBack.invoke(position)<br>    &#125;<br>&#125;<br><br>UploaderListHelper.startTaskUpload(activity) &#123;<br>    refreshProgress(it)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>闭包就是 Lambda 表达式</strong><br>lambda 表达式，通常是在需要一个函数，但是又不想去命名一个函数的场合下使用，也就是匿名函数。而 Lambda 可以简化匿名函数，使代码更加简洁。也可以将一个代码块赋值给一个变量，在调用方法的时候，可以直接将这个 lambda 表达式当作参数传递进去</p><p>kotlin 接口回调，省了个方法定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> delListener: ((<span class="hljs-built_in">Boolean</span>, DiseaseBean) -&gt; <span class="hljs-built_in">Unit</span>)<br><br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setDelListener</span><span class="hljs-params">(delListener: ((<span class="hljs-type">Boolean</span>, <span class="hljs-type">DiseaseBean</span>) -&gt; <span class="hljs-type">Unit</span>))</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.delListener = delListener<br>    &#125;<br>    <br>    delListener?.invoke(holder.btDel.isChecked, tagBean)<br></code></pre></td></tr></table></figure><p>更简单，传个方法，接口都不用写了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mcDiagnosisType.showLayout &#123;<br>                   <span class="hljs-keyword">if</span>(it)&#123; <span class="hljs-comment">//it 就是boolean</span><br>                       mcDiseaseType.animateClose()<br>                   &#125;<br>               &#125;<br>               <br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showLayout</span><span class="hljs-params">(callBack :(((<span class="hljs-type">Boolean</span>)-&gt;<span class="hljs-type">Unit</span>))?=<span class="hljs-literal">null</span>)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(isShow)&#123;<br>           animateClose()<br>           callBack?.invoke(isShow)<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           animateOpen()<br>           callBack?.invoke(isShow)<br>       &#125;<br>   &#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="作用域函数"><a href="#作用域函数" class="headerlink" title="作用域函数"></a>作用域函数</h3><p>当对一个对象调用这样的函数并提供一个 lambda 表达式时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。共有以下五种：let、run、with、apply 以及 also。</p><p>这些函数基本上做了同样的事情：在一个对象上执行一个代码块。不同的是这个对象在块中如何使用，以及整个表达式的结果是什么。<br>目的：简洁</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sas">    val person = findPerso<span class="hljs-meta">n</span>();<br>//person是可<span class="hljs-keyword">null</span>的，所以需要？<br>printl<span class="hljs-meta">n</span>(person?.age)<br>printl<span class="hljs-meta">n</span>(person?.name)<br>//上面太麻烦，findPerson加了？,所以后面不需要了,减少的判空操作。let可以安全调用<br>findPerso<span class="hljs-meta">n</span>()?.let &#123; person -&gt;<br>person.work()<br>printl<span class="hljs-meta">n</span>(person.age)<br>&#125;<br>//还可以更简洁，person也不用写<br>findPerso<span class="hljs-meta">n</span>()?.apply &#123;<br>work()<br>printl<span class="hljs-meta">n</span>(age)<br>&#125;<br></code></pre></td></tr></table></figure><p>使⽤时可以通过简单的规则作出一些判断</p><h4 id="返回自身"><a href="#返回自身" class="headerlink" title="返回自身"></a><strong>返回自身</strong></h4><p>返回值是它本身<br>从 apply 和 also 中选</p><p>作⽤域中使⽤ this 作为参数选择 apply</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val adam = <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Adam&quot;</span>)<span class="hljs-selector-class">.apply</span> &#123;<br>    age = <span class="hljs-number">32</span><br>    city = <span class="hljs-string">&quot;London&quot;</span>        <br>&#125;<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(adam)</span></span><br></code></pre></td></tr></table></figure><p>作⽤域中使⽤ it 作为参数选择 also</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val numbers = <span class="hljs-built_in">mutableListOf</span>(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>numbers<br>    <span class="hljs-selector-class">.also</span> &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;The list elements before adding new one: $it&quot;</span>) &#125;<br>    <span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;four&quot;</span>)<br></code></pre></td></tr></table></figure><p><em>with 非扩展函数</em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val numbers = <span class="hljs-built_in">mutableListOf</span>(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-function"><span class="hljs-title">with</span><span class="hljs-params">(numbers)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&#x27;with&#x27; is called with argument $this&quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;It contains $size elements&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="不需要返回自身"><a href="#不需要返回自身" class="headerlink" title="不需要返回自身"></a><strong>不需要返回自身</strong></h4><p>从 run 和 let 中选择</p><p>作用域中使用 this 作为参数，选择 run<br>作用域中使用 it 作为参数，选择 let, 适合配合空判断的时候</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val service = <span class="hljs-built_in">MultiportService</span>(<span class="hljs-string">&quot;https://example.kotlinlang.org&quot;</span>, <span class="hljs-number">80</span>)<br><br>val result = service<span class="hljs-selector-class">.run</span> &#123;<br>    port = <span class="hljs-number">8080</span><br>    <span class="hljs-built_in">query</span>(<span class="hljs-built_in">prepareRequest</span>() + <span class="hljs-string">&quot; to port $port&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 同样的代码如果用 let() 函数来写:</span><br>val letResult = service<span class="hljs-selector-class">.let</span> &#123;<br>    it<span class="hljs-selector-class">.port</span> = <span class="hljs-number">8080</span><br>    it<span class="hljs-selector-class">.query</span>(it<span class="hljs-selector-class">.prepareRequest</span>() + <span class="hljs-string">&quot; to port $&#123;it.port&#125;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;it 作为参数的好处&#x3D;&#x3D;<br>let 允许我们自定义参数名字，使可读性更强，如果倾向可读性可以选择 T.let</p><h3 id="委托机制"><a href="#委托机制" class="headerlink" title="委托机制"></a>委托机制</h3><p>Kotlin 中的委托是一种抽象的设计模式，允许将工作委托给另一个对象处理。在 Kotlin 中委托分为两种类型: 类委托和属性委托</p><h4 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h4><p>类委托的核心思想在于将一个类的具体实现委托给另一个类完成。通过使用类委托，可以将某些特定行为委托给其他类处理，从而实现代码的解耦和重用。<br>类委托的使用还要创建实现了特定接口或继承了抽象类的类，并将其作为委托对象传递给需要处理的对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 约束类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGamePlayer</span> &#123;<br>    <span class="hljs-comment">// 打排位赛</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rank</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">// 升级</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 委托对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegateGamePlayer</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> player: IGamePlayer): IGamePlayer <span class="hljs-keyword">by</span> player<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Client 场景测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> realGamePlayer = RealGamePlayer(<span class="hljs-string">&quot;张三&quot;</span>)<br>    <span class="hljs-keyword">val</span> delegateGamePlayer = DelegateGamePlayer(realGamePlayer)<br>    delegateGamePlayer.rank()<br>    delegateGamePlayer.upgrade()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h4><p>属性委托则是将属性的 getter 和 setter 方法逻辑委托给另一个类实现。属性委托允许将属性的读取和设置逻辑放在另一个地方处理，比如更改属性名称或延迟初始化等场景。通过使用属性委托，可以<em>将属性的逻辑封装在一个类中并在需要时将其传递给其他对象使用</em></p><p><a href="https://juejin.cn/post/6844904038589267982">一文彻底搞懂Kotlin中的委托 - 掘金</a></p><p><code>val</code> 属性实现 <code>ReadOnlyProperty</code>，<code>var</code> 属性实现 <code>ReadOnlyProperty</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// val 属性委托实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate1</span>: <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">Any,String</span>&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;通过实现ReadOnlyProperty实现，name:<span class="hljs-subst">$&#123;property.name&#125;</span>&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// var 属性委托实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate2</span>: <span class="hljs-type">ReadWriteProperty</span>&lt;<span class="hljs-type">Any,Int</span>&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">20</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Int</span>)</span></span> &#123;<br>       println(<span class="hljs-string">&quot;委托属性为： <span class="hljs-subst">$&#123;property.name&#125;</span> 委托值为： <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 属性委托</span><br>    <span class="hljs-keyword">val</span> d1: String <span class="hljs-keyword">by</span> Delegate1()<br>    <span class="hljs-keyword">var</span> d2: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> Delegate2()<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><h4 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h4><p>高阶函数实现的原理：<strong>函数类型其实是生成了一个对象</strong></p><p>使用 inline 能避免函数的 lambda <em>形参额外创建 Function 对像</em></p><ul><li>kotlin 源码里使用了很多的内联函数，它的作用简单来说就是方便进行类型推导，能具体化类型参数。</li><li>被 inline 标记的函数就是内联函数, 其原理就是:<em>在编译时期, 把调用这个函数的地方用这个函数的方法体进行替换</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">inline fun &lt;T&gt; method(lock: Lock, body: () -&gt; T): T &#123;<br>        lock.lock()<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> body()<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock()<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p>method (lock, {“我是 body 方法体”})&#x2F;&#x2F;lock 是一个 Lock 对象</p><p>其实上面调用的方法, 在编译时期就会把下面的内容替换到调用该方法的地方, 这样就会减少方法压栈, 出栈, 进而减少资源消耗;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>()<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是body方法体&quot;</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">lock</span>.unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说 inline 关键字实际上<em>增加了代码量，但是提升了性能</em>，而且增加的代码量是在编译期执行的，对程序可读性不会造成影响。</p><p><strong>inline 的坏处</strong>：</p><ol><li>对于一个 public 的 inline 方法，他不可以引用类的私有变量。</li><li>inline 关键字对于 lambda 的处理有的时候不是我们想要的， inline 函数的形参 lambda <em>不能有 return 语句，避免 lambda 中的 return 影响外部程序流程</em></li></ol><p>noinline 场景：当需要将函数参数作为对象返回值的时候，如果不关闭内联，就无法使用 return 返回。action2<br>![[Pasted image 20250901204508.png]]</p><p><strong>总结</strong></p><ul><li>使用 inline，内联函数到调用的地方，能减少函数调用造成的额外开销，在循环中尤其有效</li><li>使用 inline 能避免函数的 lambda 形参额外创建 Function 对象，修饰函数</li><li>使用 <em>noinline 可以拒绝形参 lambda 内联</em>，修饰变量</li><li>使用 crossinline <em>显示声明</em>，修饰变量</li></ul><p><code>inline</code> 关键字的作用，是把 <code>inline</code> 方法以及方法中的 <code>lambda</code> 参数在编译期间复制到调用方，进而<em>减少函数调用以及对象生成</em>。对于有时候我们不想让 <code>inline</code> 关键字对 <code>lambda</code> 参数产生影响，可以使用 <code>noline</code> 关键字。如果想 <code>lambda</code> 也被 <code>inline</code>（把函数到调用方），但是不影响调用方的控制流程，那么就要是用 <code>crossinline</code>。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5koin_hilt.resources/2023/09/15/18-51-47-e8036b7da53085f062f74f6d922c00b9-unknown_filename.3-e89592.png" alt="unknown_filename.3"></p><p><strong>Lambda 表达式不允许使用 return，除非这个 Lambda 表达式是内联函数的参数。</strong></p><p>(Function1）null. INSTANCE，是由于反编译器工具在找不到等效的 Java 类时的显示的结果。</p><p><a href="https://www.jianshu.com/p/1d7374349a00">Kotlin的inline noinline crossinline笔记 - 简书</a></p><p><a href="https://juejin.cn/post/6844903838269308941#comment">Kotlin inline noinline crossinline 解答 - 掘金</a></p><h4 id="Reified"><a href="#Reified" class="headerlink" title="Reified"></a>Reified</h4><ul><li>reified，字面意思：具体化，其实就是<strong>具体化泛型</strong>。运行时保留泛型类型信息，让泛型编程变得更加灵活和安全</li><li>由于 Java 中的泛型存在类型擦除的情况，任何在运行时需要知道泛型确切类型信息的操作都没法用了。比如你不能检查一个对象是否为泛型类型 T 的实例，所以需要反射。</li><li>主要还是有内联函数 inline, 才使得 kotlin 能够直接通过泛型就能拿到泛型的类型，只有内联函数的类型参数可以具体化。<br>[[7.泛型#泛型擦除]]</li></ul><p>在 Java 中，你不能做这样的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>    Class&lt;T&gt; clazz = T.class; <span class="hljs-comment">// 编译错误，因为 T 在运行时被擦除了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Kotlin 中，如果没有 <code>reified</code>，你也不能直接这样做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> clazz = T::<span class="hljs-keyword">class</span>.java <span class="hljs-comment">// 错误: 不能使用 T 作为具体化的类型参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过将函数声明为 <code>inline</code> 并在泛型类型参数前加上 <code>reified</code>，就可以在函数内部访问泛型类型的具体信息：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> clazz = T::<span class="hljs-keyword">class</span>.java<br>    println(clazz.name)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例子</strong></p><p>定义实现一个扩展函数启动 Activity，一般都需要传 Class&lt; <code>T</code> &gt; 参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Function</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Activity&gt;</span> Activity.<span class="hljs-title">startActivity</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, clazz: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    startActivity(Intent(context, clazz))<br>&#125;<br><br><span class="hljs-comment">// Caller</span><br>startActivity(context, NewActivity::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure><p>使用 reified，通过添加类型传递简化泛型参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Function</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Activity&gt;</span> Activity.<span class="hljs-title">startActivity</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    startActivity(Intent(context, T::<span class="hljs-keyword">class</span>.java))<br>&#125;<br><br><span class="hljs-comment">// Caller</span><br>startActivity&lt;NewActivity&gt;(context)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7-上传Maven</title>
    <link href="/2025/12/7c997ff43b8f.html"/>
    <url>/2025/12/7c997ff43b8f.html</url>
    
    <content type="html"><![CDATA[<h2 id="flutter-aar-上传-Maven"><a href="#flutter-aar-上传-Maven" class="headerlink" title="flutter aar 上传 Maven"></a>flutter aar 上传 Maven</h2><p>通过脚本支持了 Jenkins 上自动打包 Flutter，上传 Maven，修改版本号，一键自动化打包。</p><h3 id="上传-Maven"><a href="#上传-Maven" class="headerlink" title="上传 Maven"></a>上传 Maven</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">diff --git a/packages/flutter_tools/gradle/aar_init_script.gradle b/packages/flutter_tools/gradle/aar_init_script.gradle<br>index cc2bbe6f98..242ac61fb0 <span class="hljs-number">100644</span><br>--- a/packages/flutter_tools/gradle/aar_init_script.gradle<br>+++ b/packages/flutter_tools/gradle/aar_init_script.gradle<br>@@ -<span class="hljs-number">37</span>,<span class="hljs-number">7</span> +<span class="hljs-number">37</span>,<span class="hljs-number">10</span> @@ <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureProject</span><span class="hljs-params">(Project project, String outputDir)</span> &#123;<br>     project.uploadArchives &#123;<br>         repositories &#123;<br>             mavenDeployer &#123;<br>-                repository(url: <span class="hljs-string">&quot;file://$&#123;outputDir&#125;/outputs/repo&quot;</span>)<br>+                <span class="hljs-comment">//repository(url: &quot;file://$&#123;outputDir&#125;/outputs/repo&quot;)</span><br>+                repository(url: <span class="hljs-string">&quot;http://10.2.0.210:8081/repository/maven-releases/&quot;</span>) &#123;<br>+                    authentication(userName: <span class="hljs-string">&quot;a&quot;</span>, password: <span class="hljs-string">&quot;b&quot;</span>)<br>+                &#125;<br>             &#125;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/62284466/how-to-build-and-maven-publish-a-flutter-aar">https://stackoverflow.com/questions/62284466/how-to-build-and-maven-publish-a-flutter-aar</a></p><h3 id="自定义环境修改源码"><a href="#自定义环境修改源码" class="headerlink" title="自定义环境修改源码"></a>自定义环境修改源码</h3><p>要不然编译不过Flutter 238行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">project. android. buildTypes &#123;<br><span class="hljs-comment">// Add profile build type.</span><br>profile &#123;<br>initWith debug<br><span class="hljs-title function_">if</span> <span class="hljs-params">(it.hasProperty (<span class="hljs-string">&quot;matchingFallbacks&quot;</span>)</span>) &#123;<br>matchingFallbacks \= \[<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;release&quot;</span>\]<br>&#125;<br>&#125;<br>envTest &#123;<br>initWith debug<br>&#125;<br>pre &#123;<br>initWith debug<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jinkens上传脚本"><a href="#jinkens上传脚本" class="headerlink" title="jinkens上传脚本"></a>jinkens上传脚本</h3><p><strong>在根 build. gradle</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">apply from: <span class="hljs-string">&#x27;buildscript/update_module_properties.gradle&#x27;</span>  <br>  <br>buildscript &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>update_module_properties. gradle</strong><br>获取 jinken 构建号当做 Flutter 版本号，然后 build aar，上面的 aar_init_script 会上传到 Maven，Flutter 上传完后 cd 到项目的目录下，修改对应的依赖的 Flutter 版本，然后 push 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java">task update_module_version &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;执行  update_module_version task&#x27;</span><br>        <span class="hljs-type">def</span> <span class="hljs-variable">BUILD_NUMBER</span> <span class="hljs-operator">=</span> System.getenv(<span class="hljs-string">&#x27;BUILD_NUMBER&#x27;</span>)<br><span class="hljs-comment">//        BUILD_NUMBER = &quot;56&quot;</span><br>        <span class="hljs-type">def</span> <span class="hljs-variable">array1</span> <span class="hljs-operator">=</span> BUILD_NUMBER.toCharArray()<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">flutterVersion</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != array1.length - <span class="hljs-number">1</span>) &#123;<br>                flutterVersion.append(array1[i].toString() + <span class="hljs-string">&#x27;.&#x27;</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                flutterVersion.append(array1[i])<br>            &#125;<br>        &#125;<br>        println <span class="hljs-string">&#x27;flutterVersion :&#x27;</span> + flutterVersion.toString()<br><br>        exec &#123;<br>            workingDir<br>            commandLine <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&quot;echo flutter uploading...&quot;</span><br>            commandLine <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;flutter pub get&#x27;</span><br>            commandLine <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&quot;flutter build aar --build-number $&#123;flutterVersion.toString()&#125;  --no-debug --no-profile&quot;</span><br>        &#125;<br><br><span class="hljs-comment">//        return</span><br><br>        <span class="hljs-type">def</span> <span class="hljs-variable">branch</span> <span class="hljs-operator">=</span> System.getenv(<span class="hljs-string">&#x27;PROPERTIES_BRANCH&#x27;</span>)<span class="hljs-comment">//配置仓库分支</span><br><br>        <span class="hljs-type">def</span> <span class="hljs-variable">moduleName</span> <span class="hljs-operator">=</span> System.getenv(<span class="hljs-string">&quot;moduleName&quot;</span>)<br>        <span class="hljs-keyword">if</span> (moduleName == <span class="hljs-literal">null</span>) &#123;<br>            moduleName = System.getenv(<span class="hljs-string">&quot;JOB_BASE_NAME&quot;</span>)<br>        &#125;<br>        <span class="hljs-type">def</span> <span class="hljs-variable">aarVersion</span> <span class="hljs-operator">=</span> System.getenv(<span class="hljs-string">&quot;BUILD_VERSION&quot;</span>)<br>        <span class="hljs-keyword">if</span> (System.getenv(<span class="hljs-string">&#x27;isUserBuildVersion&#x27;</span>) == <span class="hljs-literal">false</span> || System.getenv(<span class="hljs-string">&#x27;isUserBuildVersion&#x27;</span>) == <span class="hljs-string">&#x27;false&#x27;</span>) &#123;<br>            aarVersion = System.getProperty(<span class="hljs-string">&quot;buildVersion&quot;</span>)<br>        &#125;<br>        <span class="hljs-type">def</span> <span class="hljs-variable">dirpath</span> <span class="hljs-operator">=</span> rootDir.parentFile.path + <span class="hljs-string">&#x27;/bookproperties/&#x27;</span><br>        <span class="hljs-type">def</span> <span class="hljs-variable">workingDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dirpath)<br>        <span class="hljs-type">def</span> <span class="hljs-variable">local_branch</span> <span class="hljs-operator">=</span> branch<br>        <span class="hljs-type">def</span> <span class="hljs-variable">origin_branch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;origin/&quot;</span> + branch<br>        println <span class="hljs-string">&quot;pwd&quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).text<br>        <span class="hljs-type">def</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;git branch&quot;</span><br>        <span class="hljs-type">def</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> command.execute()<br>        proc.waitFor()<br>        <span class="hljs-keyword">if</span> (proc.exitValue() == <span class="hljs-number">0</span>) &#123;<br>            def branches=  proc.in.text<br>            println <span class="hljs-string">&quot;当前所在分支：$branches&quot;</span><br>        &#125;<br>        println <span class="hljs-string">&quot;git checkout -b $local_branch $origin_branch&quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).errorStream.text<br>        println <span class="hljs-string">&quot;git checkout  $local_branch &quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).errorStream.text<br>        println <span class="hljs-string">&quot;git pull&quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).errorStream.text<br>        println <span class="hljs-string">&quot; end pull ----------------&quot;</span><br><br>        <span class="hljs-type">def</span> <span class="hljs-variable">filepath</span> <span class="hljs-operator">=</span> rootDir.parentFile.path + <span class="hljs-string">&#x27;/bookproperties/bookproperties/modules.gradle&#x27;</span><br>        <span class="hljs-type">def</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filepath)<br>        <span class="hljs-type">def</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> file.getText()<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentmodle</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span><br><br>        <span class="hljs-type">def</span> <span class="hljs-variable">originalText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">newText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>()<br>        text.eachLine &#123;<br>            <span class="hljs-keyword">if</span> (it.contains(<span class="hljs-string">&#x27;business_configure&#x27;</span>) || it.contains(<span class="hljs-string">&#x27;business_base_configure&#x27;</span>) || it.contains(<span class="hljs-string">&#x27;xeslibraries_configure&#x27;</span>) || it.contains(<span class="hljs-string">&#x27;thirdlibraries_configure&#x27;</span>)) &#123;<br>                currentmodle++<br>            &#125;<br>            <span class="hljs-comment">//flutteraar :&#x27;com.example.app_ta_flutter:flutter_release:1.0@aar&#x27;,</span><br>            <span class="hljs-keyword">if</span> (it.contains(<span class="hljs-string">&#x27;flutteraar&#x27;</span>)) &#123;<br>                originalText = it<br>                String[] splits = it.split(<span class="hljs-string">&quot;:&quot;</span>)<br>                <span class="hljs-keyword">if</span> (splits.length &gt;= <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> def content in splits) &#123;<br>                        <span class="hljs-keyword">if</span> (content.contains(<span class="hljs-string">&quot;@&quot;</span>)) &#123;<br>                            String[] splits1 = content.split(<span class="hljs-string">&quot;@&quot;</span>)<br>                            splits1[<span class="hljs-number">0</span>] = flutterVersion.toString()<br>                            newText.append(splits1[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;@&quot;</span>)<br>                            newText.append(splits1[<span class="hljs-number">1</span>])<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            newText.append(content + <span class="hljs-string">&quot;:&quot;</span>)<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                println <span class="hljs-string">&quot;需要替换的aar的包名为：&quot;</span> + it<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (text.contains(originalText)) &#123;  <span class="hljs-comment">//将flutter那一行替换了</span><br>            text = text.replaceAll(originalText, newText.toString())<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>()<br>        buffer.append(text)<br>        println(<span class="hljs-string">&quot;新的moudles---&quot;</span> + buffer.toString())<br>        file.write(buffer.toString())<br><br>        <span class="hljs-type">def</span> <span class="hljs-variable">subVcode</span> <span class="hljs-operator">=</span> System.getenv(<span class="hljs-string">&#x27;BUILD_TAG&#x27;</span>)<br>        println <span class="hljs-string">&quot;git add . &quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).errorStream.text<br>        println <span class="hljs-string">&quot;git commit -m &#x27;updateversion--$&#123;subVcode&#125;&#x27; &quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).errorStream.text<br>        println <span class="hljs-string">&quot;git push &quot;</span>.execute(<span class="hljs-literal">null</span>, workingDir).errorStream.text<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>原生的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">flutteraar:<span class="hljs-string">&#x27;com.bundle:flutter_release:3.5@aar&#x27;</span>,<br>flutterv7:<span class="hljs-string">&#x27;io.flutter:armeabi_v7a_release:1.0.0-e85ea0e79c6d894c120cda4ee8ee10fe6745e187&#x27;</span>,  <br>flutterembedding:<span class="hljs-string">&#x27;io.flutter:flutter_embedding_release:1.0.0-e85ea0e79c6d894c120cda4ee8ee10fe6745e187&#x27;</span>,  <br>flutterv8:<span class="hljs-string">&#x27;io.flutter:arm64_v8a_release:1.0.0-e85ea0e79c6d894c120cda4ee8ee10fe6745e187&#x27;</span>,<br></code></pre></td></tr></table></figure><ol><li>flutteraar: 这是 Flutter 的 AAR（Android Archive）库文件，用于在 Android 项目中引入 Flutter 框架。它包含了 Flutter 运行时和相应的依赖项，允许在 Flutter 和 Android 之间进行交互和集成。</li><li>flutterv7: 这是 Flutter 的 armeabi-v7a 架构下的发布版本库。Flutter 支持多种 CPU 架构，armeabi-v7a 是面向 ARM 架构的 32 位设备，这个库提供了在 armeabi-v7a 架构设备上运行 Flutter 应用所需的二进制文件。</li><li>flutterembedding: 这是 Flutter 的嵌入式库，用于在原生 Android 或 iOS 项目中嵌入 Flutter 模块。它提供了与 Flutter 交互的接口和工具，允许在原生应用程序中使用 Flutter 模块来实现跨平台功能。</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6-和原生通信</title>
    <link href="/2025/12/68fd6e9693db.html"/>
    <url>/2025/12/68fd6e9693db.html</url>
    
    <content type="html"><![CDATA[<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p><strong>Flutter 是如何与原生 Android、iOS 进行通信的？</strong><br>Flutter 通过 PlatformChannel 与原生进行交互，其中 PlatformChannel 分为三种：<br>BasicMessageChannel ：用于传递字符串和半结构化的信息。<br>MethodChannel ：用于传递方法调用（method invocation）。<br>EventChannel : 用于数据流（event streams）的通信。</p><p><a href="https://flutter.cn/docs/development/add-to-app">将 Flutter 集成到现有应用</a><br><a href="https://learnku.com/articles/32448">Flutter 与 Android 的相互通信</a></p><p>可以从 Native 层调用 flutter 层的 dart 代码，也可以在 flutter 层调用 Native 的代码，而作为通讯桥梁就是 MethodChannel，这个类在初始化的时候需要注册一个渠道值。<br>这个值必须是唯一的，并且在使用到的 Native 层和 Flutter 层互相对应。</p><h2 id="flutter-调用-Android"><a href="#flutter-调用-Android" class="headerlink" title="flutter 调用 Android"></a><strong>flutter 调用 Android</strong></h2><p>注册</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> nativeChannel =<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">MethodChannel</span><span class="hljs-params">(<span class="hljs-string">&#x27;com.example.flutter/native&#x27;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>flutter</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; result = &#123;<span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;我从Flutter页面回来了&#x27;</span>&#125;;<br>              nativeChannel.invokeMethod(<span class="hljs-string">&#x27;goBackWithResult&#x27;</span>, result);<br></code></pre></td></tr></table></figure><p>Android</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript">MethodChannel nativeChannel = <span class="hljs-keyword">new</span> MethodChannel(flutterEngine.getDartExecutor(), CHANNEL_NATIVE);<br>       nativeChannel.setMethodCallHandler<span class="hljs-function"><span class="hljs-params">((methodCall, result) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">switch</span> (methodCall.method) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-regexp">//回调</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">           case &quot;goBackWithResult&quot;:</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                   //</span> 返回上一页，携带数据</span></span><br><span class="hljs-params"><span class="hljs-function">                   ActivityManager.getInstance().finishActivity(FlutterActivity.<span class="hljs-keyword">class</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                   Toast.makeText(this, (<span class="hljs-built_in">String</span>) methodCall.argument(<span class="hljs-string">&quot;message&quot;</span>), Toast.LENGTH_SHORT).show();</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">break</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;getSendParams&quot;</span>:</span></span><br><span class="hljs-params"><span class="hljs-function">                   result.success(getSendParams());</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">break</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">default</span>:</span></span><br><span class="hljs-params"><span class="hljs-function">                   result.notImplemented();</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">break</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">           &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">       &#125;)</span>;</span><br><span class="hljs-function">    </span><br></code></pre></td></tr></table></figure><p>异步</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Future <span class="hljs-title">getSendParams</span>() <span class="hljs-keyword">async</span></span> &#123;<br>   String <span class="hljs-keyword">params</span> = <span class="hljs-keyword">await</span> _SendFeedBackState.nativeChannel<br>       .invokeMethod(<span class="hljs-string">&#x27;getSendParams&#x27;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>   print(<span class="hljs-string">&quot;getSendParams：&quot;</span> + <span class="hljs-keyword">params</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="Android-调用-flutter"><a href="#Android-调用-flutter" class="headerlink" title="Android 调用 flutter"></a><strong>Android 调用 flutter</strong></h2><p>Android</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>result.put(<span class="hljs-string">&quot;message&quot;</span>, message);<br><span class="hljs-comment">// 创建MethodChannel</span><br>MethodChannel flutterChannel = <span class="hljs-keyword">new</span> MethodChannel(flutterEngine.getDartExecutor(), CHANNEL_FLUTTER);<br>flutterChannel.invokeMethod(<span class="hljs-string">&quot;onActivityResult&quot;</span>, result);<br></code></pre></td></tr></table></figure><p>flutter<br>setMethodCallHandler</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@override<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span>()</span> &#123;<br>  super.initState();<br>  <span class="hljs-function">Future&lt;<span class="hljs-built_in">dynamic</span>&gt; <span class="hljs-title">handler</span>(<span class="hljs-params">MethodCall call</span>) <span class="hljs-keyword">async</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> (call.method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onActivityResult&#x27;</span>:<br>        Fluttertoast.showToast(<br>          msg: call.arguments[<span class="hljs-string">&#x27;message&#x27;</span>],<br>          toastLength: Toast.LENGTH_SHORT,<br>        );<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;goBack&#x27;</span>:<br>        <span class="hljs-comment">// 返回上一页</span><br>        <span class="hljs-keyword">if</span> (Navigator.canPop(context)) &#123;<br>          Navigator.of(context).pop();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          nativeChannel.invokeMethod(<span class="hljs-string">&#x27;goBack&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>    <br>  flutterChannel.setMethodCallHandler(handler);<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h1 id="Flutter-页面放原生-view"><a href="#Flutter-页面放原生-view" class="headerlink" title="Flutter 页面放原生 view"></a>Flutter 页面放原生 view</h1><p> 将 Native UI 嵌入到 Flutter 中去使用, 需要准备四步</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>自定义 view<br>FVideoView , 要嵌入到 Flutter 的 iOS view 或者 Android view</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FVideoView</span> <span class="hljs-meta">@JvmOverloads</span> constructor(<br>    context: Context? = ContextManager.getContext(),<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: Int = <span class="hljs-number">0</span><br>) : LinearLayout(context!!, attrs, defStyleAttr), DefaultLifecycleObserver &#123;<br>    <span class="hljs-keyword">var</span> flVideoView: FrameLayout? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">val</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.javaClass.simpleName<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentVideoData: BookVideoLiteManager.VideoPlayerData? = <span class="hljs-literal">null</span><br><br><br>    init &#123;<br>        BookLogger.i(TAG, <span class="hljs-string">&quot;FVideoView--init&quot;</span>)<br>        LayoutInflater.from(context).inflate(R.layout.flutter_video_view, <span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">// 找到子视图</span><br>        flVideoView = findViewById(R.id.flVideoView)<br><br>        <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span> &amp;&amp; context is FragmentActivity) &#123;<br>            context.lifecycle.addObserver(<span class="hljs-built_in">this</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">initCurrentVideoData</span><span class="hljs-params">(fVideoPlayBean: FVideoPlayBean)</span> &#123;<br>        fVideoPlayBean.run &#123;<br>            <span class="hljs-type">val</span> <span class="hljs-variable">module</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> == <span class="hljs-number">1</span>) &#123;<br>                BookVpDataSource.Module.VIP_MODULE<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BookVpDataSource.Module.STUDY_MODULE<br>            &#125;<br>            <span class="hljs-type">val</span> <span class="hljs-variable">playerType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> (playerType == <span class="hljs-number">1</span>) &#123;<br>                BookVpPlayerTypeMode.ALI_YUN<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BookVpPlayerTypeMode.PS_MEDIA<br>            &#125;<br>            currentVideoData = BookVideoLiteManager<br>                .VideoPlayerData(WeakReference(flVideoView))<br>                .setModule(<span class="hljs-keyword">module</span>)<br>                .setBusinessType(businessType ?: <span class="hljs-number">0</span>)<br>                .setUrlType(BookVpDataSource.URL_TYPE_FID)<br>                .setPlayerType(playerType)<br>                .setFid(fid ?: <span class="hljs-string">&quot;&quot;</span>)<br>                .setScaleMode(BookVpScaleMode.SCALE_ASPECT_FIT)<br>                .setBusinessSensorMap(mutableMapOf())<br>                .setIsVideoNoWifiPlay(<span class="hljs-literal">true</span>)<br>        &#125;<br>    &#125;<br><br>    fun <span class="hljs-title function_">startPlay</span><span class="hljs-params">(json: String?)</span> &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">fVideoPlayBean</span> <span class="hljs-operator">=</span> GsonUtil.getInstance().fromJson(json, FVideoPlayBean::class.java)<br>        initCurrentVideoData(fVideoPlayBean)<br>        resumePlay()<br>    &#125;<br><br>    fun <span class="hljs-title function_">pausePlay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(currentVideoData!=<span class="hljs-literal">null</span>)&#123;<br>            BookVideoLiteManager.getInstance().videoPlayerPause(currentVideoData)<br>        &#125;<br>    &#125;<br><br>    fun <span class="hljs-title function_">resumePlay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentVideoData != <span class="hljs-literal">null</span>) &#123;<br>            BookVideoLiteManager.getInstance().videoPlayerResume(currentVideoData)<br>        &#125;<br>    &#125;<br><br>    fun <span class="hljs-title function_">releasePlay</span><span class="hljs-params">()</span> &#123;<br>        BookVideoLiteManager.getInstance().videoPlayerRelease(currentVideoData)<br>        currentVideoData = <span class="hljs-literal">null</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">onCreate</span><span class="hljs-params">(owner: LifecycleOwner)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(owner)<br>        BookLogger.i(TAG, <span class="hljs-string">&quot;FVideoView--onCreate&quot;</span>)<br>    &#125;<br><br>    override fun <span class="hljs-title function_">onPause</span><span class="hljs-params">(owner: LifecycleOwner)</span> &#123;<br>        pausePlay()<br>        <span class="hljs-built_in">super</span>.onPause(owner)<br>        BookLogger.i(TAG, <span class="hljs-string">&quot;FVideoView--onPause&quot;</span>)<br>    &#125;<br><br>    override fun <span class="hljs-title function_">onStop</span><span class="hljs-params">(owner: LifecycleOwner)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStop(owner)<br>        BookLogger.i(TAG, <span class="hljs-string">&quot;FVideoView--onStop&quot;</span>)<br>    &#125;<br><br>    override fun <span class="hljs-title function_">onResume</span><span class="hljs-params">(owner: LifecycleOwner)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onResume(owner)<br>        resumePlay()<br>        BookLogger.i(TAG, <span class="hljs-string">&quot;FVideoView--onResume&quot;</span>)<br>    &#125;<br><br><br>    override fun <span class="hljs-title function_">onDestroy</span><span class="hljs-params">(owner: LifecycleOwner)</span> &#123;<br>        releasePlay()<br>        <span class="hljs-built_in">super</span>.onDestroy(owner)<br>        BookLogger.i(TAG, <span class="hljs-string">&quot;FVideoView--onDestroy&quot;</span>)<br>        <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span> &amp;&amp; context is FragmentActivity) &#123;<br>            (context as FragmentActivity).lifecycle.removeObserver(<span class="hljs-built_in">this</span>)<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>FVideoViewController , FVideoView 的控制器, 用来创建和管理 FVideoView<br>继承 PlatformView、MethodChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FVideoViewController</span>(context: Context?, messenger: BinaryMessenger, id: Int?, args: Any?) :<br>    PlatformView, MethodChannel.MethodCallHandler &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> videoView: FVideoView = FVideoView(context)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> methodChannel: MethodChannel?=<span class="hljs-literal">null</span><br><br>    init &#123;<br>        BookLogger.i(<span class="hljs-string">&quot;FlutterCacheManager&quot;</span>, <span class="hljs-string">&quot;FVideoViewController&quot;</span>)<br><br>        <span class="hljs-comment">//通信</span><br>        methodChannel = MethodChannel(messenger, <span class="hljs-string">&quot;FVideoView_$id&quot;</span>)<br>        methodChannel?.setMethodCallHandler(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-keyword">if</span> (args!=<span class="hljs-literal">null</span> &amp;&amp; args is String) &#123;<br>            videoView.startPlay(args)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于返回Native View,这个View会被嵌入到Flutter的视图结构中</span><br><span class="hljs-comment">     */</span><br>    override fun <span class="hljs-title function_">getView</span><span class="hljs-params">()</span>: View &#123;<br>        <span class="hljs-keyword">return</span> videoView<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当Flutter要决定销毁PlatformView时会调用这个方法,</span><br><span class="hljs-comment">     * 通常在Flutter的一个widget销毁时调用,我们可以在这个方法中做一些资源释放的工作</span><br><span class="hljs-comment">     */</span><br>    override fun <span class="hljs-title function_">dispose</span><span class="hljs-params">()</span> &#123;<br>        BookLogger.i(<span class="hljs-string">&quot;FlutterCacheManager&quot;</span>, <span class="hljs-string">&quot;dispose&quot;</span>)<br>        methodChannel?.setMethodCallHandler(<span class="hljs-literal">null</span>)<br>        methodChannel=<span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-comment">//通信flutter调用原生</span><br>    override fun <span class="hljs-title function_">onMethodCall</span><span class="hljs-params">(call: MethodCall, result: MethodChannel.Result)</span> &#123;<br>        when (call.method) &#123;<br>            <span class="hljs-string">&quot;startPlay&quot;</span>-&gt;&#123;<br>                videoView.startPlay(call.arguments as? String)<br>            &#125;<br>            <span class="hljs-string">&quot;pausePlay&quot;</span>-&gt;&#123;<br>                videoView.pausePlay()<br>            &#125;<br>            <span class="hljs-string">&quot;resumePlay&quot;</span>-&gt;&#123;<br>                videoView.resumePlay()<br>            &#125;<br>            <span class="hljs-string">&quot;releasePlay&quot;</span>-&gt;&#123;<br>                videoView.releasePlay()<br>            &#125;<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                result.notImplemented()<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>继承 PlatformViewFactory，FVideoViewFactory , 用于向 Flutter 提供 FVideoView  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FVideoViewFactory</span> (<span class="hljs-keyword">private</span> val messenger: BinaryMessenger) :<br>    PlatformViewFactory(StandardMessageCodec.INSTANCE) &#123;<br><br>    override fun <span class="hljs-title function_">create</span><span class="hljs-params">(context: Context?, viewId: Int, args: Any?)</span>: PlatformView &#123;<br>        BookLogger.i(<span class="hljs-string">&quot;FlutterCacheManager&quot;</span>, <span class="hljs-string">&quot;FVideoViewFactory&quot;</span>)<br>        <span class="hljs-keyword">return</span> FVideoViewController(context, messenger, viewId, args)<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>FVideoViewPlugin , 用于向 Flutter 注册 FVideoView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FVideoViewPlugin</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要在创建Flutter引擎的时候去注册(重要)</span><br><span class="hljs-comment">     */</span><br>    fun <span class="hljs-title function_">registerWith</span><span class="hljs-params">(flutterEngine: FlutterEngine)</span> &#123;<br>        flutterEngine.platformViewsController.registry.registerViewFactory(<br>            <span class="hljs-string">&quot;FVideoView&quot;</span>,<br>            FVideoViewFactory(flutterEngine.dartExecutor.binaryMessenger)<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>FVideoViewPlugin().registerWith(flutterEngine)</p><hr><h2 id="Flutter-注册"><a href="#Flutter-注册" class="headerlink" title="Flutter 注册"></a>Flutter 注册</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FVideoViewController</span> &#123;<br>  late MethodChannel _channel;<br><br>  FVideoViewController(<span class="hljs-type">int</span> id) &#123;<br>    _channel = MethodChannel(<span class="hljs-string">&quot;FVideoView_$id&quot;</span>);<br>    _channel.setMethodCallHandler(_handleMethod);<br>    tallog(<span class="hljs-string">&quot;FVideoViewController---$id&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">///来自native view的调用</span><br>  Future&lt;dynamic&gt; <span class="hljs-title function_">_handleMethod</span><span class="hljs-params">(MethodCall call)</span> async &#123;<br>    <span class="hljs-keyword">switch</span> (call.method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;method name&quot;</span>:<br>        <span class="hljs-type">var</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> call.arguments as String;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Future</span>.value(<span class="hljs-string">&quot;Text from native:$text&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">///后期有实际业务，写真实参数</span><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title function_">startPlay</span><span class="hljs-params">()</span> async &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> &#123;<br>        <span class="hljs-string">&quot;fid&quot;</span>: <span class="hljs-string">&quot;VE_E8kdxv&quot;</span>,<br>        <span class="hljs-string">&quot;businessType&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;playerType&quot;</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-number">1</span>,<br>      &#125;;<br>      await _channel.invokeMethod(<span class="hljs-string">&quot;startPlay&quot;</span>, jsonEncode(map));<br>    &#125; on PlatformException <span class="hljs-title function_">catch</span> <span class="hljs-params">(e)</span> &#123;<br>      tallog(e.message);<br>    &#125;<br>  &#125;<br><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title function_">pausePlay</span><span class="hljs-params">()</span> async &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      await _channel.invokeMethod(<span class="hljs-string">&quot;pausePlay&quot;</span>);<br>    &#125; on PlatformException <span class="hljs-title function_">catch</span> <span class="hljs-params">(e)</span> &#123;<br>      tallog(e.message);<br>    &#125;<br>  &#125;<br><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title function_">resumePlay</span><span class="hljs-params">()</span> async &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      await _channel.invokeMethod(<span class="hljs-string">&quot;resumePlay&quot;</span>);<br>    &#125; on PlatformException <span class="hljs-title function_">catch</span> <span class="hljs-params">(e)</span> &#123;<br>      tallog(e.message);<br>    &#125;<br>  &#125;<br><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title function_">releasePlay</span><span class="hljs-params">()</span> async &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      await _channel.invokeMethod(<span class="hljs-string">&quot;releasePlay&quot;</span>);<br>    &#125; on PlatformException <span class="hljs-title function_">catch</span> <span class="hljs-params">(e)</span> &#123;<br>      tallog(e.message);<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">Widget <span class="hljs-title function_">getPlatformView</span><span class="hljs-params">(TestVideoLogic logic, MaterialColor color)</span> &#123;<br>  <span class="hljs-keyword">if</span> (Platform.isAndroid) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        Container(<br>          color: color,<br>          child: SizedBox(<br>            height: <span class="hljs-number">200</span>,<br>            child: AndroidView(<br>              viewType: <span class="hljs-string">&quot;FVideoView&quot;</span>,<br>              creationParams: <span class="hljs-literal">null</span>,<br>              creationParamsCodec: StandardMessageCodec(),<br>              onPlatformViewCreated: (id) &#123;<br>                <span class="hljs-type">var</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> FVideoViewController(id);<br>                logic.controller = controller;<br>                logic.startPlay();<br>              &#125;,<br>            ),<br>          ),<br>        ),<br>      ],<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> UiKitView(viewType: <span class="hljs-string">&quot;FVideoView&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6-Dart语言</title>
    <link href="/2025/12/888ee5ddd5f7.html"/>
    <url>/2025/12/888ee5ddd5f7.html</url>
    
    <content type="html"><![CDATA[<ol><li>Dart 当中的 「..」表示什么意思？<br>Dart 当中的 「..」意思是 「级联操作符」，为了方便配置而使用。「..」和「.」不同的是调用「..」后返回的相当于是 this，而「.」返回的则是该方法返回的值。</li><li>Dart 的作用域<br>Dart 没有 「public」「private」等关键字，默认就是公开的，私有变量使用下划线 _开头。</li></ol><p><strong>说一下 mixin 机制？</strong><br>mixin 是 Dart 2.1 加入的特性，以前版本通常使用 abstract class 代替。简单来说，mixin 是为了解决继承方面的问题而引入的机制，<em>Dart 为了支持多重继承，引入了 mixin 关键字，它最大的特殊处在于： mixin 定义的类不能有构造方法</em>，这样可以避免继承多个类而产生的父类构造方法冲突。<br>mixins 的对象是类，mixins 绝不是继承，也不是接口，而是一种全新的特性，可以 mixins 多个类，mixins 的使用需要满足一定条件。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>抽象类（接口）</strong></p><p>抽象类通常用来定义接口，以及部分实现。<br>在 Dart 中没有 interface 这个关键字，只有 abstract，所以可以使用 abstract 来生成接口：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Demo</span>&#123;<br>  <span class="hljs-built_in">void</span> zhujiang();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Zhu</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Demo</span>&#123;<br>  @<span class="hljs-keyword">override</span><br>  <span class="hljs-built_in">void</span> zhujiang() &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果想 <strong>extents 多个类的话需要使用 with 关键字，可以多继承</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>  void zhujiang();<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span></span>&#123;<br>  void zhujiang();<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span></span>&#123;<br>  void zhujiang();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zhu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Demo</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Demo2</span>,<span class="hljs-title">Demo3</span> <span class="hljs-title">implements</span> <span class="hljs-title">Demo3</span>,<span class="hljs-title">Demo2</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  void zhujiang() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变量的默认值</strong></p><p>不要被之前的Java所禁锢，比如之前的Boolean值默认会是false，但是在<strong>Dart中的bool值默认也是null</strong>，记着，一切皆对象，对象的默认值为null</p><p><strong>num类型</strong><br>int和double是num的子类</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//int和double都是num的子类<br> num n1 <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br> num n2 <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="dynamic-，var、object"><a href="#dynamic-，var、object" class="headerlink" title="dynamic ，var、object"></a>dynamic ，var、object</h3><p><strong>dynamic</strong><br>所有 dart 对象的基础类型，在大多数情况下，不直接使用它通过它定义的变量会关闭类型检查，这意味着 dynamix x&#x3D; ‘hal’;<br>x.foo (); 这段静态类型检查不会报错，但是运行时会 crash，因为 x 并没有 foo（） 方法，所以建议大家在编程时不要直接使用 dynamic；</p><p><strong>var</strong><br>是一个关键字，意思是”我不关心这里的类型是什么”，系统会自动判断类型 runtimeType;</p><p><strong>object</strong><br>是 Dart 对象的基类，当你定义： object o &#x3D;xxx ;时这个时候系统会认为 o 是个对象，你可以调用 o 的 toString () 和 hashCode () 方法因为 Object 提供了这些方法，但是如果你尝试调用o.foo () 时，静态类型检查会运行报错。综上不难看出 dynamic 与 object 的最大的区别是在静态类型检查上。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>位置可选参数，只需要将可选参数放入中括号即可，例子如下；<br>func_text (a, [b &#x3D; 4]) { }<br>匿名函数<br>var a &#x3D; (b, c){ return b + c; };<br>&#x2F;&#x2F;一般构造方法的书写格式<br>Person (this. name, this. age);</p><p>多构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FeeDetails</span> &#123;<br><br>  FeeDetails(<span class="hljs-keyword">this</span>.title, <span class="hljs-keyword">this</span>.content);<br><br>  FeeDetails.three(<span class="hljs-keyword">this</span>.title,<span class="hljs-keyword">this</span>.content,<span class="hljs-keyword">this</span>.describe);<br>  <br>  String? content;<br>  String? describe;<br>  String? title;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>. then ()的用法</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future.wait([<br>  <span class="hljs-comment">// 2秒后返回结果  </span><br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>), () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  &#125;),<br>  <span class="hljs-comment">// 4秒后返回结果  </span><br>  Future.delayed(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">4</span>), () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; world&quot;</span>;<br>  &#125;)]).then((results)&#123;<br>  <span class="hljs-built_in">print</span>(results[<span class="hljs-number">0</span>]+results[<span class="hljs-number">1</span>]);&#125;).catchError((e)&#123;<br>  <span class="hljs-built_in">print</span>(e);&#125;);<br></code></pre></td></tr></table></figure><p><strong>可以使用三个单引号创建多行字符串对象</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">String d = <span class="hljs-string">&#x27;&#x27;&#x27;ssss</span><br><span class="hljs-string">fffffffgg</span><br><span class="hljs-string">grrrr&#x27;&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>定义函数时可省略类型</strong>（不建议）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// return null;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dart中函数是Function类型的对象。所有的函数都返回一个值。如果没有指定返回值，则 默认把语句 return null; 作为函数的最后一个语句执行。</p><p>支持缩写语法 &#x3D;&gt; （Kotlin是用&#x3D;来实现）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">test</span>()=&gt; <span class="hljs-string">&quot;zhujiang&quot;</span>;<br><span class="hljs-title class_">String</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zhujiang&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数别名"><a href="#函数别名" class="headerlink" title="函数别名"></a>函数别名</h2><p>用typedef给函数起一个别名，使用比较方便。例如定义一个方法的回调，直接使用别名定义。没返回值，则只要参数匹配就行了，如果定义了返回值，则返回值不一样会报错。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs axapta">typedef Fun1(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b);<br>typedef Fun2&lt;T, K&gt;(T a, K b);<br><span class="hljs-built_in">int</span> add(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>  <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;a + b&#x27;</span>);<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>  Demo1(<span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b), <span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-keyword">sum</span> = f(x, y);<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;sum1 = $sum&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>  Demo2(Fun1 f, <span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-keyword">sum</span> = f(x, y);<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;sum2 = $sum&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>  Demo3(Fun2&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; f, <span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-keyword">sum</span> = f(x, y);<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;sum3 = $sum&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Demo1</span>(fun1, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-attribute">Demo2</span>(add, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-attribute">Demo3</span>(add, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p><strong>级联：..</strong><br>这个其实就是链式调用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">StringBuffer stringBuffer <span class="hljs-operator">=</span> StringBuffer()<span class="hljs-comment">;</span><br>stringBuffer..write(<span class="hljs-string">&quot;sss&quot;</span>)..write(<span class="hljs-string">&quot;ssss&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Dart%E8%AF%AD%E8%A8%80.resources/2023/09/15/17-53-51-9b2b7bf0c131abeb37d8bb19a1a7b063-unknown_filename-db55be.png" alt="unknown_filename"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Dart%E8%AF%AD%E8%A8%80.resources/2023/09/15/17-53-51-dfa183c2fa6617373f49fe58e921600d-unknown_filename.1-76b24b.png" alt="unknown_filename.1"></p><p><strong>Setter和Getter</strong><br>在Java中get和set方法可以直接生成，在Dart中无需自己定义。每个实例变量都隐含的具有一个 getter， 如果变量不是 final 的则还有一个 setter。</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4-Flutter基础知识</title>
    <link href="/2025/12/32b8b7f5fae8.html"/>
    <url>/2025/12/32b8b7f5fae8.html</url>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p> Flutter 的绘制流程</p><ol><li>我们的写的代码是 Widget 。Widget 是配置（描述了 UI 应该是什么样子的），不做布局和绘制，他会被 inflate（填充）到 Element</li><li>Element 是桥梁，持有 Widget 和 RenderObject，负责管理 Widget 的生命周期、Diff、更新。</li><li>RenderObject 负责布局和绘制</li><li><strong>Widget</strong> <strong>与</strong> <strong>Element</strong> <strong>是多对一的关系</strong>，但 Element 对 RenderObject 是一一对应</li><li>BuildContext 就是 Widget 对应的 Element，可以访问树结构和 RenderObject</li><li>在第一次创建 Widget 的时候，会对应创建一个 Element，然后将该元素插入树中。如果之后 Widget 发生了变化，则将其与旧的 Widget 进行比较，并且相应地更新 Element。重要的是，<em>Element 不会被重建，只是更新而已</em>。</li></ol><p>Widget 与 Element 的关系</p><ul><li><strong>多对一</strong>（很多 Widget 可以对应同一个 Element）：<ul><li>其实更准确的说法是：<strong>一个 Element 会持有它当前对应的 Widget</strong>。</li><li>当你调用 <code>setState</code> 或刷新 UI 时，Flutter 并不会每次都创建新的 Element。它会<strong>复用现有 Element</strong>，只更新 Element 持有的 Widget 配置。</li><li><strong>所以一个 Element 在生命周期中可以绑定不同的 Widget（不同的配置），但同一时间只对应一个 Widget。</strong></li><li>Widget 是不可变对象，每次 <code>build</code> 都会生成新 Widget。如果没有 Element，每次更新 UI 都要销毁旧的 RenderObject，再创建新的 RenderObject → 开销大（性能差）。</li></ul></li></ul><p><strong>为什么不直接用 Widget？</strong><br>Widget 本身不可变，而且 Widget 很轻量，每次刷新可能会生成很多新的 Widget。<br>Element 才是“长久驻扎”的实体，它会保存状态、管理生命周期和 RenderObject。</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>在使用 Flutter 时，我们经常会遇到一个叫做 Key 的东西。Key 是 Flutter 中几乎所有 widget 都具有的属性。</p><p>Flutter 将 Key 描述为 Widget、Element 和 SemanticNodes 的标识符。这是什么意思呢？这意味着 Key 是<em>分配给 Widget 的唯一标识，通过 key 可以与其他 Widget 区分开来</em>。对于 Widget 在 Widget 树中改变位置的情况，Key 帮助保留它们的状态。说明 Key 大多数情况下对于有状态的 Widget 而言更有用，而对于无状态的 Widget 则不太需要。</p><p><strong>GlobalKey</strong></p><ul><li>跨 Widget 树查找 Element&#x2F;State。</li><li>可以用 <code>globalKey.currentState</code>、<code>globalKey.currentContext</code> 获取实例。</li><li>一般用于 <code>Form</code>、<code>Scaffold</code>、<code>Navigator</code> 等场景。</li></ul><p><strong>Key 是 Widget 的身份标识</strong>，决定了 Widget&#x2F;Element&#x2F;RenderObject 是否复用。</p><ul><li><strong>没有 Key</strong>：按位置复用。</li><li><strong>有 Key</strong>：按 Key 匹配，避免错位复用。</li></ul><p><strong>常用场景</strong>：<br>    - <code>ListView</code> &#x2F; <code>GridView</code> 子节点（复用&#x2F;顺序变化）。<br>    - 动画组件（防止错乱）。<br>    - <code>GlobalKey</code> 获取状态或上下文。</p><h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><ol><li>使用屏幕尺寸的相对值：避免直接使用固定的像素值来定义尺寸，而是使用相对于屏幕尺寸的比例值。可以使用 MediaQuery. of (context). size 获取屏幕的宽度和高度，然后根据需求进行比例计算。</li><li>使用布局容器：使用诸如 Container、Expanded、Flexible 等布局容器来自动适应父容器的大小。这样可以确保界面在不同屏幕尺寸下的自适应性。</li><li>使用响应式布局：使用 Flutter 提供的响应式布局框架，如 LayoutBuilder 和 FractionallySizedBox，来根据屏幕尺寸动态调整布局。</li><li>使用自适应字体大小：根据屏幕尺寸和设备像素比例，使用 MediaQuery. of (context). textScaleFactor 来调整字体的大小，以确保在不同设备上字体的可读性和一致性。</li><li>使用屏幕方向适配：根据屏幕的方向（横向或纵向），调整布局和元素的摆放方式，以提供更好的用户体验。</li><li>使用 Flutter 插件：有一些 Flutter 插件和库可用于简化屏幕适配的工作，如 flutter_screenutil、sizer 等，它们提供了更方便的方法和工具来进行屏幕适配。</li></ol><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>Flutter 框架自下而上分为 Embedder、Engine 和 Framework 三层。</p><ul><li>Embedder 是操作系统适配层，实现了渲染 Surface 设置，线程设置，以及平台插件等平台相关特性的适配；</li><li>Engine 层负责图形绘制、文字排版和提供 Dart 运行时，Engine 层具有独立虚拟机，正是由于它的存在，Flutter 程序才能运行在不同的平台上，实现跨平台运行；</li><li>Framework 层则是使用 Dart 编写的一套基础视图库，包含了动画、图形绘制和手势识别等功能，是使用频率最高的一层。<br><img src="http://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/20240315222429.png" alt="image.png|600"></li></ul><p><strong>FrameWork 层和 Engine 层，以及它们的作用</strong></p><ul><li>Flutter的FrameWork层是用Drat编写的框架（SDK），它实现了一套基础库，包含Material（Android风格UI）和Cupertino（iOS风格）的UI界面，下面是通用的Widgets（组件），之后是一些动画、绘制、渲染、手势库等。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。</li><li>Flutter 的 Engine 层是 Skia 2D 的绘图引擎库，其前身是一个向量绘图软件，Chrome 和 Android 均采用 Skia 作为绘图引擎。Skia 提供了非常友好的 API，并且在图形转换、文字渲染、位图渲染方面都提供了友好、高效的表现。Skia 是跨平台的，所以可以被嵌入到 Flutter 的 iOS SDK 中，而不用去研究 iOS 闭源的 Core Graphics &#x2F; Core Animation。Android 自带了 Skia，所以 Flutter Android SDK 要比 iOS SDK 小很多。</li></ul><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><code>BuildContext</code> 是一个将上下文信息与特定的 Widget 相关联的对象，与该 Widget 一起构成了 Flutter Widget 树的一部分。</p><ul><li>每个 <code>BuildContext</code> 对象只从属于一个 Widget。这意味着每个 Widget 都有一个与之关联的 <code>BuildContext</code> 对象，用于表示该 Widget 在 Widget 树中的位置和上下文信息</li><li>查找父级 Widget：通过 <code>BuildContext</code>，可以访问当前 Widget 在 Widget 树中的父级 Widget，并进一步访问父级 Widget 的属性和方法。查找子级 Widget    </li><li>访问主题（Theme）：<code>BuildContext</code> 可以用于获取当前 Widget 所在的主题数据，例如颜色、字体样式等。</li></ul><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>![[1-Flutter分享#Stateful widgets]]</p><p>![[1-Flutter分享#生命周期]]</p><h2 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h2><p>Flutter 的热重载是基于 JIT 编译模式的<em>代码增量同步</em>。由于 JIT 属于动态编译，能够将 Dart 代码编译成生成中间代码，让 Dart VM 在运行时解释执行，因此可以通过动态更新中间代码实现增量同步。</p><p>热重载的流程可以分为 5 步，包括：扫描工程改动、<em>增量编译、推送更新、代码合并</em>、Widget 重建。Flutter 在接收到代码变更后，并不会让 App 重新启动执行，而<em>只会触发 Widget 树的重新绘制</em>，因此可以保持改动前的状态，大大缩短了从代码修改到看到修改产生的变化之间所需要的时间。</p><p>另一方面，由于涉及到状态的保存与恢复，<em>涉及状态兼容与状态初始化的场景，热重载是无法支持的</em>，如改动前后 Widget 状态无法兼容、全局变量与静态属性的更改、main 方法里的更改、initState 方法里的更改、枚举和泛型的更改等。</p><p>可以发现，热重载提高了调试 UI 的效率，非常适合写界面样式这样需要反复查看修改效果的场景。但由于其状态保存的机制所限，热重载本身也有一些无法支持的边界。</p><h2 id="FlutterEngineGroup"><a href="#FlutterEngineGroup" class="headerlink" title="FlutterEngineGroup"></a>FlutterEngineGroup</h2><p>FlutterEngineGroup 加快首次渲染的速度、还能降低内存占用<br>FlutterEngineGroup 是 Flutter 框架提供的一个类，用于管理多个 Flutter 引擎的组合。它提供了引擎的创建和销毁、引擎之间的通信、引擎的生命周期管理、资源共享和多引擎的并发执行等功能。通过 FlutterEngineGroup，可以灵活地管理和控制多个 Flutter 页面的运行和交互。</p><p>共享资源：FlutterEngineGroup 允许多个 Flutter 引擎共享一些资源，如字体、图像等。通过资源的共享，可以避免多次加载相同的资源，从而减少内存占用。<br>引擎的生命周期管理：通过 FlutterEngineGroup，可以灵活地管理引擎的生命周期，包括启动引擎、暂停和恢复引擎等。合理管理引擎的生命周期可以在不需要时释放资源，从而减少内存占用。</p><h3 id="🔹-1-背景：FlutterEngine-的问题"><a href="#🔹-1-背景：FlutterEngine-的问题" class="headerlink" title="🔹 1. 背景：FlutterEngine 的问题"></a>🔹 1. 背景：FlutterEngine 的问题</h3><p>在混合开发里（原生 + Flutter），如果你需要在 App 里启动多个 Flutter 页面，有两种常见做法：</p><ol><li><p><strong>单引擎模式</strong></p><ul><li>全 App 共用一个 <code>FlutterEngine</code>。</li><li>优点：内存占用低，通信方便（共享 Dart Isolate）。</li><li>缺点：多个 Flutter 页面共享同一个 <code>Navigator</code> 和状态，路由管理复杂，不够隔离。</li></ul></li><li><p><strong>多引擎模式</strong></p><ul><li>每个 Flutter 页面创建一个新的 <code>FlutterEngine</code>。</li><li>优点：页面完全隔离，互不影响。</li><li>缺点：每个 Engine 都要单独初始化 Dart VM、Isolate，开销大（内存和启动时间）。</li></ul></li></ol><p>👉 问题就是：<strong>单引擎灵活性差，多引擎性能开销大。</strong></p><hr><h3 id="🔹-2-FlutterEngineGroup-的作用"><a href="#🔹-2-FlutterEngineGroup-的作用" class="headerlink" title="🔹 2. FlutterEngineGroup 的作用"></a>🔹 2. FlutterEngineGroup 的作用</h3><p><code>FlutterEngineGroup</code> 是 Flutter 提供的一种折中方案（自 Flutter 1.22 起支持）。</p><p>它的核心点是：</p><ul><li><strong>多个 FlutterEngine 可以共享资源（Dart VM、AOT&#x2F;JIT 代码、Skia、字体、图片缓存等）</strong></li><li>但 <strong>每个 Engine 有独立的 Dart Isolate 和状态</strong>。</li></ul><p>👉 简单来说：</p><ul><li>内存占用 ≈ 介于单引擎和多引擎之间（比多引擎省很多）。</li><li>灵活性 ≈ 多引擎（页面互不干扰）。</li></ul><hr><h3 id="🔹-3-好处总结"><a href="#🔹-3-好处总结" class="headerlink" title="🔹 3. 好处总结"></a>🔹 3. 好处总结</h3><h3 id="✅-1-多-FlutterEngine-的高性能支持"><a href="#✅-1-多-FlutterEngine-的高性能支持" class="headerlink" title="✅ 1. 多 FlutterEngine 的高性能支持"></a>✅ 1. 多 FlutterEngine 的高性能支持</h3><ul><li>相比传统的“多引擎模式”，<strong>减少了重复资源加载</strong>（VM、AOT&#x2F;JIT snapshot、缓存）。</li><li>多个 Flutter 页面可以快速启动，而不会因为每次都要初始化完整引擎而卡顿。</li></ul><h3 id="✅-2-每个页面独立隔离"><a href="#✅-2-每个页面独立隔离" class="headerlink" title="✅ 2. 每个页面独立隔离"></a>✅ 2. 每个页面独立隔离</h3><ul><li>每个 <code>FlutterEngine</code> 都有独立的 Dart Isolate。</li><li>页面之间不会共享全局变量，互不影响。</li><li>比单引擎更容易做多业务模块（比如多个 Flutter 子应用）。</li></ul><h3 id="✅-3-保持-Flutter-页面体验一致"><a href="#✅-3-保持-Flutter-页面体验一致" class="headerlink" title="✅ 3. 保持 Flutter 页面体验一致"></a>✅ 3. 保持 Flutter 页面体验一致</h3><ul><li>支持多个 Flutter 页面并存，页面切换流畅。</li><li>尤其在 <strong>混合开发场景</strong> 下，适合“原生多 Activity&#x2F;多 VC + 多 Flutter 页面”结构。</li></ul><h3 id="✅-4-内存更可控"><a href="#✅-4-内存更可控" class="headerlink" title="✅ 4. 内存更可控"></a>✅ 4. 内存更可控</h3><ul><li>相比完全多引擎模式，<strong>内存消耗降低</strong>（因为 Engine 之间共享了 VM 资源）。</li><li>不会因为频繁开新 Engine 而导致 OOM。</li></ul><hr><h3 id="🔹-4-适用场景"><a href="#🔹-4-适用场景" class="headerlink" title="🔹 4. 适用场景"></a>🔹 4. 适用场景</h3><ul><li><strong>超级 App（SuperApp）</strong>：比如淘宝、美团这类多业务大应用，每个业务模块可以有独立 FlutterEngine。</li><li><strong>多 Flutter 页面并存</strong>：比如你需要同时开多个 Flutter 界面（聊天窗口、活动页、个人页等）。</li><li><strong>多团队协作开发</strong>：每个业务团队可以独立维护自己的 Flutter 模块，互不干扰。</li></ul><hr><h3 id="🔹-5-总结一句话"><a href="#🔹-5-总结一句话" class="headerlink" title="🔹 5. 总结一句话"></a>🔹 5. 总结一句话</h3><blockquote><p><strong><code>FlutterEngineGroup</code> 的好处是</strong>：<br>在保留多引擎独立性的同时，最大限度地共享底层资源，兼顾性能和隔离性，非常适合多 Flutter 页面、混合开发、大型 App 场景。</p></blockquote><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p> <strong>flutter 布局规则</strong><br>首先，上层 widget 向下层 widget <em>传递约束条件</em>；<br>然后，下层 widget 向上层 widget <em>传递大小信息</em>。<br>最后，上层 widget 决定下层 widget 的位置。</p><h3 id="Row-嵌套-Row"><a href="#Row-嵌套-Row" class="headerlink" title="Row 嵌套 Row"></a>Row 嵌套 Row</h3><p>Row 和 Column <em>都只会在主轴方向占用尽可能大的空间</em>，而纵轴的长度则取决于他们最大子元素的长度<br>如果 Row 里面嵌套 Row，或者 Column 里面再嵌套 Column，那么<em>只有最外面的 Row 或 Column 会占用尽可能大的空间，里面 Row 或 Column 所占用的空间为实际大小</em></p><p>🔹 1. Row &#x2F; Column 的特点</p><p>Row &#x3D; 水平方向布局<br>Column &#x3D; 垂直方向布局</p><p>它们的特点是：<br>在主轴方向（Row 横向 &#x2F; Column 纵向）会尽量占满父容器的剩余空间。<br>在交叉轴方向（Row 纵向 &#x2F; Column 横向）会根据子元素大小来决定。</p><p>也就是说：<br>外层 Row&#x2F;Column 默认是“扩展型” → 会尽可能拉伸填满父容器（取决于约束）。<br>内层 Row&#x2F;Column 是“包裹内容” → 只会占自己孩子的大小（shrink-wrap）。</p><p>🔹 2. 举个例子</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Scaffold</span> (<br>  <span class="hljs-attribute">body</span>: Row (<br>    <span class="hljs-attribute">children</span>: [<br>      Container (<span class="hljs-attribute">width</span>: <span class="hljs-number">100</span>, <span class="hljs-attribute">height</span>: <span class="hljs-number">100</span>, <span class="hljs-attribute">color</span>: Colors. red),<br>      Row (<br>        <span class="hljs-attribute">children</span>: [<br>          Container (<span class="hljs-attribute">width</span>: <span class="hljs-number">50</span>, <span class="hljs-attribute">height</span>: <span class="hljs-number">50</span>, <span class="hljs-attribute">color</span>: Colors. blue),<br>          Container (<span class="hljs-attribute">width</span>: <span class="hljs-number">50</span>, <span class="hljs-attribute">height</span>: <span class="hljs-number">50</span>, <span class="hljs-attribute">color</span>: Colors. green),<br>        ],<br>      ),<br>    ],<br>  ),<br>);<br><br></code></pre></td></tr></table></figure><p>运行效果：<br>外层 Row：会尝试在水平方向填满屏幕。<br>内层 Row：只会占用两个小方块的宽度（100px），不会自己把空间撑满。<br>👉 所以你看到的现象就是：最外层 Row 占满空间，里面的 Row 只占实际内容大小。</p><p>🔹 3. 为什么会这样？<br>这是 Flutter 的约束规则（Box Constraints）：<br>父组件给子组件约束：最小宽度 &#x2F; 最大宽度 &#x2F; 最小高度 &#x2F; 最大高度。<br>Row &#x2F; Column 在主轴方向上会尽量满足父容器的最大空间。<br>但是在嵌套时，内层 Row&#x2F;Column 处于外层 Row&#x2F;Column 的交叉轴方向，所以它拿到的约束是 “可以小于最大值”，于是只会根据实际子内容大小来决定。</p><p>🔹 4. 怎么让内层也“拉伸”？<br>如果你希望里面的 Row&#x2F;Column 也能拉满，需要用 Expanded 或 SizedBox. expand：<br>这样内层 Row 就会在外层 Row 的剩余空间里拉满。</p><p>🔹 5. 总结<br>“只有最外面的 Row&#x2F;Column 会尽可能大，里面的 Row&#x2F;Column 只占实际大小” 的意思是：<br>外层 Row&#x2F;Column 在主轴方向会拉伸填满父容器。<br>内层 Row&#x2F;Column 默认不会主动拉伸，而是根据子内容大小决定。<br>如果你想让内层也拉伸，需要用 Expanded &#x2F; Flexible 来告诉 Flutter：我想要占满剩余空间。</p><h3 id="ConstrainedBox"><a href="#ConstrainedBox" class="headerlink" title="ConstrainedBox"></a>ConstrainedBox</h3><p>ConstrainedBox: 对子组件添加额外的约束。例如，如果你想让子组件的最小高度是80像素<br>UnconstrainedBox: 不会对子组件产生任何限制，它允许其子组件按照其本身大小绘制, 一般用来去掉父约束</p><p>在 Flutter 中，Container 的大小通常由其父组件和子组件共同决定。如果 Container <em>没有父组件</em>，或者它的父组件没有提供足够的约束，那么 Container 会尽可能地大。这就是为什么你看到的 Container 占据了整个屏幕。</p><p>如果你想让 <code>Container</code> 的大小为特定的值，你需要确保它的父组件提供了足够的约束。例如，你可以将 <code>Container</code> 放在一个 <code>Center</code> 组件中，这样 <code>Container</code> 就会被约束在屏幕中心，而不是占据整个屏幕。</p><h3 id="Align"><a href="#Align" class="headerlink" title="Align"></a>Align</h3><p>在<strong>Column</strong>控件外层包裹一层<strong>Align</strong>控件，是为了<strong>让 Column 控件的高度仅包裹其子控件的高度，而不是填充整个屏幕</strong>。Align 控件可以将其子控件对齐到指定位置，并根据子控件的大小来调整自身的大小。当您将 Align 控件的 alignment 属性设置为<strong>Alignment. topCenter</strong>时，它会将其子控件垂直居中对齐到顶部，并根据子控件的高度来调整自身的高度。度。度。度。。<br>如果您希望让 Column 控件填充整个屏幕，那么您可以不使用 Align 控件，直接将 Column 控件作为 Container 控件的子控件即可。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter_Tips.resources/2023/09/15/18-50-55-a78bd6be7c25bb027b2d3e58f4394e03-unknown_filename.7-1faf21.png" alt="unknown_filename.7"></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3-Flutter工作tips</title>
    <link href="/2025/12/419bc25ead72.html"/>
    <url>/2025/12/419bc25ead72.html</url>
    
    <content type="html"><![CDATA[<h2 id="溢出的解决方法"><a href="#溢出的解决方法" class="headerlink" title="溢出的解决方法"></a>溢出的解决方法</h2><ol><li>使用Column包裹在SingleChildScrollView</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">SingleChildScrollView</span>(<br>  <span class="hljs-attribute">child</span>: <span class="hljs-built_in">Column</span>(<span class="hljs-attribute">children</span>: children),<br>)<br></code></pre></td></tr></table></figure><ol start="2"><li>改成 ListView</li></ol><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">ListView</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">children</span>: <span class="hljs-variable">children</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用两者的组合Column和ListView时，使用Expanded或者给ListView一个固定高度</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Column</span>(<br>  <span class="hljs-attribute">children</span>: [<br>    ...children.<span class="hljs-built_in">take</span>(<span class="hljs-number">2</span>).<span class="hljs-built_in">toList</span>(), <span class="hljs-comment">// show first 2 children in Column</span><br>    <span class="hljs-built_in">Expanded</span>(<br>      <span class="hljs-attribute">child</span>: <span class="hljs-built_in">ListView</span>(<br>        <span class="hljs-attribute">children</span>: children.<span class="hljs-built_in">getRange</span>(<span class="hljs-number">3</span>, children.length).<span class="hljs-built_in">toList</span>(),<br>      ), <span class="hljs-comment">// And rest of them in ListView</span><br>    ),<br>  ],<br>)<br></code></pre></td></tr></table></figure><h2 id="dialog-高度自适应"><a href="#dialog-高度自适应" class="headerlink" title="dialog 高度自适应"></a>dialog 高度自适应</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter_Tips.resources/2023/09/15/18-50-55-1c252adf3b7c2331e1739f1363d3f493-unknown_filename.6-f1171e.png" alt="unknown_filename.6"></p><p>flutter可以分架构打包<br>flutter build apk –obfuscate –split-debug-info debuginfo –target-platform android-arm,android-arm64,android-x64 –split-per-abi</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><strong>Expanded 仅应在 Row，Column 或者 Flex 使用，检查代码.必须是直接的子类</strong>，否则 debug 能运行，release 报错。</li><li>使用 Flutter Web 目前不适合Web ，对于具有大量密集文本的静态网页，传统的 Web 开发方法支持更快的加载时间和更容易维护。 webdev</li></ul><p><strong>Flutter Inspector 不显示解决</strong><br>&lt; <a href="https://stackoverflow.com/questions/64725383/flutter-inspector-stuck-on-installing-dev-tools/65542661#65542661%3E">https://stackoverflow.com/questions/64725383/flutter-inspector-stuck-on-installing-dev-tools/65542661#65542661&gt;</a></p><p><strong>flutter 自己的代码打开错乱</strong><br>把. idea 删掉、对应错误的文件本地打开，然后删掉，或者用 flutter SDK 重新替换</p><h2 id="LayoutBuilder"><a href="#LayoutBuilder" class="headerlink" title="LayoutBuilder"></a>LayoutBuilder</h2><p>一个 text 的右边和另一个 text 的左边对齐, 另一个 text 宽度还不固定，这两个 widget 不在同一行，是上下两行<br>使用<strong>LayoutBuilder</strong>控件来获取第一个<strong>Text</strong>控件的宽度，并使用这个宽度来设置第二个<strong>Text</strong>控件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Column(<br>  children: [<br>    Row(<br>      children: [<br>        Text(<span class="hljs-string">&#x27;Left Text&#x27;</span>),<br>      ],<br>    ),<br>    LayoutBuilder(<br>      builder: (context, constraints) &#123;<br>        <span class="hljs-type">final</span> <span class="hljs-variable">leftTextWidth</span> <span class="hljs-operator">=</span><br>            (TextPainter(text: TextSpan(text: <span class="hljs-string">&#x27;Left Text&#x27;</span>), maxLines: <span class="hljs-number">1</span>, textDirection: TextDirection.ltr)..layout()).width;<br>        <span class="hljs-keyword">return</span> Row(<br>          children: [<br>            SizedBox(width: leftTextWidth),<br>            Text(<span class="hljs-string">&#x27;Right Text&#x27;</span>),<br>          ],<br>        );<br>      &#125;,<br>    ),<br>  ],<br>),<br></code></pre></td></tr></table></figure><p>手势Draggable文章<br><a href="https://blog.csdn.net/du591310450/article/details/89845157">https://blog.csdn.net/du591310450/article/details/89845157</a><br><a href="https://blog.csdn.net/weixin_52262025/article/details/123618314">https://blog.csdn.net/weixin_52262025&#x2F;article&#x2F;details&#x2F;123618314，用的这个</a></p><p>角度转弧度 π&#x2F;180×角度<br>弧度变角度 180&#x2F;π×弧度<br>1度&#x3D;π&#x2F;180≈0.01745弧度，1弧度&#x3D;180&#x2F;π≈57.3度。</p><p>计算重叠区域面积<br><a href="https://leetcode.cn/problems/rectangle-area/solution/223-ju-xing-mian-ji-3xing-dai-ma-by-acw_weian/">https://leetcode.cn/problems/rectangle-area/solution/223-ju-xing-mian-ji-3xing-dai-ma-by-acw_weian/</a></p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li>SingleChildScrollView 可以滚动，如果SingleChildScrollView嵌套SingleChildScrollView，第二SingleChildScrollView需要加个Expanded</li><li>有问题的时候可以试试Expanded</li><li>Expanded 平分加三个Expanded</li><li>Scaffold(  resizeToAvoidBottomInset: true,） 可以把布局顶上去，不会被输入法遮盖，键盘弹出 overflowed：放这个，Scaffold (  resizeToAvoidBottomInset: false，这样在键盘弹出时将不会 resize</li><li>Text.rich(TextSpan 一个textviwe不同颜色大小</li><li>Flexible 可以让 textview 换行</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">RichText</span>(<span class="hljs-attribute">text</span>: <span class="hljs-built_in">TextSpan</span>(<br>                <span class="hljs-attribute">children</span>: [<br>                   <span class="hljs-built_in">TextSpan</span>(<br>                     <span class="hljs-attribute">text</span>:<span class="hljs-string">&quot;*&quot;</span>,<br>                     <span class="hljs-attribute">style</span>: <span class="hljs-built_in">TextStyle</span>(<span class="hljs-attribute">color</span>: JCColor.colorAuxRedColor, <span class="hljs-attribute">fontSize</span>: <span class="hljs-number">15</span>)<br>                   ),<br>                  <span class="hljs-built_in">TextSpan</span>(<br>                      <span class="hljs-attribute">text</span>:<span class="hljs-string">&quot;费用归属&quot;</span>,<br>                      <span class="hljs-attribute">style</span>: <span class="hljs-built_in">TextStyle</span>(<span class="hljs-attribute">color</span>: JCColor.colorText222<span class="hljs-attribute">Color</span>, <span class="hljs-attribute">fontSize</span>: <span class="hljs-number">15</span>)<br>                  )<br>                ]<br>            )),<br><br></code></pre></td></tr></table></figure><ul><li><p>alignment: Alignment.centerLeft, 左对齐</p></li><li><p>row 水平居中 mainAxisAlignment:MainAxisAlignment.spaceBetween</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MainAxisAlignment</span> &#123;<br> <span class="hljs-comment">//将子控件放在主轴的开始位置</span><br>  start,  <br>   <span class="hljs-comment">//将子控件放在主轴的结束位置</span><br>  end,<br>  <span class="hljs-comment">//将子控件放在主轴的中间位置</span><br>  center,<br>  <span class="hljs-comment">//将主轴空白位置进行均分，排列子元素，手尾没有空隙</span><br>  spaceBetween,<br>  <span class="hljs-comment">//将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距为中间子控件间距的一半</span><br>  spaceAround,<br>  <span class="hljs-comment">//将主轴空白区域均分，使各个子控件间距相等</span><br>  spaceEvenly,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Row mainAxisSize: MainAxisSize.min,&#x2F;&#x2F;wrap_content ,不加的话默认为match_parent（MainAxisSize.max）</p></li><li><p>Column mainAxisAlignment: MainAxisAlignment.center,</p></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter_Tips.resources/2023/09/15/18-50-55-725fd7b1edf17b0af4da1c2abb2c2729-unknown_filename-0362bf.png" alt="unknown_filename"></p><p>listview嵌套listview</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">child: ListView.separated(<br>                      shrinkWrap: <span class="hljs-literal">true</span>,<br>                      <span class="hljs-attr">physics</span>: NeverScrollableScrollPhysics(),  <span class="hljs-comment">//list嵌套listview</span><br>                      itemCount: logic.architectureList?.<span class="hljs-built_in">length</span> ?? <span class="hljs-number">0</span>,<br>                      <span class="hljs-attr">itemBuilder</span>: <span class="hljs-function">(<span class="hljs-params">context, index</span>) =&gt;</span><br>                          _buildItem(logic.architectureList?[index]),<br>                      <span class="hljs-attr">separatorBuilder</span>: <span class="hljs-function">(<span class="hljs-params">context, index</span>) =&gt;</span> Divider(height: <span class="hljs-number">.0</span>),<br>                    ));<br><br></code></pre></td></tr></table></figure><p>ListView.separated 有分割线</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">Visibility</span>(<br>  <span class="hljs-attribute">visible</span>: true,<br>  <span class="hljs-comment">//是否保持占位</span><br>  <span class="hljs-attribute">maintainState</span>: false,<br>  <span class="hljs-attribute">child</span>: <span class="hljs-built_in">Text</span>(<span class="hljs-string">&quot;显示&quot;</span>),<br>),<br>    <br></code></pre></td></tr></table></figure><p>弹窗</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">showModalBottomSheet</span>(<br>                      <span class="hljs-attribute">shape</span>: const <span class="hljs-built_in">RoundedRectangleBorder</span>(<br>                          <span class="hljs-attribute">borderRadius</span>: BorderRadius.<span class="hljs-built_in">only</span>(<br>                              <span class="hljs-attribute">topLeft</span>: Radius.<span class="hljs-built_in">circular</span>(<span class="hljs-number">16</span>),<br>                              <span class="hljs-attribute">topRight</span>: Radius.<span class="hljs-built_in">circular</span>(<span class="hljs-number">16</span>))),<br>                      <span class="hljs-attribute">context</span>: context,<br>                      <span class="hljs-attribute">builder</span>: (BuildContext context) &#123;<br>                        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">AirTicketRuleDialog</span>();<br>                      &#125;);<br></code></pre></td></tr></table></figure><ul><li>Spacer其实就是包装了一个 Expanded 的 SizedBox. 我们可以通过它灵活控制 Row&#x2F;Column。 Spacer(flex: 2), &#x2F;&#x2F; 弹性系数为2</li><li>返回键</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">WillPopScope(<br>              child: <span class="hljs-keyword">this</span>,<br>              onWillPop: () async &#123;<br>                <span class="hljs-keyword">return</span> Future.value(<span class="hljs-literal">false</span>);<br>              &#125;);<br></code></pre></td></tr></table></figure><ul><li><p>这种布局<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter_Tips.resources/2023/09/15/18-50-55-e5d0dc17d17e1e1f247a9727186a8fba-unknown_filename.1-329925.png" alt="unknown_filename.1"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">Row</span>(<span class="hljs-attribute">children</span>: [<br>         const <span class="hljs-built_in">SizedBox</span>(<span class="hljs-attribute">width</span>: <span class="hljs-number">32</span>),<br>         <span class="hljs-built_in">Expanded</span>(<br>           <span class="hljs-attribute">child</span>: <span class="hljs-built_in">Text</span>(<br>             <span class="hljs-string">&#x27;退改行李规定&#x27;</span>,<br>             <span class="hljs-attribute">textAlign</span>: TextAlign.center,<br>         ),<br>         <span class="hljs-built_in">InkWell</span>(    ]),<br>    <br></code></pre></td></tr></table></figure></li><li><p>MediaQuery.removePadding 可以移除组件的边距，有些组件自带有边距，</p></li></ul><p><strong>通知栏高度</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">final</span> <span class="hljs-keyword">dynamic</span> padding = MediaQuery.of(context).padding;<br>padding: EdgeInsets.only(top: padding.top),<br></code></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><em>分类</em><br>缩放动画<br>ScaleTransition：可以将 Widget 平滑地缩放。<br>AnimatedContainer：可以平滑地调整 Widget 的大小。<br>旋转动画<br>RotationTransition：可以将 Widget 平滑地旋转。<br>透明渐变动画<br>FadeTransition：可以将 Widget 平滑地改变透明度。<br>AnimatedOpacity：可以平滑地调整 Widget 的透明度。</p><p><em>主要类</em><br>在使用 Flutter 动画的时候, 我们通常使用这几个组件.<br>AnimationController, 控制动画的抽象类<br>Animation, 给定值, 转换为动画<br>Tween, 执行范围<br>AnimatedBuilder, 处理动画的 Widget<br>Transform 控件可以将动画执行中的变量值处理反馈在子控件上.<br><a href="https://github.com/dlgchg/animations_flutter">https://github.com/dlgchg/animations_flutter</a></p><h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><ul><li>flutter 同一个页面，关闭后，再重新打开</li><li>eventbus</li><li>then back</li><li>在onresume里刷新</li><li>find原来的logic，调用他的方法</li></ul><p><strong>Android二次进入同一Flutter页面，Flutter没有刷新</strong><br>Flutter页面使用StatefulWidget组件，并重写didUpdateWidget（）。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>flutter run –release 这样运行，正式版也可以看日志**</p><p><strong>dio抓包</strong></p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">dio</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Dio</span>(<span class="hljs-variable">options</span>);<br>(<span class="hljs-variable">dio?</span>.<span class="hljs-property">httpClientAdapter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">DefaultHttpClientAdapter</span>).<span class="hljs-property">onHttpClientCreate</span> <span class="hljs-title function_">=</span><br>    (<span class="hljs-title class_">HttpClient</span> <span class="hljs-variable">client</span>) &#123;<br>  <span class="hljs-variable">client</span>.<span class="hljs-property">findProxy</span> <span class="hljs-title function_">=</span> (<span class="hljs-variable">uri</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#x27;<span class="hljs-variable">PROXY</span> <span class="hljs-number">172.16</span><span class="hljs-number">.60</span><span class="hljs-number">.122</span>:<span class="hljs-number">8888</span>&#x27;;<br>  &#125;;<br>&#125;;<br>    <br></code></pre></td></tr></table></figure><p>cancelTap<br>传接口时不要当成方法，要不然直接调用</p><p><a href="https://stackoverflow.com/questions/55437643/flutter-disable-system-debug-messages-in-run-tab">日志过滤</a></p><p><a href="https://gist.github.com/eduardoflorence/4fdf7d0f38b56adb3e4929e132a98e58">防止tab每次都刷新</a><br>AutomaticKeepAliveClientMixin</p><p><strong>修改 minSdkVersion</strong><br>由于 Flutter 3.13 及更高版本的更改而更新的响应</p><p>在此版本中，此文件_<strong>flutter-directory&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;flutter. gradle</strong><em>的内容已移至此新位置</em><strong>flutter-directory&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;src&#x2F;main&#x2F;groovy&#x2F;flutter. groovy</strong>_。和默认的 <code>minSdkVersion = 19</code>. 但为了安全地使用最新的软件包和 Android 设备，最好将其设置为 <code>minSdkVersion = 20</code>.</p><h2 id="flutter-动态化"><a href="#flutter-动态化" class="headerlink" title="flutter 动态化"></a>flutter 动态化</h2><p>Flutter 混合开发 - 动态下发 libflutter. so &amp; libapp. so - 掘金<br><a href="https://juejin.cn/post/7313446602441785382?utm_source=gold_browser_extension">https://juejin.cn/post/7313446602441785382?utm_source=gold_browser_extension</a></p><p><a href="https://juejin.cn/post/6950207830225862664/">Flutter动态化方案—源码解析（基于1.22以上版本) - 掘金 (juejin.cn)</a><br><a href="https://juejin.cn/post/7189533148022046778#heading-7">https://juejin.cn/post/7189533148022046778?#heading-7</a></p><h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><p>flutter create –template&#x3D;package  &#x2F;Users&#x2F;tal&#x2F;flutteProjects&#x2F;hello<br>flutter packages pub publish –dry-run<br>flutter packages pub publish –server&#x3D; <a href="https://pub.dartlang.org/">https://pub.dartlang.org</a></p><p>hello:<br>    path: &#x2F;Users&#x2F;tal&#x2F;flutteProjects&#x2F;hello </p><p>flutter build apk –split-per-abi<br><a href="https://github.com/kezong/fat-aar-android">fat-aar-android</a> ：build aar 后没有打出 release<br>assembleRelease  编译不过，报错</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>Get. off () 导航到下一个页面并删除前一个页面<br>Get. offAll () 导航到下一个页面并删除以前所有的页面<br>类似 singleTop，启动页面需要指定路由名字</p><ul><li><p><strong>跳转页面</strong></p><ul><li>原生：<code>Navigator.pushNamed(...)</code></li><li>GetX：<code>Get.toNamed(...)</code></li></ul></li><li><p><strong>关闭直到指定页面</strong></p><ul><li>原生：<code>Navigator.popUntil(ModalRoute.withName(...))</code></li><li>GetX：<code>Get.until((route) =&gt; Get.currentRoute == ...)</code></li></ul></li></ul><p>普通路由 ：直接跳转页面<br>命名路由：给路由起名字Navigator.of(context).pushNamed(“&#x2F;search”);<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter_Tips.resources/2023/09/15/18-50-55-3b0f99cf218502c6f78faa83118d2604-unknown_filename.5-6e2193.png" alt="unknown_filename.5"></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2-Flutter 状态管理框架</title>
    <link href="/2025/12/3f084f516e6f.html"/>
    <url>/2025/12/3f084f516e6f.html</url>
    
    <content type="html"><![CDATA[<h2 id="声明式-UI"><a href="#声明式-UI" class="headerlink" title="声明式 UI"></a>声明式 UI</h2><p>声明式有哪些优势，并带来了哪些问题呢？</p><p><strong>优势: 让开发者摆脱组件的繁琐控制，聚焦于状态处理</strong></p><p>习惯 Flutter 开发之后，回到原生平台开发，你会发现当多个组件之间相互关联时，对于 View 的控制非常麻烦。</p><p>而在 Flutter 中我们只需要<em>处理好状态</em>即可 (复杂度转移到了状态 -&gt; UI 的映射，也就是 Widget 的构建)。包括 Jetpack Compose、Swift 等技术的最新发展，也是在朝着「声明式」的方向演进。</p><p><strong>声明式开发带来的问题</strong></p><p>没有使用状态管理，直接「声明式」开发的时候，遇到的问题总结有三个:</p><ul><li><p><strong>逻辑和 UI 耦合</strong> ✅<br>  直接在 <code>setState</code> 的组件里写逻辑，确实会造成难以复用、测试的问题。<br>  所以才有 Provider、Riverpod、Bloc 等框架，把逻辑和 UI 解耦。</p></li><li><p><strong>难以跨组件访问数据</strong> ✅<br>  Flutter 的 widget 是树形结构，默认数据传递只能一级一级传（父传子）。<br>  如果层级很深，就会很麻烦，这就是“状态提升”问题。<br>  所以才有 InheritedWidget &#x2F; Provider &#x2F; Riverpod。</p></li><li><p><strong>无法轻松控制刷新范围</strong> ❌（这个表述有点偏）</p><ul><li>setState 的确只能以 widget 为单位刷新，刷新的是“当前组件 + 子树”。</li><li>它不会全局刷新（不会动到整个页面）。</li><li>真正的问题是：如果你的 widget 太大，一个很小的状态变化就会导致整块 widget rebuild，性能会浪费。</li><li>状态管理框架能帮你把数据拆分、精准刷新，不需要重建大块 UI。</li></ul></li></ul><p>所以要使用状态管理框架</p><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p>setState的刷新范围，不是全局刷新。<br>setState 只会触发当前 Widget 及其子树的 build () 方法重新执行。</p><p>当调用 <code>setState</code> 方法时，Flutter 会标记当前的 Widget 为”dirty”，表示该 Widget 需要重新绘制。然后，Flutter 会在下一帧（即下一个绘制周期）中执行重绘操作。<br>在重绘过程中，Flutter 会使用 diff 算法来比较前后两次状态的差异，并只重新绘制发生变化的部分。这意味着，只有受到 <code>setState</code> 调用影响的部分会被重新绘制，而不是整个界面。</p><p>为什么小的状态变化导致较大范围的重建</p><h3 id="1-Flutter-的渲染机制"><a href="#1-Flutter-的渲染机制" class="headerlink" title="1. Flutter 的渲染机制"></a>1. Flutter 的渲染机制</h3><p>Flutter 是 <strong>声明式 UI</strong>：</p><ul><li>你在 <code>build()</code> 方法里声明 UI 的“长相”。</li><li>当 <code>setState</code> 触发时，框架会<strong>丢弃旧的 widget tree</strong>（当前组件和子树），重新执行 <code>build()</code> 得到一棵新的 widget tree。</li><li>然后 Flutter 的 <strong>Element tree</strong> 和 <strong>RenderObject tree</strong> 会做 diff，决定哪些节点需要真正重新渲染。<blockquote><p>也就是说，<strong>rebuild 的范围是 Widget 层（当前组件及子树）</strong>，但最终渲染层（RenderObject）可能会更小，因为 Flutter 做了优化。</p></blockquote></li></ul><h3 id="🔹-2-什么时候会“大范围重建”"><a href="#🔹-2-什么时候会“大范围重建”" class="headerlink" title="🔹 2. 什么时候会“大范围重建”"></a>🔹 2. 什么时候会“大范围重建”</h3><p>问题出在：<br><code>setState</code> 总是作用在<strong>当前 widget 及子树</strong>，所以如果 widget 设计不合理，哪怕只是一个小状态变化，也会导致整块 UI 重建。</p><p>举例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _BigPageState createState() =&gt; _BigPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_BigPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State&lt;BigPage&gt;</span> </span>&#123;<br>  int counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    print(<span class="hljs-string">&quot;BigPage build&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Scaffold</span>(<br>      appBar: <span class="hljs-type">AppBar</span>(title: <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Demo&quot;</span>)),<br>      body: <span class="hljs-type">Column</span>(<br>        children: [<br>          <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Counter: $counter&quot;</span>),<br>          <span class="hljs-type">ElevatedButton</span>(<br>            onPressed: () &#123;<br>              setState(() &#123;<br>                counter++;<br>              &#125;);<br>            &#125;,<br>            child: <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Add&quot;</span>),<br>          ),<br>          <span class="hljs-comment">// 下面还有很复杂的列表</span><br>          <span class="hljs-type">Expanded</span>(<br>            child: <span class="hljs-type">ListView</span>.builder(<br>              itemCount: <span class="hljs-number">1000</span>,<br>              itemBuilder: (_, i) =&gt; <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Item $i&quot;</span>),<br>            ),<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的问题</p><ul><li>我只是改了 <code>counter</code>，但是 <code>BigPage</code> 整个 <code>build()</code> 重新执行。</li><li>那个 <code>ListView.builder</code> 也被 rebuild（虽然 Flutter 会尽量复用 child，但 <code>itemBuilder</code> 还是会再次调用）。</li><li>如果 UI 很大，逻辑很重，就会性能浪费。</li></ul><h3 id="🔹-3-如何避免大范围重建"><a href="#🔹-3-如何避免大范围重建" class="headerlink" title="🔹 3. 如何避免大范围重建"></a>🔹 3. 如何避免大范围重建</h3><p>核心思想：<strong>拆分 widget，让状态尽量只影响局部</strong>。</p><p>改造上面例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> counter;<br>  <span class="hljs-keyword">const</span> CounterText(<span class="hljs-keyword">this</span>.counter);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CounterText build&quot;</span>);<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;Counter: <span class="hljs-subst">$counter</span>&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  _BigPageState createState() =&gt; _BigPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_BigPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">BigPage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;BigPage build&quot;</span>);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(title: Text(<span class="hljs-string">&quot;Demo&quot;</span>)),<br>      body: Column(<br>        children: [<br>          CounterText(counter), <span class="hljs-comment">// 单独拆分出去</span><br>          ElevatedButton(<br>            onPressed: () &#123;<br>              setState(() &#123;<br>                counter++;<br>              &#125;);<br>            &#125;,<br>            child: Text(<span class="hljs-string">&quot;Add&quot;</span>),<br>          ),<br>          Expanded(<br>            child: HeavyList(), <span class="hljs-comment">// 复杂列表单独做 widget</span><br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeavyList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HeavyList build&quot;</span>);<br>    <span class="hljs-keyword">return</span> ListView.builder(<br>      itemCount: <span class="hljs-number">1000</span>,<br>      itemBuilder: (_, i) =&gt; Text(<span class="hljs-string">&quot;Item <span class="hljs-subst">$i</span>&quot;</span>),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><ul><li>点按钮时，<code>BigPage</code> 和 <code>CounterText</code> 会 rebuild。</li><li>但 <code>HeavyList</code> <strong>不会重新 build</strong>，性能大幅优化。因为是 <em>StatelessWidget</em>，并且拆分出去了</li></ul><h3 id="🔹-4-总结"><a href="#🔹-4-总结" class="headerlink" title="🔹 4. 总结"></a>🔹 4. 总结</h3><p>👉 <strong>小状态变化导致大范围重建</strong>的情况：</p><ul><li>状态放在大组件里（页面级 State）。</li><li><code>setState</code> 导致整个大组件及其子树 rebuild。</li><li>子树里有很复杂的 UI，哪怕它没用到这个状态，也要被 rebuild。</li></ul><p>👉 <strong>解决方法</strong>：</p><ul><li><strong>拆分组件</strong>（局部 widget），减少无关 UI rebuild。</li><li>或者用 <strong>状态管理框架</strong>（Provider、Riverpod、Bloc 等）精准刷新。</li></ul><h2 id="fluuter-boost"><a href="#fluuter-boost" class="headerlink" title="fluuter_boost"></a>fluuter_boost</h2><p>fluuter_boost 跳转页面比较方法。api 统一（原生 flutter），有生命周期，好管理</p><p><a href="https://github.com/alibaba/flutter_boost/issues/1451">fluuter_boost3.0 不兼容最新的flutter版本，需要修改flutter_boost源码，暂时放弃该方案</a></p><p>FlutterBoost 是阿里开源的 <strong>Flutter 混合开发解决方案</strong>，主要解决 <strong>原生应用（Android&#x2F;iOS）与 Flutter 模块的集成问题</strong>。<br>FlutterBoost 的好处就是让 Flutter 像“原生页面”一样融入现有 App，解决路由、生命周期、引擎复用等问题，让混合开发变得平滑、高效。</p><p><strong>路由与原生一致</strong></p><ul><li>FlutterBoost 提供 <strong>统一的路由栈</strong>，支持原生跳 Flutter，Flutter 跳原生，Flutter 跳 Flutter。</li><li>开发者不用自己维护复杂的 <code>Navigator</code> 和原生交互。<br>👉 保证 Flutter 页面和原生页面一样被管理，不会出现返回栈混乱。</li></ul><h2 id="状态管理框架"><a href="#状态管理框架" class="headerlink" title="状态管理框架"></a>状态管理框架</h2><p><a href="https://juejin.cn/post/7094520232575762446">Flutter 状态管理框架 Provider 和 Get 分析</a></p><p><strong>解决逻辑和页面 UI 耦合问题</strong><br>我们知道 Dart 是一种单线程的模型，所以不存在多线程下对于对象访问的竞态问题。基于此 Get 借助一个全局单例的 Map 存储对象。通过依赖注入的方式，实现了对 Presenter 层的获取。这样在任意的类中都可以获取到 Presenter。</p><p><strong>解决难以跨组件 (跨页面) 访问数据的问题</strong></p><ul><li>全局单例，任意位置可以存取</li><li>存在类型重复，内存回收问题</li></ul><p> <strong>setState 引起不必要刷新的问题</strong><br> 在 Get 中，只需要提前调用 <code>Get.put</code> 方法存储 <code>Counter</code> 对象，为 <code>GetBuilder</code> 组件指定 <code>Counter</code> 作为泛型。因为 Get 基于单例，所以 <code>GetBuilder</code> 可以直接通过泛型获取到存入的对象，并在 builder 方法中暴露。这样 <code>Counter</code> 便与组件建立了监听关系，之后 <code>Counter</code> 的变动，只会驱动以它作为泛型的 <code>GetBuilder</code> 组件更新。<br> 下面详细解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GetxController</span> &#123; <br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123; <br>count++;<br>update(); <br>&#125;<br>&#125;<br><br><span class="hljs-comment">/// 提前进行存储</span><br><span class="hljs-type">final</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> Get.put(Counter( )); <br><br><span class="hljs-comment">/// 直接通过泛型获取存储好的实例</span><br>GetBuilder&lt;Counter&gt;(<br>builder: (Counter counter) =&gt; Text(<span class="hljs-string">&#x27;$&#123;counter.count&#125;&#x27;</span>) ); <br></code></pre></td></tr></table></figure><p><strong>Get 由于全局单例带来的问题</strong><br>Get 通过全局单例，默认以 <code>runtimeType</code> 为 key 进行对象的存储，部分场景可能获取到的对象不符合预期，例如商品详情页之间跳转。由于不同的详情页实例对应的是同一 Class，即 <code>runtimeType</code> 相同。如果不添加 tag 参数，在某个页面调用 <code>Get.find</code> 会获取到其它页面已经存储过的对象。同时 Get 中一定要注意<em>考虑到对象的回收</em>，不然很有可能引起内存泄漏。要么手动在页面 <code>dispose</code> 的时候做 <code>delete</code> 操作，要么完全使用 Get 中提供的组件，例如 <code>GetBuilder</code>，它会在 <code>dispose</code> 中释放。</p><h2 id="GetX使用"><a href="#GetX使用" class="headerlink" title="GetX使用"></a>GetX使用</h2><p><a href="https://juejin.cn/post/6924104248275763208#heading-0">Flutter GetX使用—简洁的魅力！ - 掘金</a></p><h3 id="GetxController"><a href="#GetxController" class="headerlink" title="GetxController"></a>GetxController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GetxController</span> &#123; <br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123; <br>count++;<br>update(); <br>&#125;<br>&#125;<br><br><span class="hljs-comment">/// 提前进行存储</span><br><span class="hljs-type">final</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> Get.put(Counter( )); <br><br><span class="hljs-comment">/// 直接通过泛型获取存储好的实例</span><br>GetBuilder&lt;Counter&gt;(<br>builder: (Counter counter) =&gt; Text(<span class="hljs-string">&#x27;$&#123;counter.count&#125;&#x27;</span>) ); <br></code></pre></td></tr></table></figure><h4 id="🔹-代码整体逻辑"><a href="#🔹-代码整体逻辑" class="headerlink" title="🔹 代码整体逻辑"></a>🔹 代码整体逻辑</h4><p>这是用 <strong>GetX</strong> 的 <strong><code>GetBuilder</code></strong> 做状态管理的典型写法。<br>核心思想</p><ul><li><code>Counter</code> 是一个继承 <strong><code>GetxController</code></strong> 的状态类。</li><li>你把 <code>Counter</code> 实例存到 GetX 的全局容器里（类似单例）。</li><li><code>GetBuilder&lt;Counter&gt;</code> 会去取这个 <code>Counter</code> 实例，并建立监听。</li><li>当 <code>Counter.update()</code> 被调用时，只有用到这个 <code>Counter</code> 的 <code>GetBuilder</code> 才会刷新。</li></ul><h4 id="🔹-逐行解释"><a href="#🔹-逐行解释" class="headerlink" title="🔹 逐行解释"></a>🔹 逐行解释</h4><h3 id="1-定义控制器"><a href="#1-定义控制器" class="headerlink" title="1. 定义控制器"></a>1. 定义控制器</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span> </span>&#123; <br>int count = <span class="hljs-number">0</span>;<br><br>void increase() &#123; <br>count++;<br>update(); <br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><code>Counter</code> 继承自 <code>GetxController</code>，说明它是一个 <strong>可管理的状态类</strong>。</li><li><code>count</code> 是状态数据。</li><li><code>increase()</code> 修改 <code>count</code>，然后调用 <code>update()</code>。<br>  👉 <code>update()</code> 会通知所有依赖这个控制器的 <code>GetBuilder</code> 组件去刷新。</li></ul><h3 id="2-存储控制器"><a href="#2-存储控制器" class="headerlink" title="2. 存储控制器"></a>2. 存储控制器</h3><p><code>final counter = Get.put(Counter());</code> </p><ul><li><code>Get.put()</code> 是 <strong>依赖注入（DI）</strong>。</li><li>这句话等价于：<strong>把一个 <code>Counter</code> 实例存到 GetX 的全局容器里</strong>，方便后续随时取用。</li><li>由于 GetX 默认是 <strong>单例模式</strong>，所以无论在哪个地方用 <code>Get.find&lt;Counter&gt;()</code>，得到的都是同一个 <code>Counter</code> 对象。</li></ul><h3 id="3-使用-GetBuilder-绑定-UI"><a href="#3-使用-GetBuilder-绑定-UI" class="headerlink" title="3. 使用 GetBuilder 绑定 UI"></a>3. 使用 <code>GetBuilder</code> 绑定 UI</h3><p><code>GetBuilder&lt;Counter&gt;(  builder: (Counter counter) =&gt; Text(&#39;$&#123;counter.count&#125;&#39;)  );</code></p><ul><li><code>GetBuilder&lt;Counter&gt;</code> 的泛型 <code>&lt;Counter&gt;</code> 告诉 GetX：<br>  👉 我要监听 <code>Counter</code> 这个控制器。</li><li><code>builder</code> 会传入存好的 <code>Counter</code> 实例（就是 <code>Get.put()</code> 存的那个）。</li><li>当 <code>counter.update()</code> 被调用时，<strong>只有这个 <code>GetBuilder&lt;Counter&gt;</code> 会刷新</strong>。</li><li>UI 更新：<code>Text(&#39;$&#123;counter.count&#125;&#39;)</code> 会显示最新的值。</li></ul><h4 id="🔹-和-setState-的区别"><a href="#🔹-和-setState-的区别" class="headerlink" title="🔹 和 setState 的区别"></a>🔹 和 <code>setState</code> 的区别</h4><ul><li><code>setState</code> 会重建 <strong>当前 Widget 及子树</strong>。</li><li><code>GetBuilder</code> 只会更新绑定了 <code>Counter</code> 的部分，<strong>精确更新</strong>，不影响其他 UI。</li><li>而且状态 <code>Counter</code> 是全局单例，多个页面&#x2F;组件都能共享。</li></ul><h4 id="🔹-总结一句话"><a href="#🔹-总结一句话" class="headerlink" title="🔹 总结一句话"></a>🔹 总结一句话</h4><blockquote><p><code>Get.put(Counter())</code> 把状态对象存起来，<br><code>GetBuilder&lt;Counter&gt;</code> 绑定到这个状态，<br>当 <code>Counter.update()</code> 被调用时，只有依赖它的 <code>GetBuilder</code> 会刷新。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1-Flutter分享</title>
    <link href="/2025/12/5a1b7f6ccf87.html"/>
    <url>/2025/12/5a1b7f6ccf87.html</url>
    
    <content type="html"><![CDATA[<h2 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h2><p>Flutter 是 Google 推出并开源的移动应用开发框架，帮助开发者通过一套代码库高效构建多平台应用，支持 iOS、Android、Web、Windows、macOS、Linux、Fuchsia</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>跨平台：增加代码复用，降低开发成本</li><li>性能：Flutter直接将Dart代码编译为本地代码运行，再调用skia绘图引擎代码，和原生一样，这就少了像reactnative和weex等先转为原生控件，再系统渲染的步骤</li><li>热重载：修改完代码后 Ctrl+S 就能实时展现在真机界面上，不需要重新安装 apk 包，提高开发效率<br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-e8d2e77f520506b752d8a9130e7640d7-unknown_filename.3-1a3545.jpeg" alt="unknown_filename.3"><br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-c7f897332af05e9f9fa1136e521e8bc1-unknown_filename.4-6722b6.png" alt="unknown_filename.4"></li></ol><h3 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h3><p><strong>Impeller</strong> 是 Flutter 团队新开发的 **渲染引擎 (renderer)**，专门替代之前的 <strong>Skia 渲染管线</strong>。</p><ul><li>目标是 <strong>更低的延迟、更流畅的动画、更稳定的性能</strong>。</li><li>特别是为了解决 <strong>iOS 上的 jank（掉帧卡顿）</strong> 问题。</li></ul><table><thead><tr><th>对比点</th><th>Skia (旧)</th><th>Impeller (新)</th></tr></thead><tbody><tr><td><strong>渲染管线</strong></td><td>通用 2D 引擎（Skia）</td><td>Flutter 专属优化管线</td></tr><tr><td><strong>Shader</strong></td><td>运行时编译 → 可能掉帧</td><td>预编译 shader，无需运行时编译</td></tr><tr><td><strong>平台支持</strong></td><td>OpenGL &#x2F; Metal &#x2F; Vulkan（跨平台）</td><td>目前主要支持 Metal (iOS)、Vulkan (Android 部分设备)，逐步扩展</td></tr><tr><td><strong>性能</strong></td><td>动画掉帧可能性高，尤其在 iOS</td><td>更低延迟，几乎无 shader jank</td></tr><tr><td><strong>稳定性</strong></td><td>已经很成熟，但 Flutter 需要做额外适配</td><td>更适配 Flutter 绘制模型（比如曲线、图层合成等）</td></tr><tr><td><strong>目标</strong></td><td>通用图形库</td><td>专为 Flutter 设计的渲染后端</td></tr><tr><td>![[Pasted image 20250917102231.png]]</td><td></td><td></td></tr></tbody></table><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.脱离不开原生，一些功能不支持，需要原生开发<br>2.适配问题，可能会有各种各样的适配问题<br>3.基础库不完善，需要自己写</p><p>在现阶段，开始尝试探索和积累沉淀 Flutter 技术能力，逐步的完善，flutter还是值得尝试一下的，毕竟研发效率就是竞争力。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>现在的很多 app 都有进行 flutter 的功能，这是“国内大厂应用在移动端 Flutter 框架使用分析”，地址链接：<a href="https://juejin.cn/post/7012382656578977806">https://juejin.cn/post/7012382656578977806</a>。</p><h2 id="常用网址"><a href="#常用网址" class="headerlink" title="常用网址"></a>常用网址</h2><p><a href="https://flutter.cn/docs">Flutter 开发文档</a></p><p><a href="https://book.flutterchina.club/">Flutter实战</a></p><p><a href="https://www.dartcn.com/guides/language/language-tour">Dart 编程语言概览</a></p><p><a href="https://pub.flutter-io.cn/">pub仓库</a></p><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>Activity、Fragment、view 在 Flutter 中等价于 Widget.</p><p><strong>与 Android view 区别</strong></p><ul><li>Android 中 View 是可变的，当用户交互或数据更新时，可直接调用 View 的 invalidate 方法重绘，达到更新 UI 的目的。</li><li>Flutter 的 widget 是不可改变的因此不能直接更新，而必须使用 Widget 的状态。Flutter 的 widget 分为有状态和无状态两种。</li></ul><h4 id="Stateful-widgets"><a href="#Stateful-widgets" class="headerlink" title="Stateful widgets"></a>Stateful widgets</h4><p>Stateless widgets 是不可变的, 这意味着它们的属性不能改变，<strong>所有的值都是最终的.</strong><br>Stateful widgets（有状态的部件） 持有的状态可能在 widget 生命周期中发生变化. 实现一个 stateful widget 至少需要两个类:</p><ol><li>一个 StatefulWidget 类。</li><li>一个 State 类。 StatefulWidget 类本身是不变的，但是 <em>State 类在 widget 生命周期中始终存在</em>.</li></ol><p>stateful widget 将自身的构建委托给 State 对象，<em>State 对象的 build 函数负责构建该 Widget</em>，当用户交互或数据发生变化时，Widget 状态发生改变，调用 State 的 <code>setState</code> 方法通知它，而后 State 根据当前的状态信息，重新构建 Widget tree</p><ul><li>在 Android 中，您可以从父级控件调用 addChild 或 removeChild 以动态添加或删除 View。在 Flutter 中，因为 widget 是不可变的，所以没有 addChild。相反，您可以传入一个函数，该函数返回一个 widget 给父项，并通过 <em>布尔值控制该 widget 的创建</em></li><li>在 Flutter 中，一个自定义 widget 通常是通过组合其它 widget 来实现的，而不是继承</li><li>某些 widget 属性需要单个 widget（child），而其它一些属性，如 action，需要一组 widgets (children），用方括号[]表示。</li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li><strong>初始化</strong>：<code>initState()</code></li><li><strong>依赖变化</strong>：<code>didChangeDependencies()</code></li><li><strong>构建 UI</strong>：<code>build()</code></li><li><strong>更新时机</strong>：<code>didUpdateWidget()</code></li><li><strong>销毁</strong>：<code>dispose()</code><br>👉 一句话总结：<br><strong>StatefulWidget 生命周期 &#x3D; initState → build → (setState → build 循环) → dispose</strong></li></ul><p>这里的重点是 <strong>StatefulWidget</strong>，因为 StatelessWidget 没有生命周期，只有一次 build。</p><p> <strong>Flutter 生命周期分层</strong><br>在 Flutter 里，生命周期不是 Widget 本身，而是 <strong>State 对象</strong>的生命周期</p><ul><li><strong>Widget</strong>：描述 UI 的配置数据，不可变（immutable）。</li><li><strong>Element</strong>：Widget 在 Widget Tree 里的位置表示，负责管理 Widget 和 RenderObject。</li><li><strong>State</strong>：和 StatefulWidget 绑定，保存可变状态，生命周期由框架管理。</li></ul><p>所以我们平时说的“生命周期”，其实就是 <strong>State 的生命周期</strong>。</p><p><strong>statefulWidget 的生命周期方法</strong></p><p><strong>创建阶段</strong></p><ol><li><p><strong><code>createState()</code></strong></p><ul><li>在 StatefulWidget 创建时调用，只执行一次。</li><li>返回一个 <code>State</code> 对象。</li></ul></li><li><p><strong><code>initState()</code></strong></p><ul><li>在 State 对象插入到树中时调用（只执行一次）。</li><li>常用于初始化数据、订阅事件、启动动画。</li><li>⚠️ 不能在这里调用 <code>BuildContext</code> 依赖 InheritedWidget 的东西（比如 <code>Theme.of(context)</code>），因为 State 还没完全挂到树上。</li></ul></li></ol><p><strong>依赖变化阶段</strong><br> <strong><code>didChangeDependencies()</code></strong><br>    - 在 <code>initState()</code> 之后立即调用一次。<br>    - 当依赖的 InheritedWidget（如 Theme、Locale）发生变化时再次调用。<br>    - 可以安全地使用 <code>BuildContext</code>。</p><p><strong>构建阶段</strong><br><strong><code>build(BuildContext context)</code></strong><br>    - Widget 的核心方法。<br>    - 每次调用 <code>setState()</code>，都会重新执行 build()，重新构建 UI。<br>    - ⚠️ 这里只应该做 UI 构建，避免耗时操作。</p><p><strong>更新阶段</strong><br><strong><code>didUpdateWidget(covariant OldWidget oldWidget)</code></strong><br>    - 当父组件重建时，如果传给当前 Widget 的配置数据发生变化，会触发这个方法。<br>    - 适合在这里比较新旧 Widget 的差异，并做相应更新。</p><p><strong>销毁阶段</strong><br><strong><code>deactivate()</code></strong><br>    - 当 State 从树中移除时调用。<br>    - 可能会再次插入树中（比如在 TabBar 切换时），所以不是最终销毁。</p><p><strong><code>dispose()</code></strong><br>    - 当 State 被永久移除时调用。<br>    - 用于释放资源：取消订阅、关闭 AnimationController、清理 Timer 等。<br>    - ⚠️ 调用后，这个 State 就不再可用。</p><h3 id="常用Widget和属性"><a href="#常用Widget和属性" class="headerlink" title="常用Widget和属性"></a>常用Widget和属性</h3><ul><li><p>Container：父 view，宽高、背景色、圆角、margin</p></li><li><p>Padding：EdgeInsets. fromLTRB</p></li><li><p>Center：居中</p></li><li><p>TextField：输入框（TextEditingController）</p></li><li><p>Expanded：填充剩余布局，组件有个参数 flex, 可以实现比例分配。<br>  height 如果不设置界面显示会有问题，如果要设置，又不能准确的计算出结果, 可以使用 Expanded</p></li><li><p>BoxDecoration: 圆角，需要放在 Container 里，实现边框、圆角、阴影、形状、渐变、背景图像</p></li><li><p>ShapeDecoration: 实现四个边分别指定颜色和宽度、底部线、矩形边色、圆形边色、体育场（竖向椭圆）、角形（八边角）边色</p></li><li><p>UnderlineTabindicator: 下划线</p></li><li><p>EdgeInsets. only<br>  symmetric ({vertical, horizontal})：用于设置对称方向的填充，vertical 指 top 和 bottom，horizontal 指 left 和 right。</p></li><li><p>Flutter 中官方提供 CustomScrollView，让我们能够作何 Appbar 折叠的效果，并且很容易就能实现下拉刷新和加载更多。</p></li><li><p>dialog 高度设置不生效将 showBottomsheet 更换成 showAdjustableBottomSheet</p></li><li><p>MediaQuery. removePadding 可以移除组件的边距，有些组件自带有边距</p></li><li><p>expenand 必须和 colum 或 row 一起用，否则 debug 能运行，release 报错。</p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">RichText</span>(<span class="hljs-attribute">text</span>: <span class="hljs-built_in">TextSpan</span>(<br>                <span class="hljs-attribute">children</span>: [<br>                   <span class="hljs-built_in">TextSpan</span>(<br>                     <span class="hljs-attribute">text</span>:<span class="hljs-string">&quot;*&quot;</span>,<br>                     <span class="hljs-attribute">style</span>: <span class="hljs-built_in">TextStyle</span>(<span class="hljs-attribute">color</span>: <span class="hljs-attribute">Color</span>.colorAuxRedColor, <span class="hljs-attribute">fontSize</span>: <span class="hljs-number">15</span>)<br>                   ),<br>                  <span class="hljs-built_in">TextSpan</span>(<br>                      <span class="hljs-attribute">text</span>:<span class="hljs-string">&quot;你好&quot;</span>,<br>                      <span class="hljs-attribute">style</span>: <span class="hljs-built_in">TextStyle</span>(<span class="hljs-attribute">color</span>: <span class="hljs-attribute">Color</span>.colorText222<span class="hljs-attribute">Color</span>, <span class="hljs-attribute">fontSize</span>: <span class="hljs-number">15</span>)<br>                  )<br>                ]<br>            )),<br>           <br><br><br> <span class="hljs-selector-tag">Visibility</span>(<br>   <span class="hljs-attribute">visible</span>: true,<br>   <span class="hljs-comment">//是否保持占位</span><br>   <span class="hljs-attribute">maintainState</span>: false,<br>   <span class="hljs-attribute">child</span>: <span class="hljs-built_in">Text</span>(<span class="hljs-string">&quot;显示&quot;</span>),<br> ),<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-725fd7b1edf17b0af4da1c2abb2c2729-unknown_filename.6-d3375e.png" alt="unknown_filename.6"></p><h4 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h4><ul><li>在 Flutter 中，添加触摸监听器有两种方法: 如果 Widget 支持事件监听，则可以将一个函数传递给它并进行处理。例如，RaisedButton 有一个 onPressed 参数</li><li>如果 Widget 不支持事件监听，则可以将该 Widget 包装到 GestureDetector 中，并将处理函数传递给 onTap 参数。</li><li>InkWell：点击，和 GestureDetector区别，即使 InkWell 没有子控件，它仍然可以响应点击操作并执行相应的操作或触发回调函数。</li></ul><h4 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h4><p>MaterialApp 是我们使用 Flutter 开发中最常用的符合 Material Design 设计理念的入口 Widget。你可以将它类比成为网页中的</html></html>，且它自带路由、主题色，&lt;\title&gt;等功能。</p><h4 id="banner-list-三种实现方式"><a href="#banner-list-三种实现方式" class="headerlink" title="banner+list 三种实现方式"></a>banner+list 三种实现方式</h4><p>listView  <br>CustomScrollView <br>ScrollView<br>SingleChildScrollView</p><h4 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h4><p><code>Scaffold</code> 翻译过来就是 <strong>“脚手架”</strong>，在 Flutter 里它是一个 <strong>Material Design 风格的页面框架容器</strong>。</p><ul><li>提供一个<strong>标准页面的结构</strong>（AppBar、Drawer、BottomNavigationBar、FloatingActionButton、SnackBar 等）。</li><li>你只需要把页面主体内容 (<code>body</code>) 填进去，就能很快得到一个完整的 Material 风格页面。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> Scaffold(&#123;<br>  Key key,<br>  <span class="hljs-keyword">this</span>.appBar, <span class="hljs-comment">// 标题栏</span><br>  <span class="hljs-keyword">this</span>.body,  <span class="hljs-comment">// 用于显示当前界面主要内容的Widget</span><br>  <span class="hljs-keyword">this</span>.floatingActionButton, <span class="hljs-comment">// 一个悬浮在body上的按钮，默认显示在右下角</span><br>  <span class="hljs-keyword">this</span>.floatingActionButtonLocation, <span class="hljs-comment">// 用于设置floatingActionButton显示的位置</span><br>  <span class="hljs-keyword">this</span>.floatingActionButtonAnimator, <span class="hljs-comment">// floatingActionButton移动到一个新的位置时的动画</span><br>  <span class="hljs-keyword">this</span>.persistentFooterButtons, <span class="hljs-comment">// 多状态按钮</span><br>  <span class="hljs-keyword">this</span>.drawer, <span class="hljs-comment">// 左侧的抽屉菜单</span><br>  <span class="hljs-keyword">this</span>.endDrawer, <span class="hljs-comment">//  右&#x27;侧的抽屉菜单</span><br>  <span class="hljs-keyword">this</span>.bottomNavigationBar,<span class="hljs-comment">// 底部导航栏。</span><br>  <span class="hljs-keyword">this</span>.bottomSheet, <span class="hljs-comment">// 显示在底部的工具栏</span><br>  <span class="hljs-keyword">this</span>.backgroundColor,<span class="hljs-comment">// 内容的背景颜色</span><br>  <span class="hljs-keyword">this</span>.resizeToAvoidBottomPadding = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 控制界面内容 body 是否重新布局来避免底部被覆盖，比如当键盘显示的时候，重新布局避免被键盘盖住内容。</span><br>  <span class="hljs-keyword">this</span>.primary = <span class="hljs-literal">true</span>,<span class="hljs-comment">// Scaffold是否显示在页面的顶部</span><br>&#125;) <br><br></code></pre></td></tr></table></figure><h4 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h4><ul><li>一般是用来限制孩子控件的大小。</li><li>还有这么一种场景也可以使用SizeBox，就是可以代替padding和container，然后 用来设置两个控件之间的间距，比如在行或列中就可以设置两个控件之间的间距 主要是可以比使用一个padding或者container简单方便 （在Flutter中可能用不同的控件可以实现到相同的目的，尽量使用越简单的widget来实现）</li><li>控件在整个手机屏幕中间对齐：ConstrainedBox、SizedBox、Center</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Flutter 中通过 Row 和 Column 来实现线性布局，类似于 Android 中的 LinearLayout 控件<br><strong>row 水平，Column 竖直</strong></p><ul><li>对于线性布局，有主轴和纵轴之分，如果布局是沿水平方向，那么主轴就是指水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类 MainAxisAlignment 和 CrossAxisAlignment，分别代表主轴对齐和纵轴对齐。</li><li>mainAxisSize：表示 Row 在主轴 (水平) 方向占用的空间，默认是 MainAxisSize. max，表示尽可能多的占用水平方向的空间，此时无论子 widgets 实际占用多少水平空间，Row 的宽度始终等于水平方向的最大宽度；</li><li>而 MainAxisSize. min 表示尽可能少的占用水平空间，<em>当子组件没有占满水平剩余空间，则 Row 的实际宽度等于所有子组件占用的的水平空间</em></li><li>Row 和 Column <em>都只会在主轴方向占用尽可能大的空间</em>，而纵轴的长度则取决于他们最大子元素的长度</li><li>如果 Row 里面嵌套 Row，或者 Column 里面再嵌套 Column，那么<em>只有最外面的 Row 或 Column 会占用尽可能大的空间，里面 Row 或 Column 所占用的空间为实际大小</em> [[3-Flutter工作tips#约束]]</li></ul><p>Stack 类似 FrameLayout 很像，都是可以叠加的现实 View<br>flutter 中默认组件尺寸单位都是<em>dp</em><br>double. infinity，可以使宽度占用尽可能多的空间</p><p>当我们使用行（row）的时候，子组件常常因为高度的不同，导致各个子组件里面的内容不能对齐。这个时候我们可以使用 <strong>IntrinsicHeight</strong> 来保持 row 中各个子组件高度一致，从而便于纵向居中对齐。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MainAxisAlignment</span> &#123;<br> <span class="hljs-comment">//将子控件放在主轴的开始位置</span><br>  start,  <br>   <span class="hljs-comment">//将子控件放在主轴的结束位置</span><br>  end,<br>  <span class="hljs-comment">//将子控件放在主轴的中间位置</span><br>  center,<br>  <span class="hljs-comment">//将主轴空白位置进行均分，排列子元素，手尾没有空隙</span><br>  spaceBetween,<br>  <span class="hljs-comment">//将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距为中间子控件间距的一半</span><br>  spaceAround,<br>  <span class="hljs-comment">//将主轴空白区域均分，使各个子控件间距相等</span><br>  spaceEvenly,<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Dart语法"><a href="#Dart语法" class="headerlink" title="Dart语法"></a>Dart语法</h2><p>main函数使用了(&#x3D;&gt;)符号, 这是Dart中单行函数或方法的简写。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">// =&gt;是<span class="hljs-keyword">return</span>语句的简写<br>add3(a, b) =&gt; a + b; <br></code></pre></td></tr></table></figure><p>变量以下划线（_）开头，在Dart语言中使用下划线前缀标识符，会强制其变成私有的。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>[[5-线程异步多订阅]]</p><h3 id="JSON-转-Bean"><a href="#JSON-转-Bean" class="headerlink" title="JSON 转 Bean"></a>JSON 转 Bean</h3><p><a href="https://app.quicktype.io/">自动生成实体类</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;greeting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Welcome to quicktype!&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;instructions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;Type or paste JSON here&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;Or choose a sample above&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;quicktype will generate code in your&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;chosen language to parse the sample data&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>fromJson</em> map 转对象<br><em>toJson</em> 对象转 map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><br>Welcome <span class="hljs-title function_">welcomeFromJson</span><span class="hljs-params">(String str)</span> =&gt; Welcome.fromJson(json.decode(str));<br><br>String <span class="hljs-title function_">welcomeToJson</span><span class="hljs-params">(Welcome data)</span> =&gt; json.encode(data.toJson());<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> &#123;<br>    String greeting;<br>    List&lt;String&gt; instructions;<br><br>    Welcome(&#123;<br>        required <span class="hljs-built_in">this</span>.greeting,<br>        required <span class="hljs-built_in">this</span>.instructions,<br>    &#125;);<br><br>    factory Welcome.fromJson(Map&lt;String, dynamic&gt; json) =&gt; Welcome(<br>        greeting: json[<span class="hljs-string">&quot;greeting&quot;</span>],<br>        instructions: List&lt;String&gt;.from(json[<span class="hljs-string">&quot;instructions&quot;</span>].map((x) =&gt; x)),<br>    );<br><br>    Map&lt;String, dynamic&gt; <span class="hljs-title function_">toJson</span><span class="hljs-params">()</span> =&gt; &#123;<br>        <span class="hljs-string">&quot;greeting&quot;</span>: greeting,<br>        <span class="hljs-string">&quot;instructions&quot;</span>: List&lt;dynamic&gt;.from(instructions.map((x) =&gt; x)),<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="状态管理框架"><a href="#状态管理框架" class="headerlink" title="状态管理框架"></a>状态管理框架</h3><p>[[2-Flutter 状态管理框架]]</p><h3 id="集成成-Android-项目："><a href="#集成成-Android-项目：" class="headerlink" title="集成成 Android 项目："></a>集成成 Android 项目：</h3><p>android:exported&#x3D;”true”</p><ol><li>flutter create -t module flutter_module</li><li>打开 android 项目 settings. gradle，将<br> module 才有这个文件：include_flutter. groovy</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">rootProject.name = <span class="hljs-string">&quot;NativeInFlutter&quot;</span><br>include <span class="hljs-string">&#x27;:app&#x27;</span><br>include <span class="hljs-string">&#x27;:flutter_module&#x27;</span><br>setBinding(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Binding</span>([gradle: <span class="hljs-built_in">this</span>]))<br>evaluate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(settingsDir.parentFile, <span class="hljs-string">&#x27;NativeInFlutter/flutter_module/.android/include_flutter.groovy&#x27;</span><br>))<br></code></pre></td></tr></table></figure><p>这也得改 allprojects</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">buildscript &#123;<br>    repositories &#123;<br>        google()<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:7.0.0&quot;</span><br>    &#125;<br>&#125;<br>allprojects &#123;<br>    repositories &#123;<br>        google()<br>        jcenter()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>app 下 build 加：implementation project (‘: flutter’)</li></ol><h3 id="项目如何使用"><a href="#项目如何使用" class="headerlink" title="项目如何使用"></a>项目如何使用</h3><p>flutter仓库地址：<br>代码clone到与Android工程同级目录</p><p>Android目前有两种依赖方式：<br>本地依赖（适用于开发调试阶段）<br>配置文件repo_projects.xml中，打开下面这行</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;project name<span class="hljs-operator">=</span><span class="hljs-string">&quot;publication/app_ta_flutter.git&quot;</span> path<span class="hljs-operator">=</span><span class="hljs-string">&quot;app_ta_flutter&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>远程依赖（适用打包或flutter功能稳定阶段）<br>配置repo_projects.xml中，注释下面这行</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;project name<span class="hljs-operator">=</span><span class="hljs-string">&quot;publication/app_ta_flutter.git&quot;</span> path<span class="hljs-operator">=</span><span class="hljs-string">&quot;app_ta_flutter&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>开发完后，提测或者上线，需要将 flutter 代码打包。目前已经支持了 jenkins 上自动打包 flutter，上传 maven，然后修改配置仓库，增加版本号，接着 push 代码，自动化打包。</p><p>jenkins打包地址：<a href="http://10.14.200.4:8880/jenkins_app/view/%E5%9B%BE%E4%B9%A6%E5%87%BA%E7%89%88/job/android/job/lib/job/app_ta_flutter/build?delay=0sec">http://10.14.200.4:8880/jenkins_app&#x2F;view&#x2F;图书出版&#x2F;job&#x2F;android&#x2F;job&#x2F;lib&#x2F;job&#x2F;app_ta_flutter&#x2F;build?delay&#x3D;0sec</a></p><p>红框必选，其他不用写，选择完后点build<br>BUSINESS_BRANCH：选自己的开发的flutter功能对应的分支<br>PROPERTIES_BRANCH：要更新到哪个配置仓库的分支<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-cf4f336024517a44ecb86357136209e5-unknown_filename.9-bc25d6.png" alt="unknown_filename.9"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>先把 APP 杀死，在启动过程中 attach，可以先点这个</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-982887bf79e874c365e0e976d9b65cfb-unknown_filename-cd3c15.png" alt="unknown_filename"><br>出现下面这个就可以调试了<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-70dcdae8bb2ab83b9caf4a479903142d-unknown_filename.1-7c4e32.png" alt="unknown_filename.1"></p><h3 id="使用‘尾随逗号’"><a href="#使用‘尾随逗号’" class="headerlink" title="使用‘尾随逗号’"></a>使用‘尾随逗号’</h3><p>Flutter代码通常涉及构建相当深的树状数据结构，例如在一个build方法中。 为了获得良好的自动格式化，我们建议您采用可选的尾部逗号。添加尾随逗号很简单：始终在函数、方法和构造函数的参数列表末尾添加尾随逗号，以便保留您的编码格式。 这将有助于自动格式化程序为Flutter样式代码插入适当的换行符。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-33a45fb9c21b02a3c3d426222e90433c-unknown_filename.2-f5e831.png" alt="unknown_filename.2"></p><h3 id="两个好用的图片插件"><a href="#两个好用的图片插件" class="headerlink" title="两个好用的图片插件"></a>两个好用的图片插件</h3><p>FlutterQuickLocateAsset<br>FlutterAssetAutoCompletion</p><h3 id="使用自定义模板"><a href="#使用自定义模板" class="headerlink" title="使用自定义模板"></a>使用自定义模板</h3><p>提高开发效率<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-603dea0f15cbf2b8f4276c93a057db06-unknown_filename.8-395c38.png" alt="unknown_filename.8"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Flutter%E5%88%86%E4%BA%AB.resources/2023/09/18/16-04-29-ee8e403c6ab9790340a9eba9a168b4c9-unknown_filename.7-4c0965.png" alt="unknown_filename.7"></p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4-和原生混用</title>
    <link href="/2025/12/7366689dcdfe.html"/>
    <url>/2025/12/7366689dcdfe.html</url>
    
    <content type="html"><![CDATA[<h2 id="互相调用"><a href="#互相调用" class="headerlink" title="互相调用"></a>互相调用</h2><p><a href="https://developer.android.com/jetpack/compose/interop/interop-apis?hl=zh-cn">Interoperability API  |  Jetpack Compose  |  Android Developers</a></p><p><a href="https://www.cnblogs.com/mengdd/p/Jetpack-Compose-Interoperability.html">Jetpack Compose和View的互操作性 - 圣骑士wind - 博客园</a></p><p>Compose 和 View 的结合, 主要是靠两个桥梁.<br>还挺有趣的:</p><ul><li><code>ComposeView</code> 其实是个 Android View.</li><li><code>AndroidView</code> 其实是个 Composable 方法.</li></ul><p>Compose 和 View 可以互相兼容的特点保证了项目可以逐步迁移, 并且也给够了安全感, 像极了当年 java 项目迁移 kotlin，至于什么学习曲线, 经验不足, 反正早晚都要学的, 整点新鲜的也挺好</p><h2 id="混用方案概览"><a href="#混用方案概览" class="headerlink" title="混用方案概览"></a>混用方案概览</h2><p>主要有两种混用方向：</p><ol><li><p><strong>在原生页面中使用 Compose</strong>（更常见）</p></li><li><p><strong>在 Compose 页面中使用原生 View</strong></p></li></ol><h2 id="一、在原生页面中使用-Compose（你的场景）"><a href="#一、在原生页面中使用-Compose（你的场景）" class="headerlink" title="一、在原生页面中使用 Compose（你的场景）"></a>一、在原生页面中使用 Compose（你的场景）</h2><p>这是最常见的迁移路径：保持现有的 Activity&#x2F;Fragment，只在部分区域使用 Compose。</p><h3 id="核心-API：ComposeView"><a href="#核心-API：ComposeView" class="headerlink" title="核心 API：ComposeView"></a>核心 API：<code>ComposeView</code></h3><p><code>ComposeView</code> 是一个 Android View，可以在 XML 布局或代码中使用，它内部可以承载 Compose UI。</p><h4 id="方式-1：在-XML-布局中使用"><a href="#方式-1：在-XML-布局中使用" class="headerlink" title="方式 1：在 XML 布局中使用"></a>方式 1：在 XML 布局中使用</h4><p><strong>XML 布局 (<code>activity_main.xml</code>):</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 传统的 TextView --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/title_text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;这是原生标题&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 传统的 Button --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/native_button&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;原生按钮&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Compose 区域 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.compose.ui.platform.ComposeView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/compose_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>Activity 代码:</strong></p><p>kotlin</p><p>class MainActivity : AppCompatActivity() {<br>    override fun onCreate(savedInstanceState: Bundle?) {<br>        super.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)</p><pre><code class="hljs">    // 操作原生 View    findViewById&lt;Button&gt;(R.id.native_button).setOnClickListener &#123;        Toast.makeText(this, &quot;原生按钮点击&quot;, Toast.LENGTH_SHORT).show()    &#125;        // 设置 Compose 内容    val composeView = findViewById&lt;ComposeView&gt;(R.id.compose_view)    composeView.setContent &#123;        // 这里是 Compose 的世界        MyComposableContent(&quot;来自原生的参数&quot;)    &#125;&#125;</code></pre><p>}</p><p>@Composable<br>fun MyComposableContent(message: String) {<br>    var count by remember { mutableStateOf(0) }</p><pre><code class="hljs">Column(    modifier = Modifier        .fillMaxSize()        .padding(16.dp),    verticalArrangement = Arrangement.Center,    horizontalAlignment = Alignment.CenterHorizontally) &#123;    Text(text = &quot;这是 Compose 组件&quot;)    Text(text = &quot;消息: $message&quot;)    Text(text = &quot;计数: $count&quot;)    Button(onClick = &#123; count++ &#125;) &#123;        Text(&quot;Compose 按钮&quot;)    &#125;&#125;</code></pre><p>}</p><h4 id="方式-2：在代码中动态添加"><a href="#方式-2：在代码中动态添加" class="headerlink" title="方式 2：在代码中动态添加"></a>方式 2：在代码中动态添加</h4><p>kotlin</p><p>class MainActivity : AppCompatActivity() {<br>    override fun onCreate(savedInstanceState: Bundle?) {<br>        super.onCreate(savedInstanceState)</p><pre><code class="hljs">    val composeView = ComposeView(this).apply &#123;        setContent &#123;            MyComposableContent()        &#125;    &#125;        // 添加到现有的 ViewGroup 中    val root = LinearLayout(this).apply &#123;        orientation = LinearLayout.VERTICAL        addView(TextView(this@MainActivity).apply &#123;            text = &quot;原生 TextView&quot;        &#125;)        addView(composeView)    &#125;        setContentView(root)&#125;</code></pre><p>}</p><h3 id="通信：原生与-Compose-的数据传递"><a href="#通信：原生与-Compose-的数据传递" class="headerlink" title="通信：原生与 Compose 的数据传递"></a>通信：原生与 Compose 的数据传递</h3><h4 id="1-原生-→-Compose：通过参数传递"><a href="#1-原生-→-Compose：通过参数传递" class="headerlink" title="1. 原生 → Compose：通过参数传递"></a>1. 原生 → Compose：通过参数传递</h4><p>kotlin</p><p>&#x2F;&#x2F; 在 Activity 中<br>var currentTheme &#x3D; “Light”</p><p>composeView.setContent {<br>    &#x2F;&#x2F; 将原生数据作为参数传递给 Compose<br>    MyComposableContent(theme &#x3D; currentTheme)<br>}</p><p>&#x2F;&#x2F; 改变主题<br>fun changeTheme(theme: String) {<br>    currentTheme &#x3D; theme<br>    &#x2F;&#x2F; 需要重新设置 Compose 内容或使用状态管理<br>    composeView.setContent {<br>        MyComposableContent(theme &#x3D; currentTheme)<br>    }<br>}</p><h4 id="2-Compose-→-原生：通过回调接口"><a href="#2-Compose-→-原生：通过回调接口" class="headerlink" title="2. Compose → 原生：通过回调接口"></a>2. Compose → 原生：通过回调接口</h4><p>kotlin</p><p>class MainActivity : AppCompatActivity() {<br>    override fun onCreate(savedInstanceState: Bundle?) {<br>        super.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)</p><pre><code class="hljs">    val composeView = findViewById&lt;ComposeView&gt;(R.id.compose_view)    composeView.setContent &#123;        MyComposableContent(            onButtonClick = &#123; message -&gt;                // Compose 中发生的事件回调到原生                Toast.makeText(this, &quot;Compose 说: $message&quot;, Toast.LENGTH_SHORT).show()                // 可以操作其他原生 View                findViewById&lt;TextView&gt;(R.id.title_text).text = &quot;收到: $message&quot;            &#125;        )    &#125;&#125;</code></pre><p>}</p><p>@Composable<br>fun MyComposableContent(onButtonClick: (String) -&gt; Unit) {<br>    Button(onClick &#x3D; {<br>        onButtonClick(“Hello from Compose!”)<br>    }) {<br>        Text(“通知原生”)<br>    }<br>}</p><h2 id="二、在-Compose-中使用原生-View"><a href="#二、在-Compose-中使用原生-View" class="headerlink" title="二、在 Compose 中使用原生 View"></a>二、在 Compose 中使用原生 View</h2><h3 id="核心-API：AndroidView"><a href="#核心-API：AndroidView" class="headerlink" title="核心 API：AndroidView"></a>核心 API：<code>AndroidView</code></h3><p>kotlin</p><p>@Composable<br>fun WebViewComposable(url: String) {<br>    AndroidView(<br>        factory &#x3D; { context -&gt;<br>            &#x2F;&#x2F; 创建原生 View<br>            WebView(context).apply {<br>                layoutParams &#x3D; ViewGroup.LayoutParams(<br>                    ViewGroup.LayoutParams.MATCH_PARENT,<br>                    ViewGroup.LayoutParams.WRAP_CONTENT<br>                )<br>                webViewClient &#x3D; WebViewClient()<br>            }<br>        },<br>        update &#x3D; { webView -&gt;<br>            &#x2F;&#x2F; 当参数变化时更新<br>            webView.loadUrl(url)<br>        }<br>    )<br>}</p><p>&#x2F;&#x2F; 使用<br>@Composable<br>fun MyScreen() {<br>    Column {<br>        Text(“这是 Compose 文本”)<br>        WebViewComposable(“<a href="https://www.example.com/">https://www.example.com</a>“)<br>        Button(onClick &#x3D; { &#x2F;* … *&#x2F; }) {<br>            Text(“Compose 按钮”)<br>        }<br>    }<br>}</p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2-Compose 基础</title>
    <link href="/2025/12/a197a06b33a6.html"/>
    <url>/2025/12/a197a06b33a6.html</url>
    
    <content type="html"><![CDATA[<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><h3 id="1-Jetpack-Compose-简介与优势"><a href="#1-Jetpack-Compose-简介与优势" class="headerlink" title="1. Jetpack Compose 简介与优势"></a>1. <strong>Jetpack Compose 简介与优势</strong></h3><p><a href="https://jetpackcompose.cn/"><strong>Jetpack Compose 博物馆</strong></a></p><p> <strong>Compose 编译后不是转化为原生的 Android 上的 View 去显示</strong>，而是依赖于平台的 <code>Canvas</code> ，在这点上和 Flutter 有点相似，简单地说可以理解为 Compose 是全新的一套 View </p><p>Jetpack Compose 是一种声明式 UI 编程框架，采用 Kotlin 语言构建，旨在简化 Android 应用的 UI 开发。与传统的 XML 布局方式不同，Compose 通过 Kotlin 代码直接描述 UI 组件，极大地减少了繁琐的布局嵌套和视图绑定工作，从而提升了代码的简洁性和可维护性。其核心优势包括：</p><ol><li><p><strong>声明式 UI</strong>：Compose 使用声明式编程模型，UI 通过函数式组件描述，避免了传统 UI 开发中繁琐的视图层级结构和 <code>findViewById</code> 调用，降低了出错的风险。例如，直接使用 Kotlin 代码来定义 <code>LinearLayout</code> 和按钮等组件，并且可以在布局中同步嵌入事件处理（如 <code>onClick</code>）。</p></li><li><p><strong>与 Kotlin 深度整合</strong>：Compose 深度集成 Kotlin，充分利用了 Kotlin 的特性，如扩展函数、Lambda 表达式和类型安全。这使得代码更具可读性和可维护性，同时大大提升了开发效率。</p></li><li><p><strong>灵活的控制流</strong>：在 Compose 中，你可以嵌入 <code>if</code>、<code>for</code> 等控制语句来动态生成 UI 组件，这使得布局更加灵活和可控。</p></li><li><p><strong>提高开发效率</strong>：</p><ul><li><strong>实时预览</strong>：Compose 提供了实时预览功能，开发者可以在 Android Studio 中立即看到 UI 组件的变化，而无需启动整个应用程序进行测试。这样，开发者可以更高效地检查界面和修改 UI。</li><li><strong>与现有代码兼容</strong>：Jetpack Compose 允许与传统的 View 组件混合使用，这意味着你可以在不完全重构项目的情况下逐步引入 Compose。同时，Compose 中的代码可以被混淆，开启混淆后，代码的压缩率较高，有助于提高 APK 的安全性和体积优化。</li></ul></li><li><p><strong>简化 UI 管理</strong>：Compose 通过 <code>State</code> 和 <code>LiveData</code> 等机制，使得 UI 状态的管理更加简单。数据变化时，Compose 会自动更新 UI，无需手动操作视图。这避免了传统开发中可能发生的状态同步问题，例如多个视图未及时更新或发生冲突，降低了维护的复杂性。</p></li><li><p><strong>减少出错几率</strong>：通过声明式的编程模型，减少了手动操控视图的复杂度，避免了因视图更新不及时或错误的视图操作导致的异常状态。如果一条数据需要在多个位置呈现，Compose 确保了所有视图都能根据最新数据自动更新，减少了遗忘更新某个视图的可能性。</p></li></ol><p>综上所述，Jetpack Compose 通过简化 UI 的构建过程、提高开发效率、并且通过更高效的 UI 状态管理，帮助开发者减少重复工作和出错的可能性，从而加速了 Android 应用的开发和维护。</p><h3 id="2-具体实践与应用"><a href="#2-具体实践与应用" class="headerlink" title="2. 具体实践与应用"></a>2. <strong>具体实践与应用</strong></h3><p>接下来，介绍你在项目中使用 Jetpack Compose 的实际应用场景和效果：</p><h4 id="1-UI-界面的简化"><a href="#1-UI-界面的简化" class="headerlink" title="1) UI 界面的简化"></a>1) <strong>UI 界面的简化</strong></h4><ul><li><p><strong>旧 UI 与新 UI 的对比</strong>：可以举例说明，在传统的 XML + View 方式下，复杂的界面可能需要多个布局文件和冗长的逻辑处理，而使用 Compose 后，这些逻辑变得更加直观简洁。举一个具体的 UI 组件的例子，比如一个动态列表、分页加载的界面，如何通过 Jetpack Compose 更加高效地构建。</p><p>  例如：</p><ul><li>以前使用 XML 时，可能需要写 <code>RecyclerView</code>、<code>Adapter</code> 和多层嵌套的布局文件，而在 Compose 中，通过 <code>LazyColumn</code> 和 <code>Item</code> 即可直接构建，代码量大大减少，开发效率提高。</li></ul></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">LazyColumn &#123;<br>    <span class="hljs-built_in">items</span>(itemsList) &#123; item -&gt;<br>        Text(text = item.name)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-动态-UI-渲染"><a href="#2-动态-UI-渲染" class="headerlink" title="2) 动态 UI 渲染"></a>2) <strong>动态 UI 渲染</strong></h4><ul><li><p><strong>状态驱动 UI</strong>：通过 Jetpack Compose，你可以轻松实现 UI 组件的状态变化，避免了在传统方式中复杂的视图更新和通知。Compose 会根据数据的变化自动更新 UI，无需手动调用 <code>notifyDataSetChanged</code> 或 <code>setVisibility</code> 等繁琐操作。</p><p>  举例：</p><ul><li>在使用 MVVM 架构时，你通过 LiveData 或 State 来驱动 UI 变化。比如一个按钮的点击事件，使用 <code>mutableStateOf</code> 来表示 UI 状态，在 UI 层直接绑定状态，Compose 会根据状态自动刷新界面。</li></ul></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> isClicked by remember &#123; <span class="hljs-built_in">mutableStateOf</span>(false) &#125;<br><br><span class="hljs-function"><span class="hljs-title">Button</span><span class="hljs-params">(onClick = &#123; isClicked = !isClicked &#125;)</span></span> &#123;<br>    <span class="hljs-built_in">Text</span>(<span class="hljs-keyword">if</span> (isClicked) <span class="hljs-string">&quot;Clicked&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Click Me&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-与现有代码的集成"><a href="#3-与现有代码的集成" class="headerlink" title="3) 与现有代码的集成"></a>3) <strong>与现有代码的集成</strong></h4><ul><li><p><strong>Compose 与传统视图的融合</strong>：介绍你如何在现有的 Android 项目中逐步引入 Compose，并与传统的 UI 组件（如 <code>Fragment</code>、<code>Activity</code>、<code>View</code>）进行集成。Jetpack Compose 可以与现有的视图系统共存，可以逐步替代老的 UI 组件。</p><p>  比如：</p><ul><li>在某些屏幕上，你可能只使用 Compose 来替代部分界面，其他部分仍使用传统的 <code>XML</code> 布局。通过 <code>ComposeView</code>，你可以在现有的 <code>Activity</code> 或 <code>Fragment</code> 中嵌套 Compose UI。</li></ul><p>  示例：</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: View? &#123;<br>        <span class="hljs-keyword">return</span> ComposeView(requireContext()).apply &#123;<br>            setContent &#123;<br>                MyComposableScreen()<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="4-提高开发效率"><a href="#4-提高开发效率" class="headerlink" title="4) 提高开发效率"></a>4) <strong>提高开发效率</strong></h4><ul><li><p><strong>代码量减少</strong>：通过使用 Compose，开发者能够减少布局文件和视图控制器的代码量。例如，常见的视图组件如 <code>Button</code>、<code>TextView</code> 等都可以通过 Compose 声明式方式快速定义，避免了重复的 XML 和 View 查找操作。</p></li><li><p><strong>预览功能与热重载</strong>：Jetpack Compose 的 <code>@Preview</code> 注解功能允许开发者在不运行应用的情况下查看 UI 渲染效果，极大地提高了迭代开发的速度。而 Compose 的热重载（Hot Reload）功能，开发者可以快速看到修改后的 UI 效果，避免了重新启动应用的时间浪费。</p><p>  例如：</p><ul><li>你可以通过以下代码快速预览界面效果：  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Preview</span><br><span class="hljs-variable">@Composable</span><br>fun <span class="hljs-built_in">MyPreview</span>() &#123;<br>    <span class="hljs-selector-tag">MyComposableScreen</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="https://www.jetpackcompose.app/What-is-the-equivalent-of-match_parent-in-Jetpack-Compose">Jetpack Compose 中的 match_parent 相当于什么？</a></p><p><a href="https://developer.android.com/jetpack/compose/mental-model?hl=zh-cn&continue=https://developer.android.com/courses/pathways/compose?hl=zh-cn%23article-https://developer.android.com/jetpack/compose/mental-model">Compose 编程思想  |  Jetpack Compose  |  Android Developers</a></p><p><a href="https://developer.android.com/jetpack/compose/layouts/basics?hl=zh-cn">Compose 布局基础知识  |  Jetpack Compose  |  Android Developers</a></p><p><a href="https://mp.weixin.qq.com/s/olocdhk8P9u9LXXddimphA">原创：写给初学者的Jetpack Compose教程，基础控件和布局</a></p><p><a href="https://mp.weixin.qq.com/s/OdfmpzTLg4y0vNawqjUuiw">原创：写给初学者的Jetpack Compose教程，Modifier</a></p><p><a href="https://mp.weixin.qq.com/s/WOPjNLCgopu3aKEmDKSPug">原创：写给初学者的Jetpack Compose教程，使用State让界面动起来</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650280488&idx=1&sn=faad9511b5459d92178e628bca7d8a7b&chksm=886ce347bf1b6a51897dcdf4983b30b6cf6ceed4c6ab8f930c23002e6ef3c2315ad741baa588&cur_album_id=2935686295949967361&scene=190#rd">原创：写给初学者的Jetpack Compose教程，Lazy Layout</a></p><p>[[android编译优化#AGP、kotlin、compose对应版本]]</p><h3 id="Composable"><a href="#Composable" class="headerlink" title="Composable"></a>Composable</h3><p>告诉编译器：此函数旨在将数据转换为界面。<br>所有的 Composable 函数还有一个约定俗成的习惯，就是函数的命名首字母需要大写。<br>@Preview 注解，这个注解表示这个函数是用来快速预览 UI 样式的。</p><p><strong>@Composable 注解用于标记一个函数为可组合函数</strong>。可组合函数是一种特殊的函数，不需要返回任何 UI 元素，因为<strong>可组合函数描述的是所需的屏幕状态，而不是构造界面 widget</strong>；而如果按我们以前的 XML 编程方式，必须在方法中返回 UI 元素才能使用它（如返回 View 类型）。</p><p>@Composable 注解的函数之间可以相互调用，因为这样 Compose 框架才能正确处理依赖关系。另外，@Composable 函数中也可以调用普通函数，而普通函数中却不能直接调用@Composable 函数。 <strong>这里可以类比下 kotlin 中 suspend 挂起函数的用法，其用法是相似的</strong>。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Compose 通过只测量一次子项来实现高性能。单遍测量对性能有利，使 Compose 能够高效地处理较深的界面树。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-08-14-34-613f6bcc4c0266bf594c43ffca574910-20240108143446-10c80e.png" alt="image.png"><br><strong>父节点会在其子节点之前进行测量，但会在其子节点的尺寸和放置位置确定之后再对自身进行调整</strong>。</p><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><p>CollapsingToolbarScaffold<br>stickyHeader<br>HorizontalPager<br>BottomNavigationBar<br>Scaffold<br>PullRefreshIndicator<br>TopAppBar</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><a href="https://developer.android.com/jetpack/compose/lists?hl=zh-cn">列表和网格  |  Jetpack Compose  |  Android Developers</a></p><h4 id="verticalScroll"><a href="#verticalScroll" class="headerlink" title="verticalScroll"></a>verticalScroll</h4><p>我们可以使用 <code>verticalScroll()</code> 修饰符使 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=zh-cn#Column" title="androidx. compose. ui. Modifier, androidx. compose. foundation. layout. Arrangement. Vertical, androidx. compose. ui. Alignment. Horizontal, kotlin. Function1"><code>Column</code></a> 可滚动</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MessageList</span><span class="hljs-params">(messages: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Message</span>&gt;)</span></span> &#123;<br>    Column &#123;<br>        messages.forEach &#123; message -&gt;<br>            MessageRow(message)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="延迟列表"><a href="#延迟列表" class="headerlink" title="延迟列表"></a><strong>延迟列表</strong></h4><p>使用 Compose 的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary?hl=zh-cn#LazyColumn" title="androidx. compose. ui. Modifier, androidx. compose. foundation. lazy. LazyListState, androidx. compose. foundation. layout. PaddingValues, kotlin. Boolean, androidx. compose. foundation. layout. Arrangement. Vertical, androidx. compose. ui. Alignment. Horizontal, androidx. compose. foundation. gestures. FlingBehavior, kotlin. Boolean, kotlin. Function1"><code>LazyColumn</code></a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary?hl=zh-cn#LazyRow" title="androidx. compose. ui. Modifier, androidx. compose. foundation. lazy. LazyListState, androidx. compose. foundation. layout. PaddingValues, kotlin. Boolean, androidx. compose. foundation. layout. Arrangement. Horizontal, androidx. compose. ui. Alignment. Vertical, androidx. compose. foundation. gestures. FlingBehavior, kotlin. Boolean, kotlin. Function1"><code>LazyRow</code></a>。这些可组合项只会呈现屏幕上显示的元素，因此，对于较长的列表，使用它们会非常高效。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx.compose.foundation.lazy.items<br><br><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MessageList</span><span class="hljs-params">(messages: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Message</span>&gt;)</span></span> &#123;<br>    LazyColumn &#123;<br>        items(messages) &#123; message -&gt;<br>            MessageRow(message)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一个名为 [<code>itemsIndexed ()</code>]( <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary?hl=zh-cn#">https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary?hl=zh-cn#</a> (androidx. compose. foundation. lazy. LazyListScope). itemsIndexed (kotlin. collections. List, kotlin. Function2, kotlin. Function2, kotlin. Function3)) 的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyListScope?hl=zh-cn#items" title="kotlin. Int, kotlin. Function1, kotlin. Function1, kotlin. Function2"><code>items ()</code></a> 扩展函数的变体，用于提供索引</p><h4 id="内容内边距"><a href="#内容内边距" class="headerlink" title="内容内边距"></a>内容内边距</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">LazyColumn<span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-attr">contentPadding</span> = PaddingValues(<span class="hljs-attr">horizontal</span> = 16.dp, <span class="hljs-attr">vertical</span> = 8.dp)</span>,<br>) &#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如需在列表项之间添加间距，可以使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/Arrangement?hl=zh-cn#spacedBy" title="androidx. compose. ui. unit. Dp"><code>Arrangement.spacedBy ()</code></a>。以下示例在每个列表项之间添加了 <code>4.dp</code> 的间距：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">verticalArrangement</span> = Arrangement.spacedBy(<span class="hljs-number">4</span>.dp),<br></code></pre></td></tr></table></figure><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>早期 Lazy Layout 的性能很差，滚动的时候巨卡无比，确实很难让人用得下去。<br>但是在 Compose 1.5版本中，Google 做了大量的性能优化工作，所以如果你现在再来尝试一次，你会发现性能已经不是什么问题了。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>借助修饰符，您可以修饰或扩充可组合项。您可以使用修饰符来执行以下操作：</p><ul><li>更改可组合项的大小、布局、行为和外观</li><li>添加信息，如无障碍标签</li><li>处理用户输入</li><li>添加高级互动，如使元素可点击、可滚动、可拖动或可缩放</li></ul><p>修饰符是标准的 Kotlin 对象。您可以通过调用某个 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier?hl=zh-cn"><code>Modifier</code></a> 类函数来创建修饰符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ArtistCard</span><span class="hljs-params">(<span class="hljs-comment">/*...*/</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> padding = <span class="hljs-number">16.</span>dp<br>    Column(<br>        Modifier<br>            .clickable(onClick = onClick)<br>            .padding(padding)<br>            .fillMaxWidth()<br>    ) &#123;<br>        <span class="hljs-comment">// rest of the implementation</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修饰符顺序很重要</li><li>提取和重复使用修饰符</li><li><code>clickable</code> 使可组合项响应用户输入，并显示涟漪。</li><li><code>padding</code> 在元素周围留出空间。</li><li><code>fillMaxWidth</code> 使可组合项填充其父项为它提供的最大宽度。</li><li><code>size()</code> 指定元素的首选宽度和高度。</li></ul><h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><p>要相对于原始位置放置布局，请添加 <code>offset</code> 修饰符，并在 <strong>x</strong> 轴和 <strong>y</strong> 轴中设置偏移量。偏移量可以是正数，也可以是非正数。<code>padding</code> 和 <code>offset</code> 之间的区别在于，向可组合项添加 <code>offset</code> 不会改变其测量结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ArtistCard</span><span class="hljs-params">(artist: <span class="hljs-type">Artist</span>)</span></span> &#123;<br>    Row(<span class="hljs-comment">/*...*/</span>) &#123;<br>        Column &#123;<br>            Text(artist.name)<br>            Text(<br>                text = artist.lastSeenOnline,<br>                modifier = Modifier.offset(x = <span class="hljs-number">4.</span>dp)<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>offset</code> 修饰符根据布局方向水平应用。在<strong>从左到右</strong>的上下文中，正 <code>offset</code> 会将元素向右移，而在<strong>从右到左</strong>的上下文中，它会将元素向左移。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-09-16-42-f73f39387932ffed4595d6cc715e68af-20240109164252-74a948.png" alt="image.png"></p><h4 id="requiredSize"><a href="#requiredSize" class="headerlink" title="requiredSize"></a>requiredSize</h4><p>请注意，如果指定的尺寸不符合来自布局父项的约束条件，则可能不会采用该尺寸。如果您希望可组合项的尺寸固定不变，而不考虑传入的约束条件，请使用 <code>requiredSize</code> 修饰符：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Composable</span><br>fun <span class="hljs-built_in">ArtistCard</span>(<span class="hljs-comment">/*...*/</span>) &#123;<br>    <span class="hljs-selector-tag">Row</span>(<br>        modifier = Modifier.<span class="hljs-built_in">size</span>(<span class="hljs-attribute">width</span> = <span class="hljs-number">400</span>.dp, <span class="hljs-attribute">height</span> = <span class="hljs-number">100</span>.dp)<br>    ) &#123;<br>        <span class="hljs-selector-tag">Image</span>(<br>            <span class="hljs-comment">/*...*/</span><br>            modifier = Modifier.<span class="hljs-built_in">requiredSize</span>(<span class="hljs-number">150</span>.dp)<br>        )<br>        <span class="hljs-selector-tag">Column</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，即使父项的 <code>height</code> 设置为 <code>100.dp</code>，<code>Image</code> 的高度还是 <code>150.dp</code>，因为 <code>requiredSize</code> 修饰符优先级较高。</p><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p>在 View 中的话，通常可以在需要滚动的内容之外再嵌套一层 ScrollView 布局，这样 ScrollView 中的内容就可以滚动了。<br>而 Compose 则不需要再进行额外的布局嵌套，只需要借助 modifier 参数即可，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span>  <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">SimpleWidgetColumn</span><span class="hljs-params">()</span></span> &#123;  <br>    Row(  <br>        modifier = Modifier  <br>            .fillMaxSize()  <br>            .horizontalScroll(rememberScrollState()),  <br>        verticalAlignment = Alignment.CenterVertically,  <br>    ) &#123;  <br>        ...  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加间距-Spacer"><a href="#添加间距-Spacer" class="headerlink" title="添加间距 Spacer"></a>添加间距 <code>Spacer</code></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Spacer</span><span class="hljs-params">(modifier = Modifier.width(<span class="hljs-number">8</span>.dp)</span></span>)<br></code></pre></td></tr></table></figure><h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>如何才能给 Button 指定文字内容呢？它可以和 Text 配合在一起使用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Button</span>(<br>    onClick = &#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>    <span class="hljs-comment">// Uses ButtonDefaults.ContentPadding by default</span><br>    contentPadding = <span class="hljs-built_in">PaddingValues</span>(<br>        start = <span class="hljs-number">20</span>.dp,<br>        top = <span class="hljs-number">12</span>.dp,<br>        end = <span class="hljs-number">20</span>.dp,<br>        bottom = <span class="hljs-number">12</span>.dp<br>    )<br>) &#123;<br>    <span class="hljs-comment">// Inner content including an icon and a text label</span><br>    <span class="hljs-selector-tag">Icon</span>(<br>        Icons.Filled.Favorite,<br>        contentDescription = <span class="hljs-string">&quot;Favorite&quot;</span>,<br>        modifier = Modifier.<span class="hljs-built_in">size</span>(ButtonDefaults.IconSize)<br>    )<br>    <span class="hljs-selector-tag">Spacer</span>(Modifier.<span class="hljs-built_in">size</span>(ButtonDefaults.IconSpacing))<br>    <span class="hljs-selector-tag">Text</span>(<span class="hljs-string">&quot;Like&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>要想弹出 Toast 需要有 Context 参数才行。在 Composable 函数当中获取 Context 对象，可以调用 LocalContext. current 获得。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span>  <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">SimpleWidgetColumn</span><span class="hljs-params">()</span></span> &#123;  <br>    Column &#123;  <br>        ...  <br>        <span class="hljs-keyword">val</span> context = LocalContext.current  <br>        Button(onClick = &#123;  <br>            Toast.makeText(context, <span class="hljs-string">&quot;This is Toast&quot;</span>, Toast.LENGTH_SHORT).show()  <br>        &#125;) &#123;  <br>            Text(  <br>                text = <span class="hljs-string">&quot;This is Button&quot;</span>,  <br>                color = Color.White,  <br>                fontSize = <span class="hljs-number">26.</span>sp  <br>            )  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文字图片"><a href="#文字图片" class="headerlink" title="文字图片"></a>文字图片</h3><p><a href="https://developer.android.com/jetpack/compose/text?hl=zh-cn">Compose 中的文字  |  Jetpack Compose  |  Android Developers</a></p><p><a href="https://developer.android.com/jetpack/compose/graphics/images/customize?hl=zh-cn">自定义图片  |  Jetpack Compose  |  Android Developers</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val imageModifier = Modifier<br>    <span class="hljs-selector-class">.size</span>(<span class="hljs-number">150</span>.dp)<br>    <span class="hljs-selector-class">.border</span>(<span class="hljs-built_in">BorderStroke</span>(<span class="hljs-number">1</span><span class="hljs-selector-class">.dp</span>, Color.Black))<br>    <span class="hljs-selector-class">.background</span>(Color.Yellow)<br><span class="hljs-built_in">Image</span>(<br>    painter = <span class="hljs-built_in">painterResource</span>(id = R<span class="hljs-selector-class">.drawable</span>.dog),<br>    contentDescription = <span class="hljs-built_in">stringResource</span>(id = R<span class="hljs-selector-class">.string</span>.dog_content_description),<br>    contentScale = ContentScale<span class="hljs-selector-class">.Fit</span>,<br>    modifier = imageModifier<br>)<br></code></pre></td></tr></table></figure><h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span>  <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">SimpleWidgetColumn</span><span class="hljs-params">()</span></span> &#123;  <br>    Column &#123;  <br>        ...  <br>        TextField(  <br>            value = <span class="hljs-string">&quot;&quot;</span>,  <br>            onValueChange = &#123;&#125;,  <br>            placeholder = &#123;  <br>                Text(text = <span class="hljs-string">&quot;Type something here&quot;</span>)  <br>            &#125;,  <br>            colors = TextFieldDefaults.textFieldColors(  <br>                backgroundColor = Color.White  <br>            )  <br>        )  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="viewmodel"><a href="#viewmodel" class="headerlink" title="viewmodel"></a>viewmodel</h4><p>首先我们要引入如下两个库，这是 Compose 为了适配 ViewModel 和 LiveData 而专门设计的库：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&quot;androidx. lifecycle: lifecycle-viewmodel-compose: 2.6.2&quot;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&quot;androidx. compose. runtime: runtime-livedata: 1.5.1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>传统 LiveData 的用法在 Compose 中并不好使，因为传统 LiveData 依赖于监听某个值的变化，并对相应的界面进行更新，而 Compose 的界面更新则依赖于重组。<br>因此，我们需要将 LiveData 转换成 State 才行，observeAsState ()函数就是用来做这个事情的，参数中传入的0表示它的初始值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx. lifecycle. viewmodel. compose. viewModel<br><br><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">CallCounter</span> <span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier, viewModel: <span class="hljs-type">MainViewModel</span> = viewModel ()</span></span>) &#123;<br>    <span class="hljs-keyword">val</span> count <span class="hljs-keyword">by</span> viewModel.count.observeAsState (<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> doubleCount <span class="hljs-keyword">by</span> viewModel.doubleCount.observeAsState (<span class="hljs-number">0</span>)<br>    Column &#123;<br>        Counter (<br>            count = count,<br>            onIncrement = &#123; viewModel.incrementCount () &#125;,<br>            modifier.fillMaxWidth ()<br>        )<br>        Counter (<br>            count = doubleCount,<br>            onIncrement = &#123; viewModel.incrementDoubleCount () &#125;,<br>            modifier.fillMaxWidth ()<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="LaunchedEffect"><a href="#LaunchedEffect" class="headerlink" title="LaunchedEffect"></a>LaunchedEffect</h3><p><code>LaunchedEffect</code> 是 Jetpack Compose 中的一个函数，用于在协程中执行副作用操作。副作用操作通常包括异步任务、网络请求、数据库操作或其他可能会阻塞主线程的操作。</p><p><code>LaunchedEffect</code> 函数是一个协程构建器，它接受一个或多个参数，并在代码块中执行异步操作。它会自动在适当的时间启动和取消协程，确保在 Compose 组件的生命周期内正确处理副作用。当组件被创建时，<code>LaunchedEffect</code> 会启动协程，当组件被销毁时，它会自动取消协程。</p><p><code>LaunchedEffect</code> 的参数可以是任何对象，用于标识不同的副作用操作。通常使用简单的数据类对象作为参数，例如 <code>key1 = Unit</code>。</p><p>在 <code>LaunchedEffect</code> 的代码块中，你可以执行各种需要在后台进行的操作，例如网络请求、数据库访问、文件读写等。由于这些操作是在协程中执行的，因此它们不会阻塞主线程，确保应用保持响应性。</p><p>需要注意的是，<code>LaunchedEffect</code> 函数只能在 Compose 函数内部调用，例如在 <code>@Composable</code> 注解的函数内部使用。如果你尝试在非 Compose 函数中调用它，将会出现编译错误。</p><p>总结起来，<code>LaunchedEffect</code> 是一个用于在协程中执行副作用操作的函数，它确保在 Compose 组件的生命周期内正确处理副作用。它是 Jetpack Compose 中处理异步任务和副作用的重要工具之一</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">itemData?. run &#123;  <br>    LaunchedEffect (key1 = Unit) &#123;  <br>        viewModel<span class="hljs-selector-class">.getRelateVideoList</span> (itemData. id)  <br>        viewModel<span class="hljs-selector-class">.saveVideo</span> (itemData)  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DisposableEffect"><a href="#DisposableEffect" class="headerlink" title="DisposableEffect"></a>DisposableEffect</h3><p>用于在组件创建和销毁时执行一些副作用操作。当组件被销毁时，onDispose 代码块内的操作会被执行  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineScope = rememberCoroutineScope ()<br><br>DisposableEffect (<span class="hljs-built_in">Unit</span>) &#123;  <br>    <span class="hljs-keyword">val</span> timer = Timer ()  <br>    timer.schedule (<span class="hljs-keyword">object</span> : TimerTask () &#123;  <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span></span> &#123;  <br>            coroutineScope. launch &#123;  <br>                pagerState.animateScrollToPage (pagerState. currentPage + <span class="hljs-number">1</span>)  <br>            &#125;  <br>        &#125;  <br>    &#125;, <span class="hljs-number">3000</span>, <span class="hljs-number">3000</span>)  <br>    onDispose &#123;  <br>        timer.cancel ()  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1-开发实战</title>
    <link href="/2025/12/7092fe14667b.html"/>
    <url>/2025/12/7092fe14667b.html</url>
    
    <content type="html"><![CDATA[<p>fmtjava&#x2F;Compose_Eyepetizer: 一款基于 Jetpack Compose 实现的精美仿开眼视频App(提供Kotlin、Flutter、React Native、小程序版本 😁 )]( <a href="https://github.com/fmtjava/Compose_Eyepetizer">https://github.com/fmtjava/Compose_Eyepetizer</a>)</p><h1 id="navController"><a href="#navController" class="headerlink" title="navController"></a>navController</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">navController.<span class="hljs-title function_">navigate</span>(<span class="hljs-params">screen.route</span>) &#123;  <br>    <span class="hljs-title function_">popUpTo</span>(<span class="hljs-params">navController.graph.startDestinationId</span>) &#123;  <br>        saveState = <span class="hljs-literal">true</span>  <br>    &#125;  <br>    launchSingleTop = <span class="hljs-literal">true</span>  <br>    restoreState = <span class="hljs-literal">true</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>popUpTo (navController. graph. startDestinationId)<br>作用：导航时清除回退栈到指定目的地<br>效果：清除到起始目的地之间的所有页面，避免回退栈无限增长<br>saveState &#x3D; true<br>作用：保存被清除页面的状态<br>效果：当用户返回时，页面状态得以保留<br>launchSingleTop &#x3D; true<br>作用：如果目标页面已在栈顶，则不创建新实例<br>效果：避免重复创建相同页面<br>restoreState &#x3D; true<br>作用：恢复目标页面之前保存的状态<br>效果：提升用户体验，保留页面之前的交互状态</p><p>val navController &#x3D; rememberNavController()<br>作用：创建并记住一个 NavHostController 实例，用于管理应用内的导航<br>原理：rememberNavController () 是一个可组合函数，它确保在重组时返回相同的 NavHostController 实例<br>用途：通过这个控制器可以执行导航操作，如 navigate ()、popBackStack () 等</p><h1 id="变量写法"><a href="#变量写法" class="headerlink" title="变量写法"></a>变量写法</h1><h2 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h2><ol><li>状态封装原则<br>使用 private val _smsState 作为内部可变状态</li></ol><p>使用 val smsState 作为对外暴露的不可变状态流</p><p>遵循了状态封装的最佳实践，防止外部直接修改状态</p><ol start="2"><li><p>StateFlow 特性<br>MutableStateFlow&lt;SmsState&gt; 创建了一个可变的状态流<br>asStateFlow() 将可变流转换为只读流暴露给外部</p></li><li><p>状态管理优势<br>单向数据流：外部只能观察状态，不能直接修改<br>线程安全：协程 Flow 保证了状态更新的线程安全性<br>生命周期感知：配合 Compose 或 Lifecycle 可以自动处理订阅生命周期</p></li><li><p>使用场景<br>在 SmsCodePage 中可以通过.collect或.collectAsState来观察 smsState 的变化，根据不同的状态（Loading、Success、Error、Idle）来更新 UI 显示。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">val</span> <span class="hljs-variable">_smsState</span> <span class="hljs-operator">=</span> MutableStateFlow&lt;SmsState&gt;(SmsState. Idle)<br>val smsState: StateFlow&lt;SmsState&gt; = _smsState.asStateFlow ()<br>val state by viewModel.smsState.collectAsState ()<br></code></pre></td></tr></table></figure><p><strong>自动重组</strong>：当 Flow 发射新值时，Compose 会触发 UI 重组。</p><p><strong>生命周期感知</strong>：在 <code>@Composable</code> 环境中使用时，会自动跟随 <code>Lifecycle</code> 取消订阅，避免内存泄漏。</p><table><thead><tr><th align="left">对比项</th><th align="left">collect ()</th><th align="left">collectAsState ()</th></tr></thead><tbody><tr><td align="left">使用环境</td><td align="left">任意协程环境</td><td align="left">仅 Compose</td></tr><tr><td align="left">返回类型</td><td align="left">无返回值 (suspend 函数)</td><td align="left">State<T> (Compose 可观察)</td></tr><tr><td align="left">是否触发重组</td><td align="left">否❌</td><td align="left">是</td></tr><tr><td align="left">是否自动处理生命周期</td><td align="left">否，需要手动管理✅</td><td align="left">Compose 自动管理</td></tr><tr><td align="left">常见场景</td><td align="left">ViewModel、Repository、后台逻辑</td><td align="left">Compose UI 层</td></tr></tbody></table><h2 id="collectAsState"><a href="#collectAsState" class="headerlink" title="collectAsState"></a>collectAsState</h2><p>是 <strong>Jetpack</strong> <strong>Compose</strong> 中常用的一个扩展函数，用来把 <strong>Flow&#x2F;StateFlow</strong> 转换成 Compose 可感知的 <code>State&lt;T&gt;</code>，从而让 UI 自动响应数据变化。<br><strong>自动重组</strong>：当 Flow 发射新值时，Compose 会触发 UI 重组。<br><strong>生命周期感知</strong>：在 <code>@Composable</code> 环境中使用时，会自动跟随 <code>Lifecycle</code> 取消订阅，避免内存泄漏</p><h2 id="mutableStateOf-（不推荐）"><a href="#mutableStateOf-（不推荐）" class="headerlink" title="mutableStateOf （不推荐）"></a>mutableStateOf （不推荐）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plain">// 👇 新增：用 mutableStateOf 来保存 currentStep，这样 Compose 能自动重组<br>var currentStep by mutableIntStateOf(1)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Plain">LaunchedEffect(nextStep) &#123;<br>    viewModel.currentStep = nextStep<br>&#125;<br>val currentStep = viewModel.currentStep<br></code></pre></td></tr></table></figure><p><strong>问题</strong></p><ul><li>viewModel 的currentStep 变化 page 的currentStep 也会变化吗，没看到LaunchedEffect(currentStep) {  也会重组吗</li></ul><p>会的——只要 currentStep 在 ViewModel 里是 mutableStateOf（或 StateFlow 转成 State），页面里读取到了这个 state，它变更时就会触发重组。不需要 LaunchedEffect(currentStep) 来驱动 UI 更新。</p><ul><li>为什么不需要 LaunchedEffect</li></ul><p>Compose 会自动跟踪在组合阶段被读取的 State（如 mutableStateOf）。<br>当这个 State 的值变化时，读取它的 Composable 会自动 recompose。<br>LaunchedEffect 用于副作用（如发起请求、导航、动画），不是用来让 UI 监听 state 的。<br>若你用的是 StateFlow，同理，在 VM 暴露 StateFlow&lt;Int&gt;，在 UI 用 collectAsState() 即可</p><ul><li>val accountInfoBean by viewModel. accountInfoBean<br>会的。只要 viewModel. accountInfoBean 是一个 mutableStateOf（或 State&lt;T&gt;），那这行代码就已经在 Compose 中建立了订阅关系。当 ViewModel 中的值变化时，UI 会自动重组。</li></ul><p><strong>小结</strong></p><p>✅ 读 mutableStateOf&#x2F;collectAsState() → 值变化自动重组<br>❌ 不需要 LaunchedEffect(currentStep)<br>✅ 仅在需要“做一次事”（如用 nextStep 初始化、发请求）时用 LaunchedEffect(…)</p><h2 id="liveData"><a href="#liveData" class="headerlink" title="liveData"></a>liveData</h2><p>（1）<code>State&lt;T&gt;</code> 是 Compose 的“原生”状态类型</p><ul><li>Compose 的 <code>@Composable</code> 函数天然监听 <code>State&lt;T&gt;</code> 的变化并触发重组。</li><li><code>LiveData</code> 需要通过 <code>observeAsState()</code> 转换为 <code>State</code> 才能在 Compose 中使用，多了一层转换。</li><li>直接使用 <code>mutableStateOf</code> 更简洁、高效，无需依赖 Android 生命周期组件。</li></ul><p>（2）<code>LiveData</code> 是为传统 View 系统设计的</p><ul><li><code>LiveData</code> 的核心优势是 生命周期感知（自动在 <code>onStop</code> 时停止通知），防止内存泄漏。</li><li>但在 Compose 中，UI 的生命周期由 Compose 自己管理（通过 <code>DisposableEffect</code>、<code>LaunchedEffect</code> 等），不再依赖 <code>LifecycleOwner</code>。</li><li>因此 <code>LiveData</code> 的生命周期感知优势在 Compose 中 变得冗余甚至多余。</li></ul><p>（3）<code>StateFlow</code> &#x2F; <code>SharedFlow</code> 更适合现代 Compose 架构</p><h2 id="修改传入的值、rememberSaveable"><a href="#修改传入的值、rememberSaveable" class="headerlink" title="修改传入的值、rememberSaveable"></a>修改传入的值、rememberSaveable</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plain">@Composable<br>fun UpdateInfoPage(nextStep: Int) &#123;<br>    val viewModel: UpdateInfoViewModel = hiltViewModel()<br>    val context = LocalContext.current<br>    val navController = LocalNavController.current<br><br>    // 这里使用 rememberSaveable 保持步骤状态可修改、可记忆<br>    var currentStep by rememberSaveable &#123; mutableIntStateOf(nextStep) &#125;<br></code></pre></td></tr></table></figure><p><em>❗不要用 remember 包住；保证每次点击都拿到“最新的权限&#x2F;隐私状态”</em></p><h1 id="智能重组的坑"><a href="#智能重组的坑" class="headerlink" title="智能重组的坑"></a>智能重组的坑</h1><p>Compose 的重组是 “按读取字段” 触发的，不是“按对象引用”。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Plain">@Composable<br>fun HomePageContent(orderState: OrderStateBean) &#123;<br>    Text(text = orderState.title)        // 只读了 title<br>    if (orderState.hasUnread) &#123;          // 只读了 hasUnread<br>        Badge()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>🔥 即使 <code>orderStateBean.value = newBean</code>（整个对象变了），只要 <code>title</code> 和 <code>hasUnread</code> 的值没变，<code>HomePageContent</code> 就不会重组！</p></blockquote><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Plain">LifecycleResumeEffect(Unit) &#123;<br>    launchInProgress = false<br>    onPauseOrDispose &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="好图片"><a href="#好图片" class="headerlink" title="好图片"></a>好图片</h1><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/mis/202512162149471.png" alt="00bb3c10cefd1a117f526af3ecb4f0c0_MD5"></p><h1 id="标准代码结构"><a href="#标准代码结构" class="headerlink" title="标准代码结构"></a>标准代码结构</h1><p>UI 与逻辑分离 + 只对纯状态组件预览</p><ul><li><p>将 UI 拆分为两个函数：</p><ol><li><code>SmsCodePage</code>：负责和 ViewModel、NavController、状态管理交互（不预览）</li><li><code>SmsCodeContent</code>：只接收 UI 状态（如 phone、otpValue、loading、error 等），负责渲染（可预览）</li></ol></li><li><p>给 <code>SmsCodeContent</code> 添加 <code>@Preview</code>，让它能独立展示各种 UI 状态。</p></li></ul><h1 id="api用法"><a href="#api用法" class="headerlink" title="api用法"></a>api用法</h1><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p><strong>true</strong>：如果集合中 <strong>至少有一个</strong> 元素满足条件</p><p><strong>false</strong>：如果 <strong>没有任何</strong> 元素满足条件</p><p>val showDisburseFailedDialog &#x3D; remember(ordersList) {</p><p>mutableStateOf(ordersList.any { it.checkStatus &#x3D;&#x3D; 6 })</p><p>}</p><p>&#x2F;&#x2F;tood 如果ordersList里 有OrderListItem 的 checkStatus 为 6是 显示showDisburseFailedDialog</p><h2 id="takeIf"><a href="#takeIf" class="headerlink" title="takeIf"></a><em>takeIf</em></h2><p>  ocr. idPhotoId.<em>takeIf</em> <strong>{ it</strong> !&#x3D; null <strong>}</strong> ?: oldIdentity?. idPhotoId</p><p>满足是前面，不满足是后面</p><h1 id="只加载一次"><a href="#只加载一次" class="headerlink" title="只加载一次"></a>只加载一次</h1><p>rememberSaveable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plain">var hasInitLoaded by rememberSaveable &#123; mutableStateOf(false) &#125;<br>LaunchedEffect(hasInitLoaded) &#123;<br>    if (!hasInitLoaded) &#123;<br>        changeCardViewModel.getAccountInfoAndDictConfig()<br>        refreshOrders()<br>        hasInitLoaded = true<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h1><h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>mdpi 48x48</p><p>hdpi 72x72</p><p>xhdpi 96x96</p><p>xxhdpi 144x144</p><p>xxxhdpi 192x192</p><p>COMPOSE不支持.9图</p><h2 id="去掉点击效果"><a href="#去掉点击效果" class="headerlink" title="去掉点击效果"></a>去掉点击效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Plain">Row(<br>    modifier = modifier<br>        .fillMaxWidth()<br>        .clickable(<br>            interactionSource = remember &#123; MutableInteractionSource() &#125;,<br>            indication = null<br>        ) &#123; onClick() &#125;,<br>    verticalAlignment = Alignment.CenterVertically<br>) &#123;<br></code></pre></td></tr></table></figure><h2 id="本地图片做背景"><a href="#本地图片做背景" class="headerlink" title="本地图片做背景"></a>本地图片做背景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Plain">@Composable<br>fun UpdateInfoCardContainer(<br>    modifier: Modifier = Modifier,<br>    content: @Composable ColumnScope.() -&gt; Unit<br>) &#123;<br>    Column(<br>        modifier = modifier<br>            .fillMaxWidth()<br>            .clip(RoundedCornerShape(10.dp)) // 圆角<br>            .paint(<br>                painter = painterResource(id = R.drawable.profile_tab_card_bg), // 本地切图<br>                contentScale = ContentScale.Crop         // 拉伸方式<br>            )<br>            .padding(16.dp),<br>        content = content<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ul><li>Data class改成class 可以混淆，要不然 toString 就又能看到混淆前的数据</li></ul><p>函数要加（）</p><p>IconButton( onClick &#x3D; <strong>{</strong> onBackClick()</p><p>&#x2F;&#x2F;onBackClick 调不了 <strong>}</strong>,</p><h2 id="先后顺序"><a href="#先后顺序" class="headerlink" title="先后顺序"></a>先后顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Plain">Box(Modifier.navigationBarsPadding()) &#123;<br>    Box(<br>        modifier = Modifier<br>            .fillMaxWidth()<br>            .padding(horizontal = 16.dp, vertical = 16.dp) // 外边距<br>            .height(44.dp)<br>            .clip( RoundedCornerShape(10.dp))      // 先裁圆角<br>            .background(Color(0xFFCCCCCC))            // 再画背景，这样会被圆角裁剪<br>            .clickable &#123; onConfirm() &#125;,<br>        contentAlignment = Alignment.Center<br>    ) &#123;<br>        Text(<br>            text = confirmText,<br>            color =  Color.White,<br>            fontWeight = FontWeight.Bold,<br>            fontSize = 16.sp<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>weight 用于设置子元素的权重，权重越大，占据的空间就越大</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Column (modifier <span class="hljs-operator">=</span> Modifier.weight (<span class="hljs-number">1</span>f) <br></code></pre></td></tr></table></figure><p>thickness 分割线的厚度  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Divider</span> (thickness = <span class="hljs-number">0</span>.<span class="hljs-number">5</span>. dp, modifier = Modifier.padding (top = <span class="hljs-number">5</span>. dp))<br></code></pre></td></tr></table></figure><p>这是一个小圆点  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">Box (<span class="hljs-name">modifier</span> = Modifier  <br>    .padding (<span class="hljs-number">2</span>. dp)  <br>    .clip (<span class="hljs-name">CircleShape</span>)  <br>    .background (<span class="hljs-name">color</span>)  <br>    .size (<span class="hljs-number">8</span>. dp))<br></code></pre></td></tr></table></figure><h2 id="背景本地切图"><a href="#背景本地切图" class="headerlink" title="背景本地切图"></a>背景本地切图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Plain">@Composable<br>private fun TimeBlock(text: String) &#123;<br>    Box(<br>        modifier = Modifier<br>            .width(120.dp)<br>            .height(124.dp)<br>            .clip(RoundedCornerShape(8.dp)),<br>        contentAlignment = Alignment.Center<br>    ) &#123;<br>        Image(<br>            painter = painterResource(id = R.drawable.home_countdown_time_bg),<br>            contentDescription = null,<br>            contentScale = ContentScale.FillBounds,<br>            modifier = Modifier.matchParentSize()<br>        )<br><br>        Text(<br>            text = text,<br>            color = FFFDD17B,<br>            fontSize = 48.sp,<br>            fontWeight = FontWeight.Bold<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Plain">Brush.horizontalGradient(<br>    colors = listOf(<br>        FFE46C15,<br>        FFF8B42B,<br>    )<br>)<br></code></pre></td></tr></table></figure><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Plain">Button(<br>    onClick = &#123;<br>        onLeftClick()<br>    &#125;,<br>    shape = shape,<br>    colors = ButtonDefaults.buttonColors(<br>        containerColor = FF1A1A1A  // 设置背景色<br>    ),<br>    modifier = Modifier<br>        .weight(1f)<br>        .border(1.dp, FF4D4C4A, shape).height(40.dp), //坑：height再最后，要不然会覆盖<br>) &#123;<br>    Text(<br>        leftString,<br>        fontSize = 14.sp,<br>        color = Color.White<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Plain">Column(<br>    modifier = Modifier.padding(24.dp),<br>    horizontalAlignment = Alignment.CenterHorizontally<br>) &#123;<br>    Text(<br>        content,<br>        color = Color.White.copy(alpha = 0.8f),<br>        fontSize = 14.sp,<br>        textAlign = TextAlign.Center<br>    )<br> )<br></code></pre></td></tr></table></figure><p>lineHeight &#x3D; 12.<em>sp</em>, 行高</p><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plain">Image(<br>    painter = painterResource(R.drawable.home_update_fail),<br>    contentDescription = null,<br>    modifier = Modifier<br>        .align(Alignment.TopCenter)<br>        .offset(y = -40.dp)<br>        .requiredSize(350.dp) //突破父view的限制<br>)<br></code></pre></td></tr></table></figure><h2 id="ViewPager、HorizontalPager"><a href="#ViewPager、HorizontalPager" class="headerlink" title="ViewPager、HorizontalPager"></a>ViewPager、HorizontalPager</h2><p>&#x2F;&#x2F;ViewPager2, 通过将此状态对象保存在组件中，可以确保当组件重新合成时，分页状态不会丢失。  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">val pagerState <span class="hljs-operator">=</span> rememberPagerState ()<br></code></pre></td></tr></table></figure><p>HorizontalPager 是一种用于构建横向滚动页面的组件。它允许您在应用程序中创建水平滑动的页面布局，类似于 ViewPager 或 RecyclerView。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">HorizontalPager (pageCount = <span class="hljs-number">4</span>,  <br>    userScrollEnabled = false,  <br>    state = pagerState,  <br>    modifier = Modifier  <br>        .fillMaxSize ()  <br>        <span class="hljs-selector-class">.background</span> (Color. White)  <br>        <span class="hljs-selector-class">.padding</span> (padding)) &#123; pageIndex -&gt;  <br>    when (pageIndex) &#123;  <br>        <span class="hljs-number">0</span> -&gt; DailyPage ()  <br>        <span class="hljs-number">1</span> -&gt; DiscoverPage ()  <br>        <span class="hljs-number">2</span> -&gt; HotPage ()  <br>        <span class="hljs-number">3</span> -&gt; PersonPage ()  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>在 Compose 中，确实没有 <code>margin</code> 修饰符，只有 <code>padding</code> 修饰符。如果您想在 <code>Text</code> 组件周围创建间距，可以使用 <code>padding</code> 修饰符来实现类似的效果。在您提供的示例代码中，<code>Modifier.padding (top = 3. dp)</code> 将在 <code>Text</code> 组件的顶部添加3dp 的内边距，从而创建了与 <code>margin</code> 类似的效果。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Text <span class="hljs-params">(<span class="hljs-attr">text</span> = itemData. author?. description ?: &quot;&quot;,  </span><br><span class="hljs-params">    <span class="hljs-attr">color</span> = Color. White,  </span><br><span class="hljs-params">    <span class="hljs-attr">fontSize</span> = 13. sp, <span class="hljs-attr">modifier</span> = Modifier.padding (<span class="hljs-attr">top</span> = 3. dp)</span>)<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">Spacer (<span class="hljs-name">modifier</span> = Modifier.height (<span class="hljs-number">10</span>. dp))<br></code></pre></td></tr></table></figure><h2 id="zIndex"><a href="#zIndex" class="headerlink" title="zIndex"></a>zIndex</h2><p><code>zIndex</code> 是指定视图的层级顺序的属性。它控制了视图在屏幕上的显示顺序。具有较高 <code>zIndex</code> 值的视图将显示在具有较低 <code>zIndex</code> 值的视图之上。</p><p>默认情况下，视图的 <code>zIndex</code> 值为0。如果设置一个较大的正值，则视图将显示在其他视图的上方。如果设置一个较小的负值，则视图将显示在其他视图的下方。当两个视图的 <code>zIndex</code> 相同时，它们将按照它们在布局文件中的顺序进行绘制。</p><p>通过调整视图的 <code>zIndex</code> 属性，您可以控制视图的叠加顺序，从而达到覆盖或隐藏其他视图的效果。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">DiscoverTabPageWidget (<span class="hljs-name">pagerState</span>, modifier = Modifier  <br>    .weight (<span class="hljs-number">1</span>f)  <br>    .zIndex (<span class="hljs-name">-1f</span>))<br></code></pre></td></tr></table></figure><h1 id="evnetBus"><a href="#evnetBus" class="headerlink" title="evnetBus"></a>evnetBus</h1><ul><li>定义一个 <strong>在 Activity 范围内共享的 ViewModel</strong>，存放你要广播的事件。</li><li>各个页面通过 <code>viewModel()</code> &#x2F; <code>hiltViewModel()</code> 获取同一个实例，直接订阅状态。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 共享的事件中心</span><br><span class="hljs-meta">@HiltViewModel</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBusViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : ViewModel() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _event = MutableSharedFlow&lt;String&gt;() <span class="hljs-comment">// 可以换成 StateFlow</span><br>    <span class="hljs-keyword">val</span> event = _event.asSharedFlow()<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendEvent</span><span class="hljs-params">(msg: <span class="hljs-type">String</span>)</span></span> &#123;<br>        _event.emit(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//发送</span><br><span class="hljs-keyword">val</span> eventBus: EventBusViewModel = hiltViewModel()<br>LaunchedEffect(<span class="hljs-built_in">Unit</span>) &#123;<br>    eventBus.sendEvent(<span class="hljs-string">&quot;来自页面A的消息&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//监听</span><br><span class="hljs-keyword">val</span> eventBus: EventBusViewModel = hiltViewModel()<br>LaunchedEffect(<span class="hljs-built_in">Unit</span>) &#123;<br>    eventBus.event.collect &#123; msg -&gt;<br>        Log.d(<span class="hljs-string">&quot;EventBus&quot;</span>, <span class="hljs-string">&quot;收到消息: <span class="hljs-variable">$msg</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>通常不需要你手动取消监听</strong>。</p><p>原因有两个：</p><ol><li><p><strong><code>collect</code> 的生命周期是绑定在 Composable 的 <code>LaunchedEffect</code> 或 <code>DisposableEffect</code> 上的</strong></p><ul><li>当 Composable 离开界面时，它的协程会自动取消，Flow 的收集也会结束。</li><li>所以不会像传统 EventBus 一样出现「忘记 unregister 导致泄漏」的问题。</li></ul></li><li><p><strong>ViewModel 的作用域受 Activity&#x2F;Navigation 控制</strong></p><ul><li>Activity 销毁时，ViewModel 也会销毁，内部的 Flow 也不再推送事件。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解、AOP、APT</title>
    <link href="/2025/12/e15cb1ec3664.html"/>
    <url>/2025/12/e15cb1ec3664.html</url>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>注解和反射的区别</strong></p><p>反射：JAVA 反射机制是在运行状态中，对于任意一个类 (class 文件)，都能够知道这个类的所有属性和方法。<br>注解：降低项目的耦合度；自动完成一些规律性的代码；自动生成 java 代码，减轻开发者的工作量。<br>而注解需要用到反射：<br>定义注解，使用注解，读取注解（用到反射）</p><p><strong>注解和反射效率问题</strong></p><p>反射先 new 类 class，然后在从类里面 new 对象。Class.getMethod (…)还要查找所有的方法。<br>而注解编译期间就完成了注解的反射工作， jvm 只是读取。</p><p><strong>反射的缺点</strong></p><p>不安全<br>编译器没法对反射相关的代码做优化<br>慢的原因还有安全检查，访问控制等。比如说这个方法你能不能获得，能不能执行等，你传进的参数的类型检查等。比如说在使用反射调用方法的时候，传进的参数需要检查是否符合方法参数类型要求吧？<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-06-14-36-bc07632b5ecb5c7f392d21791fe030c6-18-51-39-bc07632b5ecb5c7f392d21791fe030c6-unknown_filename-eb0bec-a791eb.png" alt="unknown_filename|260"></p><p><strong>注解的用法</strong></p><p>获取类的注解<br>URLBuilder. Path path &#x3D;paramEntity.getClass (). getAnnotation (URLBuilder. Path. class);</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Builder(Retrofit retrofit, Method method) &#123;<br>  <span class="hljs-keyword">this</span>.retrofit = retrofit;<br>  <span class="hljs-keyword">this</span>.method = method;<br>  <span class="hljs-keyword">this</span>.methodAnnotations = method.getAnnotations();<br>  <span class="hljs-keyword">this</span>.parameterTypes = method.getGenericParameterTypes();<br>  <span class="hljs-keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取方法的注解</strong></p><p>Method.getAnnotations (); 是获取方法上面对应的注解。<br>method.getParameterAnnotations ()；获取的是方法参数上面的注解，是一个二维数组，第一个维度代表的是方法参数对应的下标，比如，一个方法有3个参数，那0代表第一个参数，1代表第二个参数，2代表第三个参数。</p><p><strong>获取泛型参数</strong></p><p>method.getGenericParameterTypes (); 获取的是方法参数的类型，里面带有实际的参数类型。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>@Retention注解保留的生命周期</p><ol><li>SOURCE: <em>在源文件中有效（即源文件保留</em>）而被编译器丢弃，<em>运行的时候不会在 class 文件里</em>。(编译器在，运行时没有)　　　</li><li>CLASS: 在 <em>class 文件中有效（即 class 保留）</em> 编译期注解　　</li><li>RUNTIME: <em>在运行时有效（即运行时保留） 这个范围更大</em>，写这个一般不会有什么问题<br>生命周期：<em>SOURCE &lt; CLASS &lt; RUNTIME</em></li></ol><p><em>使用场景</em></p><ol><li>一般如果需要在<strong>运行时去动态获取注解信息</strong>，用 RUNTIME 注解，Retrofit</li><li>要在编译时进行一些<em>预处理操作</em>，如 <strong>ButterKnife，用 CLASS 注解。注解会在 class 文件中存在，但是在运行时会被丢弃</strong></li><li>做一些检查性的操作，<strong>如@Override，用 SOURCE 源码注解</strong>。注解仅存在源码级别，在编译的时候丢弃该注解</li></ol><p>@Target：注解对象的作用范围。</p><p>创建一个注解遵循： public @interface 注解名 {方法参数} (运行时注入)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> getViewTo &#123;<br><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span>  -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//绑定一个View （View不能为private 或者static）否则就会通过反射去获取</span><br><span class="hljs-meta">@BindView(R.id.textview)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Binding</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Activity activity)</span> &#123;<br><span class="hljs-keyword">for</span> (Field field : activity.getClass().getDeclaredFields()) &#123;<br>  <span class="hljs-type">BindView</span> <span class="hljs-variable">bindView</span> <span class="hljs-operator">=</span> field.getAnnotation(BindView.class);<br>  <span class="hljs-keyword">if</span> (bindView != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>  field.setAccessible(<span class="hljs-literal">true</span>);<br>  field.set(activity, activity.findViewById(bindView.value()));<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>  e.printStackTrace();<br>&#125;<br>  &#125;<br>&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编译时注解-（class）与运行时注解（RUNTIME）"><a href="#编译时注解-（class）与运行时注解（RUNTIME）" class="headerlink" title="编译时注解 （class）与运行时注解（RUNTIME）"></a>编译时注解 （class）与运行时注解（RUNTIME）</h4><p>保留阶段: 编译时注解在编译期间被存储在. Class 字节码文件中，运行时无法访问。而运行时注解保留到运行时，可在运行时访问。<br>原理: <strong>编译时注解通过 APT、AbstractProcessor 等机制工作，而运行时注解是 Java 反射机制</strong>。<br>性能: 运行时注解由于使用 Java 反射，对性能有影响。编译时注解对性能没影响。<br>立物: <strong>运行时注解只需自定义注解处理器即可，不会产生其他文件。而编译时注解通常会立生新的 Java 源文件</strong>。<br>用途: 运行时注解通常在运行时被访问，例如 Retrofit 的运行时注解，需要用的时候才用到。编译时注解如@Override、 @SuppressWarnings 等，在编译期间被处理</p><h2 id="AOP（思想）"><a href="#AOP（思想）" class="headerlink" title="AOP（思想）"></a>AOP（思想）</h2><p>正如面向对象编程是对常见问题的模块化一样，面向切面编程是对横向的同一问题进行模块化，比如在某个包下的所有类中的某一类方法中都需要解决一个相似的问题，可以通过 AOP 的编程方式对此进行模块化封装，统一解决</p><p><strong>AOP 编程的具体使用场景</strong><br>日志记录<br>持久化<br>行为监测<br>数据验证<br>缓存<br>…</p><p>比如埋点，记录方法执行的时长。可以定义注解。aop 可以过滤所有被”这个注解”标记的方法和构造器。然后可以根据他提供的方法（注解），将我们想要埋点的日志插入到前面或后面。</p><p><strong>aop 三大工具</strong></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-06-14-36-1243f403caedbbb3673f06080749f3db-18-51-39-1243f403caedbbb3673f06080749f3db-unknown_filename.5-75728c-47e122.png" alt="unknown_filename.5|600"></p><p>APT：<br>解析注解生成新的文件，这其中我们最常见到的了，难度也最低。定义编译期的注解，再通过继承 Proccesor 实现代码生成逻辑，实现了编译期生成代码的逻辑。（DataBinding, Dagger2, ButterKnife, EventBus3）</p><p>AspectJ：<br>编译期和加载时代码方法等前后注入（代表框架： Hugo (Jake Wharton)）</p><p>javassist：<br>这层还有 asm，在 class 文件被转化为 dex 文件之前去修改。（ [[Gradle插件]] ）</p><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>Annotation Processing Tool (APT),<strong>注解处理工具</strong>，javac 中用于编译时扫描和解析 Java 注解的工具。可以自己定义。<br>在编译阶段执行的，它的原理就是读入 Java 源代码，解析注解，然后生成新的 Java 代码，新生成的 Java 代码最后被编译成 Java 字节码，注解解析器<strong>不能改变读入的 Java 类，比如不能加入或删除 Java 方法</strong>。</p><p>Java API 已经提供了扫描源码并解析注解的框架，开发者可以通过继承 <em>AbstractProcessor</em> 类来实现自己的注解处理逻辑。</p><p>APT 的原理：在注解了某些代码元素（如字段、函数、类等）后，<em>在编译时编译器会检查 AbstractProcessor 的子类，并且自动调用其 process() 方法</em>，然后将添加了指定注解的所有代码元素作为参数传递给该方法，开发者在根据注解元素在编译期输出对应的 Java 代码。</p><p>APT 负责处理编译时注解，JavaPoet 用于生成 Java 代码，AutoService 负责注册注解处理器。</p><h3 id="AutoServcie"><a href="#AutoServcie" class="headerlink" title="AutoServcie"></a>AutoServcie</h3><p>以前要注册注解处理器要在 module 的 META_INFO 目录新建 services 目录，并创建一个名为 Java.annotation.processing.Processor 的文件，然后在文件中写入要注册的注解处理器的全名。</p><p>后来 Google 推出了 AutoService 注解库来实现注册注解处理器的注册，通过在注解处理器上<em>加上 @AutoService(Processor.class) 注解，即可在编译时生成 META_INFO 信息</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BindViewProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JavaPoet"><a href="#JavaPoet" class="headerlink" title="JavaPoet"></a>JavaPoet</h3><p><a href="https://blog.csdn.net/l540675759/article/details/82931785">javaPoet使用指南</a></p><p><a href="https://github.com/greenrobot/EventBus/blob/master/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java">eventbus如何用的 </a></p><p>JavaPoet比普通方法 (手动字符串拼接)创建更加方便<br>APT 传统方式（手动字符串拼接）—》生成 java 文件<br>APT JavaPoet 方式–》生成 Java 文件</p><p>Butterknife_Framework_20200225 项目原生<br>New_Modular_CustomARouter 项目 javaPoet</p><h3 id="ButterKnife-的实现"><a href="#ButterKnife-的实现" class="headerlink" title="ButterKnife 的实现"></a>ButterKnife 的实现</h3><p>分为四步：</p><ol><li>定义注解</li><li>注解处理器处理注解</li><li>生成 Java 文件</li><li>引入</li></ol><h5 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BindView &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注解处理器处理注解、生成-Java-文件"><a href="#注解处理器处理注解、生成-Java-文件" class="headerlink" title="注解处理器处理注解、生成 Java 文件"></a>注解处理器处理注解、生成 Java 文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BindViewProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Elements mElementsUtils;<br>    <span class="hljs-keyword">private</span> Types mTypesUtils;<br>    <span class="hljs-keyword">private</span> Filter mFilter;<br>    <span class="hljs-keyword">private</span> Messager mMessager;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化方法</span><br><span class="hljs-comment">     * 可以初始化一些给注解处理器使用的工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>        mElementsUtils = processingEnvironment.getElementUtils();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定目标注解对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        hashSet.add(BindView.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> hashSet;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定使用的 Java 版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SourceVersion.latestSupported();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理注解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-comment">//获取所有包含 BindView 注解的元素</span><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; elementSet = roundEnvironment.getElementsAnnotatedWith(BindView.class);<br>        Map&lt;TypeElement, Map&lt;Integer, VariableElement&gt;&gt; typeElementMapHashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Element element : elementSet) &#123;<br>            <span class="hljs-comment">//因为 BindView 的作用对象是 FIELD，因此 element 可以直接转化为 VariableElement</span><br>            <span class="hljs-type">VariableElement</span> <span class="hljs-variable">variableElement</span> <span class="hljs-operator">=</span> (VariableElement) element;<br>            <span class="hljs-comment">//getEnclosingElement 方法返回封装此 Element 的最里层元素</span><br>            <span class="hljs-comment">//如果 Element 直接封装在另一个元素的声明中，则返回该封装元素</span><br>            <span class="hljs-comment">//此处表示的即是 Activity 类对象</span><br>            <span class="hljs-type">TypeElement</span> <span class="hljs-variable">typeElement</span> <span class="hljs-operator">=</span> (TypeElement) variableElement.getEnclosingElement();<br>            Map&lt;Integer, VariableElement&gt; variableElementMap = typeElementMapHashMap.get(typeElement);<br>            <span class="hljs-keyword">if</span> (variableElementMap == <span class="hljs-literal">null</span>) &#123;<br>                variableElementMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                typeElementMapHashMap.put(typeElement, variableElementMap);<br>            &#125;<br>            <span class="hljs-comment">//获取注解的值，即 ViewId</span><br>            <span class="hljs-type">BindView</span> <span class="hljs-variable">bindAnnotation</span> <span class="hljs-operator">=</span> variableElement.getAnnotation(BindView.class);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">viewId</span> <span class="hljs-operator">=</span> bindAnnotation.value();<br>            variableElementMap.put(viewId, variableElement);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (TypeElement key : typeElementMapHashMap.keySet()) &#123;<br>            Map&lt;Integer, VariableElement&gt; elementMap = typeElementMapHashMap.get(key);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> ElementUtil.getPackageName(mElementsUtils, key);<br>            <br>            <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(packageName, generateCodeByPoet(key, elementMap)).build();<br>            <span class="hljs-keyword">try</span> &#123;<br>                javaFile.writeTo(processingEnv.getFiler());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 Java 类</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> typeElement        注解对象的上层元素对象，即 Activity 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> variableElementMap Activity 包含的注解对象以及注解的目标对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> TypeSpec <span class="hljs-title function_">generateCodeByPoet</span><span class="hljs-params">(TypeElement typeElement, Map&lt;Integer, VariableElement&gt; variableElementMap)</span> &#123;<br>        <span class="hljs-comment">//自动生成的文件以 Activity 名 + ViewBinding 进行命名</span><br>        <span class="hljs-keyword">return</span> TypeSpec.classBuilder(ElementUtil.getEnclosingClassName(typeElement) + <span class="hljs-string">&quot;ViewBinding&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC)<br>                .addMethod(generateMethodByPoet(typeElement, variableElementMap))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> typeElement        注解对象上层元素对象，即 Activity 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> variableElementMap Activity 包含的注解对象以及注解的目标对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> MethodSpec <span class="hljs-title function_">generateMethodByPoet</span><span class="hljs-params">(TypeElement typeElement, Map&lt;Integer, VariableElement&gt; variableElementMap)</span> &#123;<br>        <span class="hljs-type">ClassName</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> ClassName.bestGuess(typeElement.getQualifiedName().toString());<br>        <span class="hljs-comment">//方法参数名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;_&quot;</span> + StringUtil.toLowerCaseFirstChar(className.simpleName());<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;bind&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)<br>                .returns(<span class="hljs-keyword">void</span>.class)<br>                .addParameter(className, parameter);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> viewId : variableElementMap.keySet()) &#123;<br>            <span class="hljs-type">VariableElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> variableElementMap.get(viewId);<br>            <span class="hljs-comment">//被注解的字段名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> element.getSimpleName().toString();<br>            <span class="hljs-comment">//被注解的字段的对象类型的全名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> element.asType().toString();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;0&#125;.&#123;1&#125;=(&#123;2&#125;)(&#123;3&#125;.findViewById(&#123;4&#125;));\n&quot;</span>;<br>            methodBuilder.addCode(MessageFormat.format(text, parameter, name, type, parameter, String.valueOf(viewId)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> methodBuilder.build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ButterKnife</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Activity activity)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> activity.getClass();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">bindViewClass</span> <span class="hljs-operator">=</span> Class.forName(clazz.getName() + <span class="hljs-string">&quot;ViewBinding&quot;</span>);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> bindViewClass.getMethod(<span class="hljs-string">&quot;bind&quot;</span>, clazz);<br>            method.invoke(<span class="hljs-literal">null</span>, activity);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="debug-apt"><a href="#debug-apt" class="headerlink" title="debug apt"></a>debug apt</h3><p><a href="https://www.jianshu.com/p/80a14bc35000">如何debug自定义AbstractProcessor</a> 好用</p><p><a href="https://www.jianshu.com/p/4fef2ad51f5a">Android APT 编译期进入debug模式</a><br>选 app 或者生成代码的 module</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">netstat -aon|findstr <span class="hljs-string">&quot;5005&quot;</span><br>tasklist|findstr <span class="hljs-string">&quot;5005&quot;</span><br>gradlew <span class="hljs-comment">--daemon</span><br><br>gradlew clean :app:assembleDebug -Dorg.gradle.<span class="hljs-built_in">debug</span>=<span class="hljs-literal">true</span> <span class="hljs-comment">--no-daemon</span><br>gradlew clean assembleDebug<br></code></pre></td></tr></table></figure><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><p>AspectJ 就是面向切面编程在 Java 中的一种具体实现。</p><p>Join point：程序中执行代码插入的点，例如方法调用时或者方法执行时。</p><p><a href="https://juejin.im/post/5cf1d81551882549657ce1cf#comment">Android开发之AOP编程(不错)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">enabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//在连接点进行方法替换</span><br><span class="hljs-meta">@Around(&quot;execution(@com.allin.medrecorddossier.aop.annotation.PMUserPermission * *(..))&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundJoinPoint</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-keyword">if</span> (enabled) &#123;<br><span class="hljs-keyword">return</span> joinPoint.proceed();<span class="hljs-comment">//执行原方法</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>双击</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectOnClick</span> &#123;  <br><br>    <span class="hljs-comment">//上次点击的时间  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">sLastclick</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">FILTER_TIMEM</span> <span class="hljs-operator">=</span> <span class="hljs-number">500L</span>;  <br>    <span class="hljs-comment">//上次点击事件View  </span><br>    <span class="hljs-keyword">private</span> WeakReference&lt;View&gt; weakReference;  <br>    <br>    <span class="hljs-comment">//是否过滤点击 默认是  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">checkClick</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <br>    <span class="hljs-meta">@Pointcut(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOnClick</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Around(&quot;setOnClick()&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">aroundSetOnClick</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint )</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-keyword">if</span> (System.currentTimeMillis() - sLastclick &gt;= FILTER_TIMEM) &#123;  <br>            doClick(proceedingJoinPoint);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//---- update content ----- 判断是否需要过滤点击  </span><br>            <span class="hljs-comment">//小于指定秒数 但是不是同一个view 可以点击 或者不过滤点击  </span><br>            <span class="hljs-keyword">if</span> (!checkClick || weakReference == <span class="hljs-literal">null</span> || weakReference.get() != proceedingJoinPoint.getArgs()[<span class="hljs-number">0</span>]) &#123;  <br>                doClick(proceedingJoinPoint);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//大于指定秒数 且是同一个view  </span><br><span class="hljs-comment">//                Log.e(TAG, &quot;重复点击,已过滤&quot;);  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">//执行原有的 onClick 方法  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doClick</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-comment">//判断 view 是否存在  </span><br>        <span class="hljs-keyword">if</span> (joinPoint.getArgs().length == <span class="hljs-number">0</span>) &#123;  <br>            joinPoint.proceed();  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//记录点击的view  </span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">lastView</span> <span class="hljs-operator">=</span> (View) (joinPoint).getArgs()[<span class="hljs-number">0</span>];  <br>        weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(lastView); <br>        <span class="hljs-comment">//记录点击事件  </span><br>        sLastclick = System.currentTimeMillis();  <br>        <span class="hljs-comment">//执行点击事件  </span><br>        joinPoint.proceed();  <br>  <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IOC-思想"><a href="#IOC-思想" class="headerlink" title="IOC (思想)"></a>IOC (思想)</h2><p>原来由程序代码中主动获取的资源，转变由第三方获取并使原来的代码被动接收的方式，以达到解耦的效果，称为控制反转<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-06-14-36-342a714123aa06d8aade1fe8380aff94-18-51-39-342a714123aa06d8aade1fe8380aff94-unknown_filename.4-fc5fb1-e7410c.png" alt="unknown_filename.4|600"></p><ol><li>运行时注入 xUtils, eventBus, springMVC （在运行的时候获取注解、解析注解）</li><li>源码时注入 android studio 插件</li><li>编译时注入 butterknife, dagger2 （apt 就是编译时注入，生成文件，运行的时候加载这个文件调方法就可以了）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JettButterknife</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Activity activity)</span>&#123;<br>String name=activity.getClass().getName()+<span class="hljs-string">&quot;_ViewBinding&quot;</span>;<br><span class="hljs-keyword">try</span>&#123;<br>Class&lt;?&gt; aClass=Class.forName(name);<br>IBinder iBinder=(IBinder)aClass.newInstance();<br>iBinder.bind(activity);<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密</title>
    <link href="/2025/12/7cded30043dc.html"/>
    <url>/2025/12/7cded30043dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="加密序列化"><a href="#加密序列化" class="headerlink" title="加密序列化"></a>加密序列化</h1><h3 id="一个漏洞"><a href="#一个漏洞" class="headerlink" title="一个漏洞"></a>一个漏洞</h3><p>标准情况下，私有目录的文件权限最后三位应为空(类似“rw-rw—-”)，即除应用本身外任何人无法读写;目录则允许多一个执行位(类似“rwxrwx—r&#x2F;w&#x2F;rw”)。<br>漏洞模拟：<br>1、编写漏洞App 存储sp 为 MODE_WORLD_READABLE（应该使用MODE_PRIVATE）<br>2、编写黑客 App 获取 漏洞 App的数据内容。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">SharedPreferences sp = getSharedPreferences(<span class="hljs-string">&quot;sp&quot;</span>, MODE_PRIVATE);<br>            SharedPreferences.Editor <span class="hljs-keyword">edit</span> = sp.<span class="hljs-keyword">edit</span>();<br>            <span class="hljs-keyword">edit</span>.putInt(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-number">123456</span>);<br>            <span class="hljs-keyword">edit</span>.apply();<br>            mTvSp.setText(<span class="hljs-string">&quot;密码存储完毕&quot;</span>);<br>    <br><br></code></pre></td></tr></table></figure><p>对称加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">mTvAes.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-comment">//原文 or 密文</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES对称加密&quot;</span>;<br>    <span class="hljs-comment">//秘钥</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;todayinformation&quot;</span>; <span class="hljs-comment">//不好，明文</span><br>    <span class="hljs-comment">//&quot;算法/工作模式/填充模式&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">CIPHER_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isAdle) &#123;<br>            <span class="hljs-comment">//去加密</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//生成秘钥</span><br>                <span class="hljs-type">SecretKey</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(key.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>), <span class="hljs-string">&quot;AES&quot;</span>);<br>                <span class="hljs-comment">//加密解密器</span><br>                <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>                <span class="hljs-comment">//Cipher.ENCRYPT_MODE 加密模式</span><br>                cipher.init(Cipher.ENCRYPT_MODE,secretKey);<br>                <span class="hljs-comment">//bytes 解密后的字节数组</span><br>                <span class="hljs-type">byte</span>[] bytes = cipher.doFinal(content.getBytes());<br>                <span class="hljs-comment">//如果不转成16进制 会出现乱码，因为我们加密的原文有中文</span><br>                content = ByteUtil.parseByte2HexStr(bytes);<br>                mTvAes.setText(<span class="hljs-string">&quot;加密后的结果 = &quot;</span> + content);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//去解密</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">SecretKey</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(key.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>), <span class="hljs-string">&quot;AES&quot;</span>);<br>                <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>                <span class="hljs-comment">//仅仅只有这里不一样 解密模式</span><br>                cipher.init(Cipher.DECRYPT_MODE,secretKey);<br>                <span class="hljs-type">byte</span>[] bytes = cipher.doFinal(ByteUtil.parseHexStr2Byte(content));<br>                content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                mTvAes.setText(<span class="hljs-string">&quot;解密后的结果 = &quot;</span> + content);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        isAdle = !isAdle;<br>    &#125;<br>&#125;);<br>    <br></code></pre></td></tr></table></figure><h3 id="替换式加密"><a href="#替换式加密" class="headerlink" title="替换式加密"></a>替换式加密</h3><p>按规则使⽤不同的⽂字来替换掉原先的⽂字来进⾏加密</p><blockquote><p>码表：<br>原始字符：ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>密码字符：BCDEFGHIJKLMNOPQRSTUVWXYZA<br>原始书信：I love you<br>加密书信：J mpwf zpv<br>解读后：I love you</p></blockquote><p>加密算法：替换⽂字<br>密钥：替换的码表</p><h3 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h3><ul><li><p>可以加密任何⼆进制数据</p></li><li><p>⾮对称加密的出现使得密码学有了更⼴泛的⽤途：数字签名</p></li></ul><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>加密和解密是用的同一把钥匙</p><p>把数据改得别人看不懂，即为加密；按照原路倒退着把数据改回来，即为解密。</p><p><strong>经典算法</strong><br>DES（56 位密钥，密钥太短⽽逐渐被弃⽤）、AES（128 位、192 位、256 位密钥，现在最流⾏）</p><p><strong>对称加密作⽤</strong><br>加密通信，防⽌信息在不安全⽹络上被截获后，信息被⼈读取或篡改。</p><p><strong>反破解</strong><br>⼀种优秀的对称加密算法的标准是，让破解者找不到⽐穷举法（暴⼒破解法）更有效的破解⼿段，并且穷举法的破解时间⾜够⻓（例如数千年）。</p><p><strong>对称加密的缺点</strong><br>密钥泄露：不能在不安全⽹络上传输密钥，⼀旦密钥泄露则加密通信失败。</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>原理：使⽤公钥对数据进⾏加密得到密⽂；使⽤私钥对数据进⾏解密得到原数据<br>私有密钥：一方保管<br>公有密钥：双方公有<br>发送数据之前要先和服务端约定生成公钥和私钥，<em>使用公钥加密的数据可以用私钥解密</em><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%8A%A0%E5%AF%86%E5%BA%8F%E5%88%97%E5%8C%96.resources/2023/09/15/17-37-02-acf4a4fa094186571385ce89ca141324-unknown_filename-5213f1.png" alt="unknown_filename"></p><p>由于私钥和公钥互相可解，因此⾮对称加密还可以应⽤于数字签名技术。<br>通常会对原数据 hash 以后对 hash 签名，然后附加在原数据的后⾯作为签名。这是为了让数据更⼩，别人公钥解密即可验证加密者的身份<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%8A%A0%E5%AF%86%E5%BA%8F%E5%88%97%E5%8C%96.resources/2023/09/15/17-37-02-af43325b1854854840c8500381d8ac09-unknown_filename.1-e4f0a1.png" alt="unknown_filename.1"></p><p>经典算法：RSA（可⽤于加密和签名）、DSA（仅⽤于签名，但速度更快）<br>RSA加密简单过程</p><ol><li>服务端生成配对的公钥和私钥</li><li>私钥保存在服务端，公钥发送给客户端</li><li>客户端使用公钥加密明文传输给服务端</li><li>服务端使用私钥解密密文得到明文</li></ol><p><strong>⾮对称加密的优缺点</strong><br>优点：可以在不安全⽹络上传输密钥<br>缺点：计算复杂，因此性能相⽐对称加密差很多</p><h4 id="Md5"><a href="#Md5" class="headerlink" title="Md5"></a>Md5</h4><p>1+6&#x3D;7，但是给你个7你能知道这是几跟几加得的吗？如果有人坚持认为 MD5算法是可逆的，请不妨设想一下将 MD5算法应用到文件压缩方面，那岂不是又出现了一种超级压缩技术了。。好几个 G 大小的文件都能压缩成一串 MD5，反正”可以求逆”也就是解压缩 (如果应用于压缩技术，算法就是公开的了，也不用费劲去破解了)。可惜这个显然是不可能的，哈哈哈</p><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>将⼆进制数据转换成由 64 个字符组成的字符串的编码算法</p><p><strong>什么是⼆进制数据？</strong><br>⼴义：所有计算机数据都是⼆进制数据<br>狭义：⾮⽂本数据即⼆进制数据</p><p><strong>算法</strong><br>将原数据每 6 位对应成 Base 64 索引表中的⼀个字符编排成⼀个字符串（每个字符8 位，3&#x2F;4）。算法是公开的</p><p><strong>Base64 的⽤途</strong></p><ol><li>将⼆进制数据扩充了储存和传输途径（例如可以把数据保存到⽂本⽂件、可以通过聊天对话框或短信形式发送⼆进制数据、可以在 URL 中加⼊简单的⼆进制数据）</li><li>普通的字符串在经过 Base64 编码后的结果会变得⾁眼不可读，因此可以适⽤于⼀定条件下的防偷窥（较少⽤）</li></ol><p><strong>Base64 的缺点</strong><br>因为⾃身的原理（6 位变 8 位），因此每次 Base64 编码之后，数据都会增⼤约1&#x2F;3，所以会影响存储和传输性能。</p><p><strong>Base64 加密图⽚传输更安全和⾼效？？？</strong><br>不。⾸先，Base64 并不是加密；另外，Base64 会导致数据增⼤ 1&#x2F;3，降低⽹络性能，增⼤⽤户流量开销，是画蛇添⾜的⼿段。（最好不要拿来 diss 你们公司的后端哟，友善）<br>Base64 对图⽚进⾏编码的⽤于在于，有时需要<strong>使⽤⽂本形式来传输图⽚</strong>。除此之外，完全没必要使⽤ Base64 对图⽚进⾏额外处理。</p><h4 id="URL-使⽤的百分号编码"><a href="#URL-使⽤的百分号编码" class="headerlink" title="URL 使⽤的百分号编码"></a>URL 使⽤的百分号编码</h4><p>在 URL 的字符串中，对⼀些不⽤于特殊⽤途的保留字符，使⽤百分号 “%” 为前缀进⾏单独编码，以避免出现解析错误。<br>例如，要在 <a href="http://hencoder.com/users">http://hencoder.com/users</a> 后⾯添加查询字符串，查询 name 为「隐秘&amp;伟⼤」的⽤户，如果直接写成 <a href="http://hencoder.com/user/?name=%E9%9A%90%E7%A7%98&%E4%BC%9F%E2%BC%A4">http://hencoder.com/user/?name=隐秘&amp;伟⼤</a><br>，”&amp;” 符号就会被解析为分隔符号，因此需要对它进⾏转码，转码后的 URL 为 <a href="http://hencoder.com/user/?name=%E9%9A%90%E7%A7%98&%E4%BC%9F%E2%BC%A4">http://hencoder.com/user/?name=隐秘%26伟⼤</a> 。<br>这种编码仅⽤于 URL，⽬的是避免解析错误的出现。</p><h4 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h4><p><strong>含义</strong><br>压缩：将数据使⽤更具有存储优势的编码算法进⾏编码。<br>解压缩：将压缩数据解码还原成原来的形式，以⽅便使⽤。<br><strong>⽬的</strong><br>减⼩数据占⽤的存储空间。</p><p><strong>压缩是编码吗？</strong><br>是。所谓编码，即把数据从⼀种形式转换为另⼀种形式。压缩过程属于编码过程，解压缩过程属于解码过程。<br><strong>常⻅压缩算法</strong><br>DEFLATE、JPEG、MP3 等。</p><p><strong>图⽚与⾳频、视频编解码</strong><br>将图像、⾳频、视频数据通过编码来转换成存档形式（编码），以及从存档形式转换回来（解码）。<br>⽬的：存储和压缩媒体数据（⼤多数媒体编码算法会压缩数据，但不是全部）。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><strong>定义</strong><br>把任意数据转换成指定⼤⼩范围（通常很⼩，例如 256 字节以内）的数据。<br><strong>作⽤</strong><br>相当于从数据中提出摘要信息，因此最主要⽤途是数字指纹。<br>Hash 是把任意数据转变成一小段数据，以便使用这一小段数据作为原数据的数字指纹，降低甄别成本。</p><h5 id="Hash-的实际⽤途"><a href="#Hash-的实际⽤途" class="headerlink" title="Hash 的实际⽤途"></a>Hash 的实际⽤途</h5><h5 id="唯⼀性验证"><a href="#唯⼀性验证" class="headerlink" title="唯⼀性验证"></a>唯⼀性验证</h5><p>例如 Java 中的 hashCode() ⽅法。</p><p><strong>怎么重写 hashCode ⽅法？</strong><br>把 equals() ⽅法中的每个⽤于判断相等的变量都放进 hashCode() 中，⼀起⽣成⼀个尽量不会碰撞的整数即可</p><blockquote><p>为什么每次重写 equals() ⽅法都需要？因为你要把新的判断条件放进hashCode() 啊。</p></blockquote><h5 id="数据完整性验证"><a href="#数据完整性验证" class="headerlink" title="数据完整性验证"></a>数据完整性验证</h5><p>从⽹络上下载⽂件后，通过⽐对⽂件的 Hash 值（例如 MD5、SHA1），可以确认下载的⽂件是否有损坏。如果下载的⽂件 Hash 值和⽂件提供⽅给出的 Hash 值⼀致，则证明下载的⽂件是完好⽆损的。</p><h5 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h5><p>HashMap</p><h5 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h5><p>当重要数据必须暴露的时候，有事可以选择暴露它的 Hash 值（例如 MD5），以保障原数据的安全。例如⽹站登录时，可以只保存⽤户密码的 Hash 值，在每次登录验证时只需要将输⼊的密码的 Hash 值和数据库中保存的 Hash 值作⽐对就好，⽹站⽆需知道⽤户的密码。这样，当⽹站数据失窃时，⽤户不会因为⾃⼰的密码被盗导致其他⽹站的安全也受到威胁。（加盐）<br>注意：这不属于加密。</p><p><strong>Hash 是编码吗？</strong><br>不是。 Hash 是单向过程，往往是不可逆的，⽆法进⾏逆向恢复操作，因此 Hash 不属于编码。<br><strong>Hash 是加密吗？</strong><br>不是。Hash 是单向过程，⽆法进⾏逆向回复操作，因此 Hash <em>不属于加密</em>。（记住，MD5 不是加密！）1+6&#x3D;7,7&#x3D;?+?，推导不出来</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java Lambda</title>
    <link href="/2025/12/de00bd60b777.html"/>
    <url>/2025/12/de00bd60b777.html</url>
    
    <content type="html"><![CDATA[<h2 id="JAVA-Lambda"><a href="#JAVA-Lambda" class="headerlink" title="JAVA Lambda"></a>JAVA Lambda</h2><p>闭包就是Lambda 表达式<br>lambda 表达式，通常是在需要一个函数，但是又不想去命名一个函数的场合下使用，也就是匿名函数。而Lambda可以简化匿名函数，使代码简洁。<br>也可以将一个代码块赋值给一个变量，在调用方法的时候，可以直接将这个lambda表达式当作参数传递进去<a href="https://www.zhihu.com/question/20125256/answer/324121308">链接</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-c8a411081ee3b5bc0e4cbcf524008ee3-unknown_filename-1c39f7.png" alt="unknown_filename"></p><p>什么是Lambda?我们知道，对于一个Java变量，我们可以赋给其一个“值”。<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-bcb8e51fd7ccf4cdd5815eb654adb5c5-unknown_filename.1-e7e944.png" alt="unknown_filename.1"></p><p>如果你想把“一块代码”赋给一个Java变量，应该怎么做呢？<br>比如，我想把右边那块代码，赋给一个叫做aBlockOfCode的Java变量：<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-b5483cd4e1b24538648d914404bbc0bb-unknown_filename.2-74cb8c.png" alt="unknown_filename.2"></p><p>在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-b550e963a52af94425923b3a5a3c94fe-unknown_filename.3-37cde3.png" alt="unknown_filename.3"></p><p>当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加elegant, 我们可以移除一些没用的声明。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-f2106c26a579a34ada3bc2eddd174a17-unknown_filename.4-cbb256.png" alt="unknown_filename.4"></p><p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式。<br>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？<br>在Java 8里面，所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。这是我认为理解Lambda的一个关键所在，简而言之就是，Lambda表达式本身就是一个接口的实现。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-b963d4d265d0f5076d97dfe6bd9598ff-unknown_filename.5-6b2d8e.png" alt="unknown_filename.5"></p><p>这种只有一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。<br>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-eeea87955d4f070b2310b8944e232d46-unknown_filename.6-58325d.png" alt="unknown_filename.6"></p><p>这样，我们就得到了一个完整的Lambda表达式声明：<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-a0eca88c88a767040bc3fc03c85be9dc-unknown_filename.7-91289b.png" alt="unknown_filename.7"></p><p>Lambda 表达式有什么作用?最直观的作用就是使得代码变得异常简洁。我们可以对比一下 Lambda 表达式和传统的 Java 对同一个接口的实现：</p><p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于 Lambda 可以直接赋值给一个变量，我们就可以直接把 Lambda 作为参数传给函数, 而传统的 Java 必须有明确的接口实现的定义，初始化才行：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-e8801d9a1ea836c720eeac8c45045c2a-unknown_filename.9-c60d71.png" alt="unknown_filename.9"></p><p>有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-f83e1c53aa08985ddedfae71c47d89dd-unknown_filename.10-13e9e2.png" alt="unknown_filename.10"></p><p>Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！<br>直接上例子。假设 Person 的定义和 List&lt;Person&gt;的值都给定。</p><p>现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。<br>原生态Lambda写法：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-ec38378f0f999646da004c4c5ae3b37e-unknown_filename.12-33d45b.png" alt="unknown_filename.12"></p><p>这个代码实际上已经比较简洁了，但是我们还可以更简洁么？当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（java.util.function (Java Platform SE 8 )）。<br>所以，我们在这里压根都不需要定义 NameChecker 和 Executor 这两个函数式接口，直接用 Java 8函数式接口包里的 Predicate&lt;\T&gt;和 Consumer&lt;\T&gt;就可以了——因为他们这一对的接口定义和 NameChecker&#x2F;Executor 其实是一样的。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-5bc2ca944d3f7b68946259a36a9b38c4-unknown_filename.13-6db5d6.png" alt="unknown_filename.13"></p><p>第一步简化 - 利用函数式接口包：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-7f52144c8831edaa4d6bc2d6d2f8ee83-unknown_filename.14-b5fa2a.png" alt="unknown_filename.14"></p><p>静态函数里面的 for each 循环其实是非常碍眼的。这里可以利用 Iterable 自带的 forEach()来替代。forEach()本身可以接受一个 Consumer&lt;\T&gt; 参数。</p><p>第二步简化 - 用Iterable.forEach()取代foreach loop：<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-9fe1b8b0b26596922b02a40ccb725744-unknown_filename.15-9e087e.png" alt="unknown_filename.15"></p><p>由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。<br>stream()的几个方法都是接受 Predicate&lt;\T&gt;，Consumer&lt;\T&gt;等参数的（java.util.stream (Java Platform SE 8 )）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。</p><p>第三步简化 - 利用stream()替代静态函数：<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-71d51708fef84df2ef432897375b8800-unknown_filename.16-2a5f2c.png" alt="unknown_filename.16"></p><p>对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p);</p><p>那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object&#x2F;Class的method来代替Lambda expression。格式如下：<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-aace1c7f50774f12c96486d90f7ae8c4-unknown_filename.17-f55e6d.png" alt="unknown_filename.17"></p><p>第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-12c8a27171db3c87230826528d8af218-unknown_filename.18-10c8a6.png" alt="unknown_filename.18"></p><p>这基本上就是能写的最简洁的版本了。</p><p>在Java 8中，我们会使用Lambda表达式创建匿名方法，<strong>但是有时候，我们的Lambda表达式可能仅仅调用一个已存在的方法</strong>，而不做任何其它事，对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰，Java 8的方法引用允许我们这样做。</p><p><strong>方法引用</strong>是一个更加紧凑，易读的Lambda表达式，注意方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号”::”。<br>方法引用 Person:: compareByAge 在语义上与 Lambda 表达式 (a, b) -&gt; Person.compareByAge(a, b) 是等同的，都有如下特性：真实的参数是拷贝自 Comparator&lt;\Person&gt;.compare 方法，即(Person, Person)；表达式体调用 Person.compareByAge 方法；可以省略掉参数 <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-87567c236f506bf934eb6aab3e143918-unknown_filename.19-5ce731.png" alt="unknown_filename.19"></p><p>Lambda 配合 Optional&lt;\T&gt;可以使 Java 对于 null 的处理变的异常优雅这里假设我们有一个 person object，以及一个 person object 的 Optional wrapper: <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-060fd1c2142a2e9fd497be4a5a6004ec-unknown_filename.20-c06aa5.png" alt="unknown_filename.20"></p><p>Optional&lt;\T&gt;如果不结合 Lambda 使用的话，并不能使原来繁琐的 null check 变的简单。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-18c0379d041e8fbd2736e614088f2302-unknown_filename.21-2c5c1e.png" alt="unknown_filename.21"></p><p>只有当 Optional&lt;\T&gt;结合 Lambda 一起使用的时候，才能发挥出其真正的威力！我们现在就来对比一下下面四种常见的 null 处理中，Java 8的 Lambda+Optional&lt;<br>T&gt;和传统 Java 两者之间对于 null 的处理差异。情况一 - 存在则开干 </p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-b2b683618ce6c75a03651848be8bfacb-unknown_filename.22-f5235c.png" alt="unknown_filename.22"></p><p>情况二 - 存在则返回，无则返回屁<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-58ec0225469183c57e71cb453687ac25-unknown_filename.23-c5626c.png" alt="unknown_filename.23"><br>情况三 - 存在则返回，无则由函数产生<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-3c406fa8a204d56f25099ed7d21ad484-unknown_filename.24-ff37b0.png" alt="unknown_filename.24"><br>情况四 - 夺命连环null检查<img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-72ea94d133222f1de35cd68f8e9ed4d7-unknown_filename.25-25766a.png" alt="unknown_filename.25"></p><p>由上述四种情况可以清楚地看到，Optional&lt;\T&gt;+Lambda 可以让我们少写很多 ifElse 块。尤其是对于情况四那种夺命连环 null 检查，传统 java 的写法显得冗长难懂，而新的 Optional&lt;<br>T&gt;+Lambda 则清新脱俗，清楚简洁。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/kotlin%E3%80%81Lambda.resources/2023/09/15/18-51-19-154a752183be052647f976f88363f659-unknown_filename.26-6d82e3.png" alt="unknown_filename.26"></p><p>关于Java的Lambda, 还有东西需要讨论和学习。比如如何handle lambda exception，如何利用Lambda的特性来进行parallel processing等。</p><p>总之，我只是一如既往地介绍个大概，让你大概知道，哦！原来是这样子就OK了。网上关于Lambda有很多相关的教程，多看多练。假以时日，必定有所精益。 </p>]]></content>
    
    
    <categories>
      
      <category>其他语言</category>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.代理、反射、Hook</title>
    <link href="/2025/12/3bd34b53fec4.html"/>
    <url>/2025/12/3bd34b53fec4.html</url>
    
    <content type="html"><![CDATA[<p>创建对象：newInstance<br>调用方法：invoke（）<br>设置参数：field.set(obj，21);</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>通过代理对象访问目标对象.这样做的好处是：可以在目标对象实现的基础上，扩展目标对象的功能。<br>代理对象拦截真实对象的方法调用，在真实对象调用前／后实现自己的逻辑调用<br>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。</p><p>动态代理的用途与装饰模式很相似，就是为了对某个对象进行增强。所有使用装饰者模式的案例都可以使用动态代理来替换。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81hook.resources/2023/09/15/18-51-39-782e0ca884abd8b94d3639ab8f375b0c-Image-4fa688.jpg" alt="Image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* subject（抽象主题角色）：</span><br><span class="hljs-comment">* 真实主题与代理主题的共同接口。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellBook</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ReaISubject（真实主题角色）：</span><br><span class="hljs-comment">* 定义了代理角色所代表的真实对象。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellBook</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;出版社卖书&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Proxy（代理主题角色）：</span><br><span class="hljs-comment">* 含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真实主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellBook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (realSubject == <span class="hljs-literal">null</span>) &#123;<br>            realSubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        &#125;<br>        sale();<br>        realSubject.sellBook();<br>        give();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sale</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打折&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">give</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;送优惠券&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//静态代理（我们自己静态定义的代理类)</span><br>        <span class="hljs-type">ProxySubject</span> <span class="hljs-variable">proxySubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySubject</span>();<br>        proxySubject.sellBook();<br><br>        <span class="hljs-comment">//动态代理(通过程序动态生成代理类，该代理类不是我们自己定义的。而是由程序自动生成)</span><br>        <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        <span class="hljs-type">MyHandler</span> <span class="hljs-variable">myHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHandler</span>();<br>        myHandler.setProxySubject(realSubject);<br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> (Subject) <br>Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),<br>         realSubject.getClass().getInterfaces(), myHandler);<br>        subject.sellBook();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProxySubject</span><span class="hljs-params">(RealSubject realSubject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.realSubject = realSubject;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy  　指代我们所代理的那个真实对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method   指代的是我们所要调用真实对象的某个方法的Method对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args   　指代的是调用真实对象某个方法时接受的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@reurn</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        sale();<br>        proxy = method.invoke(realSubject, args);<br>        give();<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sale</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打折&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">give</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;送优惠券&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h3><p><strong>接口类型（有一个接口）才能动态代理</strong><br>第二个参数是，Java 规定必须实现个接口，第三个是代理逻辑，要把要代理的类传进去 InvocationHandler<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81hook.resources/2023/09/15/18-51-39-970e26c7766bdff4fd28b3629f88c5c3-unknown_filename.2-2d6607.png" alt="unknown_filename.2"></p><h3 id="代理-startActivity"><a href="#代理-startActivity" class="headerlink" title="代理 startActivity"></a>代理 startActivity</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-03-01-10-00-a8af465c25d9756eb62b976b8df3cc16-18-51-39-a8af465c25d9756eb62b976b8df3cc16-unknown_filename.7-d28efe-a343b7.png" alt="unknown_filename.7|600"></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-03-01-09-56-ec825d48db15301801bbce9ae0f83d69-18-51-39-ec825d48db15301801bbce9ae0f83d69-unknown_filename.8-536d9c-654358.png" alt="unknown_filename.8|600"></p><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-30-10-21-b6f28a47ff6e37406baa546b2a6f9dca-20240130102141-5ec0a5.png" alt="image.png|900"></p><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>JAVA反射机制是在运行状态中，对于任意一个类 (class文件)，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 <br>动态获取类中信息，就是java反射 。可以理解为对类的解剖。</p><p>Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.age = age;<br><span class="hljs-built_in">this</span>.name = name;<br><br>System.out.println(<span class="hljs-string">&quot;Person param run...&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;:&quot;</span>+<span class="hljs-built_in">this</span>.age);<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>();<br>System.out.println(<span class="hljs-string">&quot;person run&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>System.out.println(name+<span class="hljs-string">&quot;...show run...&quot;</span>+age);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot; method run &quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paramMethod</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> num)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;paramMethod run.....&quot;</span>+str+<span class="hljs-string">&quot;:&quot;</span>+num);<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot; static method run......&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何获取字节码文件对象呢"><a href="#如何获取字节码文件对象呢" class="headerlink" title="如何获取字节码文件对象呢"></a>如何获取字节码文件对象呢</h3><p>要想要对字节码文件进行解剖，必须要有字节码文件对象.</p><p>获取Class对象的三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>getClassObject_3();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取字节码对象的方式：</span><br><span class="hljs-comment"> * Object类中的getClass()方法的。</span><br><span class="hljs-comment"> * 想要用这种方式，必须要明确具体的类，并创建对象。</span><br><span class="hljs-comment"> * 麻烦 .</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getClassObject_1</span><span class="hljs-params">()</span>&#123;<br><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> p.getClass();<br><br><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> p1.getClass();<br><br>System.out.println(clazz==clazz1);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 方式二：</span><br><span class="hljs-comment"> * 任何数据类型都具备一个静态的属性.class来获取其对应的Class对象。</span><br><span class="hljs-comment"> * 相对简单，但是还是要明确用到类中的静态成员。</span><br><span class="hljs-comment"> * 还是不够扩展。 </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getClassObject_2</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> Person.class;<br>System.out.println(clazz==clazz1);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 方式三：</span><br><span class="hljs-comment"> * 只要通过给定的类的 字符串名称就可以获取该类，更为扩展。</span><br><span class="hljs-comment"> * 可是用Class类中的方法完成。</span><br><span class="hljs-comment"> * 该方法就是forName.</span><br><span class="hljs-comment"> * 这种方式只要有名称即可，更为方便，扩展性更强。 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getClassObject_3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>;<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);<br><br>System.out.println(clazz);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取-Class-中的构造函数"><a href="#获取-Class-中的构造函数" class="headerlink" title="获取 Class 中的构造函数"></a>获取 Class 中的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo2</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, Exception &#123;<br>createNewObject_2();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createNewObject_2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">//cn.test.bean.Person p = new cn.test.bean.Person(&quot;小强&quot;,39);</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当获取指定名称对应类中的所体现的对象时，</span><br><span class="hljs-comment"> * 而该对象初始化不使用空参数构造该怎么办呢？</span><br><span class="hljs-comment"> * 既然是通过指定的构造 函数进行对象的初始化，</span><br><span class="hljs-comment"> * 所以应该先获取到该构造函数。 通过字节码文件对象即可完成。</span><br><span class="hljs-comment"> * 该方法是：getConstructor(paramterTypes);</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>;<br><span class="hljs-comment">//找寻该名称类文件，并加载进内存，并产生Class对象。</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(name);<br><span class="hljs-comment">//获取到了指定的构造函数对  象。</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getConstructor(String.class,<span class="hljs-type">int</span>.class);<br><br><span class="hljs-comment">//通过该构造器对象的newInstance方法进行对象的初始化。</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">38</span>);<br><br><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createNewObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException&#123;<br><br><span class="hljs-comment">//早期：new时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span><br><span class="hljs-comment">//并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象.</span><br><span class="hljs-comment">//cn.test.bean.Person p = new cn.test.bean.Person();</span><br><br><span class="hljs-comment">//现在：</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>;<br><span class="hljs-comment">//找寻该名称类文件，并加载进内存，并产生Class对象。</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(name);<br><span class="hljs-comment">//如何产生该类的对象呢？</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span>  <span class="hljs-operator">=</span> clazz.newInstance();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取-Class-中的字段"><a href="#获取-Class-中的字段" class="headerlink" title="获取 Class 中的字段"></a>获取 Class 中的字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取字节码文件中的字段。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFieldDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//clazz.getField(&quot;age&quot;);//只能获取公有的，</span><br>field = clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//只获取本类，但包含私有。 </span><br><span class="hljs-comment">//对私有字段的访问取消权限检查。暴力访问。</span><br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>field.set(obj, <span class="hljs-number">89</span>);<br><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> field.get(obj);<br>System.out.println(o);<br><span class="hljs-comment">//cn.test.bean.Person p = new cn.test.bean.Person();</span><br><span class="hljs-comment">//p.age = 30;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取-Class-中的方法"><a href="#获取-Class-中的方法" class="headerlink" title="获取 Class 中的方法"></a>获取 Class 中的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMethodDemo_3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;paramMethod&quot;</span>, String.class,<span class="hljs-type">int</span>.class);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>method.invoke(obj, <span class="hljs-string">&quot;小强&quot;</span>,<span class="hljs-number">89</span>);<br><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMethodDemo_2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>);<br><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;show&quot;</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//获取空参数一般方法。</span><br><br><span class="hljs-comment">//Object obj = clazz.newInstance();</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getConstructor(String.class,<span class="hljs-type">int</span>.class);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">37</span>);<br><br>method.invoke(obj, <span class="hljs-literal">null</span>);<br><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取指定Class中的所有公共函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMethodDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.test.bean.Person&quot;</span>);<br><br>Method[] methods  = clazz.getMethods();<span class="hljs-comment">//获取的都是公有的方法。 </span><br>methods = clazz.getDeclaredMethods();<span class="hljs-comment">//只获取本类中所有方法，包含私有。 </span><br><span class="hljs-keyword">for</span>(Method method : methods)&#123;<br>System.out.println(method);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型类的真实类型"><a href="#泛型类的真实类型" class="headerlink" title="泛型类的真实类型"></a>泛型类的真实类型</h3><p>通过Class类上的 getGenericSuperclass() 或者 getGenericInterfaces() 获取父类或者接口的类型,然后通过ParameterizedType.getActualTypeArguments()<br>Actual Type Arguments 实际的类型参数<br>get Generic Super class 获取泛型超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealType</span>&lt;T&gt;&#123;<br><br><span class="hljs-keyword">private</span> Class&lt;T&gt; clazz;<br><span class="hljs-comment">// 使用反射技术得到T的真实类型</span><br><span class="hljs-keyword">public</span> Class <span class="hljs-title function_">getRealType</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 获取当前new的对象的泛型的父类类型</span><br><span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">pt</span> <span class="hljs-operator">=</span> (ParameterizedType) <span class="hljs-built_in">this</span>.getClass().getGenericSuperclass();<br><span class="hljs-comment">// 获取第一个类型参数的真实类型</span><br><span class="hljs-built_in">this</span>.clazz = (Class&lt;T&gt;) pt.getActualTypeArguments()[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> clazz;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><p><a href="https://www.jianshu.com/p/4f6d20076922">理解 Android Hook 技术以及简单实战 - 简书</a></p><p>使用反射修改 Android 系统底层的方法和宇段<br>Hook ，就是使用反射修改 Android 系统底层的方法和宇段</p><p>Hook（钩子）: Android 操作系统中系统维护着自己的一套事件分发机制，那么 Hook 就是在事件传送到终点前截获并监控事件的传输，并修改事件流程的过程。其实就是代理模式+反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showToast</span><span class="hljs-params">(Context context, CharSequence cs, <span class="hljs-type">int</span> length)</span> &#123;<br><span class="hljs-type">Toast</span> <span class="hljs-variable">toast</span> <span class="hljs-operator">=</span> Toast.makeText(context,cs,length);<br>hook(toast);<br>toast.show();<br>&#125;<br></code></pre></td></tr></table></figure><p>Hook 的选择点：<br><strong>静态变量和单例</strong>，因为一旦创建对象，它们不容易变化，非常容易定位。</p><p>Hook 过程：<br>寻找 Hook 点，原则是静态变量或者单例对象，尽量 Hook public 的对象和方法。<br>选择合适的代理方式，如果是接口可以用动态代理。<br>偷梁换柱——用代理对象替换原始对象。<br>Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作</p><p><strong>应用</strong></p><ul><li>Hook指定应用注入广告</li><li>修复bug</li><li>App登录劫持</li></ul><blockquote><p>登录界面上面的用户信息都存储在EditText控件上，然后通过用户手动点击“登录”按钮才会将上面的信息发送至服务器端去验证账号与密码是否正确。这样就很简单了，黑客们只需要找到开发者在使用EditText控件的getText方法后进行网络验证的方法，Hook该方法，就能劫持到用户的账户与密码了</p></blockquote><p><a href="https://github.com/peiniwan/Chapter02">hook练习</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.Java集合</title>
    <link href="/2025/12/44ede1bd4d8e.html"/>
    <url>/2025/12/44ede1bd4d8e.html</url>
    
    <content type="html"><![CDATA[<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><strong>List、Set、Map是否继承自Collection接口？ (也叫容器类)</strong></p><p>List、Set 是，Map 不是。Map是键值对映射容器双列集合，Collection是单列集合，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><p><strong>Collection 和 Map 的区别</strong></p><p>Collection：单列集合，一次存一个元素<br>Map：双列集合，一次存一对集合，两个元素（对象）存在着映射关系</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E9%9B%86%E5%90%88.resources/2023/09/15/17-54-16-7396cb2022e083b345e389f85ba1996e-unknown_filename-0d8ba6.png" alt="unknown_filename"></p><p><strong>ArrayList、LinkedList的存储性能和特性</strong></p><ol><li>ArrayList 和 Vector 都是使用数组方式存储数据（不是连续），此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢据慢</li></ol><ul><li>LinkedList使用双向链表实现存储（<em>将内存中零散的内存单元通过附加的引用关联起来</em>，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，<em>内存的利用率更高</em>），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</li><li>由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装饰模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</li></ul><p>源码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">List&lt;Integer&gt; list = Collections.<span class="hljs-built_in">synchronizedList</span>(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br><br><span class="hljs-comment">// 内部大概长这样</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span> (mutex) &#123;<br>        list.<span class="hljs-built_in">add</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>技巧</strong></p><p>需要唯一吗？</p><ol><li>需要：Set   <br> 需要制定顺序：     <br> 需要： TreeSet（指定方式排序）   <br> 不需要：HashSet   <br> 但是想要一个和存储一致的顺序(有序：怎么存怎么取):LinkedHashSet</li><li>不需要：List   <br> 需要频繁增删吗？   <br> 需要：LinkedList   <br> 不需要：ArrayList</li></ol><p>如何记录每一个容器的结构和所属体系呢？</p><p>看名字！后缀名就是该集合所属的体系。前缀名就是该集合的数据结构。</p><p>看到array：就要想到数组，就要想到查询快，有角标.<br>看到link：就要想到链表，就要想到增删快，就要想要 add get remove+frist last的方法<br>看到hash:就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。不能保证元素的排列顺序，顺序有可能发生变化<br>看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable，Comparator 。判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。通常这些常用的集合容器都是不同步的。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E9%9B%86%E5%90%88.resources/2023/09/15/17-54-16-dc168fc321411f0f1476c4190ac1633a-unknown_filename.1-e26799.png" alt="unknown_filename.1"></p><p><strong>collection和Collections的区别</strong></p><p>Collection是一个接口，它是Set、List等容器的父接口；<br>Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。<br>Collections集合工具类：操作集合（一般是 list 集合）的工具类。方法全为静态的<br>sort(List list);对 list 集合进行排序;<br>sort(List list, Comparator c) 按指定比较器排序<br>fill(List list, T obj);将集合元素替换为指定对象；<br>swap(List list, int I, int j)交换集合指定位置的元素<br>shuffle(List list); 随机对集合元素排序</p><p><strong>数组和集合相互转换</strong></p><p>Arrays：用于操作数组对象的工具类，全为静态方法<br>asList()：将数组转为 list 集合<br>好处：可通过 list 集合的方法操作数组中的元素：isEmpty()、contains()、indexOf()、set()<br>弊端：数组长度固定，不可使用集合的增删操作。<br>集合转为数组：Collection.toArray()；<br>好处：限定了对集合中的元素进行增删操作，只需获取元素</p><p><strong>List、Map、Set三个接口存取元素时，各有什么特点？</strong></p><p>List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</p><p>Set和Map容器都有基于哈希存储和排序树的两种实现版本，<strong>基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</strong><br>Set就是个接口，hashset通过hashmap实现的</p><ol><li>HashSet：对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。（ArrayList只依赖equals）</li><li>TreeSet：底层是二叉树，可对元素进行排序，默认是自然顺序,保证唯一性：Comparable接口的 compareTo方法的返回值</li><li>HashMap：底层数据结构是哈希表；允许使用 null 键和 null 值，这样的键只有一个；可以有一个或多个键所对应的值为null。不同步，效率高</li><li><strong>HashTable</strong>：底层数据结构是哈希表，不可存入 null键和 null值。同步的</li></ol><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><ul><li>CopyOnWrite 容器可以在并发场景中使用。CopyOnWriteArrayList 的效率比 ArrayList 略有下降，空间利用率也下降了很多，但是 CopyOnWriteArrayList 是线程安全的</li><li>集合容器是不能遍历的时候增删的，会报错 ConcurrentModificationException，防止多个线程同时修改同一个集合的元素。</li><li>CopyOnWriteArrayList就不会报错，它的原理是<em>先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器</em>。这样做的好处是可以对CopyOnWrite容器进行并发的读写，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</li><li>遍历的时候增删可以使用 Iterator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>        <span class="hljs-comment">// 使用迭代器进行安全删除</span><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (element.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>                list.remove(element); <span class="hljs-comment">// 删除元素</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 输出删除后的结果</span><br>        System.out.println(<span class="hljs-string">&quot;删除后的结果：&quot;</span> + list);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>Map集合如何取元素两种获取集合元素的方法</strong></p><ol><li>keySet()方法获取元素原理：将Map集合中的所有键存入到Set集合中，因为Set集合具备迭代器，所以可以用迭代方式取出所有的键，再根据get方法获取每一个键对应的值。简单说就是：Map集合—-&gt;Set集合 —-&gt;迭代器取出</li><li>entrySet()方法获取元素：(上面有)原理：将Map集合中的映射关系存入到了Set集合中，而这个映射关系的数据类型是Map.Entry（结婚证），在通过迭代器将映射关系存入到Map.Entry集合中，并通过其中的getKey()和getValue()放取出键值。</li></ol><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p><strong>TreeMap 和 TreeSet 在排序时如何比较元素？</strong></p><p>答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</p><ol><li>二叉树的存储方式就像树叉一样，所以称为二叉树。而排序树的特点就是把大的数放在右边，小的数放在左边，取值时会按照从小到大的顺序取值。如果数据较多，二叉树会自动折中，然后再去判断，。这样就大大提高了存取的效率。</li><li>说到排序就俩种，自然排序（实现Comparable接口的）和指定顺序排序。排序的两种实现方式，让元素本身具备比较性（Comparable）和让容器具备比较性(比较器Comparator)。</li><li>TreeSet可以对Set集合中的元素进行排序。底层数据结构是二叉树。保证元素唯一性的依据：compareTo方法return 0。TreeSet存储对象的时候, 可以排序, 但是需要指定排序的算法。Integer能排序(有默认顺序), String能排序(有默认顺序), 自定义的类存储的时候出现异常(没有顺序)。如果想把自定义类的对象存入TreeSet进行排序, 那么必须实现Comparable接口。在类上实现Comparable， 重写compareTo()方法，在方法内定义比较算法, 根据大小关系, 返回正数负数或零，在使用TreeSet存储对象的时候, add()方法内部就会自动调用compareTo()方法进行比较, 根据比较结果使用二叉树形式进行存储。</li><li>TreeSet是依靠TreeMap来实现的。TreeSet是一个有序集合，TreeSet中的元素将按照升序排列(指排序的顺序)，缺省是按照自然排序进行排列，意味着TreeSet中的元素要实现Comparable接口。或者有一个自定义的比较器。我们可以在构造TreeSet对象时，传递实现Comparator接口的比较器对象。</li></ol><p>让容器具备比较性,定义比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。当两种排序都存在时，以比较器为主。实现方式：定义一个类，实现Comparator接口，覆盖compare方法。</p><ul><li>需求：对字符串进行按长度排序  </li><li>分析：字符串本身具备比较性，但是是按自然顺序进行的排序，所以需要对排序方式进行重新定义,所以需要让集合具备比较性  </li><li>使用比较器Comparator，覆盖compare 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTreeSet</span> &#123;  <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          TreeSet&lt;ComString&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;ComString&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Mycompare</span>());  <br>          ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComString</span>(<span class="hljs-string">&quot;asd&quot;</span>));  <br>          ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComString</span>(<span class="hljs-string">&quot;df&quot;</span>));  <br>          ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComString</span>(<span class="hljs-string">&quot;dk&quot;</span>));  <br>          ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComString</span>(<span class="hljs-string">&quot;jkkggd&quot;</span>));  <br>          ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComString</span>(<span class="hljs-string">&quot;sfsfssgds&quot;</span>));  <br>    <br>           <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> ts.iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>          System.out.println(it.next());<br>    &#125;<br>   &#125;<br>  &#125;  <br>    <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mycompare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;ComString&gt; &#123;  <br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ComString o1, ComString o2)</span> &#123;  <br>          <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> o1.getS().length() - o2.getS().length();  <br>          <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;  <br>              <span class="hljs-keyword">return</span> o1.getS().compareTo(o2.getS());  <br>          &#125;  <br>          <span class="hljs-keyword">return</span> num;  <br>      &#125;  <br>  &#125;  <br>    <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComString</span> &#123;  <br>      <span class="hljs-keyword">private</span> String s;  <br>    <br>      ComString(String s) &#123;  <br>          <span class="hljs-built_in">this</span>.s = s;  <br>      &#125;  <br>      <br>      <br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorByName</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Perosn&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1,Person o2)</span>&#123;<br>  <span class="hljs-type">int</span> temp=o1.getName().comparaTo.(o2.getName);<br>  <span class="hljs-keyword">return</span> temp==<span class="hljs-number">0</span>? o1.getAge-o2.getAge:temp;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMapDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeMap&lt;Student,String&gt; tm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Student,String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComparatorByName</span>());<br>    <br>    tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">38</span>),<span class="hljs-string">&quot;北京&quot;</span>);<br>    tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhaoliu&quot;</span>,<span class="hljs-number">24</span>),<span class="hljs-string">&quot;上海&quot;</span>);<br>    tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;xiaoqiang&quot;</span>,<span class="hljs-number">31</span>),<span class="hljs-string">&quot;沈阳&quot;</span>);<br>    tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;wangcai&quot;</span>,<span class="hljs-number">28</span>),<span class="hljs-string">&quot;大连&quot;</span>);<br>    tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhaoliu&quot;</span>,<span class="hljs-number">24</span>),<span class="hljs-string">&quot;铁岭&quot;</span>);<br>  <br>      Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = tm.entrySet().iterator(); <br>   <br>    <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>     Map.Entry&lt;Student,String&gt; me = it.next();<br>     <span class="hljs-type">Student</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> me.getKey();<br>     <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> me.getValue();<br>     <br>     System.out.println(key.getName()+<span class="hljs-string">&quot;:&quot;</span>+key.getAge()+<span class="hljs-string">&quot;---&quot;</span>+value);<br>    &#125;<br>     &#125; <br>  &#125;<br>  <br>Collections.sort(list); 自然排序[abc, bbce, cbcef, dbcefg, ebcefgh]<br>mySort(list);<br>mySort(list,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComparatorByLength</span>());<br>Collections.sort(list,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComparatorByLength</span>()); 指定排序（简单）<br>  <br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.泛型</title>
    <link href="/2025/12/298f34f5308d.html"/>
    <url>/2025/12/298f34f5308d.html</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在没有泛型之前，从集合读取到的每一个对象都必须进行转换，如果有人不小心插入了类型错误的对象，在运行的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动为你的插入进行转化，并在编译时告知是否插入了类型错误的对象，这样更安全，也更清楚。</p><p><strong>其他好处</strong><br>为了限制功能，例如 list 里必须统一类型的数据，类型安全，省去转型了。</p><p>或者抽象代码，限制后期只能存放某一类数据<br>同一个方法的参数必须是某一个或者另一个类的子类，也可以同时（泛型方法）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> &lt;E <span class="hljs-keyword">extends</span> Runnable, Serializable&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">(E param)</span></span>;<br></code></pre></td></tr></table></figure><p>泛型的创建者让泛型的使用者可以在使用时（实例化时）细化类型信息，从而可以触及到「使用者所细化的⼦类」的 API。或者，泛型是「有远见的创造者」创造的「方便使用者」的工具</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>让“方法本身”对类型参数化，而不是把类型写死或强行转型。<br> 说明：</p><ol><li>public 与返回值中间&lt;\T&gt;非常重要，可以理解为声明此方法为泛型方法。</li><li><em>只有声明了&lt;\T&gt;的方法才是泛型方法</em>，泛型类中的使用了泛型的成员方法并不是泛型方法。</li><li>&lt;\T&gt;表明该方法将使用泛型类型 T，此时才可以在方法中使用泛型类型 T。</li><li>与泛型类的定义一样，此处 T 可以随便写为任意标识，常见的如 T、E、K、V 等形式的参数常用于表示泛型。</li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">/**<br> * @param tClass 传入的泛型实参<br> * @return T 返回值为T类型<br> */<span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,<br>  IllegalAccessException&#123;<br>        T<span class="hljs-built_in"> instance </span>= tClass.newInstance();<br>       <span class="hljs-built_in"> return </span>instance;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>通过使用方法按步骤看哪可以抽象</strong></p><p>例如网络请求要封装，例如 OKHTTP 用起来还是挺麻烦，每次都写那么一堆显示不合理，可以把请求的 host、path、请求参数、返回结果封装起来。然后返回结果数据都差不多，都有 errro_code、error_msg、data，data 就可以使用泛型、data 又有 list 和不是 list 的，又可以使用泛型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHttpResponse</span>&lt;<span class="hljs-title class_">T</span>&gt; &#123;<br>        <span class="hljs-keyword">private</span> int code;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> msg;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">T</span> data;<br>     ｝<br>        <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListBean</span>&lt;<span class="hljs-title class_">T</span>&gt; &#123;<br>        <span class="hljs-keyword">private</span> int total;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">T</span>&gt; list;<br>     ｝<br>        <br><span class="hljs-type">Flowable</span>&lt;<span class="hljs-type">MyHttpResponse</span>&lt;<span class="hljs-type">ListBean</span>&lt;<span class="hljs-type">MyRecordBean</span>&gt;&gt;&gt; voiceList(<span class="hljs-meta">@Query</span>(<span class="hljs-string">&quot;offset&quot;</span>) int offset);<br>    <br><span class="hljs-type">Flowable</span>&lt;<span class="hljs-type">MyHttpResponse</span>&lt;<span class="hljs-type">TaskStatusBean</span>&gt;&gt; getTaskInfo(<span class="hljs-meta">@Query</span>(<span class="hljs-string">&quot;classCode&quot;</span>) <span class="hljs-type">String</span> classCode);<br>    <br></code></pre></td></tr></table></figure><h2 id="super-和-extends"><a href="#super-和-extends" class="headerlink" title="super 和 extends"></a>super 和 extends</h2><table><thead><tr><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr><td><code>? extends T</code></td><td><code>out T</code></td></tr><tr><td><code>? super T</code></td><td><code>in T</code></td></tr></tbody></table><p>？ entends E: 接收 E 类型或者 E 的子类型对象<br>？ super E: 接收 E 类型或者 E 的父类，<strong>扩大范围</strong></p><p>存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>List&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Apple&gt;()&#123;&#125;;<br>List&lt;Fruit&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Fruit&gt;()&#123;&#125;;<br>apple.addMeToList(apples);<br>apple.addMeToList(fruits);<br>       <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMeToList</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Apple&gt; list)</span> &#123;<br>     list.add(<span class="hljs-built_in">this</span>);<br>    &#125;<br>   &#125;<br>   apple.addMeToList(fruits);<br></code></pre></td></tr></table></figure><p>可以获取，, 看下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;Fruit&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>fruits.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br>fruits.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Banana</span>());<br><span class="hljs-type">float</span> <span class="hljs-variable">fruitsWeight</span> <span class="hljs-operator">=</span> totalWeight(fruits);<br>        <br><span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">totalWeight</span><span class="hljs-params">(List&lt;? extends Fruit&gt; fruits)</span> &#123;<br><span class="hljs-type">float</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Fruit fruit : fruits) &#123;<br>  weight += fruit.weight();<br>&#125;<br><span class="hljs-keyword">return</span> weight;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>另一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//都是在声明的时候使用? extends Fruit，? super Apple</span><br>List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Apple&gt;(); <span class="hljs-comment">// 不能用 add(item)</span><br>List&lt;? <span class="hljs-built_in">super</span> Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Fruit&gt;(); <span class="hljs-comment">// 不能用 get()</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20200102092259.png" alt="QQ截图20200102092259"></p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>在 Java 中，泛型是在 JDK 5.0引入的新特性。为了确保新版本的 Java 与旧版本的代码兼容，设计者决定在编译后将泛型信息擦除，这样可以确保使用泛型的新代码可以与不使用泛型的旧代码进行互操作。</p><p>具体来说，当编译器处理泛型类型时，<em>它会将泛型类型转换为原始类型，并插入必要的强制类型转换以确保类型安全</em>。这个过程就是所谓的“类型擦除”。因此，尽管我们在编写源代码时使用了泛型，但在生成的字节码中，泛型信息已经被擦除了。</p><p>假设我们有一个简单的泛型类 <code>Box</code>，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用这个泛型类创建对象并调用方法时，编译器会进行类型擦除。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Box&lt;Integer&gt; integerBox <span class="hljs-operator">=</span> new Box&lt;&gt;()<span class="hljs-comment">;</span><br>integerBox.setValue(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br>Integer intValue <span class="hljs-operator">=</span> integerBox.getValue()<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>在编译后，上述代码中的泛型信息将被擦除，转换为如下的非泛型代码：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Box integerBox <span class="hljs-operator">=</span> new Box()<span class="hljs-comment">;</span><br>integerBox.setValue(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br>Integer intValue <span class="hljs-operator">=</span> (Integer) integerBox.getValue()<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>在这里，泛型信息 <code>&lt;Integer&gt;</code> 被擦除，编译器在生成的字节码中插入了强制类型转换 <code>(Integer)</code> 来确保类型安全。这样即可保证运行时的类型安全性，并与旧版本的 Java 代码兼容。</p><p><strong>泛型在编译期会被擦除的概念，那么为什么我们在运行时还能读取到呢？</strong></p><p>把例如 T 这类东西擦除（为了兼容旧版本）<br>泛型的使用只是为了我们编写代码时，省去了强制转换，其实最终还是会<em>强转成对应类型的</em>，把代码设置成实际设置值</p><p>通过反射，我们可以获取类的参数化类型，并对其进行操作。Java 中提供了一些 API，如 ParameterizedType，用于在运行时获取泛型信息。利用这些 API，我们可以在运行时对泛型进行操作，例如获取泛型类型、泛型参数等信息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.getClass().getGenericSuperclass();<br></code></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/unknown_filename.1.png" alt="unknown_filename.1"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/unknown_filename.5.png" alt="unknown_filename.5"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/unknown_filename.4.png" alt="unknown_filename.4"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/unknown_filename.3.png" alt="unknown_filename.3"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/unknown_filename.2.png" alt="unknown_filename.2"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/unknown_filename.png" alt="unknown_filename"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.JVM</title>
    <link href="/2025/12/0c812ea54f22.html"/>
    <url>/2025/12/0c812ea54f22.html</url>
    
    <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>当运行 Java 程序时，首先运行 JVM（Java 虚拟机），然后再把 Java class 文件加载到 JVM 里头运行，负责加载 Java class 的这部分叫做 Class Loader。也就是类加载器。与普通程序不同的是，Java 程序（class 文件）并不是本地的可执行程序。</li><li>某个特定的 <code>类加载器在接到加载类的请求时</code>，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以<em>完成类加载任务</em>，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。<br>  委托机制的意义 — <strong>防止内存中出现多份同样的字节码</strong><br>  如果不用委托而是自己加载自己的，那么类 A 就会加载一份 System 字节码，然后类 B 又会加载一份 System 字节码，这样内存中就出现了两份 System 字节码。</li></ul><h4 id="java-虚拟机的特性"><a href="#java-虚拟机的特性" class="headerlink" title="java 虚拟机的特性"></a>java 虚拟机的特性</h4><p>一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入 Java 语言虚拟机后，Java 语言在不同平台上运行时不需要重新编译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p><h3 id="虚拟机里面"><a href="#虚拟机里面" class="headerlink" title="虚拟机里面"></a>虚拟机里面</h3><p>在虚拟机有栈、堆和方法区。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-474f1f964a2b17029bcec045c70f59c3-unknown_filename-ad723c.png" alt="unknown_filename"></p><ul><li><p>线程共享的：堆、方法区</p></li><li><p>不共享的：栈、程序计数器（代码执行的行号）</p></li><li><p>方法区：类信息、常量池、静态变量，即 <code>类被编译后的数据</code>。系统自动分配和回收。</p></li><li><p>栈区：存储运行方法的形参、局部变量、返回值、<em>对象的引用</em>。由系统自动分配和回收。</p></li><li><p>堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>成员变量（对象的字段）</strong></p><ul><li>成员变量是对象的一部分。</li><li><strong>对象本身在堆上分配</strong>，所以成员变量也存储在<strong>堆</strong>里。</li><li>不管是普通对象引用，还是基本类型字段（<code>int</code>、<code>boolean</code> 等），都跟着对象存在堆上。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span> &#123;<br>    <span class="hljs-built_in">int</span> age;        <span class="hljs-comment">// 在堆上（随着对象存储）</span><br>    String name;    <span class="hljs-comment">// name 引用在堆上，指向的 &quot;xxx&quot; 还是在堆上</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p><strong>局部变量（方法里的变量）</strong></p><ul><li>局部变量的 <strong>引用本身存在栈帧里</strong>（随方法调用进出）。</li><li>如果是基本类型（如 <code>int</code>），直接存在栈帧里的局部变量表里。</li><li>如果是对象（如 <code>new Person()</code>），对象本身仍然在堆上，局部变量只是一个<strong>指向堆的引用</strong>。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;          <span class="hljs-comment">// a 在栈上</span><br>    Person p = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// p 引用在栈上，但 Person 对象在堆上</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>✅ <strong>一句话总结</strong></p><ul><li><strong>成员变量 → 在堆上（随对象存储）</strong></li><li><strong>局部变量 → 引用在栈上，对象还是在堆上</strong></li></ul><blockquote><p><em>成员变量</em>（静态的也一样）共享引起的安全问题，局部变量的话就不会</p></blockquote><p><a href="https://blog.csdn.net/Noreaday/article/details/79711004">如何理解成员变量在堆内，局部变量在栈内？_变量定义时在栈中还是堆中-CSDN博客</a></p><p>![[1.Android内存优化#静态方法]]</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-5bda8d78ac66ccac04fabcaeea922fbb-unknown_filename.10-b29d2f.png" alt="unknown_filename.10"></p><h4 id="程序计数器-Program-Counter-Register-："><a href="#程序计数器-Program-Counter-Register-：" class="headerlink" title="程序计数器 (Program Counter Register)："></a>程序计数器 (Program Counter Register)：</h4><p>一小块内存空间，当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧 （Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>局部变量表存放了<strong>编译期</strong>可知的各种基本数据类型（boolean、byte、char、short、int、float、long、 double）、对象引用（方法区是编译后）</p><ul><li>栈区：<strong>存储运行方法的形参、局部变量、返回值、对象的引用</strong>。由系统自动分配和回收。</li><li>栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。</li><li><em>存在栈中的数据可以共享</em>。假设我们同时定义:  int a &#x3D; 3;　　int b &#x3D; 3;  编译器先处理 int a &#x3D; 3；首先它会在栈中创建一个变量为 a 的引用，然后查找有没有字面值为3的地址，如果没找到，就开辟一个存放3这个字面值的地址，然后将 a 指向3的地址。接着处理 int b &#x3D; 3；在创建完 b 的引用变量后，由于在栈中已经有3这个字面值，便将 b 直接指向3的地址。这样，就出现了 a 与 b 同时均指向3的情况。</li><li>StackOverflowError</li><li>方法压入和弹出</li><li>连续</li></ul><p>默认值为物理内存的 ​<strong>​1&#x2F;64​</strong>​（例如 8GB 内存默认约 128MB），但具体取决于 JVM 版本和平台<br>​<strong>​64 位系统​</strong>​：默认约 ​<strong>​1MB​</strong>​（如 Linux&#x2F;JDK 11+）；JDK 5 之前默认 256KB，后续版本调整为 1MB</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li>用来存放对象的，几乎所有对象都放在这里，被线程共享的，或者说是被栈共享的</li><li>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用（Android 中不适用）。</li><li>堆又可以分为新生代和老年代，实际还有一个区域叫永久代，但是 jdk1.7已经去永久代了，所以可以当作没有，永久代是当 jvm 启动时就存放的 JDK 自身的类和接口数据，关闭则释放。</li><li>oom</li><li>新生代：主要是用来存放新生的对象。一般占据堆的1&#x2F;3空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>类信息、常量池、静态变量，即 <code>类被编译后的数据</code><br>程序中的字面量（literal）如直接书写的100、hello 和常量都是放在常量池中</p><blockquote><p>类信息<br>类型全限定名<br>类型是类类型还是接口类型。<br>类型的访问修饰符（public、abstract 或 final 的某个子集）。<br>类型的常量池。<br><strong>字段名和属性</strong><br><strong>方法名和属性</strong><br>除了常量以外的所有类（静态）变量。</p></blockquote><p><strong>字面值</strong><br>值型的字面值是最常见的，字符串字面值可以算是一种，当然也可以把特殊的 null 当做字面值。字面值大体上可以分为整型字面值、浮点字面值、字符和字符串字面值、特殊字面值。</p><p><strong>常量池的好处</strong><br>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，&#x3D;&#x3D;比 equals () 快。对于两个引用变量，只用&#x3D;&#x3D;判断引用是否相等，也就可以判断实际值是否相等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">String <span class="hljs-attribute">s0</span>=”kvill”; <br>String <span class="hljs-attribute">s1</span>=”kvill”; <br>String <span class="hljs-attribute">s2</span>=”kv” + “ill”; <br>System.out.println( <span class="hljs-attribute">s0</span>==s1 ); <br>System.out.println( <span class="hljs-attribute">s0</span>==s2 ); <br>结果为： <br><span class="hljs-literal">true</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>s0和 s1中的”kvill”都是字符串常量，它们在编译期就被确定了，存放在常量池</p><p>用 new String () 创建的字符串<strong>不是常量，不能在编译期就确定</strong>，所以 new String () 创建的字符串不放入常量池中，它们有自己的地址空间。存放在堆</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-built_in">String</span> s0=”kvill”; <br><span class="hljs-built_in">String</span> s1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(”kvill”); <br><span class="hljs-built_in">String</span> s2=”kv” + <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(“ill”); <br>System.<span class="hljs-keyword">out</span>.println( s0==s1 ); <br>System.<span class="hljs-keyword">out</span>.println( s0==s2 ); <br>System.<span class="hljs-keyword">out</span>.println( s1==s2 ); <br>结果为： <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span><br><br><br><span class="hljs-built_in">String</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而“hello”这个字面量放在<strong>字符串常量池​</strong>​，方法区。</p><h2 id="深入理解-jvm"><a href="#深入理解-jvm" class="headerlink" title="深入理解 jvm"></a>深入理解 jvm</h2><h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><p>哪些内存需要回收？<br>什么时候回收？<br>如何回收？</p><ul><li>Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</li><li>而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，<em>垃圾收集器所关注的是这部分内存</em>。</li></ul><h4 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><ul><li>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</li><li>但是，至少主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</li><li>举个简单的例子，请看代码清单3-1中的 testGC（）方法：对象 objA 和 objB 都有字段 instance，赋值令 objA. instance&#x3D;objB 及 objB. instance&#x3D;objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知 GC 收集器回收它们。<br>  虚拟机并不是通过引用计数算法来判断对象是否存活的。</li></ul><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-7a2f289523a8528913072dc3e683ed93-unknown_filename.3-f891ca.png" alt="unknown_filename.3"><br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要<strong>经历两次标记过程</strong>：</p><ol><li>如果对象在进行可达性分析后发现没有与 GCRoots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是对象是否有必要执行 finalize（）方法。</li><li>当对象没有覆盖 finalize（）方法，或者 finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li></ol><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><ol><li>运行中的线程，thread 就是一种 gcroot, gcroot-&gt;asyntask-&gt;activity (泄露)</li><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li></ol><p>当前正在执行的方法里，只要某个局部变量还“持有”一个对象引用，那么这个对象就一定不能被 GC 回收。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span> ()</span> &#123;<br>    Object obj = <span class="hljs-keyword">new</span> Object (); <span class="hljs-comment">// obj 是本地变量表里的引用</span><br>    doSomething ();<br>&#125;<br><span class="hljs-comment">// 方法结束才能回收</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法区中类静态属性引用的对象。静态变量、静态对象也是一种 gcroot, 例如单例 （长生命周期）</li><li>方法区中常量引用的对象。</li><li>来自本地代码的引用，JNI 的引用是指那些<em>本地代码执行 JNI 调用过程中所创建出来的 Java 对象</em></li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Utils.leakviews.add(view);<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LinkedList&lt;View&gt; leakviews =<span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;( );<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象 (GC Roots 不可达的对象)，在标记完成后统一回收所有被标记的对象。</p><p>这样做的好处：<br>数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。<br>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-845e1b247091fa03122725c5e0087f57-unknown_filename.4-77b425.png" alt="unknown_filename.4"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还<em>存活着的对象复制到另外一块上面</em>，然后再把已使用过的内存空间一次清理掉。<br>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-ee879fc08574b1ae27c6cafbd7367eff-unknown_filename.5-f5b544.png" alt="unknown_filename.5"></p><ul><li>新生代中的对象98%是“朝生夕死”的，所以并不需要按照 1:1的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor [1] 。</li><li>当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</li><li>HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。</li><li>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当 Survivor 空间不够用时</strong>，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><ul><li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</li><li>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，<em>而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</em>。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-361c3ddc589bc8d0e3b1d1d52af27a91-unknown_filename.6-390dd1.png" alt="unknown_filename.6"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul><li>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li></ul><p>标记-清除算法 （会产生空闲内存碎片）<br>标记-整理算法（防止产生内存碎片）<br>复制算法（效率最高，但是内存利用率低）<br><em>JVM 中新生代使用复制算法，老年代使用标记整理算法</em>。</p><p>我的理解</p><ul><li>新生代和老年代分为1：2，新生代分为 Eden和俩个Survivor(&#x2F;sərˈvaɪvər&#x2F; ) 区。from 区和 to 区，8：1：1</li><li>新创建出来的对象放在 Eden 区，Eden 满了以后，会使用一次minor GC （小的 gc），使用复制算法，把存活的对象放在一个 Survivor，然后把 Eden 区清空。</li><li>如果俩个都满了，会把存活的对象当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。会把存活的对象年龄+1<ul><li>在 age 达到一定值时会移动到老年代。</li><li>在 minor GC 时，存活对象大于 to 区域，那么会直接进入老年代</li></ul></li><li>在新生代中，<em>每次垃圾收集时都发现有大批对象销毁，只有少量存活，那就选用复制算法</em>，只需要付出少量存活对象的复制成本就可以完成收集。</li><li>而老年代中因为<em>对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法</em>来进行回收。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-1e7a65daa0f422d345751f444a98c1d0-unknown_filename.7-8792bb.png" alt="unknown_filename.7"><br>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</li></ul><p><em>大对象直接进入老年代</em><br><strong>所谓的大对象是指，需要大量连续内存空间的 Java 对象</strong>，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的 byte[]数组就是典型的大对象）<br>长期存活的对象将进入老年代</p><p><strong>关于跨代引用</strong><br>为了防止不能确定新生代的对象是否被老年代的对象引用而需要进行 full GC 。<br>通过 card table 将老年代分成若干个区域，所以在 minor GC 时只需要对表中记录的老年代区域进行扫描就可以了。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-0ec6420d2d502cb05addbbc2c5eafcc6-unknown_filename.8-efc845.png" alt="unknown_filename.8"></p><p><strong>Minor GC 和 Full GC 有什么不一样吗？</strong><br>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC <em>非常频繁，一般回收速度也比较快</em>。<br>老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过<br>程）。Major GC 的速度一般会比 Minor GC 慢10倍以上。</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出 stackoverflow 异常。</li><li>堆划分的目的是为了更好的回收内存，或者更快的分配内存</li><li>string. intern，运行时也可以将新的常量放在池里</li></ul><blockquote><p>String. intern（）是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。</p></blockquote><ul><li>直接内存：nio，基于通道和缓冲区，它可以使用 native 函数库直接分配堆外的数据。</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>虚拟机遇到一条 new 指令时，首先会检查这个指令的参数是否能在常量池里定位到这个类符号的引用，并且检查这个符号引用的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul><p>对象的内存布局</p><ul><li>对象在内存中存储的布局可以分为3个部分：对象头、实例数据、对齐填充。</li><li>对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码 （HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，Mark Word</li><li>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul><p><strong>对象的访问定位</strong><br>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p><p>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-fb081e0042c97a1ca37855bc0891a9ec-unknown_filename.1-36f732.png" alt="unknown_filename.1"><br>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-28c88d4fbaef28cf4977d0abf07c1db5-unknown_filename.2-222750.png" alt="unknown_filename.2"><br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机 Sun HotSpot 而言，它是使用第二种方式进行对象访问的</p><h3 id="模拟溢出"><a href="#模拟溢出" class="headerlink" title="模拟溢出"></a>模拟溢出</h3><p><strong>堆溢出</strong><br>当出现 Java 堆内存溢出时，异常堆<br>栈信息“java. lang. OutOfMemoryError”会跟着进一步提示“Java heap space”</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">java. lang. OutOfMemoryError：Java heap <span class="hljs-literal">space</span><br>Dumping heap <span class="hljs-built_in">to</span> java_pid3404. hprof……<br>Heap dump <span class="hljs-built_in">file</span> created[<span class="hljs-number">22045981</span> <span class="hljs-keyword">bytes</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0.663</span> <span class="hljs-built_in">secs</span><br><br></code></pre></td></tr></table></figure><p>Eclipse Memory Analyzer<br>如果是内存泄露，可进一步通过工具查看泄露对象到 GC Roots 的引用链。于是就能找到泄露对象是<br>通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。</p><p><strong>StackOverflowError</strong><br>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> stackLength=<span class="hljs-number">1</span>；<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> stackLeak（）&#123;<br>          stackLength++；<br>          stackLeak（）；<br>      &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main（<span class="hljs-built_in">String</span>[]args）<span class="hljs-keyword">throws</span> Throwable&#123;<br>          JavaVMStackSOF oom=<span class="hljs-keyword">new </span><span class="hljs-class title_">JavaVMStackSOF</span>（）；<br>          <span class="hljs-keyword">try</span>&#123;<br>              oom. stackLeak（）；<br>          &#125;<span class="hljs-keyword">catch</span>（Throwable e）&#123;<br>              System. out. <span class="hljs-built_in">println</span>（<span class="hljs-string">&quot;stack length：&quot;</span>+oom. stackLength）；<br>              <span class="hljs-keyword">throw</span> e；<br>          &#125;<br>      &#125;<br>  &#125;<br>    <br></code></pre></td></tr></table></figure><p><strong>方法区和运行时常量池溢出</strong><br>运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeConstantPoolOOM</span>&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main（<span class="hljs-built_in">String</span>[]args）&#123;<br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main（<span class="hljs-built_in">String</span>[]args）&#123;<br>              <span class="hljs-built_in">String</span> str1=<span class="hljs-keyword">new </span><span class="hljs-class title_">StringBuilder</span>（<span class="hljs-string">&quot;计算机&quot;</span>）. <span class="hljs-built_in">append</span>（<span class="hljs-string">&quot;软件&quot;</span>）. toString（）；<br>              System. out. <span class="hljs-built_in">println</span>（str1. intern（）==str1）；<br>              <span class="hljs-built_in">String</span> str2=<span class="hljs-keyword">new </span><span class="hljs-class title_">StringBuilder</span>（<span class="hljs-string">&quot;ja&quot;</span>）. <span class="hljs-built_in">append</span>（<span class="hljs-string">&quot;va&quot;</span>）. toString（）；<br>              System. out. <span class="hljs-built_in">println</span>（str2. intern（）==str2）；<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这段代码在 JDK 1.6中运行，会得到两个 false，而在 JDK 1.7中运行，会得到一个 true 和一个 false<br>JDK 1.7（以及部分其他虚拟机，例如 JRockit）的 intern（）实现不会再复制实例，<strong>只是在常量池中记录首次出现的实例引用，因此 intern（）返回的引用和由 StringBuilder 创建的那个字符串实例是同一个</strong>。<br>对 str2比较返回 false 是因为“java”这个字符串在执行 StringBuilder. toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回 true。</p><h4 id="理解-GC-日志"><a href="#理解-GC-日志" class="headerlink" title="理解 GC 日志"></a>理解 GC 日志</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">33</span>.<span class="hljs-number">125</span>：[GC[DefNew：<span class="hljs-number">3324</span>K-＞<span class="hljs-number">152</span>K（<span class="hljs-number">3712</span>K），<span class="hljs-number">0</span>.<span class="hljs-number">0025925</span> secs]<span class="hljs-number">3324</span>K-＞<span class="hljs-number">152</span>K（<span class="hljs-number">11904</span>K），<span class="hljs-number">0</span>.<span class="hljs-number">0031680</span> secs]<br><span class="hljs-attribute">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>：[F u l l G C[T e n u r e d：<span class="hljs-number">0</span> K-＞<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> K（<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> K），<span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> s e c s]<span class="hljs-number">4603</span>K-＞<br><span class="hljs-attribute">210K</span>（<span class="hljs-number">19456</span>K），[Perm：<span class="hljs-number">2999</span>K-＞<span class="hljs-number">2999</span>K（<span class="hljs-number">21248</span>K）]，<span class="hljs-number">0</span>.<span class="hljs-number">0150007</span> secs][Times：user=<span class="hljs-number">0</span>.<span class="hljs-number">01</span> sys=<span class="hljs-number">0</span>.<span class="hljs-number">00</span>，real=<span class="hljs-number">0</span>.<span class="hljs-number">02</span> secs]<br><br><br></code></pre></td></tr></table></figure><p>最前面的数字“33.125：”和“100.667：”代表了 GC 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数。</p><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的，例如上面样例所使用的 Serial 收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是 ParNew 收集器，新生代名称就会变为“[ParNew”，意为“Parallel NewGeneration”。如果采用 Parallel Scavenge 收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</p><p>后面方括号内部的“3324K-＞152K（3712K）”含义是“GC 前该内存区域已使用容量-＞GC 后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC 前<br>Java 堆已使用容量-＞GC 后 Java 堆已使用容量（Java 堆总容量）”。<br>再往后，“0.0025925 secs”表示该内存区域 GC 所占用的时间，单位是秒。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.网络相关知识</title>
    <link href="/2025/12/499fe98e8149.html"/>
    <url>/2025/12/499fe98e8149.html</url>
    
    <content type="html"><![CDATA[<h2 id="移动端网络优化"><a href="#移动端网络优化" class="headerlink" title="移动端网络优化"></a>移动端网络优化</h2><p><strong>连接层优化</strong></p><ul><li>HttpDns     [[3-关于httpdns]]，HTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。另外也减少了平均访问的的延迟、降低了用户连接的失败率。后期观察效果好的话，可以推广所有域名使用。</li><li>开启 <strong>Keep-Alive</strong> → 避免频繁建连。在请求头中添加（已经默认开启了）</li><li>CDN 优化，CDN 说是可以使用最近的网络节点提供服务</li><li>IP 直连：省去 DNS 解析过程，DNS 全名 Domain Name System，解析意指根据域名得到其对应的 IP 地址。如 <a href="http://www.codekk.com/">http://www.codekk.com</a> 的域名解析结果就是 104.236.147.76。首次域名解析一般需要几百毫秒，可通过直接向 IP 而非域名请求，节省掉这部分时间，同时可以预防域名劫持等带来的风险。当然为了安全和扩展考虑，这个 IP 可能是一个动态更新的 IP 列表，并在 IP 不可用情况下通过域名访问。</li></ul><p><strong>请求层优化</strong></p><ul><li>请求合并：如果某个页面内请求过多，可以将多个请求合并为一个请求，减少握手和头部开销。</li><li>对请求体（如 JSON）也可以<em>压缩后传输</em>。</li><li>减小请求数据和返回数据大小： 对于 POST 请求，请求体可以做 Gzip 压缩，如日志，response.setHeader (“Content-Encoding”, “gzip”) ;</li><li>可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费. oss</li><li>用户无网时展示本地缓存数据，避免白屏。</li></ul><ul><li>批量上报日志&#x2F;埋点，而不是一条请求一次。</li><li>区分 Wi-Fi &#x2F; 4G &#x2F; 5G &#x2F; 弱网环境。</li></ul><p><strong>Android P 要求网络请求必须为Https，Http请求会抛异常</strong><br>Volley底层使用HttpUrlConnection实现，而HttpUrlConnection底层实质是OkHttp</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">network-security-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">base-config</span> <span class="hljs-attr">cleartextTrafficPermitted</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">network-security-config</span>&gt;</span><br>android:networkSecurityConfig=&quot;@xml/network_security_config&quot;<br></code></pre></td></tr></table></figure><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><strong>一次http网络请求的过程</strong><br>浏览器发起请求-&gt; 解析域名得到 ip 进行 TCP 连接 -&gt;浏览器发送 HTTP 请求和头信息发送-&gt;服务器对浏览器进行应答，响应头信息和浏览器所需的内容-&gt; 关闭 TCP 连接或保持-&gt; 浏览器得到数据数据进行操作。</p><p>对于HTTP协议工作原理:就是客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理。<br>先找到对方 ip 地址，然后用指定的传输协议传送到指定的端口。</p><p><strong>HTTP分层</strong></p><ul><li>Application Layer 应用层：HTTP、FTP、DNS</li><li>Transport Layer 传输层（通讯规则、传输协议）：TCP、UDP（负责传输，找到端口）</li><li>Internet Layer 网络层：IP（负责连接，找到IP）</li><li>Link Layer 数据链路层：以太网、Wi-Fi（以太网：网线，为网络提供现实世界（物理设备的支持））</li></ul><p>为什什么要分层？<br>因为网络的不稳定性，所以要url分块传输</p><p><strong>常见通讯规则、传输协议：TCP&#x2F;UDP</strong></p><p>UDP（面向无连接）–&gt;聊天、网络视频会议、步话机<br>DatagramSocket<br>将数据及源和目的封装成数据包中，不需要建立连接<br>每个数据包的大小限制在64k内<br>因无连接，是不可靠的协议<br>不需要建立连接，速度快</p><p>TCP（面向连接）–&gt;下载，打电话<br>ServiceSocket<br>建立连接，形成传输数据的通道<br>在连接中进行大数据量的传输<br>通过三次握手完成连接，是可靠的协议<br>必须建立连接，效率会稍低</p><p><strong>丢包</strong><br>todo：失败了会重连吗</p><p><strong>什么是iP地址</strong><br>Internet上的主机有两种方式表示地址： 域名：<a href="http://www.baidu.com/">www.baidu.com</a>, IP 地址：202.108.35.210 ，域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地址，这样才能和主机建立连接。</p><p><strong>什么是端口</strong><br>用于标识进程的逻辑地址，不同进程的标识，有效地址0<del>65535，其中0</del>1024系统使用或保留端口。</p><p><strong>HTTP 协议版本</strong></p><p>HTTP&#x2F;1.0</p><ul><li>链接后，只能获取一个web资源。</li><li>链接后，发送请求，服务器做出响应，链接立即断开。</li></ul><p>HTTP&#x2F;1.1</p><ul><li>链接后，可以获取多个web资源。</li><li>链接后，发送请求，服务器做出响应，链接不会立即断开。再次发送请求，直接有一段时间没操作，自动断开。（服务端可以配置）</li></ul><p><strong>三次握手</strong></p><p>SYN，SYN&#x2F;ACK，ACK</p><p>syn 客户端发送syn包给服务器，进入服务状态<br>syn-ack 服务器收到，客户端确实并发送给syn.这时进去接受状态<br>ack 客户端收到服务端的syn-ack，并向服务器确认，此时链接成功！</p><p>第一次本方发送请求，第二次对方确认连接，第三次本方再次发送确认信息告诉对方，这样双方就都知道了，从而才能建立连接。</p><p>三次握手的目的，两次行不行？<br>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误的问题。网络不好的话不知道双方的状态</p><p><strong>四次挥手</strong></p><ol><li>我不要消息了</li><li>我知道了</li><li>我没有消息给你发了</li><li>我知道了</li></ol><blockquote><p>为什么 TCP 连接在断开时是四次挥手而不是三次？<br>因为在客户端停止向服务器发送消息时，也许服务器还有消息需要向客户端发送，因此在它对客户端的「Fin」（即「我不再给你发送消息」，这个词不必记住）消息进行回应时，不需要立即附加上「我也不再向你发送消息」。在稍后服务器的消息发送完毕之后，才需要向客户端发送通知。</p></blockquote><p>fin 发送请求连接<br>ack 同意断开连接<br>fin+ack 服务端断开连接<br>ack 同意断开</p><p><strong>Keep-Alive</strong></p><p>从 HTTP&#x2F;1.1起，默认都开启了 Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。虽然这里使用 TCP 连接保持了一段时间，但是这个时间是有限范围的，到了时间点依然是会关闭的，所以我们还把其看做是每次连接完成后就会关闭。</p><p><strong>HTTP 的缺点</strong></p><p>通信使用明文, 内容可能被窃听<br>不验证通信方身份, 因此有可能遭遇伪装</p><p><strong>WWW</strong></p><p>HTTP 协议同时具备极强的扩展性，虽然浏览器请求的是 <a href="http://www.sina.com.cn/%E7%9A%84%E9%A6%96%E9%A1%B5">http://www.sina.com.cn/的首页</a> ，但是新浪在 HTML 中可以链入其他服务器的资源，比如 XXX，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了 World Wide Web，简称 WWW。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul><li>HTTPS并不是一个单独的协议，对于一些隐秘性比较高的数据可以用https协议。（ 它是在TCP层与http层之间加了个SSl&#x2F;TLS。TLS是SSL v3.0的升级版，而SSL协议，是一种安全传输协议。）</li><li>SSL&#x2F;TLS层负责客户端和服务器之间的加解密算法协商、密钥交换、通信连接的建立。<br>  主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</li><li>说白了就是加密通信的 HTTP</li></ul><p>第三步：请求网址后返回证书的公钥和数字证书，客户端验证数字证书的有效性，是ca的，怎么验证的？数字签名，都有标准的，x509<br>第四步：客户端通过后，<em>使用公钥（对称加密里的）加密内容，非对称加密分别对公钥和内容信息摘要加密</em>（hash，数字签名），发送<br>第六步：服务端使用非对称加密解密对称加密的 key，然后通过对称加密的 key 解密内容。并验证数字签名，看是否篡改过。后台返回数据<br>第七步：客户端用对称加密的 key 解密内容</p><p>服务器返回的是 <strong>数字证书（X.509）</strong>，里面包含：</p><ul><li>服务器公钥</li><li>域名（CN &#x2F; SAN）</li><li>有效期</li><li>签名算法</li><li><strong>CA 对证书内容做的数字签名</strong></li></ul><p>操作系统 &#x2F; JVM &#x2F; Android 内置：</p><ul><li><strong>根 CA 证书列表</strong></li><li>每个根 CA 证书里都有 <strong>CA 的公钥</strong></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.resources/2023/09/15/18-24-33-70041d525309b82d40b70aef257f43e2-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200106162425-ac9ed4.jpg" alt="微信图片_20200106162425"></p><p><strong>详细</strong></p><p>HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法传输数据（效率），但是协商对称加密算法的过程，需要使用非对称加密算法（不适合大量数据）来保证安全（<em>用非对称加密来给对称加密里的秘钥进行加密</em>），然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构生成的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p><p>证书就是HTTPS中数字证书，证书编号就是数字签名，而第三方机构就是指数字证书签发机构（CA）。</p><p><strong>更详细</strong></p><p>SSL&#x2F;TLS防止的安全风险：</p><ol><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ol><p>SSL&#x2F;TLS防止的安全风险原理：</p><ol><li>加密：非对称加密+对称加密，主要解决的是窃听风险</li><li>校验：数字签名，主要解决的是篡改风险</li><li>证书：数字证书，主要解决的是冒充风险</li></ol><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>对称加密的问题：秘钥如何保存和传输（非对称加密算法）</li><li>“非对称加密”加密算法，特点是<strong>公钥加密后的密文，只有私钥可以解密</strong>，私钥加密后的密文，公钥都可以解密。私钥只有一个人有，而公钥可以发给所有的人。</li><li>非对称加密一般不会单独拿来使用，他并不是为了取代对称加密而出现的，非对称加密速度比对称加密慢 很多，极端情况下会慢 1000 倍，所以一般不会用来加密大量数据，通常我们经常会将对称加密和非对称 加密两种技术联合起来使用，例如用非对称加密来给称加密里的秘钥进行加密(即秘钥交换)。</li></ul><p>RSA 加密简单过程</p><ol><li>服务端生成配对的公钥和私钥</li><li>私钥保存在服务端，公钥发送给客户端</li><li>客户端使用公钥加密明文传输给服务端</li><li>服务端使用私钥解密密文得到明文</li></ol><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名技术结合Hash算法和加密算法，<em>来防止消息被篡改和进行身份认证</em>。<br><strong>数字签名就是：发送方使用自己的私钥对信息摘要加密产生</strong></p><ol><li>发送方使用Hash算法对原文产生信息摘要，原文不变则信息摘要不变。</li><li>发送方使用自己的私钥对信息摘要加密产生数字签名，并和加密的原文一起发送。</li><li>接收方使用发送方的公钥解密获取数字签名</li><li>接收方使用Hash算法对<em>原文计算信息摘要与解密的信息摘要比对</em>，成功表示未篡改、未成功表示篡改。</li></ol><p>sign &#x3D; SHA256 (“amount&#x3D;100&amp;timestamp&#x3D;169392&amp;uid&#x3D;123&amp;key&#x3D;abc123”)，定义一个算法</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书（Digital Certificate），就是一种 <strong>电子身份证</strong>，由 <strong>权威的第三方机构 CA（Certificate Authority，证书颁发机构）</strong> 签发，用来证明一个公钥的真实性。</p><p>它里面包含：</p><ul><li>公钥（Public Key）</li><li>持有者信息（域名、组织名称、有效期等）</li><li>签发机构（CA）信息</li><li>数字签名（由 CA 用私钥签发，保证证书内容没被改）</li></ul><p>📌 通俗理解：</p><ul><li><strong>数字签名</strong> 是「签个名，证明这段数据没改过」。</li><li><strong>数字证书</strong> 是「权威机构给你办了张身份证，别人信任你」。</li></ul><p><strong>在 Android 网络请求里的作用</strong></p><p>在 Android 里，数字证书最常见的就是 <strong>HTTPS 通信</strong>：</p><ul><li>当你的 App 访问一个 HTTPS 服务器时，服务器会先把数字证书发给客户端。</li><li>客户端检查：<ol><li>证书是不是正规 CA 签发的？</li><li>域名和证书里的信息对得上吗？</li><li>有效期过期了吗？</li></ol></li><li>如果都没问题，就信任这个服务器，并用证书里的 <strong>公钥</strong> 来建立安全连接（SSL&#x2F;TLS 握手）。</li></ul><p><strong>数字签名 vs 数字证书</strong></p><table><thead><tr><th>概念</th><th>作用</th><th>谁生成的</th><th>在 Android 里的常见用法</th></tr></thead><tbody><tr><td><strong>数字签名</strong></td><td>保证数据没被篡改，验证消息完整性</td><td>通常由客户端或服务端自己生成（带密钥）</td><td>API 请求参数签名、支付接口签名</td></tr><tr><td><strong>数字证书</strong></td><td>保证公钥的真实性，验证身份</td><td>第三方权威机构 CA 签发</td><td>HTTPS 请求中验证服务器身份</td></tr></tbody></table><p>📌 简单来说：</p><ul><li>数字签名 &#x3D; <strong>数据防伪</strong></li><li>数字证书 &#x3D; <strong>身份防伪</strong></li><li><strong>数字签名</strong> 解决的是「这条消息对不对」。</li><li><strong>数字证书</strong> 解决的是「这个人是真的假的」。</li></ul><h4 id="在-Android-中使用-HTTPS"><a href="#在-Android-中使用-HTTPS" class="headerlink" title="在 Android 中使用 HTTPS"></a>在 Android 中使用 HTTPS</h4><p>正常情况：直接使用<br>需要自⼰写证书验证过程的场景</p><ul><li>用的是自签名证书（例如只用于内网的 https）</li><li>信息不全，缺乏中间证书机构（可能性不大）</li><li>手机操作系统较旧，没有安装最新加入的根证书</li><li>支付 App、银行 App。</li></ul><p><strong>OKHTTP</strong></p><p>okhttp中就能验证自己的签名，就是为了让自己的签名通过验证。其实证书的验证工作，<strong>Android 系统和网络库已经帮你做掉了</strong>。<br>如果是ca机构的证书，OKHTTP不需要配置直接就可以访问，如果是自定义的证书，OKHTTP就不行了，但是可以信任指定证书或者所有证书来访问。<br>拦截器：网络日志、缓存（okhttp自己也有）</p><p>![[Pasted image 20250909151834.png]]<br>证书失败会报错的</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket 就是为网络服务提供的一种机制，通讯的两端都必须有 Socket(套接字,就是接口的意思)，<em>网络通讯其实就是 Socket 间的通讯</em>，数据在两个 Socket 间通过 IO 传输，IP 地址标识 Internet 上的计算机，端口号标识正在计算机上运行的进程（程序）。端口号与 IP 地址的组合得出一个网络套接字。</p><p>创建 Socket 连接时，可以指定使用的传输层协议，Socket 可以支持不同的传输层协议（TCP 或 UDP），当使用 TCP 协议进行连接时，该 Socket 连接就是一个 TCP 连接。</p><p><strong>socket 则是对 TCP&#x2F;IP 协议的封装和应用</strong></p><p>1）创建客户端对象： Socket(String host,int port)，指定要接收的IP地址和端口号<br>2）创建服务端对象：ServerSocket(int port)：指定接收的客户端的端口<br>3）Socket accept()：侦听并接受到此套接字的连接，服务器用于接收客户端socket对象的方法<br>主要通过S.getOutputstream和S.getInputSteram<br>注：服务器没有 socket 流，也就没有读写操作的流，服务器是通过获取到客户端的 socket 流（accept）然后获取到其中的读写方法，对数据进行操作的，也正是因为这样服务器与客户端的数据操作才不会错乱</p><h3 id="UDP-传输的流程"><a href="#UDP-传输的流程" class="headerlink" title="UDP 传输的流程"></a><strong>UDP 传输的流程</strong></h3><p>创建 UDPSocket 发送服务对象：DatagramSocket ()，可不指定端口<br>创建 UDPSocket 接收服务对象：DatagramSocket (int port),<br>发送：void send (DatagramPacket p)<br>接收：void receive (DatagramPacket p)</p><h3 id="TCP-传输流程"><a href="#TCP-传输流程" class="headerlink" title="TCP 传输流程"></a><strong>TCP 传输流程</strong></h3><p>Socket (客户端)和 ServiceSocket 服务端()<br>建立客户端和服务端<br>建立连接后，通过 socket 中的 IO 流进行数据的传输<br>关闭 socket</p><p>1）创建客户端对象： Socket (String host, int port)，指定要接收的 IP 地址和端口号<br>2）创建服务端对象：ServerSocket (int port)：指定接收的客户端的端口<br>3）Socket accept ()：侦听并接受到此套接字的连接，服务器用于接收客户端 socket 对象的方法<br>主要通过S.getOutputstream 和S.getInputSteram<br>注：服务器没有 socket 流，也就没有读写操作的流，服务器是通过获取到客户端的 socket 流（accept）然后获取到其中的读写方法，对数据进行操作的，也正是因为这样服务器与客户端的数据操作才不会错乱</p><p>定义 tcp 的服务端  <br>建立服务端的 socket 服务，ServerSocket，并监听一个端口  <br>获取连接过来的客服端对象，通过 ServerSokcet 的 accept 方法。没有连接就会等，所以这个方法阻塞式的。  <br>客户端如果发过来数据，那么服务端要使用对应的客户端对象，并获取到该客户端对象的读取流来读取发过来的数据。  <br>关闭服务端（可选）  <br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">```<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPServerDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">// 建立服务端的socket服务，并监听一个端口</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">10003</span>);<br><span class="hljs-comment">// 通过accept方法获取连接过来的客户端对象</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> socket.getInetAddress().getHostAddress();<br>System.out.println(ip + <span class="hljs-string">&quot;......connected&quot;</span>);<br><span class="hljs-comment">// 获取客户端发过来的数据，那么要使用客户端对象的读取流来获取数据</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> in.read(buf);<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, len));<br>socket.close();<span class="hljs-comment">// 关闭客户端</span><br>ss.close();<span class="hljs-comment">// 关闭服务端，可选的操作</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>tcp 分为客户端和服务端，客服端对象的对象是 socket，服务端对应的是 serversoceket  <br>客户端，在建立的时候就可以去连接指定的主机  <br>因为 tcp 是面向连接的，所以在建立 socket 时就需要有服务端存在  <br>并连接成功，形成通路，才能在该通道上传输数据  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPClientDemo</span> &#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws Exception </span>&#123;  <br>        <span class="hljs-comment">//1、创建客户端的socket服务，指定目的主机和端口  </span><br>        Socke1<br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h2><p>Pragma和Cache-control共存时，Pragma的优先级是比Cache-Control高的。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.resources/2023/09/15/18-24-33-29ace7c2e4c48cff4f2b6ddc8cfa28c5-unknown_filename.2-24b40a.png" alt="unknown_filename.2"><br>only-if-cached表示不进行网络请求，完全只使用缓存，若缓存不命中，则返回503错误</p><ul><li>max-age:告知缓存多长时间，在没有超过缓存时间的情况下，请求会返回缓存内的数据，在超出max-age的情况下向服务端发起新的请求，请求失败的情况下返回缓存数据（测试中已验证），否则向服务端重新发起请求。</li><li>max-stale:指示客户机可以接收超出max-age时间的响应消息，max-stale在请求设置中有效，在响应设置中无效。因此max-age和max-stale在请求中同时使用的情况下，缓存的时间可以为max-age和max-stale的和。</li></ul><p>OKHTTP 一般控制缓存有两种方式：<br>1、在request里面去设置cacheControl()策略<br>2、在header里面去添加cache-control</p><p><a href="https://www.jianshu.com/p/dbda0bb8d541">Android okhttp缓存真正正确的实现方式</a></p><p>有网时不缓存，没网时设置缓存，通过Cache-Control和max-age</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpCacheInterceptor</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Interceptor</span></span> </span>&#123;<br><br><span class="hljs-meta">@Overridepublic Response intercept</span>(Chain chain) throws IOException &#123;<br>    Request request = chain.request();<br>    <span class="hljs-keyword">if</span> (!NetWorkHelper.isNetConnected(MainApplication.getContext())) &#123;<br>        request = request.<span class="hljs-keyword">new</span><span class="hljs-type">Builder</span>()<br>                .cacheControl(CacheControl.FORCE_CACHE)<br>                .build();<br>    &#125;<br><br>    Response response = chain.proceed(request);<br><br>    <span class="hljs-keyword">if</span> (NetWorkHelper.isNetConnected(MainApplication.getContext())) &#123;<br>        int maxAge = <span class="hljs-number">60</span> * <span class="hljs-number">60</span>; <span class="hljs-comment">// 如果想要不缓存，直接时间设置为0，但是需要保存下来吧</span><br>        response.<span class="hljs-keyword">new</span><span class="hljs-type">Builder</span>()<br>                .removeHeader(<span class="hljs-string">&quot;Pragma&quot;</span>)<br>                .header(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;public, max-age=&quot;</span> + maxAge)<br>                .build();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        int maxStale = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">28</span>; <span class="hljs-comment">// tolerate 4-weeks stale</span><br>        response.<span class="hljs-keyword">new</span><span class="hljs-type">Builder</span>()<br>                .removeHeader(<span class="hljs-string">&quot;Pragma&quot;</span>)<br>                .header(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;public, only-if-cached, max-stale=&quot;</span> + maxStale)<br>                .build();<br>    &#125;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;&#125;<br><br>  <span class="hljs-comment">//设置缓存100M</span><br>        Cache cache = <span class="hljs-keyword">new</span> <span class="hljs-type">Cache</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">File</span>(MainApplication.getContext().getCacheDir(),<span class="hljs-string">&quot;httpCache&quot;</span>),<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpClient</span>.Builder()<br>            .cache(cache)<br>            .addNetworkInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-type">HttpCacheInterceptor</span>())<br>            .build();<br><br><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>get和post的区别</strong><br>get提交：提交的信息都显示在地址栏中，对于敏感数据不安全，传送的数据量较小,不能大于2KB，因为地址栏存储体积有限。将信息封装到了请求的请求行中。<br>post提交：提交的信息不显示在地址栏中，对于敏感数据安全，可以提交大体积数据。将信息封装到了请求体中</p><p><strong>Cookie</strong><br>Session和Cookie是一种记录客户端状态的机制的话是由服务器发给客户端特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会在headers里带上这些特殊的信息</p><p>Cookie 的作⽤<br>会话管理：登录状态、购物⻋<br>个性化：⽤户偏好、主题<br>Tracking：分析⽤户⾏为</p><p><strong>Session</strong><br>不同于Cookie保存在客户端中，他是保存在服务器上。<br>session 的工作原理<br>1．第一步创建Session<br>2．在创建了Session的同时，服务器会为该Session生成唯一的Session id<br>3．在Session被创建之后，就可以调用Session相关的方法往Session中增加内容<br>4．当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session</p><p><strong>cookie和session 的区别</strong><br>1．存放位置不同<br>2．存取方式的不同<br>3．安全性（隐私策略）的不同<br>4．有效期上的不同<br>5．对服务器造成的压力不同</p><p><strong>URI和 URL</strong><br>统一资源标识符（URI）用于标识某一互联网资源，而统一资源定位符（URL）表示资源的地点（互联网上所处的位置）。所以 URL 是 URI 的子集。URI:http：，https：，ftp：，本地文件系统(file：)，和Jar文件(jar：)。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.resources/2023/09/15/18-24-33-9b39893ad0c1b0e07a6540c8c308707f-unknown_filename.1-a0fd1b.png" alt="unknown_filename.1"></p><p><strong>如何上传</strong><br>用post，通过表单，不过结构单一，比较繁琐，还可以通过将数据转换成jsonstring、文件、string（base64）来上传，如果是多个图片可以写个循环上传。在上传的时候可以在head添加content-type告诉服务器这是什么数据</p><p><strong>多线程断点下载</strong><br>单线程的话从输入流的第0个字节读取</p><p>原理：服务器CPU分配给每条线程的时间片相同，服务器带宽平均分配给每条线程，所以客户端开启的线程越多，就能抢占到更多的服务器资源。所以要用多线程去读取。</p><p>请求网络时首先获取资源长度设置被进度条，然后除以要开启的线程数，计算出每个线程应该下载多少字节。然后每个线程去请求网络读取数据。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//设置本次http请求所请求的数据的区间</span><br>conn.setRequestProperty(<span class="hljs-string">&quot;Range&quot;</span>, <span class="hljs-string">&quot;bytes=&quot;</span> + startIndex + <span class="hljs-string">&quot;-&quot;</span> + endIndex);<br><br><span class="hljs-comment">//请求部分数据，相应码是206</span><br><span class="hljs-keyword">if</span>(conn.getResponseCode() == <span class="hljs-number">206</span>)&#123;<br><span class="hljs-comment">//流里此时只有1/3原文件的数据</span><br>InputStream <span class="hljs-keyword">is</span> = conn.getInputStream();<br><span class="hljs-built_in">int</span> length = conn.getContentLength();<br>    <br></code></pre></td></tr></table></figure><p>特别注意： 对于移动端来说，如果不是比较大的文件，不建议使用这种方式上传，因为断点续传是通过分片上传实现的，上传单个文件需要进行多次网络请求，效率不高。</p><hr><p><strong>请求</strong></p><p>* 请求行</p><p>* 请求方式</p><p>* POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT、CONNECT       <br>                    * 请求地址</p><p>* 请求资源</p><p>* 协议版本</p><p>* HTTP&#x2F;1.1</p><p>* 请求头<br>                    * 重要的头</p><p>* If-Modified-Since        必须和响应头信息一起来完成控制本地的缓存。</p><p>* Referer                当前的网页的来源。（防止盗链）</p><p>* User-Agent          判断浏览器的版本（文件下载的时候）<br>                * 空行</p><p>* 请求体</p><p>* 封装post参数列表。</p><p><strong>响应</strong></p><p>* 响应行</p><p>* 协议版本</p><p>* HTTP&#x2F;1.1</p><p>* 状态码</p><p>200 ：请求成功处理，一切OK</p><p>302 ：请求重定向</p><p>304 ：服务器端资源没有改动，通知客户端查找本地缓存</p><p>404 ：客户端访问资源不存在</p><p>500 ：服务器内部出错<br>                * 响应头</p><p>重要的头</p><p>* Location                        和302一起完成重定向。</p><p>* Last-Modified                和请求头If-Modified-Since一起控制缓存。和状态码304</p><p>* Refresh                         完成页面的定时跳转</p><p>* Content-Disposition      设置文件是以附件打开<br>                        * Expires: -1</p><p>* Cache-Control: no-cache</p><p>* Pragma: no-cache</p><p>* 禁用缓存（网银系统）      <br>                * 空行</p><p>* 响应体</p><p>* 存放真正的数据。</p><p>转发：找班长借钱，他自己找富班长借钱，一次请求<br>重定向：找班长借钱，发送一次请求，回了我没钱，返回状态码302，给副班长地址，再去找富班长借钱，又发送了一次</p><p><strong>乱码的处理</strong><br>乱码的出现是因为服务器和客户端码表不一致导致<br>  &#x2F;&#x2F;手动指定码表<br>  text &#x3D; new String(bos.toByteArray(), “UTF-8”);</p><p><strong>网络结构有哪些</strong></p><p>C&#x2F;S  client&#x2F;server<br>特点：<br>该结构的软件，客户端和服务端都需要编写。<br>开发成本较高，维护较为麻烦。<br>好处：<br>客户端在本地可以分担一部分运算。（大型网游）<br>B&#x2F;S  browser&#x2F;server<br>特点：<br>该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。 <br>开发成本相对低，维护更为简单。（页游）<br>缺点：所有运算都要在服务端完成。</p><p><strong>什么是内网外网</strong><br>私有网段地址， 内网IP有3种：第一种10.0.0.0～10.255.255.255，第二种172.16.0.0～172.31.255.255，第三种192.168.0.0～192.168.255.255</p><p>运营商给你的100.64.* . * 也是私有地址，以前大家大家共享一个地址池，有随机的公网地址，现在公网地址更加紧张，运营商只给客户分配私网地址，然后nat后大家共享一个公网地址</p><p>172.31.40.210内网<br>192.168.17.207外网</p><p><strong>透明代理</strong></p><p>透明代理就像任何其他类型的代理一样，客户端发送到 Web 服务器的请求在到达 Web 服务器之前会先到达透明代理。当您使用透明代理时，网站所有者知道您使用的是“HTTP_VIA”代理，也知道您的真实 IP。<br>HTTP_X_FORWARDED_FOR 标头将携带您的 IP 地址并启用 HTP_VIA，让网站知道该请求来自您，但通过代理服务器。毫无疑问，透明代理安全性比较低，但在某些情况下也是可以使用的，如用作身份验证的网关</p><p><strong>在 Android 上发送 HTTP 请求的方式</strong></p><p>一般有两种，HttpURLConnection和HttpClient，两种方式都支持HTTPS协议、以流的形式进行上传和下载、配置超时时间、IPv6、以及连接池等功能。HttpURLConnection的API提供的比较简单，可以更加容易地去使用和扩展它。而且速度快、还能节省电量。</p><p>HttpURLConnection用法：</p><pre><code class="hljs">发送GET请求</code></pre><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">  URL url <span class="hljs-operator">=</span> new URL(path)<span class="hljs-comment">;</span><br>  //获取连接对象<br>  HttpURLConnection conn <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection()<span class="hljs-comment">;</span><br>  //设置连接属性<br>  conn.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>)<span class="hljs-comment">;</span><br>  conn.setConnectTimeout(<span class="hljs-number">5000</span>)<span class="hljs-comment">;</span><br>  conn.setReadTimeout(<span class="hljs-number">5000</span>)<span class="hljs-comment">;</span><br>  //建立连接，获取响应吗<br>  if(conn.getResponseCode() <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">200</span>)&#123;<br>//获取服务器响应头中的流，流里的数据就是客户端请求的数据<br>                            InputStream is <span class="hljs-operator">=</span> conn.getInputStream()<br>  &#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">获取服务器返回的流，从流中把html源码读取出来流转换成string的方法第一种：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">byte</span>[] b = <span class="hljs-built_in">new</span> <span class="hljs-type">byte</span>[<span class="hljs-number">1024</span>];<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>;<br>  ByteArrayOutputStream bos = <span class="hljs-built_in">new</span> ByteArrayOutputStream();<br>  while((<span class="hljs-built_in">len</span> = is.read(b)) != <span class="hljs-number">-1</span>)&#123;<br>      <span class="hljs-comment">//把读到的字节先写入字节数组输出流中存起来</span><br>      bos.write(b, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>);<br>  &#125;<br>  <span class="hljs-comment">//把字节数组输出流中的内容转换成字符串</span><br>  <span class="hljs-comment">//默认使用utf-8</span><br>  text = <span class="hljs-built_in">new</span> String(bos.toByteArray());    <br></code></pre></td></tr></table></figure><pre><code class="hljs">//第二种：</code></pre><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">BufferedReader</span> reader = <span class="hljs-keyword">new  </span><span class="hljs-class title_">BufferedReader</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">InputStreamReader</span>(is));<br>        StringBuilder builder = <span class="hljs-keyword">new </span><span class="hljs-class title_">StringBuilder</span>();<br>        <span class="hljs-built_in">String</span> <span class="hljs-built_in">line</span>;<br>        <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">line</span>=reader.<span class="hljs-property">readLine</span>())!=<span class="hljs-literal">null</span>) &#123;<br>            builder.<span class="hljs-property">append</span>(<span class="hljs-built_in">line</span>);<br>        &#125;<br>        <span class="hljs-built_in">String</span> <span class="hljs-built_in">text</span>=builder.<span class="hljs-property">toString</span>();<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">//第三种    </code></pre><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Reader reader = <span class="hljs-literal">null</span>;<br>    reader = <span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(stream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    char[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br>    reader.read(buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(buffer);<br><br><span class="hljs-comment">//图片的流</span><br>InputStream <span class="hljs-keyword">is</span> = <span class="hljs-literal">null</span>;<br>...<br>Bitmap bitmap = BitmapFactory.decodeStream(<span class="hljs-keyword">is</span>);<br>ImageView imageView = (ImageView) findViewById(R.id.image_view);<br>imageView.setImageBitmap(bitmap);<br></code></pre></td></tr></table></figure><p>post</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">connection</span>.setRequestMethod(&quot;POST&quot;);<br>DataOutputStream <span class="hljs-keyword">out</span> = <span class="hljs-built_in">new</span> DataOutputStream(<span class="hljs-keyword">connection</span>.getOutputStream());<br><span class="hljs-keyword">out</span>.writeBytes(&quot;username=admin&amp;password=123456&quot;);<br><br></code></pre></td></tr></table></figure><p><strong>HttpUtils的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendHttpRequest</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String address,</span><br><span class="hljs-params">            <span class="hljs-keyword">final</span> HttpCallbackListener listener)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(address);<br>                    connection = (HttpURLConnection) url.openConnection();<br>                    connection.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br>                    connection.setConnectTimeout(<span class="hljs-number">8000</span>);<br>                    connection.setReadTimeout(<span class="hljs-number">8000</span>);<br>                    connection.setDoInput(<span class="hljs-literal">true</span>);<br>                    connection.setDoOutput(<span class="hljs-literal">true</span>);<br><br><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> connection.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in));<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                    String line;<br>                    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        response.append(line);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 回调onFinish()方法</span><br>                        listener.onFinish(response.toString());<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 回调onError()方法</span><br>                        listener.onError(e);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                        connection.disconnect();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><br><br><br>HttpUtil.sendHttpRequest(address, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpCallbackListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFinish</span><span class="hljs-params">(String response)</span> &#123;<br><span class="hljs-comment">// 在这里根据返回内容执行具体的逻辑</span><br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception e)</span> &#123;<br><span class="hljs-comment">// 在这里对异常情况进行处理</span><br>&#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>这样的话，当服务器成功响应的时候我们就可以在 onFinish()方法里对响应数据进行处理了，类似地，如果出现了异常，就可以在 onError()方法里对异常情况进行处理。如此一来，我们就巧妙地利用回调机制将响应数据成功返回给调用方了。<br>另外需要注意的是，onFinish()方法和 onError()方法最终还是在子线程中运行的，因此我们不可以在这里执行任何的 UI操作，如果需要根据返回的结果来更新 UI，则仍然要使用异步消息处理机制。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.线程安全</title>
    <link href="/2025/12/ca664aa74806.html"/>
    <url>/2025/12/ca664aa74806.html</url>
    
    <content type="html"><![CDATA[<h3 id="锁机制的本质"><a href="#锁机制的本质" class="headerlink" title="锁机制的本质"></a>锁机制的本质</h3><p>在多个线程访问共同的资源时，在某⼀个线程对资源进行写操作的中途（写入已经开始，但还没结束），其他线程对这个写了一半的资源进行行了读操作，或者基于这个写了一半的资源进行了写操作，导致出现数据错误。</p><p>通过对<strong>共享资源</strong>进行访问限制，让同一时间只有一个线程可以访问资源，保证了数据的准确性。<br>不论是线程安全问题，还是针对线程安全问题所衍生出的锁机制，它们的核心都在于共享的资源，而不是某个方法或者某几行代码。</p><p><em>成员变量</em>（静态的也一样）共享引起的安全问题，局部变量的话就不会</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-21-18-37-3ce94386867a86d9f71697de15aba9b7-17-54-50-3ce94386867a86d9f71697de15aba9b7-58e17a25-31fe-4218-8165-062fe7cdd10c-b449a3-edb0f5.jpeg" alt="58e17a25-31fe-4218-8165-062fe7cdd10c|600"></p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。<br>使用锁机制：synchronized 或 lock 对象<br>同步的好处：解决了线程的安全问题。 <br>同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。 <br>同步的前提：同步中必须有多个线程并使用同一个锁。</p><p>当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?<br>不能，一个对象的一个 synchronized 方法只能由一个线程访问。</p><h4 id="同步函数和同步代码块"><a href="#同步函数和同步代码块" class="headerlink" title="同步函数和同步代码块"></a>同步函数和同步代码块</h4><p>同步函数的锁是固定的 this。同步代码块的锁是任意的对象。建议使用同步代码块。<br>静态方法的同步函数的锁<strong>是 class 类，不是 this 对象</strong>，会被叫作 <strong>类锁（class对象锁）</strong>，静态方法不属于某个对象，多个类是共享的</p><h4 id="和-Lock-的异同"><a href="#和-Lock-的异同" class="headerlink" title="和 Lock 的异同"></a>和 Lock 的异同</h4><ul><li>jdk1.5以后将同步和锁封装成了对象。并将操作锁的隐式方式定义到了该对象中，将隐式动作变成了显示动作。</li><li>synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。<strong>非公平锁</strong></li><li>Lock 接口： 出现替代了同步代码块或者同步函数。将同步的隐式锁操作变成现实锁操作。同时更为灵活。可以一个锁上加上多组监视器。</li><li>lock (): 获取锁。unlock (): 释放锁，通常需要定义 finally 代码块中。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>Synchronized 是 Java 中用于实现多线程同步的关键字，通过它可以实现线程的互斥访问和共享资源的同步访问。其底层原理是通过 Java 虚拟机中的对象监视器（<strong>Monitor</strong>）来实现的。每个 Java 对象都有一个对象监视器，用于控制对该对象的访问</li><li>当一个线程想要访问一个被 synchronized 关键字所保护的代码块时，它必须先获得该对象的对象监视器锁，其他线程将会被阻塞，直到该线程释放该锁。</li><li>在 Java 虚拟机中，对象的监视器锁是由对象头中的标志位来表示的。当一个线程获得了对象监视器锁时，该标志位被设置为 1，其他线程将无法获得该锁。</li><li>当该线程释放锁时，标志位被设置为 0，其他线程才能获得该锁。这种机制可以保证同一时刻只有一个线程能够访问被 synchronized 所保护的代码块，从而实现线程的同步和互斥。</li><li>锁状态标志位叫做 <strong>锁标志位（lock tag）</strong>，占用 2 位</li></ul><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p><strong>Java 内存模型</strong></p><p>Java 内存模型定义了一种多线程访问 Java 内存的规范。<br>Java 内存模型将内存分为了主内存和工作内存。类之间共享的变量，是存储在主内存中的，每次 Java 线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并在自己的工作内存中拷贝一份，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>有序性：即程序执行的顺序按照代码的先后顺序执行。<br>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>Java重排序是指Java虚拟机（JVM）在执行Java字节码时，可能会改变指令的执行顺序。这主要有以下几个原因：</p><ul><li><strong>提高性能</strong>：现代处理器都采用了流水线技术，可以并行执行多个指令。为了充分利用处理器的性能，JVM 可能会对指令进行重排序，以便让更多的指令可以并行执行。编译成目标平台对应的代码</li><li><strong>降低功耗</strong>：指令重排序可以减少指令的执行时间，从而降低功耗。</li><li><strong>简化代码</strong>：编译器可以利用指令重排序来简化代码，从而提高代码的执行效率。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><a href="https://guolin.blog.csdn.net/article/details/109009649">volatile关键字在Android中到底有什么用？_android volatile关键字的作用-CSDN博客</a></p><p>volatile 关键字的作用主要有两个：</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性</p><blockquote><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。保证了每次读取到 volatile 变量，一定是最新的数据。</p></blockquote><p>volatile 关键字可以保证多线程之间的可见性，即当一个线程修改了 mAtomicInteger 的值时，其他线程可以立即看到这个修改。而 AtomicInteger 是一个<em>原子类</em>，可以保证对它的操作是原子性的，即多个线程同时对它进行操作时，不会出现数据冲突和安全问题。</p><p>因此，将 mAtomicInteger 声明为 volatile AtomicInteger 可以保证多线程之间对它的操作是线程安全的。同时，使用 <em>AtomicInteger</em> 可以避免使用 synchronized 关键字来进行同步，从而提高程序的性能。</p><p><strong>volatile 的标志位</strong><br>volatile 关键字在 Java 字节码中会标记为 <code>ACC_VOLATILE</code> 标志位。JVM 会根据这个标志位来实现 volatile 的可见性。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>代码底层执行不像我们看到的高级语言，Java 程序这么简单，它的执行是 Java 代码–&gt;字节码–&gt;根据字节码执行对应的 C&#x2F;C++代码–&gt;C&#x2F;C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能 JVM 可能会对指令进行重排序，多线程下可能会出现一些安全的问题。<strong>使用 volatile 则会对禁止语义重排序</strong>，当然这也一定程度上降低了代码执行效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">mAtomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>效率</strong><br>    volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下 volatile 的总开销仍然要比锁低。</p></blockquote><h4 id="为什么不能保证原子性"><a href="#为什么不能保证原子性" class="headerlink" title="为什么不能保证原子性"></a>为什么不能保证原子性</h4><ul><li>一个变量 i 被 volatile 修饰，两个线程想对这个变量修改，都对其进行自增操作也就是 i++，i++的过程可以分为三步，首先获取 i 的值，其次对 i 的值进行加1，最后将得到的新值写会到工作内存中。</li><li>线程 A 首先得到了 i 的初始值100，但是还没来得及修改，就阻塞了，这时线程 B 开始了，它也得到了 i 的值，由于 i 的值未被修改，即使是被 volatile 修饰，主存的变量还没变化，那么线程 B 得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到工作内存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。</li><li>问题来了，线程 A 已经读取到了 i 的值为100，也就是说<em>读取的这个原子操作已经结束了，所以这个可见性来的有点晚</em>，线程 A 阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是 volatile 具有可见性，也不能保证对它修饰的变量具有原子性。</li></ul><p> <code>volatile</code> 只保证<strong>最新值对其他线程可见</strong>，但像 <code>count++</code> 这种操作其实是<strong>“读-改-写”三步</strong>，中间可能被别的线程打断，所以不能保证原子性。<br>简单一句话：<strong>可见性保证了别人能看到最新值，但操作本身可能被中断，不是不可分割的原子操作</strong>。</p><h3 id="Synchronized-和-Volatile"><a href="#Synchronized-和-Volatile" class="headerlink" title="Synchronized 和 Volatile"></a>Synchronized 和 Volatile</h3><ol><li>Synchronized 保证内存可见性和操作的原子性  ,保证不了有序性</li><li>Volatile 只能保证内存可见性，有序性，保证不了原子性</li><li>Volatile 不需要加锁，比 Synchronized 更轻量级，并不会阻塞线程（<em>volatile 不会造成线程的阻塞</em>；synchronized 可能会造成线程的阻塞。）</li><li>volatile 标记的变量不会被编译器优化, 而 synchronized 标记的变量可以被编译器优化（如编译器重排序的优化）.</li><li>volatile 是变量修饰符，<em>仅能用于变量</em>，而 synchronized 是一个方法或块的修饰符。</li><li><strong>volatile 本质是在告诉 JVM 当前变量在寄存器中的值是不确定的，使用前，需要先从主存中读取，因此可以实现可见性</strong>。而对 n&#x3D;n+1, n++等操作时，volatile 关键字将失效，不能起到像 synchronized 一样的线程同步（原子性）的效果。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>下面的这类场景就很适合使用 volatile 变量来控制并发，当 shutdown（）方法被调用时，能保证所有线程中执行的 doWork（）方法都立即停下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> shutdownRequested；<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> shutdown（）&#123;<br> shutdownRequested=<span class="hljs-literal">true</span>；<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> doWork（）&#123;<br> <span class="hljs-keyword">while</span>（！shutdownRequested）&#123;<br> <span class="hljs-comment">//do stuff</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他</strong></p><ul><li>我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。</li><li>除了 volatile 之外，<em>Java 还有两个关键字能实现可见性，即 synchronized 和 final</em></li></ul><p><strong>先行发生原则</strong></p><p>判断是否安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value=<span class="hljs-number">0</span>；<br><br>pubilc <span class="hljs-keyword">void</span> setValue（<span class="hljs-type">int</span> value）&#123;<br> <span class="hljs-built_in">this</span>.value=value；<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> getValue（）&#123;<br> <span class="hljs-keyword">return</span> value；<br>&#125;<br><br></code></pre></td></tr></table></figure><p>假设存在线程 A 和 B，线程 A 先（时间上的先后）调了“setValue（1）”，然后线程 B 调用了同一个对的“getValue（）”，那么线程 B 收到的返回值是什么？这里面的操作不是线程安全的。<br>答：由于没有同步，我们无法保证线程A对 <code>value</code> 的写入操作对线程B是可见的。也就是说，即使线程A在时间上先调用了 <code>setValue(1)</code>，线程B在调用 <code>getValue()</code> 时可能看到的是旧值（比如0）或者新值（1）。</p><p>那怎么修复这个问题呢？</p><ol><li>把 getter&#x2F;setter 方法都定义为 synchronized 方法</li><li>把 <em>value 定义为 volatile 变量</em>，由于 setter 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来实现先行发生关系。</li></ol><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><ul><li><p><strong>悲观锁</strong></p><ul><li>思想：假设一定会冲突。</li><li>操作前先上锁，别人只能等。</li><li>常见：数据库的行锁&#x2F;表锁，Java 的 <code>synchronized</code>、<code>ReentrantLock</code>。</li></ul></li><li><p><strong>乐观锁</strong></p><ul><li>思想：假设不会冲突。</li><li>操作时不加锁，提交更新时再检查是否冲突（失败就重试）。</li><li>假设不会产生冲突，先去尝试执行某项操作，失败了再进行其他处理（一般都是不断循环重试）</li><li>常见实现：CAS（Compare-And-Swap）。</li></ul></li></ul><p>👉 总结一句：</p><ul><li><strong>悲观锁：先锁再干，安全但慢</strong></li><li><strong>乐观锁：先干再检查，快但可能要重试</strong></li></ul><h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>公平锁是指各个线程在获取锁前先检查有无排队的线程，<em>按排队顺序去获取锁</em>。非公平锁是指线程获取锁前不考虑排队问题，直接尝试获取锁。值得注意是，在 AQS 的实现中，一旦线程进入排队队列，即使是非公平锁，线程也得乖乖排队。</p><h4 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h4><ul><li><strong>可重入锁</strong>：同一个线程在持有锁的情况下，可以再次获取该锁，不会被阻塞，也不会死锁。<ul><li>常见：<code>synchronized</code>、<code>ReentrantLock</code>。</li></ul></li><li><strong>不可重入锁</strong>：同一个线程如果再次尝试获取自己已经持有的锁，会被阻塞，甚至死锁。自己用 <code>synchronized</code> + 状态变量实现的锁<br>👉 简单说：<strong>可重入锁允许“同一线程重复进门”，不可重入锁不允许。</strong></li></ul><p>什么时候“应该”用不可重入锁<br><strong>99% 业务代码不该用不可重入锁</strong>。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h3><p>ReadWriteLock意义：读读不互斥、读写互斥、写写互斥共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteLockDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>  <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> lock.readLock();<br>  <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> lock.writeLock();<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>    writeLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      x++;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      writeLock.unlock();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span> &#123;<br>    readLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      System.out.print(x + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      readLock.unlock();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runTest</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a><strong>可重入锁</strong></h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-22-10-26-898c47234a0b817407bf18cd7f6466de-2024-02-21-18-37-898c47234a0b817407bf18cd7f6466de-17-54-50-898c47234a0b817407bf18cd7f6466de-9b734063-8d47-4eea-8c02-22912f7e5ebc-f3fc5a-2374dd-1ba8bc.png" alt="9b734063-8d47-4eea-8c02-22912f7e5ebc|600|600"></p><p>finally 的作用：保证在方法提前结束或出现 Exception 的时候，依然能正常释放锁。</p><p>ReentrantLock 是 Java 中的一个可重入锁，它可以用来实现线程之间的同步。与 synchronized 关键字相比，ReentrantLock 提供了更多的灵活性和功能，例如<em>可中断锁、公平锁、多条件变量</em>等。</p><p>ReentrantLock 的主要特点如下：</p><ul><li>可重入性：ReentrantLock 是可重入锁，<em>即同一个线程可以多次获得同一个锁，而不会出现死锁等问题</em>。</li><li>可中断性：ReentrantLock 支持可中断锁，即当一个线程等待锁的时候，可以通过调用 lockInterruptibly ()方法来中断等待，从而避免死锁等问题。</li><li>公平性：<em>ReentrantLock 支持公平锁和非公平锁</em>。公平锁会按照线程的请求顺序来获取锁，而非公平锁则不保证获取锁的顺序。创建非公平锁：new ReentrantLock(false)</li></ul><p>条件变量：ReentrantLock 支持多个条件变量，可以通过 newCondition ()方法来创建条件变量，从而实现更加灵活的线程同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">mCondition</span> <span class="hljs-operator">=</span> mLock.newCondition();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mLock.lock();<br>            <span class="hljs-comment">// 等待条件变量</span><br>            mCondition.await();<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread1.start();<br>        thread2.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 唤醒一个线程</span><br>        mLock.lock();<br>        mCondition.signal();<br>        mLock.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例代码中，我们创建了两个线程 thread1和 thread2，它们都会等待条件变量 mCondition。在 main ()方法中，我们等待1秒钟后唤醒了一个线程。当线程被唤醒后，它会执行任务并释放锁。这样，我们就可以使用 ReentrantLock 和条件变量来实现线程之间的同步</p><h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><p>Semaphore（信号量）是用来控制同时<strong>访问特定资源的线程数量</strong>，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。<br>Semaphore 和 ReentrantLock 类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</p><p>Semaphore 可以用来做流量分流，特别是对<strong>公共资源有限的场景</strong>，比如数据库连接。假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是 IO 密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用 Semaphore 做流量控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">40</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; COUNT; i++) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadTest</span>.Task());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//读取文件操作</span><br>                semaphore.acquire();<br>                <span class="hljs-comment">// 存数据过程</span><br>                semaphore.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>            &#125;<br>        &#125;<br>    &#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>synchronized 互斥锁</p><p>互斥同步（Mutual Exclusion＆Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，<strong>保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用</strong>。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p><p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。</p><p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行 monitorexit 指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><p>除了 synchronized 之外，我们还可以使用 java. util. concurrent（下文称J.U.C）包中的重入锁（ReentrantLock）来实现同步，相比 synchronized, ReentrantLock 增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造数要求使用公平锁。</p><p>如果读者的程序是使用 JDK 1.6或以上部署的话，性能因素就不再是选择<br>ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized，所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步。</p><h3 id="非阻塞同步（CAS）"><a href="#非阻塞同步（CAS）" class="headerlink" title="非阻塞同步（CAS）"></a>非阻塞同步（CAS）</h3><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。<br>乐观：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（<strong>最常见的补偿措施就是不断地重试，直到成功为止</strong>），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p><p>使用 AtomicInteger 代替 int 后，程序输出了正确的结果，一切都要归功于 incrementAndGet（）方法的原子性。它的实现其实非常简单。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*Atomically increment by one the current value.</span><br><span class="hljs-comment">*@return the updated value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> incrementAndGet()&#123;  <br>    <span class="hljs-keyword">for</span>(;)&#123;  <br>      <span class="hljs-built_in">int</span> current = get（）；  <br>      <span class="hljs-built_in">int</span> <span class="hljs-keyword">next</span> = current + <span class="hljs-number">1</span>；  <br>     <span class="hljs-keyword">if</span>（compareAndSet（current, <span class="hljs-keyword">next</span>））  <br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">next</span>；  <br>    &#125;  <br>&#125;<br>    <br></code></pre></td></tr></table></figure><p><strong>CAS 操作</strong><br><em>线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</em></p><p><strong>CAS</strong>指令需要有3个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p><p>incrementAndGet（）方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋给自己。如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止。</p><p>尽管 CAS 看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且 CAS 从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为 A 值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的“<strong>ABA</strong>”问题。J.U.C 包为了解决这个问题，提供了一个带有标记的原子引用<br>类“AtomicStampedReference”，它可以通过<strong>控制变量值的版本来保证 CAS 的正确性</strong>。不过目前来说这个类比较“鸡肋”，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h3 id="无同步方案-（ThreadLocal）"><a href="#无同步方案-（ThreadLocal）" class="headerlink" title="无同步方案 （ThreadLocal）"></a>无同步方案 （ThreadLocal）</h3><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p><p>我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p><p>可以通过 java. lang. ThreadLocal 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal. threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的<strong>threadLocal HashCode</strong>值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。</p><p>[[5.ThreadLocal]]<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-21-18-37-090511233588ff3117f3e524b9a20e31-17-54-50-090511233588ff3117f3e524b9a20e31-unknown_filename.2-8dbd33-542643.png" alt="unknown_filename.2|600"></p><h2 id="从1到100"><a href="#从1到100" class="headerlink" title="从1到100"></a>从1到100</h2><h3 id="交替打印"><a href="#交替打印" class="headerlink" title="交替打印"></a>交替打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculationThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CalculationThread</span> <span class="hljs-variable">calculationThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculationThread</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            calculationThread.printNumbers();<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            calculationThread.printNumbers();<br>        &#125;);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumbers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">100</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + count);<br>                count++;<br><br>                <span class="hljs-comment">// 唤醒等待的线程</span><br>                lock.notify();<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 当前线程等待</span><br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 最后一个线程执行完后，唤醒其他等待的线程</span><br>            lock.notify();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个线程在<code>printNumbers()</code>方法中共享同一个实例，它们通过获取<code>lock</code>对象的锁来实现互斥访问。</p><p>在每次循环中，线程首先输出当前的计数值 <code>count</code>，然后递增 <code>count</code>。接着线程调用 <code>lock.notify()</code> 来唤醒等待的线程，并通过 <code>lock.wait()</code> 进入等待状态，让其他线程有机会获取锁并执行。</p><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><ul><li>如果没有 join，主线程可能在子线程完成计算前就打印结果<br>[[3.java多线程#join]]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SumThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">SumThread</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SumThread</span>();<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; calculator.addRange(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; calculator.addRange(<span class="hljs-number">51</span>, <span class="hljs-number">100</span>));<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(<span class="hljs-string">&quot;Total sum: &quot;</span> + calculator.sum);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addRange</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">localSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            localSum += i;<br>        &#125;<br>        <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            sum += localSum;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>下面的可不看</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><strong>能省锁就省锁，锁的粒度粗话，不要的地方不锁，append（）操作之前直至最后一个 append（）操作之后，这样只需要加锁一次就可以了。还有 cas</strong><br>高效并发是从 JDK 1.5到 JDK 1.6的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃 cpu，自旋锁（spinlock） 则是不断循环并测试锁的状态，这样就一直占着 cpu。<br>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以<strong>让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快锁</strong>。</p><p>自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin 来更改。<br>在 JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> &#123;<br><br>  <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; sign =<span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span>&#123;<br>    Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">while</span>(!sign .compareAndSet(<span class="hljs-literal">null</span>, current))&#123;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span> ()</span>&#123;<br>    Thread current = Thread.currentThread();<br>    sign .compareAndSet(current, <span class="hljs-literal">null</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> concatString（<span class="hljs-type">String</span> s1，<span class="hljs-type">String</span> s2，<span class="hljs-type">String</span> s3）&#123;<br><span class="hljs-keyword">return</span> s1+s2+s3；<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们也知道，由于 String 是一个不可变的类，对字符串的连接操作总是通过生成新的 String 对象来进行的，因此 Javac 编译器会对 String 连接做自动优化。在 JDK 1.5之前，会转化为 StringBuffer 对象的连续 append（）操作，在 JDK 1.5及以后的版本中，会转化为 StringBuilder 对象的连续 append（）操作.</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。<br>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p><em>连续的 append（）方法就属于这类情况</em>。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以代码清单13-7为例，就是扩展到第一个 append（）操作之前直至最后一个 append（）操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。CAS</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是 JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。</p><p>偏向锁的“偏”，就是偏心的“偏”、<em>偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取</em>，则持有偏向锁的线程将永远不需要再进行同步。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.java多线程</title>
    <link href="/2025/12/e9ff2a5dcb34.html"/>
    <url>/2025/12/e9ff2a5dcb34.html</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>进程和线程的区别？多线程有什么好处？</strong></p><p>进程是操作系统资源分配的最小单位，线程是进程的一个实体，是cpu调度和分配的基本单元，同一个进程的线程共享内存空间，一个线程的操作是会影响另一个线程的。 </p><p>进程：正在进行中的程序(直译)。<br>线程：就是进程中一个负责程序执行的控制单元</p><ul><li>一个进程中可以多执行路径，称之为多线程,一个进程中至少要有一个线程。</li><li>开启多个线程是为了同时运行多部分代码。 每一个线程都有自己运行的内容。这个内容可以称为线程要执行的任务。</li><li>多线程好处：解决了多部分同时运行的问题。</li><li>什么时候使用多线程？当需要多部分代码同时执行的时候，可以使用。</li></ul><p><strong>编写多线程程序有几种实现方式？</strong></p><p>一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。Runnable不是线程，是线程里运行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><span class="hljs-comment">// extends Fu </span><br><br><span class="hljs-comment">//准备扩展Demo类的功能，让其中的内容可以作为线程的任务执行</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        show();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">20</span>; x++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;.....&quot;</span> + x);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>为什么 stop ()方法被废弃而不被使用呢？</strong></p><p>原因是 stop ()方法太过于暴力，会强行把执行一半的线程终止。这样会就不会保证线程的资源正确释放，通常是没有给与线程完成资源释放工作的机会，因此会导致程序工作在不确定的状态下。<br>使用 boolean 类型的变量，来终止线程或者使用 interrupt<br>interrupt 其实不是终止，需要自己判断 isInterrupt</p><p><strong>interrupt</strong> 对线程进行终断，但并不是真真正正的终止一个线程，而是发给线程的一个终断标志位，当调用这个方法的时候，其实就是给线程打了一个招呼，不代表这个线程就要立即停止工作，而且这个线程完全可以不理会这个终断请求（也就是说 JDK 中，线程是协作式的，而不是所谓的抢占式）；</p><p><strong>启动一个线程是调用 run ()还是 start ()方法？</strong></p><p>启动一个线程是调用 start ()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。<strong>run ()方法是线程启动后要进行回调（callback）的方法</strong>。</p><p><strong>一个线程如果出现了运行时异常会怎么样</strong></p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器（锁），那么这个对象监视器会被立即释放</p><p><strong>守护进程</strong></p><p>t1.start ();<br>t2.setDaemon (true); &#x2F;&#x2F; setDameon 是守护线程，可以理解为后台线程，你停我也停。前台必须手动结束<br>t2.start ();</p><p><strong>多次 start 一个线程会怎么样</strong></p><p>会抛出 java. lang. IllegalThreadStateException   线程状态非法异常</p><p><strong>Android 一个线程占用多大内存?</strong></p><p>在 iava 中每个线程需要分配线程内存，用来存储自身的线程变量<br>在 idk 1.4 中每个线程是 256 K 的内存，在 idk 1.5 中每个线程是 1 M 的内存。在 java 中每 new 一个线程，jvm 都是向操作系统请求 new 一个本地线程，此时操作系统会使用剩余的内存空间来为线程分配内存，而不是使用 jvm 的内存。<br>当操作系统的可用内存越少，则 jvm 可用创建的新线程也就越少</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a><strong>状态转换</strong></h2><p><strong>线程的基本状态以及状态之间的关系？</strong> </p><p>创建并运行线程：</p><ul><li>新建状态(New Thread)：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。</li><li>就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。</li><li>运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。</li></ul><blockquote><p>可以通过Thread类的isAlive方法来判断线程是否处于就绪&#x2F;运行&#x2F;阻塞状态：当线程处于就绪&#x2F;运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。</p></blockquote><ul><li><p>阻塞和唤醒线程阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：             <br>  a) 当执行了某个线程对象的sleep()、join方法等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。             <br>  b) 当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()&#x2F;notify()方法的执行要求线程首先获得该对象的锁。</p></li><li><p>死亡状态 (Dead)：线程在 run ()方法执行结束后进入死亡状态。此外，如果线程执行了 interrupt ()或 stop ()方法，那么它也会以异常退出的方式进入死亡状态。</p></li></ul><p>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：<br>“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；<br>而“等待状态”则是在等待一段时间，或者唤醒动作的发生。<br>在程序等待进入同步区域的时候，线程将进入这种状态。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-22-10-04-a715ebcb1354714e62ea3843bf0ead4a-2024-02-21-18-40-a715ebcb1354714e62ea3843bf0ead4a-2024-02-21-18-39-a715ebcb1354714e62ea3843bf0ead4a-17-54-50-a715ebcb1354714e62ea3843bf0ead4a-unknown_filename.1-9c1fa3-f2f70d-d05788-8e4940.png" alt="unknown_filename.1|600|600|600|600"></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>在Java中，<code>join()</code> 方法是Thread类的一个方法，用于等待该线程结束。具体来说，当在一个线程A（也可以是主线程）中调用线程B的 <code>join()</code> 方法时，线程A会被挂起（进入等待状态），直到线程B执行完毕，线程A才会继续执行。</p><h3 id="模式-1：并行任务聚合"><a href="#模式-1：并行任务聚合" class="headerlink" title="模式 1：并行任务聚合"></a>模式 1：并行任务聚合</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-keyword">Thread</span>&gt; workers = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">Thread</span> worker = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(<span class="hljs-literal">new</span> Task());<br>    worker.start();<br>    workers.add(worker);<br>&#125;<br><br><span class="hljs-comment">// 等待所有工作线程完成</span><br>for (<span class="hljs-keyword">Thread</span> w : workers) &#123;<br>    w.<span class="hljs-keyword">join</span>();<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;所有任务已完成&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="模式-2：顺序化线程执行"><a href="#模式-2：顺序化线程执行" class="headerlink" title="模式 2：顺序化线程执行"></a>模式 2：顺序化线程执行</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> phase1 = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(Stage1);<br><span class="hljs-keyword">Thread</span> phase2 = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(Stage2);<br><br>phase1.start();<br>phase1.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// 等待阶段1完成</span><br><br>phase2.start(); <span class="hljs-comment">// 开始阶段2</span><br></code></pre></td></tr></table></figure><h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><p><strong>wait 和 sleep 区别？</strong><br>sleep来自Thread类，和wait来自Object类<br>调用<em>sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</em><br>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒</p><p><strong>wait和notify</strong><br>wait：使一个线程处于等待（阻塞&#x2F;冻结）状态，并且<em>释放所持有的对象的锁，让其他线程可以进入</em>Synchronized 数据块，当前线程被放入对象等待池中；是 Object 的方法，必须与 synchronized 关键字一起使用</p><p>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；<br>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><p>标准写法，打印前得先初始化：</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.resources/2023/09/15/17-54-50-4ed5186c918ee4070244c8dca3902b83-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190915124035-71be64.png" alt="微信截图_20190915124035"></p><p><strong>用法</strong></p><ul><li>在未达到目标时 wait ()</li><li>用 while 循环检查</li><li>设置完成后 notifyAll ()</li><li>wait () 和 notify () &#x2F; notifyAll () 都需要放在同步代码块里</li><li>wait是进入一个同步的方法中，释放锁，用完后唤醒，让另一个线程进行操作。跟锁有关系</li></ul><p><strong>线程的 sleep ()方法和 yield ()方法有什么区别？</strong></p><ol><li>sleep ()方法给其他线程运行机会时不考虑线程的优先级，因此可能会给低优先级的线程以运行的机会；yield ()方法只会给相同优先级或更高优先级的线程以运行的机会；  Thread.setPriority (Thread. MAX_PRIORITY);</li><li>线程执行 sleep ()方法后转入阻塞（blocked）状态，而执行 yield ()方法后转入就绪（Runnable）状态。</li><li>yield () 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，<strong>即线程仍处于可执行状态，随时可能再次分得 CPU 时间</strong>。调用 yield () 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。</li><li>sleep ()方法声明抛出 InterruptedException，而 yield ()方法没有声明任何异常</li></ol><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>线程池的好处</strong></p><ul><li>因为不需要每次处理复杂逻辑耗时操作都创建一个线程，比如加载网络，避免了线程的创建和销毁所带来的性能开销和消耗的时间，能有效控制线程池的最大并发数，避免了大量线程间抢占资源而导致的阻塞现象</li><li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能（ExecutorService 是安全的）</li><li>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</li></ul><p><strong>线程池相关方法</strong></p><ul><li>Java为我们提供了 ExecutorService 线程池来优化和管理线程的使用。</li><li>Executors类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，他们的内部其实是通过：ThreadPoolExecutor</li><li>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池</li></ul><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim">public <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-type">int</span> corePoolSize,<br>                              <span class="hljs-type">int</span> maximumPoolSize,<br>                              long keepAliveTime,<br>                              <span class="hljs-type">TimeUnit</span> unit,<br>                              <span class="hljs-type">BlockingQueue</span>&lt;<span class="hljs-type">Runnable</span>&gt; workQueue,<br>                              <span class="hljs-type">ThreadFactory</span> threadFactory,<br>                              <span class="hljs-type">RejectedExecutionHandler</span> handler) <span class="hljs-meta">&#123;...&#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a><strong>线程池的参数</strong></h3><ol><li>核心线程数,<strong>核心线程会一直存活，及时没有任务需要执行</strong>，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；核心线程数默认是0，需要自己去实现。</li><li>表示在<em>线程池中最多能创建多少个线程</em>；</li><li>如果线程池没有要执行的任务 存活多久</li><li>存活时间的单位</li><li>如果 线程池里管理的线程都已经用了,剩下的任务 临时存到LinkedBlockingQueue对象中排队，先进先出</li><li>threadFactory <code>线程工厂</code>，如何去创建线程的，可以自定义线程创建的执行者,他们有适当的线程名称、优先级,甚至他们还可以守护进程。</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 自定义线程池示例</span><br>ExecutorService pool = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span> (<br>    <span class="hljs-number">3</span>, <span class="hljs-comment">// corePoolSize (核心线程数=3)</span><br>    <span class="hljs-number">10</span>, <span class="hljs-comment">// maximumPoolSize (最大线程数=10)</span><br>    <span class="hljs-number">60</span>, TimeUnit.SECONDS, <span class="hljs-comment">// 非核心线程空闲60秒后销毁</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>) <span class="hljs-comment">// 任务队列容量100</span><br>);<br></code></pre></td></tr></table></figure><p>核心线程数 vs 最大线程数<br>核心线程：常驻线程（不会被销毁）<br>最大线程 &#x3D; 核心线程 + 非核心线程（可动态销毁）</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.resources/2023/09/15/17-54-50-e4b5e50ac1e601dfb4bcf4ebba175621-unknown_filename-a8ab40.png" alt="unknown_filename"></p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><ul><li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li><li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 。</li><li>如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</li></ul><p><strong>自定义线程池ThreadPoolExecutor</strong></p><p>自定义ThreadManager类管理多线程，例如</p><ul><li>请求网络数据线程交由长时间任务线程池执行</li><li>访问数据库交由短时间任务线程池执行</li><li>图片下载任务将由单任务线程池执行</li><li>20个图片都做一些操作，创建固定线程池</li></ul><p><strong>Executors弊端</strong></p><p>Executors的4个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>Executors的4个功能线程有如下弊端：<br>FixedThreadPool 和 SingleThreadExecutor：主要问题是堆积的请求处理队列均采用 <em>LinkedBlockingQueue，可能会耗费非常大的内存</em>，甚至 OOM。<br>CachedThreadPool 和 ScheduledThreadPool：主要问题是<em>线程数最大数是 Integer.MAX_VALUE</em>，可能会创建数量非常多的线程，甚至 OOM。</p><p><strong>LinkedBlockingQueue</strong></p><p>在 Java 多线程应用中，队列的使用率很高，多数生产消费模型的首选数据结构就是队列 (先进先出)。Java 提供的线程安全的 Queue 可以分为阻塞队列（安全）和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子 ConcurrentLinkedQueue（也是安全的，cas）。</p><p>LinkedBlockingQueue 是线程安全的队列，通过 ReentrantLock 保证的。(链表实现的队列)<br>由于 LinkedBlockingQueue 实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，<em>LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是 Integer. MAX_VALUE</em>，其中主要用到 put 和 take 方法，put 方法在队列满的时候会阻塞直到有队列成员被消费，take 方法在队列空的时候会阻塞，直到有队列成员被放进来。<br>2 的 31 次方 - 1</p><p><strong>有界无界</strong></p><p>如果我们要实现一个无界队列，也就是说，队列的大小事先不确定，理论上可以支持无限大。这种情况下，我们适合选用链表来实现队列。因为链表支持快速地动态扩容。<br>如果我们要实现一个有界队列，也就是说，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待。直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong>newFixedThreadPool</strong></p><p>创建一个固定线程数量的线程池</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。<br>应用场景：控制线程最大并发数。</p><p><strong>newSingleThreadExecutor</strong></p><p>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>特点：只有1个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。<br>应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。</p><p><strong>newCachedThreadPool</strong></p><p>创建一个可以根据实际情况调整线程池中线程的数量的线程池</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60</span>L, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-type">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：无核心线程，非核心线程数量无限，执行完闲置60s后回收，任务队列为不存储元素的阻塞队列。<br>应用场景：执行大量、耗时少的任务。</p><p><strong>newScheduledThreadPool</strong> </p><p>创建一个可以定时或者周期性执行任务的线程池</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。<br>应用场景：执行定时或周期性的任务。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.resources/2023/09/15/17-54-50-a8f01d3147bfada39116543af2382dda-unknown_filename.5-ace0e8.png" alt="unknown_filename.5|700"><br>为什么-1，若线程数等于 CPU 逻辑核心数，线程池可能占用所有可用计算资源，导致系统进程（如 UI 渲染、GC、IO 处理）因缺乏资源而卡顿。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(  <br><span class="hljs-built_in">        CORE_POOL_SIZE,</span> CORE_POOL_SIZE, <span class="hljs-number">0</span>, TimeUnit.SECONDS,  <br><span class="hljs-built_in">        sPoolWorkQueue,</span> sThreadFactory)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我们的方案是:只有核心线程，线程数量固定，执行完立即回收</p><p>内存优化方案1：</p><ol><li>保持核心线程始终存活</li><li>将非核心线程的存活时间延长，避免频繁创建新的线程<br> 可以避免频繁创建线程的内存分配负担和内存碎片问题</li></ol><p>内存优化方案2：</p><ol><li>核心线程也可以回收</li><li>非核心线程存活时间变短，及时回收资源<br> 可以避免内存峰值过高的问题，及时回落</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MAX_CPU_COUNT = CPU_COUNT * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> KEEP_ALIVE_TIME_IN_MINUTES = <span class="hljs-number">30L</span>;<br></code></pre></td></tr></table></figure><p>降低线程数量并不是说不用线程或少用线程，而是让线程在空闲的时候自动销毁，基于这一理论，通过替换创建线程池的方法，或者直接修改线程池的参数：<br>将 corePoolSize 设置为 0<br>为 maxPoolSize 设置上限 MAX_CPU_COUNT</p><h2 id="Callable、FutureTask"><a href="#Callable、FutureTask" class="headerlink" title="Callable、FutureTask"></a>Callable、FutureTask</h2><p><a href="https://blog.csdn.net/yx0628/article/details/79508220">Java并发Concurrent包——Callable&#x2F;Future&#x2F;FutureTask解析</a></p><p>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。<br>省了自己写回调了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; &#123; <br><span class="hljs-comment">// 计算结果，如果无法计算结果，则抛出一个异常 </span><br> <span class="hljs-function">V <span class="hljs-title">call</span>() throws Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>FutureTask、RunnableFuture相比runnable有结果的返回<br>看看：AsyncTaskInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程开始计算&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;子线程结束计算，共用时5秒&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-comment">// Future的使用</span><br>        <span class="hljs-comment">//Future&lt;Integer&gt; result = executor.submit(new CountTask());</span><br>        <span class="hljs-comment">// FutureTask的使用</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountTask</span>());<br>        executor.submit(futureTask);<br>        executor.shutdown();<br>        <span class="hljs-comment">// Future获取结果</span><br>        <span class="hljs-comment">//Integer i = result.get();</span><br>        <span class="hljs-comment">// futureTask获取结果</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> futureTask.get();<br></code></pre></td></tr></table></figure><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>多个线程在处理同一资源，但是任务却不同。<br>生产者和消费者在同一时间段内共用同一个存储空间，生产者向空间里存放数据，而消费者取用数据，如果不加以协调可能会出现以下情况：<br>存储空间已满，而生产者占用着它，消费者等着生产者让出空间从而去除产品，生产者等着消费者消费产品，从而向空间中添加产品。互相等待，从而发生死锁。</p><p><strong>wait()和notify()方法的实现</strong></p><p>缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">FULL</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock&quot;</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>()).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>()).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>()).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>()).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>()).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>()).start();<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>                    <span class="hljs-keyword">while</span> (count == FULL) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            LOCK.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    count++;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;生产者生产，目前总共有&quot;</span> + count);<br>                    LOCK.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>                    <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            LOCK.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        &#125;<br>                    &#125;<br>                    count--;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;消费者消费，目前总共有&quot;</span> + count);<br>                    LOCK.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>指多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象。它们中的一个或者全部都在等待某个资源被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadlockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;资源1&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;资源2&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Lock</span>(str1, str2), <span class="hljs-string">&quot;线程1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Lock</span>(str2, str1), <span class="hljs-string">&quot;线程2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String str1;<br>    <span class="hljs-keyword">private</span> String str2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Lock</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.str1 = str1;<br>        <span class="hljs-built_in">this</span>.str2 = str2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;运行&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (str1) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;锁住&quot;</span>+ str1);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (str2) &#123;<br>                    <span class="hljs-comment">// 执行不到这里</span><br>                    System.out.println(Thread.currentThread().getName()<br>                            + <span class="hljs-string">&quot;锁住&quot;</span> + str2);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br>线程<span class="hljs-number">1</span>运行<br>线程<span class="hljs-number">1</span>锁住资源<span class="hljs-number">1</span><br>线程<span class="hljs-number">2</span>运行<br>线程<span class="hljs-number">2</span>锁住资源<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>线程1运行线程1锁住资源1，线程2运行线程2锁住资源2，两个线程是同时执行的，线程1锁住了资源1，线程2锁住了资源2，线程1企图锁住资源2，但是资源2已经被线程2锁住了，线程2企图锁住资源1，但是资源1已经被线程1锁住了，然后就死锁了。<br>你的同步（锁）有我的同步，我的同步有你同步</p><p><strong>要出现死锁问题需要满足以下条件</strong></p><ol><li>互斥条件：一个资源每次只能被一个线程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>解决方法</p><ol><li>如果想要打破互斥条件，我们需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；</li><li>打破不可抢占条件，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，<strong>占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请</strong>，这个其实也很难找到适用场景；</li><li><strong>进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态</strong>。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；</li><li>避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.Java基础</title>
    <link href="/2025/12/20507b7f51aa.html"/>
    <url>/2025/12/20507b7f51aa.html</url>
    
    <content type="html"><![CDATA[<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>Java 的 Object 类有哪些常用的方法？</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E5%9F%BA%E7%A1%80.resources/2023/09/15/17-54-06-3b9dc88315a3954a30083e244228dcec-unknown_filename.9-723e23.png" alt="unknown_filename.9"></p><p><strong>哪些场景下，子类需要重写 equals 方法和 hashCode 方法？</strong><br>比较两个对象是否相等的时候。<br>hashCode 相等，两个对象不一定相等；两个对象 equals 后相等，则两个对象的 hashCode 一定相等。必须都相等才可以</p><p>为什么在写自定义的类的时候要重写 equals？<br>默认是<strong>比较的两个对象内存的地址</strong></p><p>什么要同时重写 hashcode 方法？<br>未重写之前 hashcode 方法返回的是对象的32位 JVM 内存地址，当我们把这<strong>不同地址但是实际相等</strong>的两个对象放进 HashMap 里面的时候它们不被看成是同一个对象，占据了两个位置。这个跟我们的预期不符，所以要重写 hashcode 方法。</p><p><strong>java 中，强制转换符把 float 转换为 int 时，按四舍五入，还是直接丢掉小数部分</strong></p><p>直接舍掉小数，比如 float 是4.7 转换成 int 后是4 而不是5 要四舍五入的话转换前先加上0.5<br>比如 int i ; double j &#x3D; 4.7; i &#x3D; (int)(j+0.5);</p><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p><strong>静态的作用</strong></p><p>static 修饰的代码块，当类被加载时执行，且被执行一次，作为对静态属性的初始化。不要实例化就可以类名. 的方式调用，在内存中只有一份，可以<strong>多个对象共享同一份内存空间</strong>。静态导入，是将类中的所有静态成员导入进来。</p><p>静态变量：当类加载器将类加载到 JVM 中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。<br>静态代码块：代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。不能包含 this 或者 super, 它们通常被用初始化静态变量。</p><p><strong>编译时 vs 运行时</strong></p><p>编译时：将 Java 代码编译成．class 文件的过程<br>运行时：就是 Java 虚拟机执行．class 文件的过程<br>编译时 vs 运行时：编译时类型和运行时类型<br>编译时类型：编译时类型由声明该变量时使用的类型决定（形参）<br>运行时类型：运行时类型由实际赋给该变量的对象决定（实参）</p><p><strong>执行顺序</strong></p><ol><li><strong>静态变量、静态代码块</strong>  </li><li>子类静态变量、静态代码块  </li><li>自己的变量、代码块、构造函数 </li><li><strong>子类变量、代码块、构造函数</strong></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestNew</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> b;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">meth</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;x = &quot;</span>+x);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;a = &quot;</span>+a);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;b = &quot;</span>+b);<br>&#125;<br><span class="hljs-keyword">static</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;static block initialized&quot;</span>);<br>b = a*<span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>meth(<span class="hljs-number">42</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果是：static block initialized<br>x &#x3D; 42<br>a &#x3D; 3<br>b &#x3D; 12<br>上述 class TestNew 的执行顺序是：首先 static 块执行 (打印一条消息)，a 被设置为3，最后 b 被初始化为 a* 4 成12。<br>然后调用 main ()，main () 调用 meth () ，把值42传递给 x。3个 println ( ) 语句引用两个 static 变量 a 和 b，以及局部变量 x 。</p><p><strong>Java int 和 Integer</strong></p><p>1、Integer 是 int 的包装类，int 则是 java 的一种基本数据类型 <br>2、Integer 变量必须实例化后才能使用，而 int 变量不需要 <br>3、Integer 实际是对象的引用，当 new 一个 Integer 时，实际上是生成一个指针指向此对象；而 int 则是直接存储数据值 <br>4、Integer 的默认值是 null，int 的默认值是0</p><h3 id="值传递、引用传递"><a href="#值传递、引用传递" class="headerlink" title="值传递、引用传递"></a>值传递、引用传递</h3><p>java 在方法传递参数时，是将变量复制一份，然后传入方法体去执行</p><p><em>基本数据类型不会修改</em>。因为，a、b 中的值，只是从 num1、num2的复制过来的。也就是说，a、b 相当于 num1、num2的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><em>引用类型会修改，是引用</em><br><em>string 类型特殊，不会修改</em><br>String 对象一旦创建，内容不可更改。每一次内容的更改都是重现创建出来的新对象。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String s &#x3D; new String (“xyz”); 创建了几个字符串对象？<br>两个对象，一个是（常量池方法区）的“xyz”;，一个是用 new 创建在堆上的对象。如果 xyz 创建过了，就是一个对象，会复用常量池。</p><ul><li>string 类型和 StringBuffer 类型的主要性能区别其实在于 <em>String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象</em>，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后, JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</li><li>string 值能改是因为创建了新的对象，而 StringBuilder 通过 <code>append()</code>、<code>insert()</code> 等方法直接<em>操作内部缓冲区</em>，避免重复创建对象。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E5%9F%BA%E7%A1%80.resources/2023/09/15/17-54-06-bfadebde34077dcb0cd63f0690681190-unknown_filename.10-0ed521.png" alt="unknown_filename.10"></li></ul><p>新版本<br>string “+” 在<em>高版本中改了</em>。” Hello, “ + “world! “ 这样的表达式，编译器会把它处理成一个连接好的常量字符串”Hello, world!”。这样，也就不存在反复的对象创建和销毁了，性能提高了，但是不可变性没变。<br> 编译器优化（常量折叠）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译时直接合并为单字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>; <br><span class="hljs-comment">// 等效于→ String s = &quot;abc&quot;;</span><br></code></pre></td></tr></table></figure><p>但该优化不适用于变量操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 运行时创建新对象！</span><br></code></pre></td></tr></table></figure><p>优先使用：<strong>StringBuilder 之所以快</strong>，是因为内部预先分配了一部分内存（空间换时间），只有在内存不足的时候，才会去扩展内存<br>StringBuilder 是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。</p><h3 id="string-为什么是-final"><a href="#string-为什么是-final" class="headerlink" title="string 为什么是 final"></a>string 为什么是 final</h3><p><em>防止继承破坏不可变性</em><br>​​禁止任何子类继承​​。若允许继承，子类可能通过重写方法（如 <code>equals()</code>、<code>hashCode()</code>）或添加可变字段，破坏 <code>String</code> 的不可变特性</p><p><em>实现字符串池</em>       <br><strong>唯一性保证​</strong>​：相同内容的字符串字面量在池中仅存储一份，避免重复创建相同内容的字符串对象，减少内存占用。<br>String s1 &#x3D; “Hello”; String s2 &#x3D; “Hello”; &#x2F;&#x2F; s1 &#x3D;&#x3D; s2 为 true，因为指向池中同一对象<br>[[6.JVM#方法区]]</p><p><em>线程安全</em><br>​​无同步开销​​：多线程共享 String 对象时无需加锁。<br>​​避免竞态条件​​：例如，在并发环境下，多个线程同时读取同一 String 对象不会因数据竞争导致错误。（对象是同一个）</p><p>虽然 final 代表了不可变，但<strong>仅仅是引用地址不可变，并不代表了数组本身不会变</strong>, 请看下面图片。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E5%9F%BA%E7%A1%80.resources/2023/09/15/17-54-06-098a7a27d0ec66292059fbdf80a307fe-unknown_filename.3-fe5b58.png" alt="unknown_filename.3"><br>final 也可以将数组本身改变的，这个时候，起作用的还有 private，正是因为两者保证了 String 的不可变性。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>(1) 修饰类：表示该类不能被继承；<br>(2) 修饰方法：表示方法不能被重写；<br>(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p><p>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；<br>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。<br>举个例子：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E5%9F%BA%E7%A1%80.resources/2023/09/15/17-54-06-736330e06f8259dde7e325e12c51a05e-0-531e70.png" alt="0"></p><p><strong>为什么匿名内部类中引用的局部变量必须要加 final</strong></p><p>内部类里面使用外部类的<strong>局部变量</strong>时，其实就是内部类的对象在使用它，内部类对象生命周期中都可能调用它，而内部类试图访问外部方法中的局部变量时，外部方法的局部变量很可能已经不存在了，那么就得延续其生命，<em>拷贝到内部类中，而拷贝会带来不一致性，从而需要使用 final 声明保证一致性</em>。</p><p>说白了，内部类会自动拷贝外部变量的引用，为了避免：</p><ol><li>外部方法修改引用，而导致内部类得到的引用值不一致</li><li>内部类修改引用，而导致外部方法的参数值在修改前和修改后不一致。于是就用 final 来让该引用不可改变。</li></ol><ul><li>匿名内部类访问的外部类局部变量为什么要用 final 修饰，jdk8为啥不需要了？<ol><li>因为匿名内部类使用的是<strong>外部类局部变量的值</strong>，并非引用</li><li>jdk8 其实用了语法糖，自动加了 final，其实和原来一样</li></ol></li></ul><p><strong>++在前还是后</strong><br>i++是先赋值再++<br>++i 是先++再赋值<br>比如：i &#x3D; 1; j &#x3D; i++; 那么此时的 j &#x3D; 1; i &#x3D; 2;<br>i &#x3D; 1; j &#x3D; ++i, 那么此时的 j &#x3D; 2, i &#x3D; 2;<br>i++这种在前在后都一样，只是先赋值还是先+1的问题。影响的是 j 的值</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>面向对象的特征有哪些方面？<br>答：四大特性封装、继承、多态、抽象。</p><p>继承<br>    一个子类可以有多个直接父类 (java 中不允许, 但进行了改良，在 java 中是通过”多实现”的方式来体现。因为多个父类中有相同成员，会产生调用不确定性。</p><p>多态<br>    用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而<em>方法重写（override）实现的是运行时的多态性</em>（也称为后绑定）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Animal a)</span><br> &#123;<br>  a.eat();<br>  <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat)<span class="hljs-comment">//instanceof：用于判断对象的具体类型,只能用于引用数据类型判断 </span><br><span class="hljs-comment">//通常在向下转型前用于健壮性的判断, 如果传入了其他的东西就不能调用</span><br>  &#123; <br>   <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;<br>   c.catchMouse();<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>   <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<br>   d.lookHome();<br>  &#125;<br></code></pre></td></tr></table></figure><p>多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容。<br>多态的弊端： 前期定义的内容不能使用 (调用) 后期子类的特有内容。</p><p>重载（overload）在同一个类中，名字相同，参数个数不同 or 参数类型不同。<br>覆盖（override）子类重写父类的方法中。覆盖也称为重写，覆写。</p><p><strong>构造器（constructor）是否可被重写（override）？</strong><br>答：构造器不能被继承，因此不能被重写，但可以被重载。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象是将一类对象的共同特征总结出来的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p>Abstract: 关键字，用于修饰类和方法。</p><ol><li>abstract 修饰的方法：没有方法体，只有方法的声明</li><li>Abstract 修饰的类：抽象类，不能被实例化</li></ol><p>注意：</p><ol><li>有抽象方法的类一定是抽象类，但抽象类中可以没有抽象方法</li><li>不能用 abstract 修饰私有方法、构造方法、静态方法。用 Abstract 修饰的成员就是要去实现，而构造器不能被继承不能被重写（可以被重载），其他不能修饰的原因是一样的。</li></ol><p>抽象类（abstract class）和接口（interface）有什么异同？</p><pre><code class="hljs">答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。</code></pre><p>接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</p><pre><code class="hljs">答：接口可以继承接口，并且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</code></pre><p>静态嵌套类 (Static Nested Class) 和内部类（Inner Class）的不同？</p><pre><code class="hljs">答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。内部类访问特点：</code></pre><ol><li>内部类可以直接访问外部类中的成员，包括私有成员</li><li><em>外部类要访问内部类，必须建立内部类的对象</em>。Outer. Inner in &#x3D; new Outer (). new Inner (); in.show (); 如果内部类中定义了静态成员，该内部类也必须是静态的。</li></ol><p>抽象的（abstract）方法是否可同时是静态的（static）, 是否可同时是本地方法（native），是否可同时被 synchronized 修饰？</p><pre><code class="hljs">答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</code></pre><p>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</p><pre><code class="hljs">答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</code></pre><p>访问修饰符 public, private, protected, 以及不写（默认）时的区别？<br>    <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E5%9F%BA%E7%A1%80.resources/2023/09/15/17-54-06-08d4c2d538e2beda458f1518833d5ed2-10d42a6e-8f6f-45dd-b14b-bc14e35972ef-d39db8.jpg" alt="10d42a6e-8f6f-45dd-b14b-bc14e35972ef"></p><p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p><p>String 是最基本的数据类型吗？</p><pre><code class="hljs">答：不是。Java中的基本数据类型只有8个：byte（1个字节7位，2^7）、short（2,2^15）、int（4）、long（8）、float（4）、double（8）、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</code></pre><p>整形默认 int，浮点默认 double，小的自动转成大的，大的得强转小的。java:byte short int long float double char boolean 先乘除后加减先算术再移位最后逻辑</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Java%E5%9F%BA%E7%A1%80.resources/2023/09/15/17-54-06-46c95b9b0ae06a41e26d70280b700758-wpsbe76-d0ceb2.png" alt="wpsbe76"></p><p>float f&#x3D;3.4; 是否正确？</p><pre><code class="hljs">答: 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float) 3.4; 或者写成 float f =3.4F。</code></pre><p>float 和 double 之间的区别</p><pre><code class="hljs">单精度浮点数有效数字8位，第7位数字将会四舍五入，双精度浮点数有效数字16位，在程序中处理速度不同，一般来说，CPU 处理单精度浮点数的速度比处理双精度浮点数快，如果不声明，默认小数为 double 类型，所以如果要用 float 的话，必须进行强转</code></pre><p>int, long 的取值范围以及 BigDecimal，数值越界了如何处理？</p><pre><code class="hljs">双精度浮点型变量 double 可以处理16位有效数。BigDecimal，用来对超过16位有效位的数进行精确的运算。但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用 Float 和 Double 处理，但是 Double.valueOf (String) 和 Float.valueOf (String) 会丢失精度。所以开发中，如果我们需要精确计算的结果。比如计算金额、转换格式单位等</code></pre><h3 id="拆箱装箱"><a href="#拆箱装箱" class="headerlink" title="拆箱装箱"></a>拆箱装箱</h3><p>当基本数据类型给引用数据类型装箱，当基本数据类型和引用数据类型做运算拆箱</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> AutoUnboxingTest &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main (String[] args) &#123;<br>        <span class="hljs-type">Integer</span> a = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span> (<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Integer</span> b = <span class="hljs-number">3</span>;                  // 将<span class="hljs-number">3</span>自动装箱成 <span class="hljs-type">Integer</span> 类型<br>        <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println (a == b);     // <span class="hljs-keyword">false</span> 两个引用没有引用同一对象<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println (a == c);     // <span class="hljs-keyword">true</span> a 自动拆箱成 <span class="hljs-type">int</span> 类型再和 c 比较<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test03 &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main (String[] args) &#123;<br>        <span class="hljs-type">Integer</span> f1 = <span class="hljs-number">100</span>, f2 = <span class="hljs-number">100</span>, f3 = <span class="hljs-number">150</span>, f4 = <span class="hljs-number">150</span>;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println (f1 == f2);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println (f3 == f4);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4四个变量都是 Integer 对象引用，所以下面的&#x3D;&#x3D;运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf 答案：小于127就是 TRUE，大于127就是 false，因为当数值在 byte 范围内容，如果该数值已经存在，则不会在开辟新的空间，所以 a 和 b 指向了同一个 Integer 对象，同一个引用。</p><p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 有错吗?<br>    答：对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 由于1是 int 类型，因此 s1+1运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 &#x3D; 1; s1 +&#x3D; 1; 可以正确编译，因为 s1+&#x3D; 1; 相当于 s1 &#x3D; (short)(s1 + 1); 其中有隐含的强制类型转换。</p><p>Math.round (11.5) 等于多少？Math.round (-11.5) 等于多少？</p><pre><code class="hljs"> 答：Math.round (11.5) 的返回值是12，Math.round (-11.5) 的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</code></pre><p>swtich 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？ </p><pre><code class="hljs">答：从 Java 7开始，expr 还可以是字符串（String），但是长整型（long）都不行</code></pre><p>数组有没有 length () 方法？String 有没有 length () 方法？ </p><pre><code class="hljs">答：数组没有 length () 方法，有 length 的属性。String 有 length () 方法。</code></pre><p>阐述 final、finally、finalize 的区别。</p><ol><li>final：同上</li><li>finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。</li><li>finalize：Object 类中定义的方法，Java 中允许使用 finalize () 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize () 方法可以整理系统资源或者执行其他清理工作。</li></ol><ul><li>equals 和=&#x3D;\的区别？</li></ul><ol><li>基本数据类型，也称原始数据类型。byte, short, char, int, long, float, double, boolean   他们之间的比较，应用双等号（=&#x3D;\）, 比较的是他们的值。</li><li>复合数据类型、引用数据类型 (类) 当他们用（=&#x3D;\）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个 new 出来的对象，他们的比较后的结果为 true，否则比较后结果为 false。</li><li>JAVA 当中所有的类都是继承于 Object 这个基类的，在 Object 中的基类中定义了一个 equals 的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如 String, Integer, Date 在这些类当中 equals 有其自身的实现，而不再是比较类在堆内存中的存放地址了。</li><li>对于复合数据类型之间进行 equals 比较，在没有覆写 equals 方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为 Object 的 equals 方法也是用双等号（=&#x3D;\）进行比较的，所以比较后的结果跟双等号（=&#x3D;\）的结果相同。</li></ol><p>this 和 super</p><pre><code class="hljs">当成员变量和局部变量重名，可以用关键字 this 来区分。this 就是所在函数所属对象的引用。简单说：哪个对象调用了 this 所在的函数，this 就代表哪个对象。this 也可以用于在构造函数中调用其他构造函数。子父类中的成员变量同名用 super 区分父类。</code></pre><p>Error 和 Exception 有什么区别？</p><pre><code class="hljs">答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</code></pre><p>try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的代码会不会被执行，什么时候被执行，在 return 前还是后?</p><pre><code class="hljs">答：会执行，在方法返回调用者前执行。注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰。</code></pre><p>Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</p><ol><li>一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用来指定一块预防所有异常的程序；</li><li>catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；</li><li>throw 语句用来明确地抛出一个异常；</li><li>throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；</li><li>finally 为确保一段代码不管发生什么异常状况都要被执行；</li><li>try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM。</li></ol><ul><li>列出一些你常见的运行时异常？<br>  ArithmeticException（算术异常）<br>  ClassCastException （类转换异常）<br>  IllegalArgumentException （非法参数异常）<br>  IndexOutOfBoundsException （下标越界异常）<br>  NullPointerException （空指针异常）<br>  SecurityException （安全异常）</li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Java 在 new 一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。我们先假设是第一次使用该类，这样的话 new 一个对象就可以分为两个过程：加载并初始化类和创建对象。</p><p>一、类加载过程（第一次使用该类）<br>Java 是使用双亲委派模型来进行类的加载的，所以在描述类加载过程前，我们先看一下它的工作过程：<br>1、加载<br>2、验证<br>3、准备<br>4、解析<br>5、初始化（先父后子）</p><p>为静态变量赋值<br>执行 static 代码块</p><p>加载: JVM 通过类加载器将描述类的数据从 Class 文件加载到内存中。类加载器根据类的全限定名 (包名+类名) 从文件系统或者 JAR 文件中找到对应的. Class 文件，然后读取其字节码数据并存储在内存中。</p><p>验证: 加载后的字码数据需要进行验证，以确保其内容是符合 Java 虚拟机规范的、安全的，并且与 JVM 的运行环境相兼容。验证的目的是防止恶意代码的执行，并确保字节码数据的完整性和正确性</p><p>准备: 准备阶段是为类的静态变量分配内存并设置默认的初始值。这个阶段不会执行任何初始化操作。</p><p>解析: 解析阶段是将类中的符号引用转换为直接引用。符号引用是指在类中使用的字符串形式的类名、方法名和字段名等，而直接引用则是指向运行时具体对象的指针。解析阶段是在类被加载后进行的，因此不会影响类的加载过程</p><p>初始化: 初始化阶段是执行类的构造器方法&lt;\clinit&gt;0 的过程，它会对类的静态变量进行初始化操作。初始化阶段会执行类中的所有 static 代码块和 static 变量的初始化代码，并执行构造器方法中的代码</p><p>二、创建对象</p><p>一个对象实例化过程<br>Zi p &#x3D; new zi ();</p><ol><li>JVM 会读取指定的路径下的 zi. Class 文件，并加载进内存，并会先加载 zi 的父类 (如果有直接的父类的情况下).</li><li>在堆内存中的开辟空间，分配地址。</li><li>并在对象空间中，对对象中的属性进行默认初始化。</li><li>调用对应的构造函数进行初始化。</li><li>在构造函数中，第一行会先到调用父类中构造函数进行初始化。</li><li>父类初始化完毕后，在对子类的属性进行显示初始化。</li><li>在进行子类构造函数的特定初始化。</li><li>初始化完毕后，将地址值赋值给引用变量.</li></ol><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*被动使用类字段演示一：</span><br><span class="hljs-comment">*通过子类引用父类的静态字段，不会导致子类初始化</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span>&#123;<br><span class="hljs-keyword">static</span>&#123;<br>System. out. println（<span class="hljs-string">&quot;SuperClass init！&quot;</span>）；<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> value=<span class="hljs-number">123</span>；<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span>&#123;<br><span class="hljs-keyword">static</span>&#123;<br>System. out. println（<span class="hljs-string">&quot;SubClass init！&quot;</span>）；<br>&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*非主动使用类字段演示</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main（String[]args）&#123;<br>System. out. println（SubClass. value）；<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类<br>的初始化而不会触发子类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*被动使用类字段演示三：</span><br><span class="hljs-comment">*常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstClass</span>&#123;<br><span class="hljs-keyword">static</span>&#123;<br>System. out. println（<span class="hljs-string">&quot;ConstClass init！&quot;</span>）；<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HELLOWORLD=<span class="hljs-string">&quot;hello world&quot;</span>；<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*非主动使用类字段演示</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main（String[]args）&#123;<br>System. out. println（ConstClass. HELLOWORLD）；<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码运行之后，也没有输出“ConstClass init！”</p><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制（运行时）。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）</strong> 7 个阶段。其中验证、准备、解析 3 个部分统称为连接（Linking）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/JVM.resources/2023/09/15/17-32-15-55d02093212c91c4139b62c620eef4e7-unknown_filename.9-a12233.png" alt="unknown_filename.9|700"></p><h2 id="Java-8的语法特性"><a href="#Java-8的语法特性" class="headerlink" title="Java 8的语法特性"></a>Java 8的语法特性</h2><p>Java 8引入了许多新的语法特性，以下是其中一些主要的特性：</p><ol><li><p>Lambda 表达式：Lambda 表达式是一种简洁的语法，<em>用于表示匿名函数</em>。它允许将函数作为参数传递给方法，或者在集合操作中进行函数式编程。Lambda 表达式使用箭头符号（-&gt;）将参数列表与函数体分隔开，并可以省略参数类型和大括号。</p></li><li><p>方法引用：方法引用提供了一种简洁的方式来<em>直接引用现有的方法或构造函数</em>。它可以替代Lambda 表达式，使代码更加简洁易读。方法引用的语法是<code>类名::方法名</code>，可以引用静态方法、实例方法和构造函数。</p></li><li><p>函数式接口：<em>函数式接口是只包含一个抽象方法的接口</em>。Java 8引入了<code>java.util.function</code>包，提供了一些常用的函数式接口，如<code>Predicate</code>、<code>Consumer</code>、<code>Function</code>等，用于支持函数式编程。</p></li><li><p>默认方法：默认方法是接口中的一个新特性，允许在接口中提供具有默认实现的方法。这样，在接口的实现类中可以直接使用默认方法，而无需强制实现。默认方法的目的是在不破坏现有接口的情况下，向接口添加新的方法。</p></li><li><p>Stream API：Stream API 提供了一种处理集合数据的函数式编程方式。它允许对集合进行过滤、映射、排序、归约等操作，提供了一种简洁、高效的方式来处理集合数据。</p></li><li><p>Optional 类：Optional 类是用来解决空指针异常的问题。它封装了一个可能为空的值，并提供了一些方法来处理空值情况，避免了显式的空指针检查。</p></li><li><p>新的日期和时间 API：Java 8引入了全新的日期和时间 API，取代了旧的<code>java.util.Date</code>和<code>java.util.Calendar</code>类。新的 API 提供了更加易用和功能强大的日期和时间操作方式。</p></li></ol><h4 id="Map-的新方法"><a href="#Map-的新方法" class="headerlink" title="Map 的新方法"></a>Map 的新方法</h4><p>在 JDK8中 Map 接口提供了一些新的便利的方法，getOrDefault (Object, V) 允许调用者在代码语句中规定获得在 map 中符合提供的键的值，否则在没有找到提供的键的匹配项的时候返回一个“默认值”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK8之前的实现方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">capitalGeorgia</span> <span class="hljs-operator">=</span> statesAndCapitals.get(<span class="hljs-string">&quot;Georgia&quot;</span>);<br><span class="hljs-keyword">if</span> (capitalGeorgia == <span class="hljs-literal">null</span>)<br>&#123;<br>   capitalGeorgia = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>&#125;<br> <br><span class="hljs-comment">// JDK8的实现方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">capitalWisconsin</span> <span class="hljs-operator">=</span> statesAndCapitals.getOrDefault(<span class="hljs-string">&quot;Wisconsin&quot;</span>, <span class="hljs-string">&quot;Unknown&quot;</span>);<br><br><br></code></pre></td></tr></table></figure><p>Map.putIfAbsent (K, V)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK8之前的实现方式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">capitalMississippi</span> <span class="hljs-operator">=</span> statesAndCapitals.get(<span class="hljs-string">&quot;Mississippi&quot;</span>);<br><span class="hljs-keyword">if</span> (capitalMississippi == <span class="hljs-literal">null</span>)&#123;<br>   capitalMississippi = statesAndCapitals.put(<span class="hljs-string">&quot;Mississippi&quot;</span>, <span class="hljs-string">&quot;Jackson&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">// JDK8的实现方式</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">capitalNewYork</span> <span class="hljs-operator">=</span> statesAndCapitals.putIfAbsent(<span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;Albany&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>热修复、插件化、组件化</title>
    <link href="/2025/12/82dcb152a5ce.html"/>
    <url>/2025/12/82dcb152a5ce.html</url>
    
    <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p><strong>模块化：项目按照独立的模块进行划分</strong></p><p>项目组件化的重要环节在于，将项目按照模块来进行拆分，拆分成一个个业务module和其他基础module（lib），各个业务module之间互不依赖，互相解耦！每个业务module都可以安排不同的开发人员团队来进行开发，不强制使用一种开发模式，MVP可以，MVC也可以！然后各个业务module之间通过路由机制进行跳转和传递！</p><p><strong>资源名冲突</strong><br>color，shape，drawable，图片资源，布局资源，或者anim资源等等，都有可能造成资源名称冲突。有时候大家负责不同的模块，如果不是按照统一规范命名，则会偶发出现该问题</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">android &#123;<br><span class="hljs-regexp">//</span> 所有xml资源命名以 <span class="hljs-string">&quot;login_&quot;</span> 开头、否则编译报红<br>resourcePrefix <span class="hljs-string">&quot;login_&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组件化模块间交互"><a href="#组件化模块间交互" class="headerlink" title="组件化模块间交互"></a>组件化模块间交互</h3><ul><li>使用 EventBus 的方式，缺点是：EventBean 维护成本太高，不好去管理：</li><li>使用广播的方式，缺点是：不好管理，都统一发出去了</li><li>使用隐士意图方式，缺点是：在 AndroidManifest. xml 里面配置 xml 写的太多了</li><li>使用类加载方式，缺点就是，容易写错包名类名，缺点较少</li><li>使用全局 Map 的方式，缺点是，要注册很多的对象</li></ul><h3 id="网上开源的组件化"><a href="#网上开源的组件化" class="headerlink" title="网上开源的组件化"></a>网上开源的组件化</h3><p><a href="https://github.com/luojilab/DDComponentForAndroid/wiki/1%E3%80%81%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">1、组件数据交互 · luojilab&#x2F;DDComponentForAndroid Wiki</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Router<span class="hljs-selector-class">.getInstance</span>()<span class="hljs-selector-class">.getService</span>(MedRecordDossierService::class<span class="hljs-selector-class">.java</span>.name).getPatientFragment<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-558129a1644d0736cd25072fe9b87f86-unknown_filename.6-93023b.png" alt="unknown_filename.6"></p><p>核心思路非常朴素且高效：<strong>面向接口编程 + 中央 Router（Service Locator）做实现的注册与查找 + 组件生命周期钩子控制注册&#x2F;反注册</strong>。<br>这样组件之间既能互相调用，又不需要互相依赖实现代码，达到彻底解耦。</p><h4 id="1-交互的契约层：把“接口”单独下沉"><a href="#1-交互的契约层：把“接口”单独下沉" class="headerlink" title="1. 交互的契约层：把“接口”单独下沉"></a>1. 交互的契约层：把“接口”单独下沉</h4><p>项目推荐把所有组件对外暴露的服务接口统一放到 <code>componentservice</code> 这个 module 里（只放接口、数据结构等“契约”）。</p><ul><li><strong>示例</strong>：例如 <code>reader</code> 组件要对外提供一个能力（返回一个阅读页 Fragment），就在 <code>componentservice</code> 定义：<ul><li><code>ReadBookService</code>（接口，只描述能力，不包含实现）</li></ul></li></ul><p>这样其它组件只需要依赖 <code>componentservice</code>，不会依赖 <code>reader</code> 组件本身。</p><h4 id="2-实现层：实现类留在组件内部，外部不可见"><a href="#2-实现层：实现类留在组件内部，外部不可见" class="headerlink" title="2. 实现层：实现类留在组件内部，外部不可见"></a>2. 实现层：实现类留在组件内部，外部不可见</h4><p><code>reader</code> 组件内部自己实现 <code>ReadBookServiceImpl</code>，并返回真实的 <code>ReaderFragment</code>。<br>由于组件代码隔离，这个实现类对外部组件不可见，外部永远只能看到接口。</p><h4 id="3-注册与发现：Router-充当中央“服务注册表”"><a href="#3-注册与发现：Router-充当中央“服务注册表”" class="headerlink" title="3. 注册与发现：Router 充当中央“服务注册表”"></a>3. 注册与发现：Router 充当中央“服务注册表”</h4><h4 id="Router-内部的数据结构"><a href="#Router-内部的数据结构" class="headerlink" title="Router 内部的数据结构"></a>Router 内部的数据结构</h4><p>Router 里维护了一个 <code>HashMap&lt;String, Object&gt; services</code>，用来保存 “<code>serviceName</code> -&gt; <code>serviceImpl</code>” 的映射，并提供以下方法</p><ul><li><code>addService(serviceName, impl)</code></li><li><code>getService(serviceName)</code></li><li><code>removeService(serviceName)</code></li></ul><p>所以它本质上就是一个线程安全（synchronized）的 <strong>Service Locator</strong>。</p><h5 id="注册时机：每个组件的-ApplicationLike"><a href="#注册时机：每个组件的-ApplicationLike" class="headerlink" title="注册时机：每个组件的 ApplicationLike"></a>注册时机：每个组件的 ApplicationLike</h5><p>每个组件提供一个 <code>ApplicationLike</code>（相当于“组件自己的 Application”，用于组件生命周期控制）。</p><ul><li><strong>加载时</strong>：在组件加载时 <code>onCreate()</code> 里把实现注册进 Router。</li><li><strong>卸载时</strong>：在组件卸载时 <code>onStop()</code> 里反注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注册</span><br>router.addService(ReadBookService.class.getSimpleName(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadBookServiceImpl</span>());<br><span class="hljs-comment">// 反注册</span><br>router.removeService(ReadBookService.class.getSimpleName());<br></code></pre></td></tr></table></figure><p>这就是“组件可动态加载&#x2F;卸载”时交互仍然可控的关键。</p><h4 id="4-调用方式：使用方从-Router-拿接口再调用"><a href="#4-调用方式：使用方从-Router-拿接口再调用" class="headerlink" title="4. 调用方式：使用方从 Router 拿接口再调用"></a>4. 调用方式：使用方从 Router 拿接口再调用</h4><p>其它组件要使用 <code>reader</code> 的能力时：</p><ol><li>调用 <code>Router.getInstance().getService(ReadBookService.class.getSimpleName())</code></li><li><strong>判空</strong>（因为组件可能没被集成&#x2F;没加载）</li><li><strong>强转为接口类型</strong> <code>ReadBookService</code></li><li>调用接口方法拿到结果（例如 Fragment）</li></ol><p><strong>关键点</strong>：调用方只依赖接口，不依赖实现，也不需要知道实现类名。</p><h4 id="5-为什么它能做到“组件动态加载-卸载”"><a href="#5-为什么它能做到“组件动态加载-卸载”" class="headerlink" title="5. 为什么它能做到“组件动态加载&#x2F;卸载”"></a>5. 为什么它能做到“组件动态加载&#x2F;卸载”</h4><p>除了 <code>services</code>，Router 还维护了一个 <code>components</code> 表（<code>HashMap&lt;String, IApplicationLike&gt;</code>），并提供：</p><ul><li><code>registerComponent(classname)</code>：通过 <code>Class.forName(classname)</code> 反射创建 <code>IApplicationLike</code>，调用其 <code>onCreate()</code>，然后记录到 <code>components</code> 中。</li><li>对应也有反注册逻辑：卸载时会走 <code>onStop()</code> 并从表中移除。<br>因此，“组件是否可被调用”完全取决于它是否完成了 <code>ApplicationLike</code> 的注册流程，以及服务表里是否存在对应实现。</li></ul><h4 id="6-这种交互方式的特点与边界"><a href="#6-这种交互方式的特点与边界" class="headerlink" title="6. 这种交互方式的特点与边界"></a>6. 这种交互方式的特点与边界</h4><table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td><strong>真正解耦</strong></td><td>组件间只通过接口交互。</td></tr><tr><td><strong>支持按需集成</strong></td><td>没集成&#x2F;没加载的组件，<code>getService()</code> 返回 <code>null</code>，调用方可降级处理。</td></tr><tr><td><strong>支持动态卸载</strong></td><td><code>onStop()</code> 反注册即可切断能力暴露。</td></tr></tbody></table><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-02-07-14-59-905bdcd01cc8d7186ed1dae4e73d68bd-20240207145904-ef292d.png" alt="image.png|800"></p><p>彻底明白 Phone Module与 AndroidLibrary的区别<br>Phone Module 可以单独运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 配置资源路径，方便测试环境，打包不集成到正式环境</span><br>sourceSets &#123; <span class="hljs-comment">// 节省apt大小</span><br><span class="hljs-selector-tag">main</span> &#123;<br><span class="hljs-keyword">if</span> (!isRelease) &#123;<br><span class="hljs-comment">// 如果是组件化模式，需要单独运行时</span><br>manifest<span class="hljs-selector-class">.srcFile</span> <span class="hljs-string">&#x27;src/main/debug/AndroidManifest.xml&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 集成化模式，整个项目打包apk</span><br>manifest<span class="hljs-selector-class">.srcFile</span> <span class="hljs-string">&#x27;src/main/AndroidManifest.xml&#x27;</span><br>java &#123;<br><span class="hljs-comment">// release 时 debug 目录下文件不需要合并到主工程</span><br>exclude <span class="hljs-string">&#x27;**/debug/**&#x27;</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="项目重构"><a href="#项目重构" class="headerlink" title="项目重构"></a>项目重构</h3><ul><li><p>项目由于业务需求越来越大，不同项目的功能想相互迁移变的越来越难，经过查阅大量文章，推动项目组件化，分成基础组件层、业务组件层、业务module层，从下往上依赖，module是不同的业务，如社区、还款等，方便迁移并且可以独立运行。</p></li><li><p>传递数据是通过scheme，scheme是一种页面内跳转协议，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面：通过scheme协议，服务器可以定制化告诉App跳转那个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转指定页面。</p></li><li><p>基础组件层：<br>  底层使用的库和封装的一些工具库（libs），比如okhttp,rxjava,rxandroid,glide、相机、照片等</p></li><li><p>业务组件层：<br>  与业务相关，封装第三方sdk，比如封装后的支付等、自定义view、工具类</p></li><li><p>业务模块层：<br>  按照业务划分模块，比如说还款模块，社区模块等</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;qianbaoguanjia80e866a23d&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Intent intent = <span class="hljs-literal">new</span> Intent(Intent.ACTION_VIEW,<br>Uri.parse(<span class="hljs-string">&quot;qianbaoguanjia80e8565663d://brushcard?goWhere=&quot;</span> + <span class="hljs-string">&quot;1&quot;</span>));<br>startActivity(intent);<br><br>Intent intent = getIntent();<br><span class="hljs-built_in">String</span> action = intent.getAction();<br><span class="hljs-keyword">if</span> (Intent.ACTION_VIEW.<span class="hljs-keyword">equals</span>(action)) &#123;<br><br>Uri uri = intent.getData();<br><span class="hljs-keyword">if</span> (uri != <span class="hljs-built_in">null</span>) &#123;<br><span class="hljs-built_in">String</span> dataString = intent.getDataString();<br><span class="hljs-keyword">Log</span>.d(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;dataString:&quot;</span> + dataString);<br><br><span class="hljs-built_in">String</span> host = uri.getHost();<span class="hljs-comment">//从哪来</span><br><span class="hljs-keyword">if</span> (host.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;brushcard&quot;</span>)) &#123;<br><span class="hljs-built_in">String</span> goWhere = uri.getQueryParameter(<span class="hljs-string">&quot;goWhere&quot;</span>);<span class="hljs-comment">//到哪去</span><br><span class="hljs-keyword">if</span> (goWhere.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;1&quot;</span>)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><h2 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h2><ul><li>减少体积、添加功能</li><li>提高打开速度（多个 dex，效果不理想)</li><li>为什么有反射：private 防不住的，不是限制做坏事，是限制不小心写错了</li><li>把插件 apk 放在 asset 里，或者网络下载，保存在本地，可以<em>通过 dexClassLoader 加载</em></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-959a108dc14d4ede457274785e93557a-QQ%E6%88%AA%E5%9B%BE20191220155257-00878f.png" alt="QQ截图20191220155257"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br><span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>setContentView(R.layout.activity_main);<br><br><span class="hljs-type">File</span> <span class="hljs-variable">apk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(getCacheDir() + <span class="hljs-string">&quot;/plugin-debug.apk&quot;</span>);<br><span class="hljs-keyword">try</span> (<span class="hljs-type">Source</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Okio.source(getAssets().open(<span class="hljs-string">&quot;plugin-debug.apk&quot;</span>));<br> <span class="hljs-type">BufferedSink</span> <span class="hljs-variable">sink</span> <span class="hljs-operator">=</span> Okio.buffer(Okio.sink(apk))) &#123;<br>  sink.writeAll(source);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>  e.printStackTrace();<br>&#125;<br><span class="hljs-type">DexClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexClassLoader</span>(apk.getPath(), getCacheDir().getPath(), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-type">Class</span> <span class="hljs-variable">utilsClass</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;com.demo.pluginnable_plugin.Utils&quot;</span>);<br>  <span class="hljs-type">Constructor</span> <span class="hljs-variable">utilsConstructor</span> <span class="hljs-operator">=</span> utilsClass.getDeclaredConstructors()[<span class="hljs-number">0</span>];<br>  <span class="hljs-comment">//   utilsConstructor.setAccessible(true); //反射用法需要</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">utils</span> <span class="hljs-operator">=</span> utilsConstructor.newInstance();<br>  <span class="hljs-type">Method</span> <span class="hljs-variable">shoutMethod</span> <span class="hljs-operator">=</span> utilsClass.getDeclaredMethod(<span class="hljs-string">&quot;shout&quot;</span>);<br>  <span class="hljs-comment">//    shoutMethod.setAccessible(true);</span><br>  shoutMethod.invoke(utils);<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>  e.printStackTrace();<br>&#125;<br><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<span class="hljs-comment">//打不开</span><br>intent.setClassName(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;com.hencoder.a37_pluginnable_plugin.SecondActivity&quot;</span>);<br>startActivity(intent);<br>  &#125;<br>&#125;<br>    <br><br></code></pre></td></tr></table></figure><p>动态加载其他 apk 的 activity，<em>可以设置个代理类，因为一开始是不知道要启动的名字是叫什么的</em></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-1d77e0a5d9d2cc3928337e4240560cb9-unknown_filename.8-bd7ba6.png" alt="unknown_filename.8"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>  Object realActivity;<br><br><br><span class="hljs-comment">//  realActivity = dexClassLoader.loadClass(???);</span><br><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br><span class="hljs-comment">//    realActivity.onCreate(savedInstanceState);</span><br>  &#125;<br><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.onStart();<br><span class="hljs-comment">//    realActivity.onStart();</span><br>  &#125;<br><br>  <span class="hljs-comment">//动态加载asset\resour（主要是图片）</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Resources <span class="hljs-title function_">getResources</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resources</span>(getAssets(), <span class="hljs-built_in">super</span>.getResources().getDisplayMetrics(), <span class="hljs-built_in">super</span>.getResources().getConfiguration());<br>  &#125;<br><br><br>  <span class="hljs-keyword">private</span> AssetManager <span class="hljs-title function_">createAssetManager</span><span class="hljs-params">(String dexPath)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">AssetManager</span> <span class="hljs-variable">assetManager</span> <span class="hljs-operator">=</span> AssetManager.class.newInstance();<br>      <span class="hljs-type">Method</span> <span class="hljs-variable">addAssetPath</span> <span class="hljs-operator">=</span> assetManager.getClass().getMethod(<span class="hljs-string">&quot;addAssetPath&quot;</span>, String.class);<br>      addAssetPath.invoke(assetManager, dexPath);<br>      <span class="hljs-keyword">return</span> assetManager;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">/*private Resources createResources(AssetManager assetManager) &#123;</span><br><span class="hljs-comment">    Resources superRes = mContext.getResources();</span><br><span class="hljs-comment">    Resources resources = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="hljs-comment">    return resources;</span><br><span class="hljs-comment">  &#125;*/</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-1773bde8e552cb02c3c2b9b615f41295-unknown_filename.2-c24a95.png" alt="unknown_filename.2"></p><p><strong>ClassLoader有PathClassLoader、DexClassLoader俩个子类</strong></p><p> <em>Android 8.0</em><br>与 DexClassLoader <strong>完全一致</strong>，这个 optimizedDirectory 在 Android 8.0 以后也被舍弃了，只能使用系统默认的位置了。</p><p><em>5.0–8.0</em></p><ul><li>PathClassLoader 和 DexClassLoader 都能加载外部的 dex／apk，只不过<strong>区别是 DexClassLoader 可以指定 optimizedDirectory</strong>，也就是 dex2oat 的产物 .odex （优化后的 dex 文件）存放的位置，而 PathClassLoader 只能使用系统默认位置。</li><li>DEX 文件同级目录下添加一个 oat&#x2F; 文件作为 .odex 的存储目录。</li></ul><p><em>android 4.4之前</em></p><ul><li><p>PathClassLoader 只能加载安装在 Android 系统内 APK 文件（*&#x2F;data&#x2F;app 目录下*），其他位置的文件加载时都会报 ClassNotFoundException。因为 PathClassLoader 会读取 &#x2F;data&#x2F;dalvik-cache 目录下的经过 Dalvik 优化过的 dex 文件，这个目录的 dex 文件是在安装 apk 包的时候由 Dalvik 生成的，没有安装的时候，自然没有生成这个文件。</p></li><li><p>对于 App 而言，Apk 文件中有一个 classes. dex 文件，那么这个 dex 就是 Apk 的主 dex, 是通过 PathClassLoader 加载的。</p></li><li><p>DexClassLoader：可以加载任意目录下的 dex&#x2F;jar&#x2F;apk&#x2F;zip 文件，是实现热修复的重点。</p></li><li><p>PathClassLoader：用于加载 Android 系统类和开发编写应用的类，只能加载已经安装应用的 dex 或 apk 文件，是 Android 默认使用的类加载器，也是 getSystemClassLoader 的返回对象。</p></li></ul><p>BootClassLoader：主要用于加载系统的类，包括 java 和 android 系统的类库，和 JVM 中不同，BootClassLoader 是 ClassLoader 内部类，是由 Java 实现，它也是所有系统 ClassLoader 的 父 ClassLoader。</p><ul><li>我们可以指定到 getCacheDir().getPath()</li></ul><ul><li>在 App 的 Activity 中，通过 getClassLoader 获取到的是 PathClassLoader, 它的父类是 BootClassLoader。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-02948fd9b34281a931a019cd061f9bb3-unknown_filename.3-007fef.png" alt="unknown_filename.3|600"></p><h3 id="loadClass-的类加载过程"><a href="#loadClass-的类加载过程" class="headerlink" title="loadClass() 的类加载过程"></a>loadClass() 的类加载过程</h3><p><strong>双亲委托机制</strong><br>宏观上：是⼀个带缓存的、从上到下的加载过程（即网上所说的「双亲委托机制」）<br>这样做的意义是为了性能，每次加载都会消耗时间，但如果父亲加载过，就可以直接拿来使用了。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-dcb489261f7dff4d3db54abb729db1eb-unknown_filename.1-4e2a34.png" alt="unknown_filename.1|600"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException<br>        &#123;<br>                <span class="hljs-comment">// First, check if the class has already been loaded</span><br>                Class&lt;?&gt; c = findLoadedClass(name);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                            c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            c = findBootstrapClassOrNull(name);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                        <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                        <span class="hljs-comment">// from the non-null parent class loader</span><br>                    &#125;<br>    <br>    <br>                    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                        <span class="hljs-comment">// to find the class.</span><br>                        c = findClass(name);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="代理-startActivity"><a href="#代理-startActivity" class="headerlink" title="代理 startActivity"></a>代理 startActivity</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-03-01-10-00-a8af465c25d9756eb62b976b8df3cc16-18-51-39-a8af465c25d9756eb62b976b8df3cc16-unknown_filename.7-d28efe-a343b7.png" alt="unknown_filename.7|600"></p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><strong>热更更新和插件化的区别</strong></p><ol><li>插件化的内容在原 App 中没有，而热更新是原 App 中的内容做了改动</li><li>插件化在代码中有固定的入口，而热更新则可能改变任何一个位置的代码，热更新的原理 ClassLoader 的 dex 文件替换，直接修改字节码。</li><li>热修复（热更新）主要用来修复代码、修复bug，而插件化是增加新的功能类或者是资源文件。</li></ol><p><strong>应用场景</strong></p><p>当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，你得：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。</p><p><strong>热修复和插件化的原理主要是操作ClassLoader</strong></p><ul><li>Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class文件加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader（类加载器）。</li><li>一个ClassLoader可以包含多个dex文件，每个dex文件是一个Element（元素），多个dex文件排列成一个有序的数组dexElements，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找不到从下一个dex文件继续查找，如果找到类则返回。</li><li>然后就可以做一些事情，比如，<em>在这个数组的第一个元素放置我们的补丁，里面包含修复过的类，这样的话，当遍历findClass的时候，后面的就会忽略</em>。</li><li>热更新的关键在于，<em>把补丁dex文件加载放进一个Element</em>，并且插入到dexElements这个数组的前面(插入到后面的话会被忽略掉)</li></ul><h3 id="手写热更新"><a href="#手写热更新" class="headerlink" title="手写热更新"></a>手写热更新</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-d52c46072c8e7043e6332cff6c41c212-unknown_filename-f5841f.png" alt="unknown_filename|700"></p><p>创建一个新的dexElements，把补丁的每个DexElement放到新的数组里，把旧的都拷贝到新的后面，然后把数组换了<br>newClassLoader.pathList.dexElements</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotfixApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    File apk; <span class="hljs-comment">// 存储热修复补丁文件</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachBaseContext</span><span class="hljs-params">(Context base)</span> &#123;<br>        <span class="hljs-built_in">super</span>.attachBaseContext(base); <span class="hljs-comment">// 调用父类方法初始化基础上下文</span><br>        <br>        <span class="hljs-comment">// 1. 定位热修复文件路径（位于应用缓存目录）</span><br>        apk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(getCacheDir() + <span class="hljs-string">&quot;/hotfix.dex&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2. 检查热修复文件是否存在</span><br>        <span class="hljs-keyword">if</span> (apk.exists()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 3. 获取当前应用的类加载器（PathClassLoader）</span><br>                <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> getClassLoader();<br>                <br>                <span class="hljs-comment">// 4. 反射获取BaseDexClassLoader中的pathList字段</span><br>                <span class="hljs-type">Class</span> <span class="hljs-variable">loaderClass</span> <span class="hljs-operator">=</span> BaseDexClassLoader.class;<br>                <span class="hljs-type">Field</span> <span class="hljs-variable">pathListField</span> <span class="hljs-operator">=</span> loaderClass.getDeclaredField(<span class="hljs-string">&quot;pathList&quot;</span>);<br>                pathListField.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 突破私有访问限制</span><br>                <br>                <span class="hljs-comment">// 5. 获取当前类加载器的DexPathList对象，先获取字段，然后获取字段的值</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">pathListObject</span> <span class="hljs-operator">=</span> pathListField.get(classLoader); <br>                <br>                <span class="hljs-comment">// 6. 获取DexPathList中的dexElements数组字段</span><br>                <span class="hljs-type">Class</span> <span class="hljs-variable">pathListClass</span> <span class="hljs-operator">=</span> pathListObject.getClass();<br>                <span class="hljs-type">Field</span> <span class="hljs-variable">dexElementsField</span> <span class="hljs-operator">=</span> pathListClass.getDeclaredField(<span class="hljs-string">&quot;dexElements&quot;</span>);<br>                dexElementsField.setAccessible(<span class="hljs-literal">true</span>);<br>            <br>             <span class="hljs-comment">// 9. 获取当前应用的dexElements数组</span><br>             <span class="hljs-type">Object</span> <span class="hljs-variable">dexElementsObject</span> <span class="hljs-operator">=</span> dexElementsField.get(pathListObject);<br>                <br>                <span class="hljs-comment">// 7. 创建新的类加载器加载热修复DEX</span><br>                <span class="hljs-comment">// 注意：这里使用PathClassLoader而不是DexClassLoader（兼容性问题）</span><br>                <span class="hljs-type">PathClassLoader</span> <span class="hljs-variable">newClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathClassLoader</span>(<br>                    apk.getPath(), <span class="hljs-comment">// 热修复DEX路径</span><br>                    <span class="hljs-literal">null</span>          <span class="hljs-comment">// 父类加载器（设为null使用默认）</span><br>                );<br>                <br>                <span class="hljs-comment">// 8. 获取新类加载器的DexPathList和dexElements</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">newPathListObject</span> <span class="hljs-operator">=</span> pathListField.get(newClassLoader);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">newDexElementsObject</span> <span class="hljs-operator">=</span> dexElementsField.get(newPathListObject);<br><br>                <br>                <span class="hljs-comment">// 10. 计算新旧数组长度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">oldLength</span> <span class="hljs-operator">=</span> Array.getLength(dexElementsObject);    <span class="hljs-comment">// 原始数组长度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">newLength</span> <span class="hljs-operator">=</span> Array.getLength(newDexElementsObject); <span class="hljs-comment">// 补丁数组长度</span><br>                <br>                <span class="hljs-comment">// 11. 创建合并后的新数组（大小为原始+补丁）</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">concatDexElementsObject</span> <span class="hljs-operator">=</span> Array.newInstance(<br>                    dexElementsObject.getClass().getComponentType(), <span class="hljs-comment">// 数组元素类型</span><br>                    oldLength + newLength                            <span class="hljs-comment">// 总长度</span><br>                );<br>                <br>                <span class="hljs-comment">// 12. 将补丁DEX元素复制到新数组前端（优先加载）</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newLength; i++) &#123;<br>                    Array.set(concatDexElementsObject, i, Array.get(newDexElementsObject, i));<br>                &#125;<br>                <br>                <span class="hljs-comment">// 13. 将原始DEX元素复制到新数组后端</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldLength; i++) &#123;<br>                    Array.set(concatDexElementsObject, newLength + i, Array.get(dexElementsObject, i));<br>                &#125;<br>                <br>                <span class="hljs-comment">// 14. 关键步骤：将新数组设置回当前类加载器</span><br>                dexElementsField.set(pathListObject, concatDexElementsObject);<br>                <br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>                e.printStackTrace(); <span class="hljs-comment">// 异常处理（实际项目需更健壮）</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>   <br>   <br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>     TextView titleTv;<br>     Button showTitleBt;<br>     Button hotfixBt;<br>     Button removeHotfixBt;<br>     Button killSelfBt;<br>     File apk;<br>   <br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>   <br>       <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>       setContentView(R.layout.activity_main);<br>   <br>       titleTv = findViewById(R.id.titleTv);<br>       showTitleBt = findViewById(R.id.showTitleBt);<br>       hotfixBt = findViewById(R.id.hotfixBt);<br>       removeHotfixBt = findViewById(R.id.removeHotfixBt);<br>       killSelfBt = findViewById(R.id.killSelfBt);<br>   <br>       apk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(getCacheDir() + <span class="hljs-string">&quot;/hotfix.dex&quot;</span>);<br>   <br>       View.<span class="hljs-type">OnClickListener</span> <span class="hljs-variable">onClickListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View v)</span> &#123;<br>           <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>             <span class="hljs-keyword">case</span> R.id.showTitleBt:<br>               <span class="hljs-type">Title</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Title</span>();<br>               titleTv.setText(title.getTitle());<br>               <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> R.id.hotfixBt:<br>               <span class="hljs-keyword">try</span> (<span class="hljs-type">Source</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Okio.source(getAssets().open(<span class="hljs-string">&quot;apk/hotfix.dex&quot;</span>));<br>                    <span class="hljs-type">BufferedSink</span> <span class="hljs-variable">sink</span> <span class="hljs-operator">=</span> Okio.buffer(Okio.sink(apk))) &#123;<br>                 sink.writeAll(source);<br>               &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                 e.printStackTrace();<br>               &#125;<br>   <span class="hljs-comment">//            OkHttpClient client = new OkHttpClient();</span><br>   <span class="hljs-comment">//            Request request = new Request.Builder()</span><br>   <span class="hljs-comment">//                .url(&quot;https://api.hencoder.com/patch/upload/hotfix.dex&quot;)</span><br>   <span class="hljs-comment">//                .get()</span><br>   <span class="hljs-comment">//                .build();</span><br>   <span class="hljs-comment">//            client.newCall(request)</span><br>   <span class="hljs-comment">//                .enqueue(new Callback() &#123;</span><br>   <span class="hljs-comment">//                  @Override</span><br>   <span class="hljs-comment">//                  public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;</span><br>   <span class="hljs-comment">//                  &#125;</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">//                  @Override</span><br>   <span class="hljs-comment">//                  public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;</span><br>   <span class="hljs-comment">//                    try &#123;</span><br>   <span class="hljs-comment">//                      FileOutputStream fos = new FileOutputStream(apk);</span><br>   <span class="hljs-comment">//                      fos.write(response.body().bytes());</span><br>   <span class="hljs-comment">//                      fos.close();</span><br>   <span class="hljs-comment">//                    &#125; catch (Exception e) &#123;</span><br>   <span class="hljs-comment">//                      e.printStackTrace();</span><br>   <span class="hljs-comment">//                    &#125;</span><br>   <span class="hljs-comment">//                    v.post(new Runnable() &#123;</span><br>   <span class="hljs-comment">//                      @Override</span><br>   <span class="hljs-comment">//                      public void run() &#123;</span><br>   <span class="hljs-comment">//                        Toast.makeText(MainActivity.this, &quot;加载补丁成功&quot;, Toast.LENGTH_SHORT).show();</span><br>   <span class="hljs-comment">//                      &#125;</span><br>   <span class="hljs-comment">//                    &#125;);</span><br>   <span class="hljs-comment">//                  &#125;</span><br>   <span class="hljs-comment">//                &#125;);</span><br>               <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> R.id.removeHotfixBt:<br>               <span class="hljs-keyword">if</span> (apk.exists()) &#123;<br>                 apk.delete();<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> R.id.killSelfBt:<br>               android.os.Process.killProcess(android.os.Process.myPid());<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>         &#125;<br>       &#125;;<br>   <br>       showTitleBt.setOnClickListener(onClickListener);<br>       hotfixBt.setOnClickListener(onClickListener);<br>       removeHotfixBt.setOnClickListener(onClickListener);<br>       killSelfBt.setOnClickListener(onClickListener);<br>     &#125;<br>   &#125;<br>   <br>   <br><br>   <span class="hljs-type">def</span> <span class="hljs-variable">patchPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;com/hencoder/a38_hotfix/Title&#x27;</span><br>   <br>   task hotfix &#123;<br>       doLast &#123;<br>   <span class="hljs-comment">//        exec &#123;</span><br>   <span class="hljs-comment">//            commandLine &#x27;rm&#x27;, &#x27;-r&#x27;, &#x27;./build/patch&#x27;</span><br>   <span class="hljs-comment">//        &#125;</span><br>   <span class="hljs-comment">//        exec &#123;</span><br>   <span class="hljs-comment">//            commandLine &#x27;mkdir&#x27;, &#x27;./build/patch&#x27;</span><br>   <span class="hljs-comment">//        &#125;</span><br>           exec &#123;<br>               commandLine <span class="hljs-string">&#x27;javac&#x27;</span>, <span class="hljs-string">&quot;./src/main/java/$&#123;patchPath&#125;.java&quot;</span>, <span class="hljs-string">&#x27;-d&#x27;</span>, <span class="hljs-string">&#x27;./build/patch&#x27;</span><br>           &#125;<br>           exec &#123;<br>               commandLine <span class="hljs-string">&#x27;C:\\Users\\41009\\AppData\\Local\\Android\\Sdk\\build-tools\\29.0.2\\d8.bat&#x27;</span>, <span class="hljs-string">&quot;./build/patch/$&#123;patchPath&#125;.class&quot;</span>, <span class="hljs-string">&#x27;--output&#x27;</span>, <span class="hljs-string">&#x27;./build/patch&#x27;</span><br>           &#125;<br>           exec &#123;<br>               commandLine <span class="hljs-string">&#x27;mv&#x27;</span>, <span class="hljs-string">&quot;./build/patch/classes.dex&quot;</span>, <span class="hljs-string">&#x27;./build/patch/hotfix.dex&#x27;</span><br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="tinker"><a href="#tinker" class="headerlink" title="tinker"></a><strong>tinker</strong></h3><p><a href="https://www.jianshu.com/p/212121671ec6">好文章</a><br>有 Git 才有 tinkerID，有还报错的话本地提交一次。<br>需要改造 Application，不支持 AndroidDagger<br><a href="https://www.jianshu.com/p/63fcffa3d4b2">https://www.jianshu.com/p/63fcffa3d4b2</a><br>坑太多，建议使用 <a href="http://www.tinkerpatch.com/">http://www.tinkerpatch.com/</a></p><p>tinker 将 old. apk 和 new. apk 做了 diff，拿到 patch. dex，然后将 patch. dex 与本机中 apk 的 classes. dex 做了合并，生成新的 classes. dex，运行时通过反射将合并后的 dex 文件放置在加载的 dexElements 数组的前面。</p><h3 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h3><p>原理：<br>方法的替换，把有bug的方法替换成补丁文件中的方法。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-d2717d7c63a8224a518e62ebd51bc7f0-Image-bcf7fb.jpg" alt="Image"></p><p><strong>优点</strong>：<br>重大bug，需要紧急修复<br>可以下次迭代修复的bug<br>影响用户体验的行为<br>无需重启</p><p><strong>缺点</strong>：<br>无法添加新类(内部类也不行)和新的字段、新的方法<br>资源文件无法替换   试了下换原有的图片可以，但是新增的不行<br>不能修改xml布局文件   不能<br>加固后的包补丁无法使用，如果要加固，需要加固前的包来生成补丁，不过这样生成的补丁也很容易破解<br>不能对同一个方法修复两次，否则App根本跑不起来<br>对加载过的补丁文件要做名字修改 如果名字重叠 就不会再次加载</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-ef8df50043de69c909b3b348173a9b0b-Image.3-627eb5.png" alt="Image.3"></p><p><strong>补丁加载的时机</strong><br>可以放在自定义Application的onCreate方法中，也可以放在button的点击事件中，也可以放在监听网络变化的广播中。<br>加载过的补丁会被保存到data&#x2F;packagename&#x2F;files&#x2F;apatch_opt目录下，所以下载过来的补丁用过一次就可以删除了。</p><p>操作：<br>通过命令生成补丁</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> -<span class="hljs-selector-tag">a</span>,<span class="hljs-attr">--alias</span> &lt;alias&gt;     keystore entry alias.<br> -e,<span class="hljs-attr">--epassword</span> &lt;\*\*\*&gt;   keystore entry password.<br> -f,<span class="hljs-attr">--from</span> &lt;loc&gt;        new Apk file path.<br> -k,<span class="hljs-attr">--keystore</span> &lt;loc&gt;    keystore path.<br> -n,<span class="hljs-attr">--name</span> &lt;name&gt;       patch name.<br> -o,<span class="hljs-attr">--out</span> &lt;dir&gt;         output dir.<br> -<span class="hljs-selector-tag">p</span>,<span class="hljs-attr">--kpassword</span> &lt;\*\*\*&gt;   keystore password.<br> -t,<span class="hljs-attr">--to</span> &lt;loc&gt;          old Apk file path.<br><br>apkpatch -f D:\\addfixUtils\\<span class="hljs-number">2</span><span class="hljs-selector-class">.apk</span> -t D:\\addfixUtils\\<span class="hljs-number">1</span><span class="hljs-selector-class">.apk</span> -o D:\\addfixUtils\\output -k D:\\addfixUtils\\key<span class="hljs-selector-class">.jks</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">000000</span> -<span class="hljs-selector-tag">a</span> liuyu -e <span class="hljs-number">000000</span><br></code></pre></td></tr></table></figure><p>其他<br>如果本地保存了多个补丁，那么AndFix会按照补丁生成的时间顺序加载补丁。具体是根据.apatch文件中的PATCH.MF的字段Created-Time。</p><p>刚开始做的demo中，每次产生的apatch文件用的名字都是相同的，结果导致只有第一次的补丁能生效。看了源码后发现只有每次名字不同才能加载，log中应该也有提示，但是没注意到。</p><p>由于原理类似dexposed,所以目前发现activity的生命周期方法中不要直接hotfix.推荐在initview&#x2F;initdata之类的方法中进行.</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-15c550c8d2ad51ca4061a52ab8968183-Image.1-fffad7.jpg" alt="Image.1"></p><p>常见问题<br><a href="http://baichuan.taobao.com/docs/doc.htm?spm=a3c0d.7629140.0.0.Tokj1O&treeId=234&articleId=105843&docType=1">http://baichuan.taobao.com/docs/doc.htm?spm=a3c0d.7629140.0.0.Tokj1O&amp;treeId=234&amp;articleId=105843&amp;docType=1</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96.resources/2023/09/15/18-49-57-4623ba0ad503b9577b793569ab28422f-Image.2-5459d7.jpg" alt="Image.2"></p><p>阿里百川<br><a href="http://www.tuicool.com/articles/viEJfeE">http://www.tuicool.com/articles/viEJfeE</a><br>主要好处是可以对补丁很好的管理，例如停止发布、继续发布、发布回滚等等</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVP MVVM</title>
    <link href="/2025/12/cf89bd963647.html"/>
    <url>/2025/12/cf89bd963647.html</url>
    
    <content type="html"><![CDATA[<h1 id="Jetpack-MVP-MVVM"><a href="#Jetpack-MVP-MVVM" class="headerlink" title="Jetpack MVP MVVM"></a>Jetpack MVP MVVM</h1><p>[[MVI学习]]</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-d7f74906a1a5c013af78bcd20d16185e-QQ%E6%88%AA%E5%9B%BE20191218104245-33c467.png" alt="QQ截图20191218104245"></p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>(Model-View-Controller)<br>M 是指逻辑层，V 是指视图层，C 则是控制器。通过 controller 的控制去操作 model 层的数据，并且返回给视图层展示。一个逻辑层可以对于多种视图层。</p><p>Android 中也可以说采用了 MVC 框架，在 Android 中： </p><ol><li>视图层（View）：一般采用 XML 文件进行界面的描述，使用的时候可以非常方便的引入，但是用 xml 编写了，又需要在 Acitvity 声明并且实例化。</li><li>控制层（Controller）：控制层的通常落在了众多的 Acitvity 的肩上，要通过 Activity 交割 Model 业务逻辑层处理，并且 activity 还充当了 view 层职责。</li><li>模型层（Model）：java bean、对数据库的操作、对网络等的操作都应该在 Model 里面处理，当然对业务计算等操作也是必须放在的该层的。</li></ol><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP 就是基于 MVC 的模式上的一个演化版本。在 MVC 模式中，Activity 应该是属于 View 这一层。而实质上，它既承担了 View，同时也包含一些 Controller 的东西在里面。随着项目的迭代更新，这对开发很不友好，耦合度也原来越高，项目越来越难维护，而 MVP 就是解决这样的痛点。</p><p>MVP 的 model 层相对于 MVC 是一样的，而 activity 和 fragment 不再是 controller 层，而是纯粹的 view 层，所有关于用户事件的转发全部交由 presenter 层处理。</p><p>代理模式，交给另一个类做功能。</p><ol><li>view 层: View 对应于 Activity 或者 fragment，负责 View 的绘制以及与用户交互</li><li>Presenter 负责完成 View 于 Model 间的交互<ul><li>本地存储数据，如数据库，文件，SharedPreferences（本质也是文件）</li><li>内存的缓存或临时数据</li><li>通过各种网络协议获取的远程数据</li></ul></li></ol><h4 id="MVP-优点"><a href="#MVP-优点" class="headerlink" title="MVP 优点"></a>MVP 优点</h4><ol><li>Model 与 View 完全分离，彻底解耦</li><li>Presenter 复用，可以将一个 Presenter 用于多个视图，而不用改变 Presenter 的逻辑</li><li>可以实现 View 接口进行逻辑测试（Presenter 的单元测试）</li></ol><h4 id="MVP-的缺点"><a href="#MVP-的缺点" class="headerlink" title="MVP 的缺点"></a>MVP 的缺点</h4><ol><li>V 层与 P 层还是有一定的耦合度。一旦 V 层某个 UI 元素更改，那么对应的接口就必须得改，数据如何映射到 UI 上、事件监听接口这些都需要转变，牵一发而动全身。如果这一层也能解耦就更好了。（其他 mvc 也可以做到，看上面的 demo）</li><li>Model 层过大，做好模块划分，进行接口隔离，在内部进行分层。</li><li>MVP 额外的增加了很多类和接口, 这个可以根据项目业务进行相应地优化。划分 v&#x2F;p 比较麻烦，一个 activity 引用了 v 以后，那得把 v 里面的方法都实现，即使没有用到.</li><li>当 View 层在退出时，如果 Model 层中仍有业务 (如子线程未完成、网络请求超时等) 没有结束，而 Presenter 层中持有 Model 层和 View 层的引用，那么即使 View 的引用已经释放，由于 Presenter 层的强引用 GC 也无法回收它们。</li></ol><p><strong>mvp 中 presenter 的内存泄漏如何解决?</strong></p><ul><li>弱引用 (WeakReference)的使用: 在 Presenter 中，避免直接持有对 View 层的强引用，而是使用 WeakReference 来代替。这样当 View 层被销毁时，WeakReference 会自动变为 null，垃圾回收器可以正常回收相应的内存。</li><li>合理管理生命周期: 在 Activity 或 Fragment 的生命周期中，适时地创建和销毁 Presenter 对象。例如，可以在 Activity 的 onCreate 方法中创建 Presenter，在 onDestroy 方法中销毁 Presenter。这样可以确保当 Activity 被销毁时，Presenter 也能被正确释放。</li><li>取消耗时任务: 如果在 Activity 中启动了耗时的任务 (如网络请求)，在 Activity 销毁时需要确保这些任务被取消。这可以通过在 Activity 的 onDestroy 方法中取消请求来实现。</li></ul><p>让所有的 Presenter 都继承 BasePresenter, 然后在 activity（onDestory ()）&#x2F;fragment（onDestoryview ()）中相应的生命周期里面调用，在相应的方法里面, 初始化, 结束异步操作, 释放资源, 将 view&#x3D;null; 而在 activity 里面, 由于 Presenter 并没有 view 的引用了, 所以 p 随着 activity 的销毁也就跟着销毁了. 不会造成泄漏等。<br>在 MVP 中 BaseActivity 中统一把请求取消掉</p><h4 id="写一个-MVP-例子"><a href="#写一个-MVP-例子" class="headerlink" title="写一个 MVP 例子"></a>写一个 MVP 例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java">       <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HomeView</span> &#123;<br>            <span class="hljs-comment">//显示加载页</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">showProgress</span><span class="hljs-params">()</span>;<br>            <span class="hljs-comment">//关闭加载页</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">hideProgress</span><span class="hljs-params">()</span>;<br>            <span class="hljs-comment">//加载新数据</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">newDatas</span><span class="hljs-params">(Book book)</span>;<br>            <span class="hljs-comment">//显示加载失败</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">showLoadFailMsg</span><span class="hljs-params">()</span>;<br>        &#125;<br>    <br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeFragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HomeView</span> &#123;<br>            <span class="hljs-keyword">private</span> HomePresenter homePresenter;<br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadData</span><span class="hljs-params">()</span> &#123;<br>                homePresenter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HomePresenter</span>(<span class="hljs-built_in">this</span>);<br>                homePresenter.getDataResults(<span class="hljs-number">1</span>);<br>            &#125;<br>    <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newDatas</span><span class="hljs-params">(Book book)</span> &#123;&#125;<br>    <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showProgress</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hideProgress</span><span class="hljs-params">()</span> &#123;&#125;<br>        &#125;<br>    <br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomePresenter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OnLoadDataListListener</span>&lt;Book&gt; &#123;<br>            <span class="hljs-keyword">private</span> HomeView mView;<br>            <span class="hljs-keyword">private</span> Model mModel;<br>    <br>            <span class="hljs-keyword">public</span> <span class="hljs-title function_">HomePresenter</span><span class="hljs-params">(HomeView mView)</span> &#123;<br>                <span class="hljs-built_in">this</span>.mView = mView;<br>                <span class="hljs-built_in">this</span>.mModel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Model</span>();<br>                mView.showProgress();<br>            &#125;<br>    <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDataResults</span><span class="hljs-params">(<span class="hljs-type">int</span> page)</span> &#123;<br>                mModel.loadData(page,<span class="hljs-built_in">this</span>);<br>            &#125;<br>    <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(Book book)</span> &#123;<br>                mView.newDatas(book);<br>                mView.hideProgress();<br>            &#125;<br>    <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable e)</span> &#123;<br>                Log.e(<span class="hljs-string">&quot;onFailure&quot;</span>,e.toString());<br>                mView.showLoadFailMsg();<br>            &#125;<br>        &#125;<br>    <br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadData</span><span class="hljs-params">(<span class="hljs-keyword">final</span> OnLoadDataListListener listener,<span class="hljs-type">int</span> page)</span> &#123;<br>                HttpData.getInstance().getHomeInfo(page,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;BOKKK&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span> <span class="hljs-params">(Throwable e)</span> &#123;<br>                        listener.onFailure (e);<br>                    &#125;<br>                    <br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResult</span> <span class="hljs-params">(Book book)</span> &#123;<br>                        listener.onSuccess (book);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br>    <br></code></pre></td></tr></table></figure><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><a href="https://tech.meituan.com/2016/11/11/android-mvvm.html">如何构建Android MVVM 应用框架 - 美团技术团队</a></p><p>官方图<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Jetpack_MVP_MVVM.resources/2023/09/18/09-57-43-91292531382e5905716b9d61adaca31b-unknown_filename.6-8672ee.png" alt="unknown_filename.6|600"></p><ul><li>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</li><li>图中所有的箭头都是单向的，比方说 Activity 指向了 ViewModel，表示》Activity 是依赖于 ViewModel 的，但是反过来 ViewModel 不能依赖于 Activity。其他的几层也是一样的道理，一个箭头就表示一个依赖关系。<br>  依赖关系是不可以跨层的，比方说 UI 控制层不能和仓库层有依赖关系，每一层的组件都只能和它的相邻层交互。</li></ul><p>由于 livedata 当更新 viewmodel 层的数据的时候，view 层会相应的变动 ui。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">UserModel model = ViewModelProviders.of (<span class="hljs-keyword">this</span>). <span class="hljs-keyword">get</span> (UserModel. <span class="hljs-keyword">class</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVI学习</title>
    <link href="/2025/12/35c15b4003bd.html"/>
    <url>/2025/12/35c15b4003bd.html</url>
    
    <content type="html"><![CDATA[<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>[[4.Flow学习]]</p><p><a href="https://juejin.cn/post/7022624191723601928">MVVM 进阶版：MVI 架构了解一下</a></p><p><a href="https://juejin.cn/post/7025222741322121223">MVI 架构更佳实践：Mavericks</a></p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/MVI%E5%AD%A6%E4%B9%A0.resources/2023/09/15/17-54-24-7256f73dfbc44cf9009a4e36bb0dc56f-unknown_filename.2-20144d.png" alt="unknown_filename.2|600"></p><p>MVI 是在响应式编程的前提下，通过 “将页面状态聚合” 来统一消除上述 2 个问题，<br>也即原先分散在各个 LiveData 中的 String、Boolean 等状态，<em>现全部聚合到一个 JavaBean &#x2F; data class 中</em>，由唯一的粘性观察者回推，所有控件都在该观察者中响应数据的变化。</p><p>MVI 架构为了解决 MVVM 在逻辑复杂时需要写多个 LiveData (可变+不可变) 的问题,<em>使用 ViewState 对 State 集中管理</em>，只需要订阅一个 ViewState 便可获取页面的所有状态</p><p>通过集中管理 ViewState，只需对外暴露一个 LiveData，解决了 MVVM 模式下 LiveData 膨胀的问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义ViewState类</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterViewState</span>(<span class="hljs-keyword">val</span> count: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure><p>但页面的所有状态都通过一个 LiveData 来管理，也带来了一个严重的问题，即页面不支持局部刷新</p><p>虽说如果是 RecyclerView 可以通过 DifferUtil 来解决，但毕竟不是所有页面都是通过 RecyclerView 写的，支持 DifferUtil 也有一定的开发成本</p><p>因此直接使用 MVI 架构会带来一定的性能损耗，相信这是很多人不愿意用 MVI 架构的原因之一</p><h3 id="MVI"><a href="#MVI" class="headerlink" title="MVI"></a>MVI</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/MVI%E5%AD%A6%E4%B9%A0.resources/2023/09/15/17-54-24-11967c835f0c1b4f07e6b4685c4b2024-unknown_filename-5f81eb.png" alt="unknown_filename|500"><br>由于没有明确的状态管理标准，随着应用程序的增长或添加功能或事先没有计划的功能，视图渲染和业务逻辑可能会变得有点混乱，并且这种情况经常发生在 Android 应用开发过程中。可能你经常遇到状态管理导致<strong>业务逻辑和 UI 渲染的分工不明确</strong>，最终导致应用架构的混乱。而新提出的 MVI 架构，提倡一种单向数据流的设计思想，非常适合数据驱动型的 UI 展示项目。MVI 的架构思想来源于前端，由于 Model、View 和 Intent 三部分组成。</p><p><strong>Model</strong>: 与其他 MVVM 中的 Model 不同的是，MVI 的 Model 主要指 UI 状态（State）。当前界面展示的内容无非就是 UI 状态的一个快照：例如数据加载过程、控件位置等都是一种 UI 状态<br><strong>View</strong>: 与 MVvM 中的 View 一致，可能是一个 Activity、Fragment 或者任意 UI 承载单元。MVI 中的 View 通过订阅 Intent 的变化实现界面刷新<br><strong>Intent</strong>: 此 Intent 不是 Activity 的 Intent，<em>用户的任何操作都被包装成 Intent 后发送给 Model 进行数据请求</em></p><p>运用函数式编程思想将需求翻译成业务意图（I）、数据（M）、界面状态（V）间的函数关系，再用响应式编程的方式将其串联成数据流的过程。</p><p>个人感觉 mvi 和 mvvm 的区别就是 mvi 把 viewmodel 的方法改成了一个来统一处理，通过它的参数 intent 来区分不同调用。v 层也是一样，原来每个业务都有自己的 livedata，v 层需要对每一个 livedata 单独监听。<em>如果使用 mvi 只需要使用一个 livedata 就可以了，利用 state 来区分不同的业务</em>。</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>&#x3D;&#x3D;MVI 强调数据的单向流动，主要分为以下几步&#x3D;&#x3D;</p><p>&#x3D;&#x3D;Intent 和 action 类似&#x3D;&#x3D;</p><ol><li>用户操作以 <code>Intent</code> 的形式通知 <code>Model</code></li><li><code>Model</code> 基于 <code>Intent</code> 更新 <code>State</code></li><li><code>View</code> 接收到 <code>State</code> 变化刷新 UI。<br>数据永远在一个环形结构中单向流动，不能反向流动</li></ol><p>我们使用 <code>ViewModel</code> 来承载 <code>MVI</code> 的 <code>Model</code> 层，总体结构也与 <code>MVVM</code> 类似, 主要区别在于 <code>Model</code> 与 <code>View</code> 层交互的部分</p><ol><li><code>Model</code> 层承载 <code>UI</code> 状态，并暴露出 <code>ViewState</code> 供 <code>View</code> 订阅，<code>ViewState</code> 是个 <code>data class</code>,包含所有页面状态</li><li><code>View</code> 层通过 <code>Action</code> 更新 <code>ViewState</code>，替代 <code>MVVM</code> 通过调用 <code>ViewModel</code> 方法交互的方式。（Action 可以理解成 intent）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-23-14-44-12801848c8e876fb0db0401a8f990c97-20240123144421-1c2e73.png" alt="image.png|600"></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>大型页面使用，很多 liveData, 一俩个 liveData 不需要 MVi</li><li>用户的任何操作都被包装成 Intent 发送给 Model 进行数据请求</li></ul><p>大方向流程：</p><ol><li>view 点击调 viewModle 方法，把 intent（意图）发过去</li><li>通过 intent 更新 state（Model）</li><li>view 接收到 <code>State</code> 变化刷新 UI。</li></ol><p>Action 这一层可以加也可以不加, <code>Mavericks</code> 中 <code>View</code> 层与 <code>Model</code> 层的交互，也并没有包装成 <code>Action</code>，而是直接暴露的方法<br>上篇文章也的确有很多同学说使用 <code>Action</code> 交互比较麻烦，看起来 <code>Action</code> 这层的确可要可不要</p><p><a href="https://juejin.cn/post/7289662055183155235?utm_source=gold_browser_extension">尘埃落地 😛 遍历全网Android-MVI架构，学习总结一波 - 掘金</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span></span> &#123;<br>        fabStar.setOnClickListener &#123;<br>            viewModel.dispatch(MainViewAction.FabClicked)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainViewModel</span> : <span class="hljs-type">ViewModel</span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(action: <span class="hljs-type">MainViewAction</span>)</span></span> =<br>        reduce(viewStates.value, action)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reduce</span><span class="hljs-params">(state: <span class="hljs-type">MainViewState</span>?, viewAction: <span class="hljs-type">MainViewAction</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (viewAction) &#123;<br>            <span class="hljs-keyword">is</span> MainViewAction.NewsItemClicked -&gt; newsItemClicked(viewAction.newsItem)<br>            MainViewAction.FabClicked -&gt; fabClicked()<br>            MainViewAction.OnSwipeRefresh -&gt; fetchNews(state)<br>            MainViewAction.FetchNews -&gt; fetchNews(state)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>View</code> 通过 <code>Action</code> 与 <code>ViewModel</code> 交互，通过 <code>Action</code> 通信，有利于 <code>View</code> 与 <code>ViewModel</code> 之间的进一步解耦，同时所有调用以 <code>Action</code> 的形式汇总到一处，也有利于对行为的集中分析和监控</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><code>MVI</code> 也有一些缺点，比如</p><ol><li>所有的操作最终都会转换成 <code>State</code>，所以当复杂页面的 <code>State</code> 容易膨胀</li><li><code>state</code> 是不变的，因此每当 <code>state</code> 需要更新时都要创建新对象替代老对象，这会带来一定内存开销</li></ol><p>软件开发中没有银弹，所有架构都不是完美的，有自己的适用场景, 读者可根据自己的需求选择使用。</p><ul><li>使用 <code>ViewState</code> 对 <code>State</code> 集中管理，只需要订阅一个 <code>ViewState</code> 便可获取页面的所有状态  </li><li>通过集中管理 <code>ViewState</code>，只需对外暴露一个 <code>LiveData</code>，解决了 <code>MVVM</code> 模式下 <code>LiveData</code> 膨胀的问题</li></ul><p>但页面的所有状态都通过一个 <code>LiveData</code> 来管理，也带来了一个严重的问题，即<strong>页面不支持局部刷新</strong><br>虽说如果是 <code>RecyclerView</code> 可以通过 <code>DifferUtil</code> 来解决，但毕竟不是所有页面都是通过 <code>RecyclerView</code> 写的，支持 <code>DifferUtil</code> 也有一定的开发成本<br>因此直接使用 <code>MVI</code> 架构会带来一定的性能损耗，相信这是很多人不愿意用 <code>MVI</code> 架构的原因之一</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _viewStates<span class="hljs-operator">:</span> MutableLiveData<span class="hljs-operator">&lt;</span>MainViewState<span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span> MutableLiveData() <br><span class="hljs-keyword">val</span> viewStates <span class="hljs-operator">=</span> _viewStates.asLiveData()<br></code></pre></td></tr></table></figure><p>这段代码是在使用 MVI（Model-View-Intent）架构模式时常见的一种写法。</p><p>首先，<code>_viewStates</code> 是一个私有的 <code>MutableLiveData</code> 对象，用于保存界面的状态。<code>MutableLiveData</code> 是 Android Jetpack 中的一个组件，用于在组件之间进行数据通信。</p><p>接着，<code>viewStates</code> 是一个公开的只读属性，它通过调用 <code>_viewStates</code> 的 <code>asLiveData()</code> 方法返回一个不可变的 <code>LiveData</code> 对象。<code>LiveData</code> 是一个被观察的数据持有者，可以通知观察者有关数据的变化。</p><p>在 MVI 架构中，<code>viewStates</code> 属性通常用于将界面的状态暴露给视图层（View Layer）。通过观察 <code>viewStates</code> 属性，视图层可以及时地获取最新的界面状态，并相应地更新用户界面。</p><p>为什么要使用这样的写法呢？MVI 架构的一个关键思想是<em>单向数据流，即将界面的状态作为单一的源头</em>，通过派发意图（Intents）和处理器（Reducers）来改变状态。通过将 <code>_viewStates</code> 声明为私有的 <code>MutableLiveData</code>，可以确保只有该类内部才能修改界面状态，而外部只能观察状态的变化。</p><p>此外，将 <code>_viewStates</code> 转换为不可变的 <code>LiveData</code> 对象可以保护数据的封装性，防止外部组件直接修改内部状态。</p><p>总结起来，这段代码的作用是在 MVI 架构中定义一个用于保存界面状态的私有 <code>MutableLiveData</code> 对象 <code>_viewStates</code>，并通过公开的只读属性 <code>viewStates</code> 将其暴露给视图层。这样可以确保界面状态的封装性和单向数据流的规范性。</p><h2 id="密封类-sealed"><a href="#密封类-sealed" class="headerlink" title="密封类 sealed"></a>密封类 sealed</h2><p><em>Kotlin 中的 sealed 类是一种特殊类型的类，用于限制继承关系</em>。当一个类被声明为 sealed 类时，它只能被其所在文件中的类继承，这意味着你无法在其他文件中继承它。</p><p>sealed 类常用于建模一组有限的类型，比如表示某个状态或者某个特定类型的集合。通过将这些相关的类型定义为 sealed 类的子类，可以在编译期间对所有可能的类型进行静态检查。</p><p>sealed 类与普通类的区别在于，必须将其所有可能的子类定义在同一文件中，且这些子类必须是 sealed 类的直接子类。这样做的好处是，在编译器能够检查出所有可能的子类，并且可以在 when 表达式中使用密封类作为分支条件，而不需要添加 else 分支。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> (<span class="hljs-keyword">val</span> message: String) : Result ()<br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span> (<span class="hljs-keyword">val</span> code: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> message: String) : Result ()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processResult</span> <span class="hljs-params">(result: <span class="hljs-type">Result</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (result) &#123;<br>        <span class="hljs-keyword">is</span> Success -&gt; println (<span class="hljs-string">&quot;Success: <span class="hljs-subst">$&#123;result. message&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">is</span> Error -&gt; println (<span class="hljs-string">&quot;Error: <span class="hljs-subst">$&#123;result. code&#125;</span> - <span class="hljs-subst">$&#123;result. message&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> success = Success (<span class="hljs-string">&quot;Operation completed successfully&quot;</span>)<br><span class="hljs-keyword">val</span> error = Error (<span class="hljs-number">404</span>, <span class="hljs-string">&quot;Resource not found&quot;</span>)<br><br>processResult (success)<br>processResult (error)<br><br></code></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个 sealed 类 Result，并将它的两个可能的子类 Success 和 Error 定义在同一文件中。然后我们编写了一个函数 processResult，根据传入的 Result 对象进行处理。通过使用 when 表达式，我们能够对 Result 类型的不同子类进行分支处理。</p><p>总而言之，Kotlin 中的 sealed 类提供了一种方便的方式来建模有限类型集合，并在编译期间进行类型检查，使代码更加安全和可靠。</p><hr><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面是 chatGPT 给的例子</p><h3 id="1-创建一个-Model-类："><a href="#1-创建一个-Model-类：" class="headerlink" title="1. 创建一个 Model 类："></a>1. 创建一个 Model 类：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">data <span class="hljs-keyword">class</span> <span class="hljs-symbol">CounterModel</span> (<span class="hljs-symbol">val</span> <span class="hljs-symbol">count: <span class="hljs-symbol">Int</span></span>)<br></code></pre></td></tr></table></figure><h3 id="2-创建一个-Intent-类："><a href="#2-创建一个-Intent-类：" class="headerlink" title="2. 创建一个 Intent 类："></a>2. 创建一个 Intent 类：</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterIntent</span> &#123;<br>    <span class="hljs-keyword">object</span> IncrementIntent : CounterIntent ()<br>    <span class="hljs-keyword">object</span> DecrementIntent : CounterIntent ()<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-创建一个-ViewState-类："><a href="#3-创建一个-ViewState-类：" class="headerlink" title="3. 创建一个 ViewState 类："></a>3. 创建一个 ViewState 类：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">data <span class="hljs-keyword">class</span> <span class="hljs-symbol">CounterViewState</span> (<span class="hljs-symbol">val</span> <span class="hljs-symbol">count: <span class="hljs-symbol">Int</span></span>)<br><br></code></pre></td></tr></table></figure><h3 id="4-创建一个-ViewModel-类："><a href="#4-创建一个-ViewModel-类：" class="headerlink" title="4. 创建一个 ViewModel 类："></a>4. 创建一个 ViewModel 类：</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterViewModel</span> : <span class="hljs-type">ViewModel</span> () &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableLiveData&lt;CounterViewState&gt;()<br>    <span class="hljs-keyword">val</span> state: LiveData&lt;CounterViewState&gt;<br>        <span class="hljs-keyword">get</span> () = _state<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        _state. value = CounterViewState (<span class="hljs-number">0</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processIntent</span> <span class="hljs-params">(intent: <span class="hljs-type">CounterIntent</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> currentState = _state. value ?: CounterViewState (<span class="hljs-number">0</span>)<br><br>        <span class="hljs-keyword">when</span> (intent) &#123;<br>            <span class="hljs-keyword">is</span> CounterIntent. IncrementIntent -&gt; &#123;<br>                _state. value = currentState.copy (count = currentState. count + <span class="hljs-number">1</span>)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CounterIntent. DecrementIntent -&gt; &#123;<br>                _state. value = currentState.copy (count = currentState. count - <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-在-Activity-或-Fragment-中使用-ViewModel："><a href="#5-在-Activity-或-Fragment-中使用-ViewModel：" class="headerlink" title="5. 在 Activity 或 Fragment 中使用 ViewModel："></a>5. 在 Activity 或 Fragment 中使用 ViewModel：</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pf">class CounterActivity : AppCompatActivity () &#123;<br><br>    private lateinit var viewModel: CounterViewModel<br><br>    override fun <span class="hljs-keyword">on</span>Create (savedInstanceState: Bundle?) &#123;<br>        super.<span class="hljs-keyword">on</span>Create (savedInstanceState)<br>        <span class="hljs-built_in">set</span>ContentView (R.layout. activity_counter)<br><br>        viewModel = ViewModelProvider (this). get (CounterViewModel:: class. java)<br><br>        viewModel.<span class="hljs-keyword">state</span>.observe (this, Observer &#123; <span class="hljs-keyword">state</span> -&gt;<br>            render (<span class="hljs-keyword">state</span>)<br>        &#125;)<br><br>        buttonIncrement. <span class="hljs-built_in">set</span>OnClickListener &#123;<br>            viewModel.processIntent (CounterIntent. IncrementIntent)<br>        &#125;<br><br>        buttonDecrement. <span class="hljs-built_in">set</span>OnClickListener &#123;<br>            viewModel.processIntent (CounterIntent. DecrementIntent)<br>        &#125;<br>    &#125;<br><br>    private fun render (<span class="hljs-keyword">state</span>: CounterViewState) &#123;<br>        textViewCount. text = <span class="hljs-keyword">state</span>.count.<span class="hljs-keyword">to</span>String ()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用了 ViewModel 来处理业务逻辑和状态管理，同时使用 LiveData 来观察状态的变化。通过定义 Model、Intent、ViewState 来区分数据模型、用户操作意图、界面状态，实现了简单的 MVI 架构。希望这个例子能帮助你更好地理解如何在 Android 应用中使用 MVI 架构。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LiveData、ViewModel</title>
    <link href="/2025/12/242ac5540d80.html"/>
    <url>/2025/12/242ac5540d80.html</url>
    
    <content type="html"><![CDATA[<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><ul><li><strong>职责分离</strong>：让UI组件（Activity&#x2F;Fragment）专注于数据展示，而数据获取和状态管理由ViewModel负责。</li><li><strong>状态保留</strong>：在配置更改（如旋转屏幕）时自动保留数据，无需开发者手动处理。但是当用户按返回键退出 Activity 或系统回收资源时， ViewModel 会<strong>随 Activity 一起销毁</strong></li><li><strong>数据共享</strong>：同一Activity内的多个Fragment可通过ViewModel轻松共享数据。如果多个 activity 共享的话创建 Application 级别的 ViewModel，不推荐</li><li><strong>资源清理</strong>：通过重写<code>onCleared()</code>可集中释放资源，避免内存泄漏。</li><li><strong>测试友好</strong>：分离的业务逻辑使单元测试更简单、更聚焦。</li></ul></blockquote><p><a href="https://juejin.cn/post/7009911778968616968">MvvM封装</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre><code class="hljs">UserModel model = ViewModelProviders.of (this). get (UserModel. class);</code></pre><ul><li>使用 ViewModelProvider 的 get（）方法来获取作为参数传入的 ViewModel 类型的实例。 </li><li>先从尝试从ViewModelStore 取，<em>ViewModel 存储在 ViewModelStore 的 HasHmap 中</em>。</li></ul><ul><li>如果没取到，通过ViewModelProviders create 反射创建 ViewModel</li><li>最近把创建的 ViewModel 保存在 ViewModelStore 里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewModel</span>&gt; T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">canonicalName</span> <span class="hljs-operator">=</span> modelClass.getCanonicalName();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> DEFAULT_KEY + <span class="hljs-string">&quot;:&quot;</span> + canonicalName;<br>    <br>    <span class="hljs-comment">// 1. 尝试从缓存获取</span><br>    <span class="hljs-type">ViewModel</span> <span class="hljs-variable">viewModel</span> <span class="hljs-operator">=</span> mViewModelStore.get(key);<br>    <br>    <span class="hljs-keyword">if</span> (modelClass.isInstance(viewModel)) &#123;<br>        <span class="hljs-keyword">return</span> (T) viewModel;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 通过Factory创建新实例</span><br>    <span class="hljs-keyword">if</span> (mFactory <span class="hljs-keyword">instanceof</span> KeyedFactory) &#123;<br>        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        viewModel = mFactory.create(modelClass);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 存储并返回</span><br>    mViewModelStore.put(key, viewModel);<br>    <span class="hljs-keyword">return</span> (T) viewModel;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ViewModelProvider 传 activity 的原因是</strong><br>没有绑定 activity 的生命周期。</p><ul><li>每个 activity 都有一个 ViewModelStore，ViewModelStore 里 HashMap&lt;String, ViewModel&gt; mMap，key 是自己 viewmodel 的名字，值是自己 viewmodel 的 class 类。</li></ul><p><strong>clear 什么时候执行</strong></p><ul><li>在 ComponentActivity 创建的时候，ViewModelStore 进行了生命周期的绑定工作， onDestroy () ，遍历调用所有的 ViewMode调用了 clear () 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">    getLifecycle().addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleEventObserver</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStateChanged</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LifecycleOwner source,</span><br><span class="hljs-params">                        <span class="hljs-meta">@NonNull</span> Lifecycle.Event event)</span> &#123;<br>                    <span class="hljs-keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;<br>                        <span class="hljs-comment">// 只有是正常的onDestory才能clear掉ViewModelStore</span><br>                        <span class="hljs-keyword">if</span> (!isChangingConfigurations()) &#123;<br>                            <span class="hljs-comment">// 执行流程ViewmodelStore.clear --&gt; ViewModel.clear --&gt; ViewModel.OnClear</span><br>                            getViewModelStore().clear();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>ViewModelStore<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">for</span> (ViewModel vm : mMap.values()) &#123;<br>          vm.clear();<br>      &#125;<br>      mMap.clear();<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>没有持有 view 的引用，要不然用 livedata 干啥</strong><br>ViewModel 不应该直接引用 Views 的原因; 它们可以比 View 的生命周期更长久<br>ViewModel 不能持有 activity，fragment 等 view 的引用，避免内存泄漏。他可以获取到 application 的 context</p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul><li><strong>不要持有 UI 引用</strong>：class LeakyViewModel(activity: Activity) : ViewModel()</li><li>多个 Activity 或 Fragment 之间的数据共享: 当需要在多个 Activity 或 Fragment 之间共享数据时，使用 ViewModel 可以方便地实现这目标。但是，需要注意传递数据的正确性，避免出现数据不一致的情况。</li><li>状态保存和恢复: 在使用 ViewModel 时，需要注意保存和恢复数据的状态。如果数据丢失，可能会导致用户界面出现问题。因此，需要适当地使用 ViewModel 来保存和恢复数据。</li></ul><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>2.0之后，其实是用到了 Activity 的 onRetainNonConfigurationInstance () 和 getLastNonConfigurationInstance () 这两个方法<br>在横竖屏切换 onRetainNonConfigurationInstance 保存 ViewModel 的实例，然后 getViewModelStore 发现有保存的就恢复</p><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">onRetainNonConfigurationInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1. 获取自定义保留对象（向后兼容旧API）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">custom</span> <span class="hljs-operator">=</span> onRetainCustomNonConfigurationInstance();<br><br>    <span class="hljs-comment">// 2. 获取当前ViewModelStore</span><br>    <span class="hljs-type">ViewModelStore</span> <span class="hljs-variable">viewModelStore</span> <span class="hljs-operator">=</span> mViewModelStore;<br>    <br>    <span class="hljs-comment">// 3. 处理尚未初始化的ViewModelStore情况</span><br>    <span class="hljs-keyword">if</span> (viewModelStore == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 尝试从上次配置变更的保留实例中获取</span><br>        <span class="hljs-type">NonConfigurationInstances</span> <span class="hljs-variable">nc</span> <span class="hljs-operator">=</span><br>                (NonConfigurationInstances) getLastNonConfigurationInstance();<br>        <span class="hljs-keyword">if</span> (nc != <span class="hljs-literal">null</span>) &#123;<br>            viewModelStore = nc.viewModelStore;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 判断是否需要创建保留实例</span><br>    <span class="hljs-keyword">if</span> (viewModelStore == <span class="hljs-literal">null</span> &amp;&amp; custom == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 无需保留任何内容</span><br>    &#125;<br><br>    <span class="hljs-comment">// 5. 创建新的保留实例容器</span><br>    <span class="hljs-type">NonConfigurationInstances</span> <span class="hljs-variable">nci</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonConfigurationInstances</span>();<br>    nci.custom = custom;<br>    nci.viewModelStore = viewModelStore;<br>    <br>    <span class="hljs-keyword">return</span> nci; <span class="hljs-comment">// 返回保留的实例</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>ComponentActivity  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 getViewModelStore() 方法中</span><br><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title function_">getViewModelStore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mViewModelStore == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 尝试从保留实例恢复</span><br>        <span class="hljs-type">NonConfigurationInstances</span> <span class="hljs-variable">nc</span> <span class="hljs-operator">=</span><br>            (NonConfigurationInstances) getLastNonConfigurationInstance();<br>        <span class="hljs-keyword">if</span> (nc != <span class="hljs-literal">null</span>) &#123;<br>            mViewModelStore = nc.viewModelStore; <span class="hljs-comment">// 关键恢复点</span><br>        &#125;<br>        <span class="hljs-comment">// 如果没有则创建新的</span><br>        <span class="hljs-keyword">if</span> (mViewModelStore == <span class="hljs-literal">null</span>) &#123;<br>            mViewModelStore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewModelStore</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mViewModelStore;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ViewModel 还提供了以下方法来帮助开发者保存状态：</strong></p><ul><li>**onSaveInstanceState ()**：该方法用于保存 ViewModel 的临时状态数据。</li><li>**onRestoreInstanceState ()**：该方法用于恢复 ViewModel 的临时状态数据。</li></ul><h4 id="SavedStateHandle"><a href="#SavedStateHandle" class="headerlink" title="SavedStateHandle"></a>SavedStateHandle</h4><p>SavedStateHandle 是一个类，它用于保存 ViewModel 的状态数据。SavedStateHandle 可以保存任何可序列化类型的数据，例如基本类型、String、List、Map 等。<br>需要开发者手动调用 <code>savedStateHandle.set()</code> 方法进行保存。<br>原因如下：</p><ul><li><strong>灵活性</strong>: 自动保存所有数据可能会导致不必要的开销，因为并非所有数据都需要持久保存。例如，一些临时数据可能只在当前界面中使用，不需要保存到 Bundle 中。</li><li><strong>控制力</strong>: 手动保存数据可以让开发者更好地控制保存哪些数据以及何时保存数据。例如，开发者可以选择在特定条件下才保存数据，或者只保存部分数据。</li></ul><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>一句话概括 LiveData：LiveData 是可感知生命周期的，可观察的数据持有者。作用就是更新 UI。<br>它有一些可以被认为是优点的特性：</p><ul><li><strong>观察者的回调永远发生在主线程</strong> 也是缺点，setValue 主线程中调用，子线程 postValue。</li><li><strong>仅持有单个且最新的数据</strong></li><li>自动取消订阅</li><li>提供「可读可写」和「仅可读」两个版本收缩权限</li><li>配合 DataBinding 实现「双向绑定」</li></ul><p><a href="https://juejin.cn/post/7007602776502960165?utm_source=gold_browser_extension#comment">不做跟风党，LiveData，StateFlow，SharedFlow 使用场景对比 - 掘金</a></p><p><strong>监听 Acitivty 生命周期可以这样写</strong><br>实现：DefaultLifecycleObserver<br>注册：getLifecycle (). addObserver (GpsManager. getInstance)</p><p>LiveData 是一个可被观察的数据持有者类，它只<em>有在 STARTED 或者 RESUMED 状态时才会被激活，在 DESTROYED 状态时，会自动 removeObserver ()</em><br>有一种情况下，不会自动 removeObserver ()：当你调用 observeForever ()方法的时候，你需要手动去调用 removeObserver()方法。</p><h3 id="LiveData-的优点"><a href="#LiveData-的优点" class="headerlink" title="LiveData 的优点"></a>LiveData 的优点</h3><p>LiveData 的优点是具备生命周期感知，自动管理 Observer，避免内存泄漏。</p><p>防泄漏：当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。<br>防崩溃：当 Activity 处于后台状态时，是不会收到 LiveData 的任何事件的。当某个页面请求网络数据成功后需要同步 UI, 但这个页面已经不可见, 这时就会停止同步 UI 的操作</p><blockquote><p>一条消息能被多个观察者消费，多个页面公用 liveDta, 实现多个页面数据的同时监听</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlayLiveData</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前播放进度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">progressLiveData</span> <span class="hljs-operator">=</span> MutableLiveData&lt;ProgressBean&gt;()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 播放模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">playModeLiveData</span> <span class="hljs-operator">=</span> MutableLiveData&lt;Int&gt;()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">resetLiveData</span> <span class="hljs-operator">=</span> MutableLiveData&lt;Int&gt;()<br><br>&#125;<br>PlayerManager： <span class="hljs-type">val</span> <span class="hljs-variable">playLiveData</span> <span class="hljs-operator">=</span> PlayLiveData ()<br><br>  PlayerManager.instance.playLiveData.progressLiveData.observe (<span class="hljs-built_in">this</span>, Observer &#123;<br>            playVM?.setProgress (it)<br>        &#125;)<br></code></pre></td></tr></table></figure><blockquote><p>需要生命周期的工具类，更加内聚</p></blockquote><p><a href="https://juejin.cn/post/6844903976240939021">是让人耳目一新的 Jetpack MVVM 精讲啊！</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/LiveData%E3%80%81ViewModel.resources/2023/09/18/09-58-30-fb520e7d716dd6db26fc8fe33fdb38d2-unknown_filename.4-0a851c.png" alt="unknown_filename.4|700"></p><h3 id="LiveData-的缺点"><a href="#LiveData-的缺点" class="headerlink" title="LiveData 的缺点"></a>LiveData 的缺点</h3><ul><li>LiveData 只能在主线程更新数据： 只能在主线程 setValue，即使 postValue 内部也是切换到主线程执行</li><li>LiveData 不防抖： <em>重复 setValue 相同的值，订阅者会收到多次 onChanged</em> () 回调（可以使用 distinctUntilChanged () 解决，此处不展开）；</li><li>LiveData 不支持背压： <em>在数据生产速度 &gt; 数据消费速度时，中间的数据会忽略</em>。比如在子线程大量 <strong>postValue</strong> 数据但主线程消费跟不上时，中间就会有一部分数据被忽略。</li><li>LiveData 数据重放问题（粘性）： <em>注册新的订阅者，会重新收到 LiveData 存储的数据</em>，这在有些情况下不符合预期（可以使用自定义的 LiveData 子类 SingleLiveData 或 UnPeekLiveData 解决）</li></ul><h4 id="不防抖"><a href="#不防抖" class="headerlink" title="不防抖"></a>不防抖</h4><p><code>setValue()/postValue()</code> 传入相同的值多次调用，观察者的 <code>onChanged()</code> 会被多次调用。</p><p>严格讲这不算一个问题，看具体的业务场景，处理也很容易，官方在 <code>Transformations</code> 中提供了 <code>distinctUntilChanged()</code> 方法，配合官方提供的扩展函数，如下使用即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span> <span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>  <span class="hljs-keyword">super</span>.onViewCreated (view, savedInstanceState)<br><br>  viewModel.headerText.distinctUntilChanged().observe(viewLifecycleOwner) &#123;<br>    header.text = it<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="粘性事件"><a href="#粘性事件" class="headerlink" title="粘性事件"></a>粘性事件</h4><p><a href="https://www.jianshu.com/p/79d909b6f8bd">如何优雅的使用LiveData实现一套EventBus（事件总线） - 简书</a></p><p>设计成了黏性事件，发送事件后在订阅也可以收到消息。<br>原因：LiveData setValue 的时候里面有个 mVersion，然后+1，当观察者注册时（<code>considerNotify()</code>） 会判断，观察者的 <code>mLastVersion</code> 默认为 <code>-1</code>，满足 <code>mLastVersion &lt; mVersion</code> 条件，发现版本号落后，立即调用 <code>onChanged()</code> ，所以订阅者会马上收到订阅之前发布的最新消息</p><p><a href="https://juejin.cn/post/6844903997921296397#heading-10">Android 使用 LiveData 实现 EventBus - 掘金</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span> <span class="hljs-params">(T value)</span> &#123;<br>    assertMainThread (<span class="hljs-string">&quot;setValue&quot;</span>);<br>    <span class="hljs-comment">// 发送版本+1</span><br>    mVersion++;<br>    mData = value;<br>    <span class="hljs-comment">// 信息分发</span><br>    dispatchingValue (<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>记住这里的 mVersion，它本问题关键，每次更新数据都会自增，默认值是 -1</strong>。然后我们跟进下 dispatchingValue () 方法：</p><p>mDispatchingValue 的判断主要是为了解决并发调用 dispatchingValue 的情况，当对应数据的观察者在执行的过程中, 如有新的数据变更, 则不会再次通知到观察者，所以观察者内的执行不应进行耗时工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchingValue</span> <span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;<br> <br>        <span class="hljs-keyword">if</span> (mDispatchingValue) &#123;<br>            mDispatchInvalidated = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mDispatchingValue = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            mDispatchInvalidated = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (initiator != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">// 这里</span><br>                considerNotify (initiator);<br>                initiator = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="hljs-built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =<br>                        mObservers.iteratorWithAdditions (); iterator.hasNext (); ) &#123;<br>                  <span class="hljs-comment">// 这里</span><br>                    considerNotify (iterator.next (). getValue ());<br>                    <span class="hljs-keyword">if</span> (mDispatchInvalidated) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (mDispatchInvalidated);<br>        mDispatchingValue = <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p>可以看到，无论条件判断，最终都会执行 considerNotify () 方法，所以我们继续跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">considerNotify</span> <span class="hljs-params">(ObserverWrapper observer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (! observer. mActive) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (! observer.shouldBeActive ()) &#123;<br>            observer.activeStateChanged (<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>  <span class="hljs-comment">// 判断 version</span><br>        <span class="hljs-keyword">if</span> (observer. mLastVersion &gt;= mVersion) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        observer. mLastVersion = mVersion;<br>        <span class="hljs-comment">//noinspection unchecked</span><br>        observer.mObserver.onChanged ((T) mData);<br>    &#125;<br></code></pre></td></tr></table></figure><p>终于到了最关键的时候了！！<strong>如果 ObserverWrapper 的 mLastVersion 小于 LiveData 的 mVersion</strong>，那么就会执行的 onChange () 方法去通知观察者数据已更新。</p><p>而 ObserverWrapper. mLastVersion 的默认值是 -1， <em>LiveData 只要更新过数据，mVersion 就肯定会大于 -1</em>，所以订阅者会马上收到订阅之前发布的最新消息！！</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol><li>反射：<a href="https://link.juejin.cn/?target=https://tech.meituan.com/2018/07/26/android-livedatabus.html" title=" https://tech.meituan.com/2018/07/26/android-livedatabus.html">Android 消息总线的演进之路：用 LiveDataBus 替代 RxBus、EventBus</a> 使用的反射的方式修改 <strong>LiveData 中的 mVersion 值</strong>去实现。</li><li>包装类： <a href="https://juejin.cn/post/6844903949267386376#comment" title=" https://juejin.cn/post/6844903949267386376#comment">基于 LiveData 实现事件总线思路和方案</a>，此方案是基于自定义观察者包装类，因为粘性消息最终会调用到 Observer onChange () 方法，因此我们自定义 Observer 包装类，自己维护实际的订阅消息数，来判断是否需要触发真正的 onChange () 方法。</li></ol><h5 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h5><p>自定义 Observer，mLastVersion 默认就直接等于 LiveData 的 version</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">internal open <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExternalObserverWrapper</span>&lt;T&gt;(val observer: Observer&lt;in T&gt;, val liveData: ExternalLiveData&lt;T&gt;): Observer&lt;T&gt;&#123;<br>    <span class="hljs-comment">// 新建观察者包装类的时候, 内部实际的 version 直接等于 LiveData 的 version</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">var</span> <span class="hljs-variable">mLastVersion</span> <span class="hljs-operator">=</span> liveData. version<br>    override fun <span class="hljs-title function_">onChanged</span> <span class="hljs-params">(t: T)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mLastVersion &gt;= liveData. version)&#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        mLastVersion = liveData. version<br>        observer.onChanged (t)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="只接收一次"><a href="#只接收一次" class="headerlink" title="只接收一次"></a>只接收一次</h4><p>如果在多线程中同一个时刻，多次调用了 postValue () 方法，&#x3D;&#x3D;只有最后次调用的值会得到更新&#x3D;&#x3D;。也就是此方法是有可能会丢失事件！！</p><p> 设计原因：为了兼顾性能，<strong>UI 只需显示最终状态即可，省略中间态造成的频发刷新</strong>。这或许是设计目的之一，但是一个更为合理的解释是：<strong>即使 post 多次也没有意义，所以只 post 一次即可</strong></p><p>源码：</p><ol><li>postValue 只是把传进来的数据先存到 mPendingData，不保留中间值，后写入的值直接覆盖前值</li><li>当无待处理值时创建新任务，才 post 数据</li></ol><p>解决方案：<em>重写 postValue 方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">mPostValueRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span> () &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>        Object newValue;<br>        <span class="hljs-keyword">synchronized</span> (mDataLock) &#123;<br>            newValue = mPendingData;<br>          <span class="hljs-comment">// 设置 mPendingData 为 not_set，重置状态</span><br>            mPendingData = NOT_SET;<br>        &#125;<br>        setValue ((T) newValue);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postValue</span> <span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">boolean</span> postTask;<br>    <span class="hljs-keyword">synchronized</span> (mDataLock) &#123;<br>      <span class="hljs-comment">// 判断 postTask 是否为 not_set</span><br>        postTask = mPendingData == NOT_SET;<br>        mPendingData = value;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (! postTask) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ArchTaskExecutor.getInstance (). postToMainThread (mPostValueRunnable);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LiveData-源码"><a href="#LiveData-源码" class="headerlink" title="LiveData 源码"></a>LiveData 源码</h3><blockquote><p>LiveData 本质上是一个<strong>带生命周期感知的观察者容器</strong>。<br>源码里通过 <code>ObserverWrapper</code> 包装 Observer，每个 Observer 都有一个 <code>active</code> 状态和 <code>lastVersion</code>。</p><p>当调用 <code>observe</code> 时，如果是绑定 <code>LifecycleOwner</code>，就用 <code>LifecycleBoundObserver</code> 监听生命周期，只有在 <strong>STARTED &#x2F; RESUMED</strong> 状态才会变成 active。页面 DESTROYED 时会自动移除 Observer，避免内存泄漏。</p><p>数据更新时，<code>setValue</code> 会递增版本号 <code>mVersion</code>，分发时只有 <strong>active 且 lastVersion 小于当前 version</strong> 的 Observer 才会收到回调，从而避免重复分发。</p><p><code>postValue</code> 本质是切到主线程再调用 <code>setValue</code>，多次 post 只保留最后一次。</p><p>总结就是：<strong>LiveData 通过生命周期控制 + 版本号机制，保证只在合适的时机、安全地通知 UI</strong>。</p></blockquote><ul><li><p><strong>为什么不会内存泄漏？</strong><br>  DESTROYED 时自动 removeObserver</p></li><li><p><strong>是不是粘性？</strong><br>  新 Observer active 时会收到<strong>最新一次</strong>数据，但不会收到历史多次</p></li><li><p><strong>和 EventBus 最大区别？</strong><br>  LiveData 有生命周期感知，EventBus 没有</p></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/LiveData%E3%80%81ViewModel.resources/2023/09/18/09-58-30-b54e070258904c61dd0edbec046c752c-unknown_filename.2-fab62d.png" alt="unknown_filename.2|800"><br>setValue 里会执行 Observer 的 onChanged 方法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Observer</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-built_in">void</span> onChanged (T t);<br>&#125;<br></code></pre></td></tr></table></figure><p>有同学提出，我如果希望这种情况下，Activity 在后台依然能够响应数据的变更，可不可以呢？当然可以，LiveData 此外还提供了 observerForever () 方法，在这种情况下，它能够响应到任何生命周期中数据的变更事件<br><a href="https://juejin.cn/post/6844903748574117901">https://juejin.cn/post/6844903748574117901</a><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/LiveData%E3%80%81ViewModel.resources/2023/09/18/09-58-30-ae9b459418614f84964fdb07c894d200-unknown_filename.3-565c58.png" alt="unknown_filename.3|700"></p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是一个接口，是一个生命周期感知组件能够感知 Activity、 Fragment 等组件的生命周期变化，并将变化通知到已注册的观察者。LifecycleOwner 之所以设计成接口，是为了其它对象可以使用到，这样其它对象就无需要求 Activity、Fragment 在特定的生命周期中调用特定的方法，比如终结方法、暂停方法，而这些要求往往可能被程序员所忽略，也使 Activity、Fragment 变得臃肿复杂。</p><p>业务层逻辑更加内聚，无需依赖 UI 去做生命周期相关阶段的处理，避免出错</p><p><strong>真正有生命周期的是 lifrcycle</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LifecycleOwner</span> &#123;<br>    <span class="hljs-meta">@NonNull</span><br>    Lifecycle <span class="hljs-title function_">getLifecycle</span> <span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>原理</strong>：接口，在 Activity、Fragment 生命周期的方法里调用 Lifecycle 接口各自的方法</p><p>LifecycleOwner 观察它<br>LifecycleObserver 观察者</p><p>可以通过被 LifecycleOwner 类的 <em>addObserver</em> (LifecycleObserver o)方法注册, 被注册后，LifecycleObserver 便可以观察到 LifecycleOwner 的生命周期事件。</p><p>当一个应用程序实现了 Application. <em>ActivityLifecycleCallbacks</em> 接口时，它可以注册一个监听器来监控和响应应用程序中活动（Activity）的生命周期事件。通过实现这个接口，应用程序可以接收有关活动的创建、启动、暂停、恢复和销毁等生命周期事件的通知。</p><p>场景：看前后台 implements <em>Application.ActivityLifecycleCallbacks</em></p><p>讲的不错<br><a href="https://juejin.cn/post/6955491901265051661?utm_source=gold_browser_extension">引入Jetpack架构后，你的App会发生哪些变化？上篇文章我给大家分享了我对架构的理解，从思想层面去讲述架构的演进过程 - 掘金</a></p><p>VoiceViewManager DefaultLifecycleObserver<br>使用前需要在当前页面注册监听 lifecycle.addObserver (VoiceViewManager)</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有些时候我们从 repository 层拿到的数据需要进行处理，例如从数据库获得 User List，我们想根据 id 获取某个 User。</p><p>此时我们可以借助 MediatorLiveData 和 Transformatoins 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainViewModel</span> &#123;<br>  <span class="hljs-type">val</span> <span class="hljs-variable">viewModelResult</span> <span class="hljs-operator">=</span> Transformations.map (repository.getDataForUser ()) &#123; data -&gt;<br>     convertDataToMainUIModel (data)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android端代码规范</title>
    <link href="/2025/12/d64dc819a208.html"/>
    <url>/2025/12/d64dc819a208.html</url>
    
    <content type="html"><![CDATA[<p><em>有好的建议可以提、集思广益，逐渐补充完善项目的代码规范</em></p><h1 id="代码注意事项"><a href="#代码注意事项" class="headerlink" title="代码注意事项"></a>代码注意事项</h1><ul><li>代码必须格式化、去除无效引用</li><li>dialog 统一使用半透明activity（）</li><li>通用common抽象，只能放公共类，不要放业务相关</li><li>相关联的逻辑应该在一起，不相关联的逻辑不应该混在一起</li><li>严禁使用new handler()、new Thread()，可以项目使用项目里的ThreadUtils</li><li>第三方代码必须二次封装后再使用</li><li>recycleView有各种写法，统一（BaseRecyclerViewAdapterHelper就挺好的）</li><li>eventbus一定不要重复，分场景定义</li><li>避免重复添加fragment导致的崩溃，建议调用FragmentTransaction.add方法，先判断fragment.isAdded()</li><li>如果使用Java语言，在所有使用 Object的地方，必须进行判空，除非你能非常确定对象不会为空，推荐使用项目里的ObjectUtils.isNotEmpty()</li><li>kotlin严禁使用避免使用 !!</li><li>使用图片加载时用ImageLoadingUtil，不要直接使用glide</li><li>Bundle不要传递过大参数。控制在500K以内，过大的时候可以选中存储为文件，然后传递文件路径在解析</li><li>写工具类先看工具类有没有，不要重复添加</li><li>全局获取：ContextManager.getApplication()</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">ActivityUtils activity 类<br><br>ObjectUtils 判空工具类<br><br>ContextManager <span class="hljs-built_in">application</span> 代理类，页面监听代理<br><br>MetaDataUtils 获取清单文件内的配置<br><br>cThreadUtils 线程池<br><br>CommonLoadingDialog 通用loading 弹窗，不要再布局里面再放一个lottie view<br></code></pre></td></tr></table></figure><ul><li>待补充…</li></ul><h1 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h1><p><strong>按功能分包</strong></p><p>好处：  </p><ol><li>高内聚、低耦合，哪块要添新功能，只改某一个 package 下的东西  </li><li>很容易删除功能  </li><li>package 的大小有意义了,包里 class 太多,表示这块需要重构（划分子包）</li></ol><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p><strong>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解，避免歧义。</strong></p><h3 id="类名：大写驼峰"><a href="#类名：大写驼峰" class="headerlink" title="类名：大写驼峰"></a>类名：大写驼峰</h3><p>模块名 + 功能（Activity、Fragment、Adapter）</p><h3 id="方法名：小写驼峰"><a href="#方法名：小写驼峰" class="headerlink" title="方法名：小写驼峰"></a>方法名：小写驼峰</h3><p>方法名通常是动词或动词短语。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>initXX()</code></td><td>初始化相关方法，使用 init 为前缀标识，如初始化布局 <code>initView()</code></td></tr><tr><td><code>isXX()</code>, <code>checkXX()</code></td><td>方法返回值为 boolean 型的请使用 is&#x2F;check 为前缀标识</td></tr><tr><td><code>getXX()</code></td><td>返回某个值的方法，使用 get 为前缀标识</td></tr><tr><td><code>setXX()</code></td><td>设置某个属性值</td></tr><tr><td><code>handleXX()</code>, <code>processXX()</code></td><td>对数据进行处理的方法</td></tr><tr><td><code>displayXX()</code>, <code>showXX()</code></td><td>弹出提示框和提示信息，使用 display&#x2F;show 为前缀标识</td></tr><tr><td><code>updateXX()</code></td><td>更新数据</td></tr><tr><td><code>saveXX()</code>, <code>insertXX()</code></td><td>保存或插入数据</td></tr><tr><td><code>resetXX()</code></td><td>重置数据</td></tr><tr><td><code>clearXX()</code></td><td>清除数据</td></tr><tr><td><code>removeXX()</code>, <code>deleteXX()</code></td><td>移除数据或者视图等，如 <code>removeView()</code></td></tr><tr><td><code>drawXX()</code></td><td>绘制数据或效果相关的，使用 draw 前缀标识</td></tr></tbody></table><h3 id="变量名：小写驼峰"><a href="#变量名：小写驼峰" class="headerlink" title="变量名：小写驼峰"></a>变量名：小写驼峰</h3><p>全局变量 ：mXXX</p><h3 id="静态变量、常量：大写下划线-A-B"><a href="#静态变量、常量：大写下划线-A-B" class="headerlink" title="静态变量、常量：大写下划线 A_B"></a>静态变量、常量：大写下划线 A_B</h3><h3 id="其他命名"><a href="#其他命名" class="headerlink" title="其他命名"></a>其他命名</h3><p>命名要明白，见名知其意，例如：</p><p>工具类：util</p><p>管理类：Manager</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h3 id="图片（drawable-和drawable-xxhdpi-）"><a href="#图片（drawable-和drawable-xxhdpi-）" class="headerlink" title="图片（drawable&#x2F; 和drawable-xxhdpi&#x2F;）"></a>图片（drawable&#x2F; 和drawable-xxhdpi&#x2F;）</h3><p>命名规则：<code>类型&#123;_模块名&#125;_逻辑名称</code>、<code>类型&#123;_模块名&#125;_颜色</code>。<code>&#123;&#125;</code> 中的内容为可选</p><p>位置：公用的放在common，自己的模块用到的放自己模块</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>btn_main_about.png</code></td><td>主页关于按键 <code>类型_模块名_逻辑名称</code></td></tr><tr><td><code>btn_back.png</code></td><td>返回按键 <code>类型_逻辑名称</code></td></tr><tr><td><code>divider_maket_white.png</code></td><td>商城白色分割线 <code>类型_模块名_颜色</code></td></tr><tr><td><code>ic_edit.png</code></td><td>编辑图标 <code>类型_逻辑名称</code></td></tr><tr><td><code>bg_main.png</code></td><td>主页背景 <code>类型_逻辑名称</code></td></tr><tr><td><code>btn_red.png</code></td><td>红色按键 <code>类型_颜色</code></td></tr></tbody></table><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><table><thead><tr><th><code>sel_btn_xx</code></th><th>作用在 <code>btn_xx</code> 上的 <code>selector</code></th></tr></thead><tbody><tr><td><code>btn_xx_normal</code></td><td>默认状态效果</td></tr><tr><td><code>btn_xx_pressed</code></td><td><code>state_pressed</code> 点击效果</td></tr><tr><td><code>btn_xx_focused</code></td><td><code>state_focused</code> 聚焦效果</td></tr><tr><td><code>btn_xx_disabled</code></td><td><code>state_enabled</code> 不可用效果</td></tr><tr><td><code>btn_xx_checked</code></td><td><code>state_checked</code> 选中效果</td></tr><tr><td><code>btn_xx_selected</code></td><td><code>state_selected</code> 选中效果</td></tr><tr><td><code>btn_xx_hovered</code></td><td><code>state_hovered</code> 悬停效果</td></tr><tr><td><code>btn_xx_checkable</code></td><td><code>state_checkable</code> 可选效果</td></tr></tbody></table><h3 id="布局资源文件（layout-）"><a href="#布局资源文件（layout-）" class="headerlink" title="布局资源文件（layout&#x2F;）"></a>布局资源文件（layout&#x2F;）</h3><p>命名规则：类型_模块名_功能(可选)</p><table><thead><tr><th>activity</th><th>activity_模块名</th><th>例如 R.layout.activity_login</th></tr></thead><tbody><tr><td>fragment</td><td>fragment_模块名</td><td>例如 R.layout.fragment_login</td></tr><tr><td>include</td><td>layout_模块名_功能名</td><td>例如 R.layout.layout_login_bottom</td></tr><tr><td>adapter</td><td>item_模块名_功能名</td><td>例如 R.layout.item_simple_text</td></tr><tr><td>dialog</td><td>dialog_模块_功能名</td><td>例如 R.layout.dialog_time_picker</td></tr><tr><td>widget</td><td>widget_模块_功能</td><td>例如 R.layout.widget_app_clock</td></tr></tbody></table><h3 id="布局资源-id-命名"><a href="#布局资源-id-命名" class="headerlink" title="布局资源 id 命名"></a>布局资源 id 命名</h3><p>id 命名直接采用小写驼峰样式，因为使用viewBinding直接就可以就可以获取ID，不需要再重新转一下了</p><p>控件Id命名：控件缩写_(模块名)_功能名</p><table><thead><tr><th>TextView</th><th>EditText</th><th>ImageView</th><th>Button</th><th>ListView</th><th>CheckBox</th><th>LinearLayout</th><th>RelativeLayout</th><th>FrameLayout</th></tr></thead><tbody><tr><td>tvShopName</td><td>et</td><td>iv</td><td>btn</td><td>lv</td><td>cb</td><td>ll</td><td>rl</td><td>fl</td></tr></tbody></table><h3 id="strings-xml"><a href="#strings-xml" class="headerlink" title="strings.xml"></a>strings.xml</h3><p><code>&lt;string&gt;</code> 的 <code>name</code> 命名使用下划线命名法，采用以下规则：<code>&#123;模块名（moudle）_&#125;逻辑名称</code>，这样方便同一个界面的所有 <code>string</code> 都放到一起，方便查找。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>main_menu_about</code></td><td>主菜单按键文字</td></tr><tr><td><code>friend_title</code></td><td>好友模块标题栏</td></tr><tr><td><code>friend_dialog_del</code></td><td>好友删除提示</td></tr><tr><td><code>login_check_email</code></td><td>登录验证</td></tr><tr><td><code>dialog_title</code></td><td>弹出框标题</td></tr></tbody></table><h1 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h1><h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p>每个类完成后应该有作者姓名和描述的注释，对自己的代码负责，也好找人。</p><p>具体可以在 AS 中自己配制，进入 Settings -&gt; Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header，输入</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">/**<br> *     desc   : 类描述 <br> *     <span class="hljs-keyword">time</span>   : $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125;<br> *     author : $&#123;USER&#125;<br> */<br></code></pre></td></tr></table></figure><h3 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h3><p>不强制，因为有些方法一看就知道是干啥的，在方法前一行输入 <code>/** + 回车</code> ，AS 便会帮你生成模板，我们只需要补全参数即可</p><h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><p>&#x2F;&#x2F;</p><h3 id="提测的代码todo"><a href="#提测的代码todo" class="headerlink" title="提测的代码todo"></a>提测的代码todo</h3><p>建议，不强制，不要无效的todo </p><h1 id="代码样式规范"><a href="#代码样式规范" class="headerlink" title="代码样式规范"></a>代码样式规范</h1><h3 id="编写简短方法"><a href="#编写简短方法" class="headerlink" title="编写简短方法"></a>编写简短方法</h3><p>在可行的情况下，尽量编写短小精炼的方法。有些情况下较长的方法是恰当的，因此对方法的代码长度没有做出硬性限制。如果某个方法的代码超出 40 行，请考虑是否可以在不破坏程序结构的前提下对其拆解。</p><h3 id="类成员的顺序"><a href="#类成员的顺序" class="headerlink" title="类成员的顺序"></a>类成员的顺序</h3><p>推荐使用如下排序：</p><ol><li>常量（Kotlin 伴生对象放在开头）</li><li>字段</li><li>构造函数</li><li>重写函数和回调</li><li>方法</li></ol><p>如果类继承于 Android 组件（例如 <code>Activity</code> 或 <code>Fragment</code>），那么把重写函数按照他们的生命周期进行排序是一个非常好的习惯，例如，<code>Activity</code> 实现了 <code>onCreate()</code>、<code>onDestroy()</code>、<code>onPause()</code>、<code>onResume()</code>，它的正确排序如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MainActivity</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">Activity</span> &#123;<br>    <span class="hljs-comment">//Order matches Activity lifecycle</span><br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">onCreate</span>() &#123;&#125;<br><br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">onResume</span>() &#123;&#125;<br><br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">onPause</span>() &#123;&#125;<br><br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">onDestroy</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数参数的排序"><a href="#函数参数的排序" class="headerlink" title="函数参数的排序"></a>函数参数的排序</h3><p>在 Android 开发过程中，<code>Context</code> 在函数参数中是再常见不过的了，我们最好把 <code>Context</code> 作为其第一个参数。</p><p>正相反，我们把回调接口应该作为其最后一个参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Context always goes first</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">loadUser</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> userId)</span></span>;<br><br><span class="hljs-comment">// Callbacks always go last</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">loadUserAsync</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> userId, UserCallback callback)</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android编译优化</title>
    <link href="/2025/12/d0387facc838.html"/>
    <url>/2025/12/d0387facc838.html</url>
    
    <content type="html"><![CDATA[<h2 id="AAR"><a href="#AAR" class="headerlink" title="AAR"></a>AAR</h2><p>首次运行时间：<br>485.0s</p><p>android gradle 7.2升级<br>Android Gradle plugin supports Configuration cache from 7.0.0. Current version is 4.0.1.<br>Start AGP Upgrade Assistant<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-10-14-17-edbb593233fa7cb893d2a0e95fb7ee21-20240110141658-072af9.png" alt="image.png"></p><h2 id="迁移KTS"><a href="#迁移KTS" class="headerlink" title="迁移KTS"></a>迁移KTS</h2><p><a href="https://juejin.cn/post/7230416597012283453#comment">小伙快把你的Gradle从Groovy迁移到KTS - 掘金</a><br><a href="https://juejin.cn/post/7069568821568208927#heading-2">Kotlin DSL 实战：像 Compose 一样写代码 - 掘金</a></p><h3 id="什么是-DSL"><a href="#什么是-DSL" class="headerlink" title="什么是 DSL"></a>什么是 DSL</h3><p>DSL 全称是 <strong>Domain Specific Language</strong>，即领域特定语言。顾名思义 DSL 是用来专门解决某一特定问题的语言，比如我们常见的 SQL 或者正则表达式等，DSL 没有通用编程语言（Java、Kotlin等）那么万能，但是在特定问题的解决上更高效。</p><p>创作一套全新新语言的成本很高，所以很多时候我们可以基于已有的通用编程语言打造自己的 DSL，比如日常开发中我们将常见到 gradle 脚本 ，其本质就是来自 Groovy 的一套 DSL.</p><p>Kotlin 是一门对 DSL 友好的语言，它的许多语法特性有助于 DSL 的打造，提升特定场景下代码的可读性和安全性</p><p>Kotlin 是 Android 的主要编程语言，因此我们可以在 Android 开发中发挥其 DSL 优势，提升特定场景下的开发效率。例如 Compose 的 UI 代码就是一个很好的示范，它借助 DSL 让 Kotlin 代码具有了不输于 XML 的表现力，</p><h2 id="KSP"><a href="#KSP" class="headerlink" title="KSP"></a>KSP</h2><p><a href="https://juejin.cn/post/6939472660573192206?utm_source=gold_browser_extension">ksp，加快编译速度</a><br>在<code>ksp</code>出来以前，对于这种注解解释器，我们使用的都是java所提供的<code>AbstractProcessor</code><br>官方对于ksp的介绍就是，这是一个轻量级替换kapt的一个方案，<em>优点就是速度更快，参数更少更简单一点</em>。<br>同时<code>ksp</code>相比于<code>kapt</code>接入方式也更清凉，还有就是它本身也支持增量编译等</p><p>由于官方文档中推荐我们使用<code>gradle.kts</code>，所以这次对项目整体进行了升级。这部分后续会更新另外一个文章，凡事还是逃不开真香定律的，这东西相比于<code>Groovy</code>对开发也更友善一点，毕竟kts还是强类型语言。<br><a href="https://juejin.cn/post/7307723901529374757?searchId=20240104180824AB04B4108D93B012D85D">迁移Kapt到KSP, Kapt将很快被废弃 - 掘金</a></p><p>以下是迁移步骤概览:</p><ol><li>检查你使用的库是否支持 KSP.</li><li>在项目中添加 KSP 插件.</li><li>用 KSP 替换注解处理器.</li><li>移除 kapt 插件.</li></ol><h2 id="AGP、kotlin、compose对应版本"><a href="#AGP、kotlin、compose对应版本" class="headerlink" title="AGP、kotlin、compose对应版本"></a>AGP、kotlin、compose对应版本</h2><p><a href="https://kotlinlang.org/docs/gradle-configure-project.html#apply-the-plugin">Configure a Gradle project | Kotlin Documentation</a></p><p><a href="https://developer.android.google.cn/jetpack/androidx/releases/compose-kotlin?hl=zh-cn">Compose 与 Kotlin 的兼容性对应关系  |  Android 开发者  |  Android Developers</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-10-14-07-b8070320ee476da0ddb4629e2581f0b2-2024-01-10-11-46-b8070320ee476da0ddb4629e2581f0b2-20240110114642-44d6ba-f76bcb.png" alt="image.png"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2024-01-10-14-07-d3a0e018fe7731dac90e5d52e4db0119-2024-01-10-11-47-d3a0e018fe7731dac90e5d52e4db0119-20240110114712-926a0d-2d53c6.png" alt="image.png"><br><code>classpath &#39;com.android.tools.build:gradle:版本号&#39;</code> 指定了 AGP 的版本。<br>而 Gradle 的版本通常在 <code>gradle/wrapper/gradle-wrapper.properties</code> 文件中指定</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.优化工具使用</title>
    <link href="/2025/12/19d23d9f2543.html"/>
    <url>/2025/12/19d23d9f2543.html</url>
    
    <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell dumpsys meminfo  com<span class="hljs-selector-class">.esread</span><span class="hljs-selector-class">.sunflowerstudent</span> -d<br>adb shell dumpsys meminfo \<span class="hljs-selector-attr">[PackageName\]</span>，可以打印出指定包名的应用内存信息<br></code></pre></td></tr></table></figure><p>目前栈中所有的Activity的实例，如果数量大于1，说明有内存泄漏的界面。</p><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>App植入LeakCanary之后, 在检测可能的内存泄露后, 会弹出Toast提示，并在桌面生成一个Leaks的icon，点击该icon进入Leaks界面, 可以比较清晰的看到内存泄露疑点。可以看到leak对象的引用关系。</p><p><a href="https://juejin.im/entry/5817e6e0a0bb9f005880fc5d">Android 性能优化之利用 LeakCanary 检测内存泄漏及解决办法</a></p><h2 id="Android-Profile"><a href="#Android-Profile" class="headerlink" title="Android Profile"></a>Android Profile</h2><p>打开Android Studio，然后就从android profile（性能分析器）里面观察App的内存使用曲线，突然发现内存使用越来越大了，并且没有回落，就很有可能是发生内存泄漏了。<br>使用App后在Android Profiler中先触发GC然后dump内存快照（hprof），之后点击按package分类，就可以查看到你的App目前在内存中残留的class,点击class即可在右边查看到对应的实例以及引用对象。按理来说已经被销毁的activity不应该出现在这里</p><ul><li>强制GC：点击垃圾桶按钮，建议点击后等待几秒后再次点击，尝试多次，让GC更加充分。</li><li>可以选择某一段区域，在下面就有堆栈信息。<br>  Android 7.1 或更低版本需要记录<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-c49117006048d9af67e0aae75f91a833-unknown_filename.3-874b30.png" alt="unknown_filename.3"></li><li>堆栈是默认是按Retained Size排序的，Shallow Size指的是该对象本身占用内存的大小，Retained Heap表示这个对象以及它所持有的其它引用（包括直接和间接）所占的总内存，分析内存泄漏时，内存最大的对象也是最应该去怀疑的</li><li>根据引用关系就可以知道是谁让这个leak的activity活着的, 然后可以 jump to source</li><li>此例中, 比较简单, 可以很清晰看到是ListenerManager的静态单例sInstance最终支配了MemoryLeakActivity. sIntance连接到GC Roots, 故而导致MemoryLeakActivity GC Roots可达, 无法被回收.</li><li>上述步骤, 可以让我们快速定位可能的内存泄露. 当然, 内存问题除了内存泄露, 还可以看哪个<code>内存消耗大</code>。</li><li><em>bitmap特别大时点开看看图片的宽高是不是有特比大的</em></li></ul><p><strong>在某个页面gc后不在这个页面的view或者activity、fragment不应该出现在堆栈里面</strong>，看看是不是有某个东西引用的他们</p><p><strong>捕获堆转储</strong><br>使用：点击 Dump Java heap <br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-5bcb5723df9c47660f74eae8b807b68a-unknown_filename.1-7b0a4c.webp" alt="unknown_filename.1"></p><table><thead><tr><th>名称</th><th>意义</th></tr></thead><tbody><tr><td>Total Count</td><td>内存中该类的对象个数</td></tr><tr><td>Heap Count Count</td><td>堆内存中该类的对象个数</td></tr><tr><td>Sizeof</td><td>物理大小</td></tr><tr><td>Shallow size</td><td>对象本身占有内存大小</td></tr><tr><td>Retained Size</td><td>释放该对象后，节省的内存大小</td></tr><tr><td>depth</td><td>深度</td></tr><tr><td>Dominating Size</td><td>管辖的内存大小</td></tr></tbody></table><h3 id="分析内存的技巧"><a href="#分析内存的技巧" class="headerlink" title="分析内存的技巧"></a>分析内存的技巧</h3><p>使用 Memory Profiler 时，您应对应用代码施加压力并尝试强制内存泄漏。 在应用中引发内存泄漏的一种方式是，先<em>让其运行一段时间，然后再检查堆。 泄漏在堆中可能逐渐汇聚到分配顶部</em>。 不过，泄漏越小，您越需要运行更长时间的应用才能看到泄漏。<br>您还可以通过以下方式之一触发内存泄漏：</p><ul><li>将设备从纵向旋转为横向，然后在不同的 Activity 状态下反复操作多次。 旋转设备经常会导致应用泄漏 Activity、Context 或 View 对象，因为系统会重新创建 Activity，而如果您的应用在其他地方保持对这些对象之一的引用，系统将无法对其进行垃圾回收。</li><li>处于不同的 Activity 状态时，在您的应用与另一个应用之间切换（导航到主屏幕，然后返回到您的应用）。</li></ul><p><strong>分析步骤：</strong></p><ol><li>不断在手机上操作一个功能，如果该数据在不断地增加，每次GC后没有明显的回落，则判定该功能模块存在内存泄露问题。</li><li>如果反复操作该功能之后，有一定范围的起伏，但是又被稳定在某一个有限的范围内，则说明代码良好，没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平；</li><li>如果有效内存，手机可能会出现程序被kill，但是程序被kill并不能代表程序一定有内存泄露。</li><li>横竖屏切换，看内存是回落，没有的话这里存在内存泄漏</li></ol><h3 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h3><p>在您的堆转储中，请注意由下列任意情况引起的内存泄漏：</p><ul><li>长时间引用<strong>Activity、Context、View、Drawable</strong> 和其他对象，可能会保持对 Activity 或 Context 容器的引用。</li><li>可以保持 Activity 实例的非静态内部类，如 Runnable。</li><li>对象保持时间超出所需时间的缓存。</li></ul><p>手动设置 null，解除引用关系</p><p>Lint 外，还有像 FindBugs 、 Checkstyle 等<code>静态代码分析工具</code>，主要就静态对象或变量引用着的实例<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-9b49caa44ad87eeb147d65a467d3f405-unknown_filename.2-3d2d9a.png" alt="unknown_filename.2"></p><p><strong>sampling模式和instrumentation模式的区别</strong><br>两者的区别：</p><ul><li>在sampling模式中，profiler以固定的间隔对运行中的程序进行采样，根据采样结果统计出程序中各个部分的开销。</li><li>在instrumentation模式中，profiler对运行中的程序所执行的每一个指令都进行记录，最后根据这份记录生成程序中各个部分的开销。</li></ul><p>在实际使用中：</p><ul><li>sampling模式速度快，记录产生的数据量小，但是统计结果并不十分精确，适合于对程序全局性能进行初步的分析，找出程序瓶颈大致的“区间”。</li><li>instrumentation模式能精确记录程序各个部分的开销，但是速度慢，记录产生的数据量大，适合于对程序局部进行精细分析，精确定位瓶颈位置。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li>在内存里发现两个极少概率出现的empty view，占用了很大的内存：用ViewStub对empty view做了懒加载，对于这些没有马上用到的资源要做延迟加载，还有很多大概率不会出现的View更加要做懒加载。 -2M</li><li>发现详情页的轮播大图的Viewpager用的Adapter是FragmentPagerAdapter，导致了所有的page都会被保存，当图片页数多的时候，往后翻内存会不断上升。优化：这种页数多的ViewPager使用FragmentStatePagerAdapter来替代，它只会保留前后pager,在页数多的时候可以 节省大量内存。</li><li>遇到个问题，设置显示图片的时候传了dp,可是传了一个像素。会进行俩次算像素，看内存会出现有个特别的大的。</li></ol><h2 id="Memory-Analyzer（MAT）"><a href="#Memory-Analyzer（MAT）" class="headerlink" title="Memory Analyzer（MAT）"></a>Memory Analyzer（MAT）</h2><p>内存泄漏不像闪退的BUG，排查起来相对要比较困难些</p><ol><li>当内存泄漏发生时，LeakCanary 会弹窗提示并生成对应的堆存储信息记录，这让我们对隐蔽的内存泄漏问题有了更加直观的感觉，但从实际使用来看，LeakCanary 的每个提示也并非是真正存在内存泄漏问题，要想确定是否存在问题我们还需要借助 MAT 来进行最后的确定。</li><li>Android 系统本身就存在一些问题导致应用内存泄漏，LeakCanary 的 <strong>AndroidExcludedRefs</strong> 类帮助我们处理了不少这类问题。</li></ol><p>生成的 Heap 文件不是标准的 Java Heap，所以 MAT 无法打开，我们需要转换成标准的 Java Heap 文件，这个工具 Android Studio 就有提供，叫做 Captures,右击选中的 hprof，Export to standard .hprof 选择保存的位置，即可生成一个标准的 hprof 文件。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-2fef8fd707f7783272e924da0c2b8cfd-unknown_filename-731cad.jpeg" alt="unknown_filename"></p><h1 id="卡顿监测"><a href="#卡顿监测" class="headerlink" title="卡顿监测"></a>卡顿监测</h1><h2 id="perfetto"><a href="#perfetto" class="headerlink" title="perfetto"></a>perfetto</h2><p>[[perfetto]]</p><h2 id="Traceview"><a href="#Traceview" class="headerlink" title="Traceview"></a><strong>Traceview</strong></h2><p>它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。它可以用来查看整个过程有哪些函数调用，但是工具本身带来的性能开销过大，有时无法反映真实的情况。比如一个函数本身的耗时是 1 秒，开启 Traceview 后可能会变成 5 秒，而且这些函数的耗时变化并不是成比例放大。<br>在 Android 5.0 之后，新增了 <strong>startMethodTracingSampling</strong> 方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响</p><p><strong>Traceview 此工具已弃用</strong><br>要检查通过使用 Debug 类检测您的应用而捕获的 . trace 文件、记录新方法跟踪、导出 . trace 文件以及检查应用进程的实时 CPU 使用情况，请使用 Android Studio CPU Profiler。</p><p><strong>Hierarchy Viewer</strong><br>如果要在运行时检查应用的视图层次结构，请使用 Layout Inspector。如果您要分析应用布局的渲染速度，请使用 Window. OnFrameMetricsAvailableListener，如本博文中所述。</p><p><strong>获取方法运行时间</strong><br>matrix trace canary</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>        Debug.startMethodTracing(<span class="hljs-string">&quot;&quot;</span>);      <span class="hljs-regexp">//</span>traceview，不准确，耗时，配对，侵入型强，可以自定义插件<br><span class="hljs-regexp">//</span>        Trace.beginSection(<span class="hljs-string">&quot;xx&quot;</span>);  <span class="hljs-regexp">//</span>Systrace<br><br><span class="hljs-regexp">//</span>        Debug.stopMethodTracing();<br><span class="hljs-regexp">//</span>        Trace.endSection();<br><span class="hljs-regexp">//</span>        python systrace.py -a 包名 view am<br></code></pre></td></tr></table></figure><h2 id="CPU-Profiler"><a href="#CPU-Profiler" class="headerlink" title="CPU Profiler"></a>CPU Profiler</h2><p>操作前点记录，完了点stop，会生成下面的<br>一般看红色，<strong>蓝色是自己的代码的方法的耗时</strong>，红色时间长<br><strong>特点</strong><br>找到最耗费时间的路径：Flame Chart、Top Down。<br>找到最耗费时间的节点：Bottom Up。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-038b44ad52d56d983de7698038f9e944-unknown_filename.4-93d226.png" alt="unknown_filename.4"></p><p>CPU 时间轴<br>显示应用的实时 CPU 使用率（以占总可用 CPU 时间的百分比表示）以及应用当前使用的线程总数。此时间轴还显示其他进程（如系统进程或其他应用）的 CPU 使用率，以便您可以将其与您应用的使用率进行对比。您可以通过沿时间轴的水平轴移动鼠标来检查历史 CPU 使用率数据。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-afe2227fde7b5961d52c7000b8d20f09-unknown_filename.17-a73bd1.png" alt="unknown_filename.17"></p><h4 id="Call-Chart"><a href="#Call-Chart" class="headerlink" title="Call Chart"></a>Call Chart</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-6cf35971b24aafa0ad1256aa1ee3b6c3-unknown_filename.14-f04401.png" alt="unknown_filename.14"></p><h4 id="Flame-Chart"><a href="#Flame-Chart" class="headerlink" title="Flame Chart"></a>Flame Chart</h4><p>Flame Chart 标签提供一个倒置的调用图表，用来汇总完全相同的调用堆栈。也就是说，将具有相同调用方顺序的完全相同的方法或函数收集起来，并在火焰图中将它们表示为一个较长的横条（而不是将它们显示为多个较短的横条，如调用图表中所示）。<strong>这样更方便您查看哪些方法或函数消耗的时间最多</strong>。不过，这也意味着，水平轴不代表时间轴，而是表示执行每个方法或函数所需的相对时间量。</p><p>注意，方法 D 多次调用 B（B1、B2 和 B3），其中一些对 B 的调用也调用了 C（C1 和 C3）。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-6d8e94410035f7316d67f3051506f39f-unknown_filename.15-77c3a5.png" alt="unknown_filename.15"></p><p>使用“Top Down”和“Bottom Up”检查跟踪数据<br>Top Down 标签显示一个调用列表，在该列表中展开方法或函数节点会显示它的被调用方。图 8 显示了图 4 中调用图表的自上而下图。图中的每个箭头都从调用方指向被调用方。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-8acf8ee2bab97e7f07e0c2270c215bb6-unknown_filename.16-754fae.png" alt="unknown_filename.16"></p><p>Bottom Up<strong>标签用于按照消耗的 CPU 时间由多到少</strong>（或由少到多）的排序对方法或函数排序。您可以检查每个节点以确定哪些调用方在调用这些方法或函数上所花的 CPU 时间最多</p><p><strong>检查帧渲染数据</strong><br>您可以检查应用在主线程和 RenderThread 上渲染每个帧所用的时间，以调查导致界面卡顿和帧速率较低的瓶颈。要查看帧渲染数据，请使用可让您跟踪系统调用的配置记录跟踪数据。记录跟踪数据后，在名为 FRAMES 的部分下查找有关每个帧的信息</p><p>每个所用时间超过 16 毫秒的帧都以红色显示。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-13cf044e7980302f9007a740b50b0d96-unknown_filename.13-9fd9a6.png" alt="unknown_filename.13"></p><h2 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h2><p>使⽤ python 终端命令⽣成 Trace ⽂件 <a href="https://developer.android.com/topic/performance/tracing/command-line">官⽅⽂档</a><br>在⾼版本中，可以通过 System tracing ⽣成 trace ⽂件，⽣成的⽂件可以在 这⾥ <a href="https://www.perfetto.dev/">在线分析</a><br>在代码中主动做标记</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-d851935c8c00007bae5709e6639d96b9-unknown_filename.19-e4c79a.png" alt="unknown_filename.19"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.resources/2023/09/15/17-55-11-3d8b41363cc4b63a4eed274442fde467-unknown_filename.18-dae593.png" alt="unknown_filename.18"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.WebView 缓存池</title>
    <link href="/2025/12/c8be8dba48e3.html"/>
    <url>/2025/12/c8be8dba48e3.html</url>
    
    <content type="html"><![CDATA[<h1 id="一次把-WebView-秒开：WebView-缓存池的设计与落地"><a href="#一次把-WebView-秒开：WebView-缓存池的设计与落地" class="headerlink" title="一次把 WebView 秒开：WebView 缓存池的设计与落地"></a>一次把 WebView 秒开：WebView 缓存池的设计与落地</h1><p>移动端只要一碰到 H5，性能问题通常绕不开：首屏白屏、进入慢、返回卡、低端机尤其明显。很多时候并不是页面本身慢，而是 <strong>WebView 第一次创建与初始化</strong> 太“重”。</p><p>如果你的业务里存在「高频打开 WebView」的场景（活动页、协议页、结果页、视频互动层等），那么 <strong>WebView 缓存池</strong>基本是性价比最高的一类优化：把创建成本前置，把复用做成工程能力。</p><p>本文按“为什么 → 怎么做 → 怎么验证 → 注意什么”展开，并给出可直接参考的 <code>WebViewPool</code> 伪代码结构。</p><hr><h2 id="1-为什么-WebView-会慢"><a href="#1-为什么-WebView-会慢" class="headerlink" title="1. 为什么 WebView 会慢"></a>1. 为什么 WebView 会慢</h2><p>WebView 打开一个 H5 的完整链路里，HTML&#x2F;CSS&#x2F;JS 的解析与渲染当然重要，但很多应用的“首次慢”主要来自：</p><ul><li><p>WebView 实例创建</p></li><li><p>内核初始化&#x2F;环境准备</p></li><li><p>Settings 与 Client 初始化</p></li><li><p>渲染管线准备</p></li></ul><p>这部分开销往往在第一次进入时集中爆发，导致白屏时间明显拉长。</p><p>因此优化的关键是：<strong>不要在用户点击进入页面的那一刻才创建 WebView</strong>。</p><hr><h2 id="2-缓存池解决什么问题"><a href="#2-缓存池解决什么问题" class="headerlink" title="2. 缓存池解决什么问题"></a>2. 缓存池解决什么问题</h2><p>WebView 缓存池的目标很明确：</p><ul><li><p>在合适时机 <strong>预创建</strong> 1 个或多个 WebView</p></li><li><p>页面需要时 <strong>直接取现成的</strong></p></li><li><p>页面结束时 <strong>回收并重置</strong>，保证下一次可用</p></li></ul><p>工程上通常会维护两类容器：</p><ul><li><p><code>idle</code>：空闲可借出的 WebView</p></li><li><p><code>inUse</code>：已借出正在使用的 WebView</p></li></ul><p>并且需要解决一个核心难点：<strong>Context 生命周期</strong>。</p><hr><h2 id="3-Context-生命周期：为什么必须用-MutableContextWrapper"><a href="#3-Context-生命周期：为什么必须用-MutableContextWrapper" class="headerlink" title="3. Context 生命周期：为什么必须用 MutableContextWrapper"></a>3. Context 生命周期：为什么必须用 MutableContextWrapper</h2><p>WebView 不能随便拿 <code>Application</code> 当最终 Context（尤其涉及主题、窗口、权限、资源等），但你又不能让一个长期存活的 WebView 强引用 Activity Context —— 否则内存泄漏基本是必然的。</p><p>常见解法是 <code>MutableContextWrapper</code>：</p><ul><li><p>预加载时：baseContext &#x3D; <code>Application</code></p></li><li><p>借出给页面时：baseContext 切到 <code>Activity</code></p></li><li><p>回收时：baseContext 切回 <code>Application</code></p></li></ul><p>这样既能“长命”，又能“在页面里正常跑”。</p><hr><h2 id="4-WebViewPool-伪代码结构（Kotlin-风格）"><a href="#4-WebViewPool-伪代码结构（Kotlin-风格）" class="headerlink" title="4. WebViewPool 伪代码结构（Kotlin 风格）"></a>4. WebViewPool 伪代码结构（Kotlin 风格）</h2><p>说明：</p><ul><li>重点展示：预加载、借出、归还、销毁重建、多进程隔离的基本思路。</li></ul><h3 id="4-1-核心数据结构"><a href="#4-1-核心数据结构" class="headerlink" title="4.1 核心数据结构"></a>4.1 核心数据结构</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * WebViewPool：进程内单例（每个进程各自维护一份）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">object</span> WebViewPool &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> DEFAULT_MAX_IDLE = <span class="hljs-number">1</span>  <span class="hljs-comment">// 建议从 1 起步，按收益再扩</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> maxIdle = DEFAULT_MAX_IDLE<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> idle = ArrayDeque&lt;PooledWebView&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> inUse = LinkedHashMap&lt;String, PooledWebView&gt;() <span class="hljs-comment">// key = ownerId（页面唯一标识）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> appContext: Context<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>, maxIdleCount: <span class="hljs-type">Int</span> = DEFAULT_MAX_IDLE)</span></span> &#123;<br>        appContext = application.applicationContext<br>        maxIdle = maxIdleCount<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledWebView</span>(<br>    <span class="hljs-keyword">val</span> webView: WebView,<br>    <span class="hljs-keyword">val</span> wrapper: MutableContextWrapper,<br>    <span class="hljs-keyword">var</span> state: State = State.IDLE,<br>    <span class="hljs-keyword">var</span> createUptimeMs: <span class="hljs-built_in">Long</span> = SystemClock.uptimeMillis()<br>) &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123; IDLE, IN_USE &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-预加载：在合适时机创建空闲-WebView"><a href="#4-2-预加载：在合适时机创建空闲-WebView" class="headerlink" title="4.2 预加载：在合适时机创建空闲 WebView"></a>4.2 预加载：在合适时机创建空闲 WebView</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 预加载：建议在内核 ready 后触发（系统 WebView / X5 等）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">preloadIfNeeded</span><span class="hljs-params">()</span></span> &#123;<br>    ensureMainThread()<br><br>    <span class="hljs-keyword">val</span> need = maxIdle - idle.size<br>    <span class="hljs-keyword">if</span> (need &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>    repeat(need) &#123;<br>        idle.addLast(createPooledWebView(appContext))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createPooledWebView</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: PooledWebView &#123;<br>    <span class="hljs-keyword">val</span> wrapper = MutableContextWrapper(context) <span class="hljs-comment">// base = appContext</span><br>    <span class="hljs-keyword">val</span> wv = WebView(wrapper)<br><br>    <span class="hljs-comment">// 统一初始化（仅放“通用”项，避免业务绑定）</span><br>    initSettings(wv)<br>    initClients(wv)<br><br>    <span class="hljs-comment">// 可选：提前加载一个空白页，加速后续首次渲染通道建立</span><br>    wv.loadUrl(<span class="hljs-string">&quot;about:blank&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> PooledWebView(webView = wv, wrapper = wrapper, state = PooledWebView.State.IDLE)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initSettings</span><span class="hljs-params">(wv: <span class="hljs-type">WebView</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = wv.settings<br>    s.javaScriptEnabled = <span class="hljs-literal">true</span><br>    s.domStorageEnabled = <span class="hljs-literal">true</span><br>    s.loadsImagesAutomatically = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// 其余按你业务安全/兼容策略配置（UA、mixed content、缓存策略等）</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initClients</span><span class="hljs-params">(wv: <span class="hljs-type">WebView</span>)</span></span> &#123;<br>    wv.webChromeClient = <span class="hljs-keyword">object</span> : WebChromeClient() &#123;&#125;<br>    wv.webViewClient = <span class="hljs-keyword">object</span> : WebViewClient() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-借出：页面创建时获取-WebView，并绑定到-Activity-Context"><a href="#4-3-借出：页面创建时获取-WebView，并绑定到-Activity-Context" class="headerlink" title="4.3 借出：页面创建时获取 WebView，并绑定到 Activity Context"></a>4.3 借出：页面创建时获取 WebView，并绑定到 Activity Context</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ownerId：建议用页面实例唯一 ID（例如 Activity hash / UUID）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">acquire</span><span class="hljs-params">(ownerId: <span class="hljs-type">String</span>, activity: <span class="hljs-type">Activity</span>)</span></span>: WebView &#123;<br>    ensureMainThread()<br><br>    <span class="hljs-comment">// 先从空闲池取</span><br>    <span class="hljs-keyword">val</span> pooled = <span class="hljs-keyword">if</span> (idle.isNotEmpty()) idle.removeFirst()<br>                 <span class="hljs-keyword">else</span> createPooledWebView(appContext) <span class="hljs-comment">// 兜底新建</span><br><br>    <span class="hljs-comment">// 绑定 Activity Context</span><br>    pooled.wrapper.baseContext = activity<br><br>    <span class="hljs-comment">// 标记使用中</span><br>    pooled.state = PooledWebView.State.IN_USE<br>    inUse[ownerId] = pooled<br><br>    <span class="hljs-comment">// 返回给页面</span><br>    <span class="hljs-keyword">return</span> pooled.webView<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-归还：页面-finish-destroy-时回收，并“销毁-重建”保证干净"><a href="#4-4-归还：页面-finish-destroy-时回收，并“销毁-重建”保证干净" class="headerlink" title="4.4 归还：页面 finish&#x2F;destroy 时回收，并“销毁 + 重建”保证干净"></a>4.4 归还：页面 finish&#x2F;destroy 时回收，并“销毁 + 重建”保证干净</h3><p>这里采用你文档里提到的策略：<strong>用过的 WebView 不直接回到空闲池</strong>，而是销毁后补一个新的回去，降低状态污染风险（历史栈、JS 全局变量、Cookie&#x2F;Storage 侧影响等）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">release</span><span class="hljs-params">(ownerId: <span class="hljs-type">String</span>)</span></span> &#123;<br>    ensureMainThread()<br><br>    <span class="hljs-keyword">val</span> pooled = inUse.remove(ownerId) ?: <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment">// 解绑 Activity，避免泄漏</span><br>    pooled.wrapper.baseContext = appContext<br><br>    <span class="hljs-comment">// 清理 + 销毁（务必在主线程）</span><br>    destroySafely(pooled.webView)<br><br>    <span class="hljs-comment">// 补一个新的回到空闲池（保持池大小）</span><br>    <span class="hljs-keyword">if</span> (idle.size &lt; maxIdle) &#123;<br>        idle.addLast(createPooledWebView(appContext))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">destroySafely</span><span class="hljs-params">(wv: <span class="hljs-type">WebView</span>)</span></span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 从父容器移除</span><br>        (wv.parent <span class="hljs-keyword">as</span>? ViewGroup)?.removeView(wv)<br><br>        <span class="hljs-comment">// 停止加载与计时器</span><br>        wv.stopLoading()<br>        wv.onPause()<br>        wv.pauseTimers()<br><br>        <span class="hljs-comment">// 清理状态（按需增删）</span><br>        wv.loadUrl(<span class="hljs-string">&quot;about:blank&quot;</span>)<br>        wv.clearHistory()<br>        wv.clearCache(<span class="hljs-literal">true</span>)<br>        wv.clearFormData()<br><br>        <span class="hljs-comment">// 移除 JS 接口（如果你有注入）</span><br>        <span class="hljs-comment">// wv.removeJavascriptInterface(&quot;xxx&quot;)</span><br><br>        wv.webChromeClient = <span class="hljs-literal">null</span><br>        wv.webViewClient = <span class="hljs-literal">null</span><br><br>        wv.destroy()<br>    &#125; <span class="hljs-keyword">catch</span> (_: Throwable) &#123;<br>        <span class="hljs-comment">// 避免回收流程因异常中断</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-5-池状态：便于测试与埋点"><a href="#4-5-池状态：便于测试与埋点" class="headerlink" title="4.5 池状态：便于测试与埋点"></a>4.5 池状态：便于测试与埋点</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PoolSnapshot</span>(<br>    <span class="hljs-keyword">val</span> idleCount: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> inUseCount: <span class="hljs-built_in">Int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">snapshot</span><span class="hljs-params">()</span></span>: PoolSnapshot &#123;<br>    <span class="hljs-keyword">return</span> PoolSnapshot(idle.size, inUse.size)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ensureMainThread</span><span class="hljs-params">()</span></span> &#123;<br>    check(Looper.getMainLooper() == Looper.myLooper()) &#123;<br>        <span class="hljs-string">&quot;WebViewPool must run on main thread.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-测试怎么做才算“有效”"><a href="#5-测试怎么做才算“有效”" class="headerlink" title="5. 测试怎么做才算“有效”"></a>5. 测试怎么做才算“有效”</h2><p>建议至少覆盖三类验证：</p><ol><li><p><strong>耗时指标</strong></p><ul><li><p>页面进入耗时（到首屏&#x2F;到可交互）</p></li><li><p>WebView 创建耗时（优化后应接近 0，或稳定下降）</p></li></ul></li><li><p><strong>稳定性</strong></p><ul><li><p>频繁进出（100 次级别）</p></li><li><p>冷启动后首次进入与后续进入</p></li><li><p>低端机验证</p></li></ul></li><li><p><strong>多进程</strong></p><ul><li><p>每个进程独立池</p></li><li><p>输出当前进程名 + 池子计数，避免“以为复用了，实际没复用”</p></li></ul></li></ol><hr><h2 id="6-常见坑与边界"><a href="#6-常见坑与边界" class="headerlink" title="6. 常见坑与边界"></a>6. 常见坑与边界</h2><ul><li><p><strong>池子别开太大</strong>：WebView 吃内存，通常从 1 开始，按收益再加。</p></li><li><p><strong>用过的 WebView 直接复用</strong>风险很高：历史栈、JS 全局变量、页面注入、对象引用都可能污染下一次页面。</p></li><li><p><strong>必须主线程操作</strong>：创建、销毁、loadUrl、attach&#x2F;detach 等都应在主线程。</p></li><li><p><strong>Context 切换要严格</strong>：借出切到 Activity，归还切回 Application，避免泄漏。</p></li></ul><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>WebView 缓存池的本质是“把创建成本前置，用统一生命周期管理换稳定的性能收益”。在高频 H5 场景下，它能非常直接地改善首屏体验，并且工程上可控、可回滚、可观测。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.Android其他优化</title>
    <link href="/2025/12/f43e3cf48b3d.html"/>
    <url>/2025/12/f43e3cf48b3d.html</url>
    
    <content type="html"><![CDATA[<h2 id="WebView-性能优化"><a href="#WebView-性能优化" class="headerlink" title="WebView 性能优化"></a>WebView 性能优化</h2><p>[[4-WebView 缓存池]]</p><ul><li>在客户端刚启动时，就初始化一个全局的 WebView 待用，并隐藏；当用户访问了 WebView 时，直接使用这个 WebView 加载对应网页，并展示。这种方法可以比较有效的减少初始化 WebView 的时间。</li><li>主要的还是 h5那边的优化</li><li>Android 版本不同，采用了不同的内核，兼容性 crash</li><li>oom：WebView 动态加载。就是不在 xml 中写 WebView，写一个 layout，然后把 WebView add 进去。</li><li>腾讯 X5内核相对于系统 webview 好的多。</li><li>单&#x2F;多进程化：webView 在独立的进程里面，那么 WebView 的进程崩溃不会影响到主进程运行；同时 WebView 的安全漏洞也很难影响到主进程；如果是多进程的话，可以使用 WebView 的容器池，有二次秒开的作用；不过缺点就是需要你做好和 WebView 的跨进程通讯了。</li></ul><blockquote><p>开一个 webview 的多进程 WebActivity ，里面放着另一个进程的 CommonWebFragment，完后把 URL 传过去就可以加载了。如果需要交互得用到 aidl 多进程通讯</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-93885f320fefe236b76196fbcf6ad5a0-unknown_filename.7-ef69d2.png" alt="unknown_filename.7"></p></blockquote><ul><li>网络优化：我们可以让 WebView 的 host 和客户端的 host 保持一致，那么就达到复用 DNS 缓存的效果；如果客户端有针对网络请求进行了优化，那么可以让 WebView 的全部网络请求托管给客户端</li><li>H5离线包：这个是手 Q 的 H5方案之一，让客户端提前去下载离线的 H5数据包，WebView 只需要加载本地 H5数据包即可，这么做不仅可以避免一些 http 的劫持，而且跳过了 WebView 的建立 TCP 连接和 H5、CCS 等数据下载的过程，直接开始 UI 渲染，大大提高了 WebView 的效率</li><li>用户体验方面，可以在顶部显示一个一个 progress，显示网页加载进度，而不是一个白屏呈现给用户看。</li><li>设置一个全局的 WebView，减少 WebView 初始化的时间，避免后续操作的堵塞</li></ul><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>removeView、clearHistory、clearView、destroy、置为 null，各种 dialog dismiss</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">fun <span class="hljs-title function_">destroyWebView</span><span class="hljs-params">()</span> &#123;<br>bridgeWebView?.let &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">val</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> it.parent<br>parent?.let &#123; p -&gt;<br>(p as ViewGroup).removeView(bridgeWebView)<br>&#125;<br>it.stopLoading()<br>it.settings.javaScriptEnabled = <span class="hljs-literal">false</span><br>it.loadDataWithBaseURL(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>, <span class="hljs-literal">null</span>)<br>it.clearHistory()<br>it.clearView()<br>it.removeAllViews()<br>fileJsController?.release()<br>it.destroy()<br>bridgeWebView = <span class="hljs-literal">null</span><br>dialog?.dismiss()<br>activateDialog?.dismiss()<br>&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>e.printStackTrace()<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引擎初始化"><a href="#引擎初始化" class="headerlink" title="引擎初始化"></a>引擎初始化</h3><p>WebView 在实例化的时候，需要<em>先初始化 Chromium 引擎</em>，而 Chromium 引擎又是一个重量级的组件，而且很多初始化的工作都需要在主线程中完成，这样就很容易造成主线程卡顿甚至 ANR。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShadowWebView</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preloadWebView</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Application app)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            app.getMainLooper().getQueue().addIdleHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>.IdleHandler() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span><span class="hljs-params">()</span> &#123;<br>                    startChromiumEngine();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable t) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Oops!&quot;</span>, t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startChromiumEngine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> invokeStaticMethod(Class.forName(<span class="hljs-string">&quot;android.webkit.WebViewFactory&quot;</span>), <span class="hljs-string">&quot;getProvider&quot;</span>);<br>            invokeMethod(provider, <span class="hljs-string">&quot;startYourEngines&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;<span class="hljs-type">boolean</span>.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">true</span>&#125;);<br>            Log.i(TAG, <span class="hljs-string">&quot;Start chromium engine complete: &quot;</span> + (SystemClock.uptimeMillis() - t0) + <span class="hljs-string">&quot; ms&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable t) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Start chromium engine error&quot;</span>, t);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ShadowWebView 通过 WebViewTransformer 在 Application onCreate () 回调中注入 ShadowWebView.preloadWebView ()，当主线程 IDLE 时，启动 Chromium 引擎。</p><p>该方案的优点是无侵入、接入成本低，缺点是由于这种方式反射了非公开 API，可能存在兼容性问题。</p><h2 id="过度绘制、布局优化"><a href="#过度绘制、布局优化" class="headerlink" title="过度绘制、布局优化"></a>过度绘制、布局优化</h2><p>[[2.Handler 里的各种消息]]</p><h3 id="Overdraw-过度绘制"><a href="#Overdraw-过度绘制" class="headerlink" title="Overdraw (过度绘制)"></a>Overdraw (过度绘制)</h3><p>描述的是<em>屏幕上的某个像素在同一帧的时间内被绘制了多次</em>。在多层次的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，这就会导致某些像素区域被绘制了多次，可能出现卡顿现象，浪费大量的 CPU 以及 GPU 资源。也会出现耗电的问题。调试 GPU 过渡绘制— 显示过渡绘制区域</p><ul><li>颜色标识: 从好到差: 蓝-绿-淡红-红</li><li>验收标准:</li></ul><ol><li>控制过度绘制为2x（绿色）</li><li>不允许存在4x（红色）过度绘制</li><li>不允许存在面积超过屏幕1&#x2F;4区域的3x 过度绘制（淡红色区域）</li></ol><h3 id="处理方案：布局的优化"><a href="#处理方案：布局的优化" class="headerlink" title="处理方案：布局的优化"></a>处理方案：布局的优化</h3><ol><li>减少一个布局的不必要节点，减少层级，可以使用 sdk 提供的工具 Hierarchy Viewer 进行层级查看具体使用</li><li>使用&lt; merge &#x2F;&gt;标签减少布局的嵌套层次，根布局 content 就是个 fragment，如果自己就是 fragment，就可以使用 merge。merge 必须放在布局文件的根节点上。通常和 include 一起使用。</li><li>使用&lt; ViewStub &#x2F;&gt;标签来加载一些不常用的布局（懒加载），多状态，有数据，空数据，加载失败，加载异常，网络异常等。</li><li>减少多余的 background</li><li>使用约束布局</li><li>尽量使用 view 自身的参数，例如：Button, 有一个可以把图绘制在左边的参数:android:drawableLeft</li><li>尽量重用一个布局文件，使用 include 标签，多个相同的布局可以复用</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-246cacada30d0c628b8117abffb00621-unknown_filename.2-c8a0a9.png" alt="unknown_filename.2"></p><p>viewStub 子 view 必须有个父 view 包裹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> layout: View? = <span class="hljs-literal">null</span><br><span class="hljs-title function_">if</span> <span class="hljs-params">(viewStub3.parent != <span class="hljs-literal">null</span>)</span> &#123;   <br>layout = viewStub3?.inflate()    <br>viewStub3.visibility = View.VISIBLE    <br><span class="hljs-type">var</span> <span class="hljs-variable">voiceView</span> <span class="hljs-operator">=</span>        <br>layout?.findViewById&lt;InteractionVoicePlayerView&gt;(R.id.voiceView)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ViewStub 原理<br>在布局层次中占据一个空白的位置，并在需要时通过动态替换成指定的布局。<br>当 ViewStub 被添加到布局中时，它只占据非常少的内存，并且不会立即加载或渲染其布局资源。它只有在被显式调用 inflate () 方法或设置 visibility 为可见时，才会加载并填充其指定的布局资源。<br>一旦 <code>ViewStub</code> 被加载（inflated），它就<strong>不再是布局的一部分</strong>（被实际布局替换）</p><p>【强制】<br>页面拥上的 View 越多， measure、 layout、 draw 所花费的时间就越久。要缩短这个时间，关键是保持 View 的树形结构尽量扁平，而且要移除所有不需要渲染的 View。理想情况下，总共的 measure， layout， draw 时间应该被很好的控制在 16ms 以内，以保证滑动屏幕时 UI 的流畅。</p><h3 id="AsyncLayoutInflater"><a href="#AsyncLayoutInflater" class="headerlink" title="AsyncLayoutInflater"></a>AsyncLayoutInflater</h3><p>异步布局加载<br>AsyncLayoutInflater 的使用非常简单，就是把 setContentView 和一些 view 的初始化操作都放到了 onInflateFinished 回调中<br>有局限，所有构建的 View 中必须不能直接使用 Handler 或者是调用 Looper. myLooper ()，因为异步线程默认没有调用 Looper. prepare ()，可以优化</p><p><a href="https://mp.weixin.qq.com/s/wmFBPYkwGh8ijQMODF27Fw">https://mp.weixin.qq.com/s/wmFBPYkwGh8ijQMODF27Fw</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>       <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncLayoutInflater</span>(<span class="hljs-built_in">this</span>).inflate(R.layout.activity_main,<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncLayoutInflater</span>.OnInflateFinishedListener()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInflateFinished</span><span class="hljs-params">(View view, <span class="hljs-type">int</span> resid, ViewGroup parent)</span> &#123;<br>               setContentView(view);<br>               rv = findViewById(R.id.tv_right);<br>           &#125;<br>       &#125;);<br>    <br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="APK-体积优化大小"><a href="#APK-体积优化大小" class="headerlink" title="APK 体积优化大小"></a>APK 体积优化大小</h2><p><a href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.md">Android-Notes&#x2F;blogs&#x2F;Android&#x2F;性能优化&#x2F;包体积优化.md at master · Omooo&#x2F;Android-Notes</a></p><p>删、缩、挪<br>对于低端机来说，过多的 dex 文件编译会严重影响冷启动时间，应用在运行时，Resource 资源、Library 以及 Dex 类加载这些都会占用不少的内存。安装包在解压后，占用 ROM 空间可能会翻倍，对 ROM 空间占用也会有一定压力。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul><li>保持良好的编程习惯，不要重复或者不用的代码，谨慎添加 libs，移除使用不到的 libs。 </li><li>native code 的部分，大多数情况下只需要支持 armabi 与 x86的架构即可。如果非必须，可以考虑拿掉 x86的部分。</li><li>代码压缩与优化: 在打包编译的时候自动移除无用资源，使用 R8 进行无用代码移除，并使用 gradle 插件进行无用资源的移除。同时，可以考虑使用 Proguard 进行代码压缩和混淆，减少包体积。Debug 的时候不用混淆，因为会压缩，删除，编译变慢</li></ul><h3 id="缩"><a href="#缩" class="headerlink" title="缩"></a>缩</h3><p>使用 Lint 工具查找没有使用到的资源。去除不使用的图片，String，XML 等等。 assets 目录下的资源请确保没有用不上的文件。生成 APK 的时候，aapt 工具本身会对 png 做优化，但是在此之前还可以使用其他工具如 tinypng 对图片进行进一步的压缩预处理。 jpeg 还是 png，根据需要做选择，在某些时候 jpeg 可以减少图片的体积。也可以使用 webp 图片。</p><p>尽可能的重用已有的图片资源。例如对称的图片，只需要提供一张，另外一张图片可以通过代码旋转的方式实现。<br>能用代码绘制实现的功能，尽量不要使用大量的图片。例如减少使用多张图片组成 animate-list 的 AnimationDrawable，这种方式提供了多张图片很占空间。</p><blockquote><p>使用 svg 图片<br>(Scalable Vector Graphics)，可缩放矢量图。SVG 不会像位图一样因为缩放而让图片质量下降。优点在于可以减小 APK 的尺寸。常用于简单小图标。无论放大缩小都不会失真<br>Android 中只支持 vector，我们可以通过 vector 将 svg 的根节点 svg 转换为 vector。<br><strong>SVG 批量转换</strong><br>java -jar svg2vector-cli-1.0.0. jar -d . -o a -h 20 -w 20<br>-d 指定 svg 文件所在目录<br>-o 输出 android vector 图像目录<br>-h 设置转换后 svg 的高<br>-w 设置转换后 svg 的宽<br>Android 5.0（API 21）之前的版本不支持矢量图，使用 Vector Asset Studio 有两种方式适配</p></blockquote><p>WebP：相比于JPEG、PNG和GIF，通常能提供更小的文件体积（在相同质量下）；支持透明背景（类似PNG）和动画（替代GIF）</p><h3 id="挪"><a href="#挪" class="headerlink" title="挪"></a>挪</h3><p>图片优化: 将图片上传到服务器，并通过动态下载的方式减少包体积。这种方式适用于首次加载时依赖网络环境的情况。另外，可以采用图片着色器来处理同图不同色的情况，避免需要多张图片。</p><p>assets 目录下也可以挪<br>so 动态下发有可能下载失败，毕竟是少部分用户，不可能一直下载不下来。另外所有用户都有收益，那这个就值得做。</p><p>大多的 X86设备除了支持 X86类型的 SO 库，还兼容 ARM 类型的 SO 库，所以应用市场上大部分的 APP 只适配了 ARM 类型的 SO 库</p><ol><li>判断目录中是否存在 so 文件, 存在则直接调用第三方 sdk</li><li>不存在 SO 文件从服务器下载相应的 so 库 (大的话可以压缩)</li><li>将 so 库复制到&#x2F;data&#x2F;data&#x2F;packagename&#x2F;…（context.getDir (“libs”, Context. MODE_PRIVATE)）</li><li>System.loadLibrary (xx)</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><h4 id="AndResGuard"><a href="#AndResGuard" class="headerlink" title="AndResGuard"></a>AndResGuard</h4><blockquote><p>目前 R8 已经支持资源路径混淆，并且也支持白名单配置。AndResGuard 可能要退出历史舞台了。</p></blockquote><p>resource. arsc – &gt; Android Resource</p><ul><li>andresguard，路径变成了 r&#x2F;d&#x2F;a，在 AndResGuard 中，我们支持针对 resources. arsc、PNG、JPG 以及 GIF 等文件的强制压缩。资源混淆，res 下的图片名字也改了</li><li><em>用的7z，有着更好的压缩率</em></li></ul><p>res 变成了 r<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-e95c9dd075233784e2ff4d3220a9a6a3-unknown_filename.8-c64873.png" alt="unknown_filename.8"><br>原理：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-ad9f3136fa75fbec1b82e870e60add2d-unknown_filename.9-df167f.png" alt="unknown_filename.9"></p><h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><p>耗电优化的第一个方向是优化应用的后台耗电。因为用户最容易感知这个，我明明没有怎么打开，为什么耗这么多？在后台不要做这些：长时间获取 WakeLock (及时释放)、WiFi 和蓝牙的扫描、GPS、video、audio</p><ul><li>减少 cpu 占用率</li><li>网络传输：设备以最大的传输速率进行操作。</li><li>数据压缩：缩减传输时间，降低电量消耗</li><li>选择更快的传输方式：虽然4G 芯片比 Wifi 芯片耗电低，但 Wifi 的速率可以让数据在较短时间内完成传输，从而降低电量消耗。</li><li>请求集中发送</li><li>gps 的使用：不同的场景以及不同类型的 App 对定位更加需要个性化的区分。即时注销定位监听</li><li>谨慎使用 WakeLock：Wake Lock 是一种锁的机制，只要有人拿着这个锁，系统就无法进入休眠。一些 App 为了能在后台持续做事情，就会持有一个 WakeLock</li><li>动态注册广播</li><li>使用 JobScheduler，一些任务通过 JobScheduler 来触发，例如可推迟的网络请求、下载、GPS 等，可以在特定场景：连接 Wifi、连接电源等场景触发。既完成了任务，也无需考虑由于一些任务导致的电量消耗。（监听网络环境改变）</li></ul><p>Android 最近几版的特色主要集中在省电和后台管理上，O 的发布，对 Service 和 Broadcast 又近一步加强了管束。主要可概括为如下两点：</p><ol><li>后台应用不被允许创建后台服务，必须通过 JobScheduler 或者 Context.startForegroundService ()进行创建</li><li>特定的隐式广播不再被允许启动，必须通过 JobScheduler 调用或者显式注册的方式才能启动</li></ol><p>JobSchedule 的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理。这样做有两个好处：避免频繁的唤醒硬件模块，造成不必要的电量消耗以及避免在不合适的时间 (例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量。</p><ul><li>使用 Battery History</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">adb kill-serveadb devices adb start-server<br>adb shell dumpsys batterystats --enable full-wake-historyadb shell dumpsys batterystats --reset<br><br>adb bugreport &gt; bugreport. txtadb shell dumpsys batterystats &gt; batterystats. txt<br>adb shell dumpsys batterystats &gt; com. example. android. demo. app &gt; batterystats. txt<br><span class="hljs-number">7.0</span>以上<br>adb bugreport bugreport. zip<br>D:\PycharmProjects\goProjects\src\github. com\google\battery-historian\<br>go run cmd/battery-historian/battery-historian. go http:<span class="hljs-comment">//localhost:9999/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.图片、glide优化</title>
    <link href="/2025/12/8d549286cbae.html"/>
    <url>/2025/12/8d549286cbae.html</url>
    
    <content type="html"><![CDATA[<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><p>[[7-图片低配系统 oom 优化]]</p><p>一、图片压缩的意义是什么</p><p>1.节约流量、2.降低服务器带宽、3.降低 app 内存占用</p><p>二、图片压缩的分类</p><p>1.质量压缩(图片存储卡大小)<br>2.尺寸压缩 (内存)</p><p><strong>如果是一张的话压缩处理，大量图片的话用 lru</strong></p><p>int maxMemory &#x3D; (int) (Runtime.getRuntime().maxMemory() &#x2F; 1024)</p><ul><li>若发生OOM，则使用try catch将其捕获，然后清除图片cache，尝试降低bitmap format</li><li>图库占用内存过多也可以采用单独的进程。</li><li>html用webview加载了也就10几行代码，古董机也可以加载出来</li></ul><h3 id="view-的宽高比图片小如何优化"><a href="#view-的宽高比图片小如何优化" class="headerlink" title="view 的宽高比图片小如何优化"></a>view 的宽高比图片小如何优化</h3><p>PNG 图片部分：<br>我们修改 imageview 的大小并不会影响 PNG 图片占用内存大小：宽 X 高 X 像素占用字节</p><p>SVG 矢量图部分：<br>我们修改 imageview 的大小并不会SVG影响图片占用内存大小，需要注意的是 SVG 图片实际的显示分辨率是由SVG 的 xml文件中的 width&#x2F;height 决定的，所以<em>SVG 既然支持缩放，那我们就把宽高写小</em>了好了，这样可以省内存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>图片压缩大概分为两类，质量压缩和尺寸压缩。例如一些固定宽高的图片，feed，头像等等就可以对尺寸压缩，或者指定宽高的图片（oss、svg）。修改图片的格式、质量、编码格式。在内存不足的时候可以清除内存缓存，在滚动的时候可以暂停图片加载，停下来的时候再去加载。</p></li><li><p>glide也可以裁剪（请求属性不申请内存）。</p></li><li><p><strong>onTrimMemory，调用 Glide.cleanMemroy() 清理掉所有的内存缓存</strong>。（内部是LruBitmapPool ）</p></li><li><p>升级到 Glide4.0，使用 asDrawable 代替 asBitmap，drawable 更省内存。（或者下载下来，用空间换时间）</p></li><li><p>对于一些低端设备，我们可以将图片格式从 ARGB_8888 变为 RGB_565，可以让图片内存的占用减少一半</p><blockquote><p>低端机判断：<br>总内存小、Cpu (1.5G 低端)、SDK</p></blockquote></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (view.getContext() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (scrollState) &#123;<br>            <span class="hljs-keyword">case</span> SCROLL_STATE_IDLE:<br>                Glide.<span class="hljs-keyword">with</span>(view.getContext()).resumeRequests()<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>            <span class="hljs-keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:<br>            <span class="hljs-keyword">case</span> SCROLL_STATE_FLING:<br>                Glide.<span class="hljs-keyword">with</span>(view.getContext()).pauseRequests()<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="createBitmap"><a href="#createBitmap" class="headerlink" title="createBitmap"></a>createBitmap</h4><p>Bitmap.createBitmap () 方法，从名字上就可以看出，它是为了创建一个 Bitmap 对象，绘制的时候用。<br>利用 Glide 的来优化此步骤，就需要用到 BitmapPool。BitmapPool 本身是一个接口，我们通常会使用到它的实现类 LruBitmapPool，从名称就可以看出，它基于 LRU 的规则，在一定的内存限制下，缓存和管理一些可供重用的 Bitmap 对象。不必重新创建。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> bitmapPool = Glide.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>).bitmapPool<br><span class="hljs-keyword">val</span> bitmap = bitmapPool.<span class="hljs-keyword">get</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,Bitmap.Config.ARGB_8888)<br><span class="hljs-keyword">if</span> (bitmap==<span class="hljs-literal">null</span>) &#123;<br>    bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);<br>&#125;<br><span class="hljs-comment">// 处理 → 使用 bitmap</span><br><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// 用完回收 bitmap</span><br>bitmapPool.put(bitmap)<br></code></pre></td></tr></table></figure><h4 id="超长图"><a href="#超长图" class="headerlink" title="超长图"></a>超长图</h4><p>对于不失真的超长图，超大图，可以使用系统的API <strong>BitmapRegionDecoder</strong> ，它可以用来显示图片指定的一个矩形区域。通过自定义View重写onTouchEvent()判断手势滑动位置，从而改变矩形区域的位置，重新计算mRect（ruai kte）去获取<em>部分bitmap</em>绘制到屏幕上。invidedata刷新ondraw。<br>可以用开源库：subsampling-scale-image-view</p><h4 id="重复图片监控"><a href="#重复图片监控" class="headerlink" title="重复图片监控"></a><strong>重复图片监控</strong></h4><p>重复图片指的是 Bitmap 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。之前我实现过一个内存 Hprof 的分析工具，它可以自动将重复 Bitmap 的图片和引用链输出。下图是一个简单的例子，你可以看到两张图片的内容完全一样，通过解决这张重复图片可以节省 1MB 内存<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%9B%BE%E7%89%87glide%E4%BC%98%E5%8C%96.resources/2023/09/15/18-47-41-cbb9cee8c56cf98dbc9c728a66e82e48-unknown_filename.5-299a8a.png" alt="unknown_filename.5"></p><p><strong>三级缓存</strong></p><ul><li>先读取内存缓存, 因为优先加载, 速度最快，内存缓存没有再读取本地缓存, 次优先加载, 速度也快，本地没有再加载网络缓存, 速度慢,浪费流量在网络缓存中从网络下载图片，并且保存在本地和内存中，在下载的时候可以对图片进行压缩</li><li>服务器端下载的图片是使用 Http的缓存机制，每次执行将本地图片的时间发送给服务器，如果俩次访问的时间间隔短，返回码是 304，会读取网络缓存（说明服务端的图片和本地的图片是相同的，直接使用本地保存的图片），如果返回码是 200，则开始下载新的图片并实现缓存。在从服务器获取到图片后，需要再在本地和内存中分别存一份，这样下次直接就可以从内存中直接获取了，这样就加快了显示的速度，提高了用户的体验。</li></ul><h4 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h4><p>FrameSequence是Android framework中里的一个工具包。 它封装了: libgif (gif编解码库c++ )，并提供Java API播放gif。使用它要比glide加载GIF效果效果要好，glide加载加载GIF图片CPU占用高，并且内存占用一直在增加。使用FrameSequence库就可以解决，不过每次判断去怎么加载很麻烦，可以使用glide的AppGlideModule apt注解解析器来自动生成代码。判断GIF图片时将InputStream转成FrameSequenceDrawable解析。这个还可以做播放Webp动画。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>自定义GlideModule。设置MemoryCache和BitmapPool大小，在未复用的情况下，每张图片都需要一块内存。而使用复用的时候，如果存在能被复用的图片会重复使用该图片的内存。所以复用不能减少程序正在使用的内存大小，而是解决了频繁申请内存导致的内存抖动、碎片等问题。</p><h3 id="优化bitmap"><a href="#优化bitmap" class="headerlink" title="优化bitmap"></a>优化bitmap</h3><h4 id="inBitmap"><a href="#inBitmap" class="headerlink" title="inBitmap"></a><strong>inBitmap</strong></h4><ul><li><code>inBitmap</code> 是 <code>BitmapFactory.Options</code> 中的一个参数  </li><li>作用：<strong>复用已有 Bitmap 的内存，而不是重新分配和回收内存</strong></li><li>优点：<ul><li>减少内存分配</li><li>降低 GC 频率</li><li>提升图片加载性能</li></ul></li></ul><p>二、使用 inBitmap 的基本套路（两步走）</p><ol><li><strong>先解码一张可复用的 Bitmap</strong></li><li><strong>后续解码时通过 inBitmap 复用这块内存</strong></li></ol><p>最简单示例（Android 4.4+）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 解码第一张 Bitmap，作为可复用内存</span><br>BitmapFactory.<span class="hljs-type">Options</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapFactory</span>.Options();<br>options.inMutable = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 必须设置为 true</span><br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">reusableBitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeResource(<br>        getResources(), R.drawable.img_1, options<br>);<br><br><span class="hljs-comment">// 2. 使用 inBitmap 复用内存解码第二张 Bitmap</span><br>BitmapFactory.<span class="hljs-type">Options</span> <span class="hljs-variable">reuseOptions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapFactory</span>.Options();<br>reuseOptions.inMutable = <span class="hljs-literal">true</span>;<br>options.inSampleSize = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 图片缩放采样</span><br>reuseOptions.inBitmap = reusableBitmap;<br><br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap2</span> <span class="hljs-operator">=</span> BitmapFactory.decodeResource(<br>        getResources(), R.drawable.img_2, reuseOptions<br>);<br></code></pre></td></tr></table></figure><p>Android 版本差异</p><p>Android 4.4 之前（API &lt; 19）</p><ul><li>inBitmap 复用条件非常严格</li><li>旧 Bitmap 和新 Bitmap 必须：<ul><li>宽度相同</li><li>高度相同</li><li>Bitmap. Config 相同</li></ul></li></ul><blockquote><p>结论：<strong>规格必须完全一致，否则无法复用</strong></p></blockquote><hr><p>Android 4.4 之后（API ≥ 19）</p><ul><li>系统放宽了 inBitmap 的限制</li><li>只要满足：<ul><li><strong>旧 Bitmap 占用的内存大小 ≥ 新 Bitmap 所需内存大小</strong></li></ul></li></ul><p>示例：</p><ul><li>大图 → 小图 ✅</li><li>小图 → 大图 ❌</li></ul><p>常见崩溃点（高频面试点）</p><p>忘记设置 inMutable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">options.inMutable = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>IllegalArgumentException: Problem decoding into existing bitmap</p><p>inBitmap 通过复用已存在 Bitmap 的内存，减少内存分配和 GC；Android 4.4 之后只要旧 Bitmap 的内存大于等于新 Bitmap 即可复用，但必须设置 inMutable。</p><h4 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h4><p>options.insamplesize &#x3D; calculateInsampleSize(options，reqWidth: 100，reqHeight: 100); &#x2F;&#x2F;算出采样率（临近采样压缩算法）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%9B%BE%E7%89%87glide%E4%BC%98%E5%8C%96.resources/2023/09/15/18-47-41-e9e1e0c0ce1bdad78ad6214a83b84dcc-unknown_filename.4-099550.png" alt="unknown_filename.4"><br>一般会这两种算法一起用压缩图片</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap compressBySampleSize(<span class="hljs-keyword">final</span> Bitmap src,<br>                                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxWidth,<br>                                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxHeight,<br>                                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> recycle) &#123;<br>    <span class="hljs-keyword">if</span> (isEmptyBitmap(src)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    BitmapFactory.<span class="hljs-keyword">Options</span> <span class="hljs-keyword">options</span> = <span class="hljs-keyword">new</span> BitmapFactory.<span class="hljs-keyword">Options</span>();<br>    <span class="hljs-keyword">options</span>.inJustDecodeBounds = <span class="hljs-keyword">true</span>;<br>    ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>    src.compress(CompressFormat.JPEG, <span class="hljs-number">100</span>, baos);<br>    <span class="hljs-keyword">byte</span>[] bytes = baos.toByteArray();<br>    BitmapFactory.decodeByteArray(bytes, <span class="hljs-number">0</span>, bytes.length, <span class="hljs-keyword">options</span>);<br>    <span class="hljs-keyword">options</span>.inSampleSize = calculateInSampleSize(<span class="hljs-keyword">options</span>, maxWidth, maxHeight);<br>    <span class="hljs-keyword">options</span>.inJustDecodeBounds = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (recycle &amp;&amp; !src.isRecycled()) src.recycle();<br>    <span class="hljs-keyword">return</span> BitmapFactory.decodeByteArray(bytes, <span class="hljs-number">0</span>, bytes.length, <span class="hljs-keyword">options</span>);<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h4><p>bitmap.compress时可以指定它的的格式和图片质量<br>webp&lt;jpeg&lt;png（无损压缩）<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%9B%BE%E7%89%87glide%E4%BC%98%E5%8C%96.resources/2023/09/15/18-47-41-9a5cf42f99501286cdaa5875e3cdd162-unknown_filename.2-a5fa5d.png" alt="unknown_filename.2"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 将图片保存在本地，</span><br>bitmap.compress(CompressFormat.JPEG, <span class="hljs-number">100</span>,<br><span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">file</span>));<span class="hljs-comment">//100是质量</span><br>Bitmap bitmap = BitmapFactory.decodeStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">file</span>));<span class="hljs-comment">//decodeStream放的是输入输出流</span><br><span class="hljs-keyword">return</span> bitmap;<br></code></pre></td></tr></table></figure><h4 id="加载大图片"><a href="#加载大图片" class="headerlink" title="加载大图片"></a>加载大图片</h4><p>正常一张720x1080的图片在内存中占多少空间？怎么加载大图片？如何面对大的 bitmap如何处理？</p><ol><li>看他的渲染方式，占用的字节不同的。RGB888每个像素占用4个字节，很容易内存溢出</li><li>图片的总大小 &#x3D; 图片的总像素 * 每个像素占用的大小</li><li>计算机把图片所有像素信息全部解析出来，保存至内存，很容易内存溢出</li></ol><p>加载大图片<br>可以对图片的宽高和质量进行压缩,步骤：<br>获取屏幕宽高，获取图片宽高，图片的宽高除以屏幕宽高，算出宽和高的缩放比例，取较大值作为图片的缩放比例，且大于1才缩放，然后按缩放比例加载图片<br>获取屏幕宽高 、获取图片宽高<br>&#x2F;&#x2F;请求图片属性但不申请内存<br>opts.inJustDecodeBounds &#x3D; true;</p><p><strong>在不失真的条件下显示一张超高清的图片或者长图？</strong><br>针对这个问题，我自己一般用以下两种方法解决：</p><ol><li>使用WebView来加载该图片；</li><li>网络大图：Http协议中的Range &#x2F; Accept-Range ，他可以指定获取body的一部分，从而达到分块加载图片的效果；</li><li>subsampling-scale-image-view（底层就是BitmapRegionDecoder）</li><li><strong>BitmapRegionDecoder</strong> 可以用来显示图片指定的一个矩形区域。通过自定义View重写onTouchEvent()判断手势滑动位置，从而改变矩形区域的位置，重新计算mRect（ruai k te）去获取部分bitmap绘制到屏幕上。invidedata刷新ondraw</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@Override <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onDraw(Canvas canvas) &#123; <br>BitmapRegionDecoder，<span class="hljs-keyword">options</span>就是BitmapFactory.<span class="hljs-keyword">Options</span><br>      Bitmap bm = mDecoder.decodeRegion(mRect, <span class="hljs-keyword">options</span>);<br>      canvas.drawBitmap(bm, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br>&#125; <br><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lmj623565791/article/details/49300989/">https://blog.csdn.net/lmj623565791/article/details/49300989/</a></p><p>GestureDetector 方便点</p><h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><p><strong>glide 问题</strong></p><p>使用Glide时，注意对传入的Acticity与Fragment进行判断，避免传入已经销毁Acticity，造成IllegalArgumentException异常。可以参考这篇<a href="https://blog.csdn.net/loners_/article/details/73521968">Glide类似You cannot start a load for a destroyed activity异常简单分析</a></p><h4 id="优化GIF"><a href="#优化GIF" class="headerlink" title="优化GIF"></a>优化GIF</h4><p>FrameSequence是Android framework中里的一个工具包。 它封装了: giflib (gif编解码库c++ )，并提供Java API播放gif。使用它要比glide加载GIF效果效果要好，glide加载加载GIF图片CPU占用高，并且内存占用一直在增加。使用FrameSequence库就可以解决，不过每次判断去怎么加载很麻烦，可以使用glide的AppGlideModule apt注解解析器来自动生成代码。判断GIF图片时将InputStream转成FrameSequenceDrawable解析。这个还可以做播放Webp动画。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GlideModule</span><br>public class GifGlideModule extends AppGlideModule &#123;<br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">registerComponents</span>(<br>    <span class="hljs-variable">@NonNull</span> Context context, <span class="hljs-variable">@NonNull</span> Glide glide, <span class="hljs-variable">@NonNull</span> Registry registry) &#123;<br>        <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.registerComponents</span>(context, glide, registry);<br>        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.append</span>(Registry.BUCKET_GIF,<br>                InputStream.class,<br>                FrameSequenceDrawable.class, new <span class="hljs-built_in">GifDecoder</span>(glide.<span class="hljs-built_in">getBitmapPool</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Glide加载Gif图片的原理：将gif根据每一帧解析成很张图片,然后在依次设置给ImageView。</p></blockquote><p><strong>FrameSequenceDrawable原理</strong><br>利用了两个Bitmap对象，其中一个用于绘制到屏幕上，另外一个用于解析下一张要展示的图片，利用了HandlerThread在子线程解析，每次解析的时候获取上一张图片的展示时间，然后使用Drawable自身的scheduleSelf方法在指定时间替换图片，在达到替换时间时，会调用draw方法，在draw之前先去子线程解析下一张要展示的图片，然后重复这个步骤，直到播放结束或者一直播放。</p><p><strong>需要自己编译</strong></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%9B%BE%E7%89%87glide%E4%BC%98%E5%8C%96.resources/2023/09/15/18-47-41-d013ac47e8d28dc68e35b2a37cf53e65-unknown_filename.3-bbc5f1.png" alt="unknown_filename.3"></p><h3 id="bitmap-复用"><a href="#bitmap-复用" class="headerlink" title="bitmap 复用"></a>bitmap 复用</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E5%9B%BE%E7%89%87glide%E4%BC%98%E5%8C%96.resources/2023/09/15/18-47-41-524c206d7f8e799e3f88d5be4cf09261-unknown_filename.1-d70d56.png" alt="unknown_filename.1"></p><p>加载进度需要自己实现</p><p><strong>Glide默认缓存</strong><br>内存缓存最大空间(maxSize)&#x3D;每个进程可用的最大内存 * 0.4<br>磁盘缓存大小: 250 * 1024 * 1024(250MB)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> DEFAULT_DISK_CACHE_SIZE = <span class="hljs-number">250</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br></code></pre></td></tr></table></figure><p>磁盘缓存目录磁盘缓存目录: 项目&#x2F;cache&#x2F;image_manager_disk_cache</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String DEFAULT_DISK_CACHE_DIR <span class="hljs-operator">=</span> <span class="hljs-string">&quot;image_manager_disk_cache&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>几乎所有的 OOM 错误都是因为宿主应用出了问题，而不是 Glide 本身。 应用里两种常见的 OOM 错误分别是：<br>过大的内存分配 (Excessively large allocations)<br>内存泄露(Memory leaks, 被分配的内存没有被释放)</p><ul><li>引入largeHeap属性，让系统为App分配更多的独立内存。</li><li>禁止Glide内存缓存。设置skipMemoryCache(true)。内存缓存是CPU，速度更快。</li><li>自定义GlideModule。设置MemoryCache和BitmapPool大小。</li><li>升级到Glide4.0，使用asDrawable代替asBitmap，drawable更省内存。（或者下载下来，用空间换时间）<br>   Bitmap 储存的是 像素信息（把所有信息都保存下来了，一个像素4个字节，想想有多大），Drawable 储存的是 对 Canvas 的一系列操作。而 BitmapDrawable 储存的是「把 Bitmap 渲染到 Canvas 上」这个操作。</li><li>ImageView的scaleType为fitXY时，改为fitCenter&#x2F;centerCrop&#x2F;fitStart&#x2F;fitEnd显示。</li><li><em>不使用application作为context</em>。当context为application时，会把imageView是生命周期延长到整个运行过程中，imageView不能被回收，从而造成OOM异常。</li><li>当列表在滑动的时候，调用Glide的pauseRequests()取消请求，滑动停止时，调用resumeRequests()恢复请求。</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (view.getContext() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (scrollState) &#123;<br>            <span class="hljs-keyword">case</span> SCROLL_STATE_IDLE:<br>                Glide.<span class="hljs-keyword">with</span>(view.getContext()).resumeRequests()<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>            <span class="hljs-keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:<br>            <span class="hljs-keyword">case</span> SCROLL_STATE_FLING:<br>                Glide.<span class="hljs-keyword">with</span>(view.getContext()).pauseRequests()<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><ul><li>Try catch某些大内存分配的操作。考虑在catch里面尝试一次降级的内存分配操作。例如decode bitmap的时候，catch到OOM，可以尝试把采样比例再增加一倍之后，再次尝试decode。</li><li>BitmapFactory.Options和BitmapFactory.decodeStream获取原始图片的宽、高，绕过Java层加载Bitmap，再调用Glide的override(width,height)控制显示。（？？）</li><li>onTrimMemory，调用 Glide.cleanMemroy() 清理掉所有的内存缓存。（内部是LruBitmapPool ）</li><li>如果是处于 lowMemory 的时候，将图片的 DecodeFormat 设置为 RGB_565</li><li>使用 glide 自己的圆角图片。bitmapTransfrom</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.冷启动优化</title>
    <link href="/2025/12/69d6bc2a702f.html"/>
    <url>/2025/12/69d6bc2a702f.html</url>
    
    <content type="html"><![CDATA[<h2 id="冷启动优化"><a href="#冷启动优化" class="headerlink" title="冷启动优化"></a>冷启动优化</h2><p><em>traceview 检查耗时的方法</em></p><p>App 进程的创建等环节我们是无法主动控制的。应用开发唯一能做的就是<em>减少在 Application 和第一个 Activity 中的工作量，从而缩短冷启动的时间</em>。</p><p>Application 会执行多次，要只在主 app 的 Application 执行，加速启动<br>if (AppUtils. inMainProcess (getApplication ()))</p><p>核心目标：<strong>减少首屏压力，让重要内容先出来</strong></p><ul><li><strong>分步加载</strong><br>  大的任务拆成小步骤，逐步完成</li><li><strong>异步加载</strong><br>  把耗时操作放到子线程执行</li><li><strong>延迟加载</strong><br>  👉 _非必要的数据延后加载_（首屏不需要的先别做）</li><li><strong>优先级控制</strong><br>  体积大、优先级低的任务靠后执行<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-872a5a864c80580899de8a7dfe2e0c14-unknown_filename.4-092937.png" alt="unknown_filename.4|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-72eb67eadf999b646d9508200bcb5fc9-unknown_filename.5-90cf7e.png" alt="unknown_filename.5|600"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-ebc96f2a1e2e0ecb1297ffb4fb16c7f5-unknown_filename.6-c5af45.png" alt="unknown_filename.6|600"></li></ul><p>非必要资源延迟初始化：用到的时候在加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LaunchTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;AppTheme&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/splash_bg<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul><li>避免在启动时做密集耗时的初始化</li><li>避免 I&#x2F;O 操作、网络操作、布局嵌套等考虑异步</li><li><strong>初始化三方组件，不阻塞主线程</strong>，比如：图片选择库、日志上传模块、统计、推送、语音库等等</li><li>使用 Activity 的 windowBackground 主题属性来为启动的 Activity 提供一个简单的 drawable，让用户产生一种速度加快的感觉。</li></ul><p>热启动和冷启动</p><ul><li>冷启动 ：在启动应用前，系统还没有 App 的任何进程。冷启动流程就是 app 启动流程全过程，包括创建 app 进程、加载资源、启动主线程等等。这种启动耗时最长。</li><li>热启动 ：app 进程处于后台，系统只是把它从后台带到前台，展示给用户。相比冷启动，热启动过程时间更短。但启动时，系统依然会展示一个空白背景，直到第一个 Activity 的内容呈现为止。</li></ul><p>IntentService</p><ul><li>使用 intentservice，普通服务后台任务运行完，即使它不执行任何操作，服务也会一直运行，这些是十分消耗内存的。</li><li>IntentService 子线程分担部分初始化工作。开启 IntentSerVice 线程，将部分逻辑和耗时的初始化操作放到这里处理，可以减少 application 初始化时间</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">adb <span class="hljs-built_in">shell</span> am <span class="hljs-built_in">start</span> -W packagename/MainActivity<br>adb <span class="hljs-built_in">shell</span> am <span class="hljs-built_in">start</span> -S -R <span class="hljs-number">10</span> -W packagename/.MainActivity<br></code></pre></td></tr></table></figure><p>adb shell am start -S -R 10 -W com.miui.home&#x2F;.settings.MiuiHomeSettingActivity</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%96%B0%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85.resources/2023/09/15/17-43-38-81152591059fd65de1bae63e2a6822f1-unknown_filename.36-09a7c8.png" alt="unknown_filename.36"></p><h3 id="BoostMultiDex"><a href="#BoostMultiDex" class="headerlink" title="BoostMultiDex"></a>BoostMultiDex</h3><p>Dex 压缩<br>当 Dex 非常多的时候会增加应用的安装时间，对于十个以上的 Dex，首次生成 ODEX 的时间可能就会达到分钟级别。</p><p>过多的 dex 文件编译会严重影响冷启动时间（解决方案 <a href="https://github.com/bytedance/BoostMultiDex">BoostMultiDex</a>）</p><p>Android 低版本（4. X 及以下，SDK &lt; 21）的设备，采用的 Java 运行环境是 Dalvik 虚拟机。它相比于高版本，最大的问题就是在安装或者升级更新之后，首次冷启动的耗时漫长。这常常需要花费几十秒甚至几分钟，用户不得不面对一片黑屏，熬过这段时间才能正常使用 APP。</p><p><strong>BoostMultiDex</strong>是一个用于 Android 低版本设备（4. X 及以下，SDK &lt; 21）快速加载多 DEX 的解决方案，由抖音&#x2F;Tiktok Android 技术团队出品。</p><p>相比于 Android 官方原始 MultiDex 方案，它能够减少80%以上的黑屏等待时间，挽救低版本 Android 用户的升级安装体验。并且，不同于目前业界所有优化方案，BoostMultiDex 方案是从 Android Dalvik 虚拟机底层机制入手，从根本上解决了安装 APK 后首次执行 MultiDex 耗时过长问题。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.ANR及问题排查</title>
    <link href="/2025/12/2923418e8129.html"/>
    <url>/2025/12/2923418e8129.html</url>
    
    <content type="html"><![CDATA[<h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><h3 id="什么是-ANR"><a href="#什么是-ANR" class="headerlink" title="什么是 ANR"></a>什么是 ANR</h3><p>ANR 全称 Applicatipon No Response；Android 设计 ANR 的用意，是系统通过与之交互的组件 (Activity，Service，Receiver，Provider) 以及用户交互 (InputEvent) 进行超时监控，以判断应用进程 (主线程) 是否存在<em>卡死或响应过慢</em>的问题。其实就是很多系统中看门狗 (watchdog) 的设计思想。</p><p>Android 在主线程是不能做阻塞耗时操作的，例如加载网络数据、数据库查询、文件读写，如果在应用中无响应的话会导致 ANR (Application Not Response)<br><strong>手机可分配的 CPU 占满也会发生 ANR</strong></p><p>没有在规定的时间内，干完要干的事情，就会发生 ANR。也有可能不是自己应用的问题</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-35-37ba3ad4b94e35e194ad63e0fc8c6b99-unknown_filename.3-176d2f.png" alt="unknown_filename.3|600"></p><p><strong>ANR 触发流程解析</strong></p><ol><li><p><strong>SystemServer（系统服务进程）</strong>    </p><ul><li>通过 <code>setTimeOut</code> 设置广播接收的超时阈值（前台广播 10 秒，后台广播 60 秒）</li><li>通过 Binder 线程向 APP 发送广播：<code>mAppThread.scheduleReceiver()</code></li></ul></li><li><p><strong>APP 进程接收广播</strong></p><ul><li>Binder 线程收到广播后，向主线程的 <code>MessageQueue</code> 插入消息（图中多个 <code>Message1</code>）</li><li>消息内容：要求执行 <code>Receiver.onReceive()</code></li></ul></li><li><p><strong>主线程处理延迟</strong></p><ul><li>主线程正处理其他消息（<code>Message1</code> 队列积压）</li><li>无法及时执行广播接收器的 <code>onReceive()</code> 方法</li></ul></li><li><p><strong>AMS 监控超时</strong></p><ul><li>ActivityManagerService (AMS) 在后台计时</li><li>超时前未收到 <code>ActivityManagerProxy.finishReceiver()</code> 完成通知</li></ul></li><li><p><strong>触发 ANR</strong></p><ul><li>AMS 检测超时后，判定应用无响应</li><li>系统弹出 ANR 对话框并记录日志</li></ul></li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据具体的原因和场景，可以将 ANR 分为以下几种类型：</p><ul><li><p><strong>Input dispatching timeout</strong></p><ul><li>主线程卡住没处理输入事件（touch&#x2F;key）</li><li>典型：UI线程执行耗时操作</li></ul></li><li><p><strong>BroadcastQueue timeout</strong></p><ul><li>广播接收器 <code>onReceive()</code> 超时</li></ul></li><li><p><strong>Service timeout</strong></p><ul><li><code>onCreate()</code> 或 <code>onStartCommand()</code> 耗时</li></ul></li><li><p><strong>ContentProvider timeout</strong></p><ul><li>主线程在 <code>ContentProvider</code> 的 <code>onCreate()</code>、<code>query()</code> 阻塞</li></ul></li><li><p><strong>system_server Watchdog</strong></p><ul><li>关键系统服务（AMS&#x2F;WMS&#x2F;PMS）卡住</li></ul></li></ul><p> 5s 内没有响应用户输入事件<br>10s 内广播接收器没有处理完毕<br>20s 内服务没有处理完毕</p><h3 id="造成-ANR-的常见原因"><a href="#造成-ANR-的常见原因" class="headerlink" title="造成 ANR 的常见原因"></a>造成 ANR 的常见原因</h3><ol><li>应用在主线程上进行长时间的计算、耗时的 I&#x2F;O 的操作。</li><li>主线程处于阻塞状态，等待获取锁。</li><li>主线程与其他线程之间发生死锁。</li><li>主线程在对另一个进程进行同步 Binder 调用，而后者需要很长时间才能返回。(如果我们知道调用远程方法需要很长时间，我们应该避免在主线程调用)</li></ol><p>A.主线程耗时操作，如复杂的layout，庞大的for循环，IO等。<br>B.主线程被子线程同步锁block<br>C.主线程被Binder 对端block<br>D.Binder被占满导致主线程无法和SystemServer通信<br>E.得不到系统资源（CPU&#x2F;RAM&#x2F;IO）</p><h3 id="分析-anr"><a href="#分析-anr" class="headerlink" title="分析 anr"></a><strong>分析 anr</strong></h3><p>adb pull &#x2F;data&#x2F;anr&#x2F;traces. txt trace. txt<br>ANR 产生时, 系统会生成一个 traces. txt 的文件放在&#x2F;data&#x2F;anr&#x2F;下. 可以通过 adb 命令将其导出到本地，这个文件里有 ANR 发生的进程 pid, 时间, 以及进程名字 (包名)，还有 anr 产生的位置和方法。最新的 ANR 信息在最开始部分。</p><p>[[Trace 文件怎么读]]</p><p>主要原因是主线程做了耗时操作（io、网络、数据库）</p><ul><li>先 确定发生 ANR 的时间具体时间点、什么类型的 anr</li><li>当 ANR 被发现后，两个很重要的日志输出是：<em>CPU 使用情况和进程的函数调用栈</em>，这两类日志是我们解决 ANR 问题的关键</li></ul><ul><li><em>看 cpu，如果 cpu 占用很高，说明主线程可能阻塞</em>。</li><li>看线程转态，是阻塞还是等待</li><li>看 stackSize</li></ul><p><strong>第一步: 确定发生ANR的时间具体时间点、什么类型的 anr</strong></p><ul><li>event log，通过检索”<em>am_anr</em>”关键字，可以找到发生 ANR 的应用</li><li>main log，通过检索”<em>ANR in</em> “关键字，可以找到 ANR 的信息，<em>日志的上下文会包含 CPU 的使用情况</em></li><li>往下翻找到“main”线程则可看到对应的阻塞 log</li></ul><p>根据这行log我们确定的信息<br>发生anr的时间点：12-17 06:02:14.463,<br>进程pid：8769,<br>进程名：com.android.updater,<br>发生ANR的类型是：BroadcastTimeout,</p><p>发生的具体类或者原因：{ act&#x3D;android.intent.action.BOOT_COMPLETED flg&#x3D;0x9000010 cmp&#x3D;com.android.updater&#x2F;.BootCompletedReceiver (has extras) }</p><p><strong>eg:</strong>  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">12</span>-<span class="hljs-number">17</span> <span class="hljs-number">06</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>.<span class="hljs-number">370</span> <span class="hljs-number">1566</span> <span class="hljs-number">1583</span> W BroadcastQueue: Timeout of broadcast BroadcastRecord&#123;<span class="hljs-number">21</span>ef8c2 u0 android.intent.action.BOOT_COMPLETED&#125; - receiver=android.os.BinderProxy@<span class="hljs-number">2</span>a6c365, started **<span class="hljs-number">60006</span>ms** ago<br><br><span class="hljs-attribute">12</span>-<span class="hljs-number">17</span> <span class="hljs-number">06</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>.<span class="hljs-number">370</span>  <span class="hljs-number">1566</span>  <span class="hljs-number">1583</span> W BroadcastQueue: Receiver during timeout: ResolveInfo&#123;<span class="hljs-number">5</span>a8283a com.android.updater/.BootCompletedReceiver m=<span class="hljs-number">0</span>x108000&#125;<br></code></pre></td></tr></table></figure><p>这行日志中很多信息是和Events log是重合的,但是我们我们可以通过” <em>started 60006ms ago</em>“可以知道这信息是在1分多钟之前执行的,现在还没有执行结束,已经达到了发生ANR规定的时间,可以确定这是个后台广播,所以我们可以把信息锁定在时间点:12-17 06:02:00.370<em>往前推算的一分钟内</em>,观察在这段时间内具体执行了哪些操作,导致后台广播没有执行完成.</p><p>注意:</p><ol><li><em>ANR in对应的ANR的时间点往往是比am_anr的时间点是靠后的</em>,一般不使用这个时间确定ANR发生的具体时间点</li><li>cpu占用95%有时候并不算高，在多核中每个核最大占用率都是100%（八核占用率是800%）</li></ol><p><strong>第二步：ANR发生时打印的堆栈和系统附加信息</strong><br>发生ANR时,各个应用进程和系统进程的函数堆栈信息都输出到了一个&#x2F;data&#x2F;anr&#x2F;traces.txt的文件.我们往往比较关注的是发生ANR的应用进程主线程具体执行堆栈,我们可以知道在发生ANR这个时间点主线程具体在做什么,为什么卡住了,是等锁,binder call调用还是主线程存在耗时的操作等等.</p><p><strong>eg:</strong></p><p><em>main(线程名)、prio(线程优先级,默认是5)、tid(线程唯一标识ID)、Sleeping(线程当前状态)</em></p><p>“main” prio&#x3D;5 tid&#x3D;1 Sleeping<br>| group&#x3D;”main” sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x73132d10 self&#x3D;0x5598a5f5e0<br><em>&#x2F;&#x2F;sysTid是线程号(主线程的线程号和进程号相同)</em><br>| sysTid&#x3D;17027 nice&#x3D;0 cgrp&#x3D;default sched&#x3D;0&#x2F;0 handle&#x3D;0x7fb6db6fe8<br>| state&#x3D;S schedstat&#x3D;( 420582038 5862546 143 ) utm&#x3D;24 stm&#x3D;18 core&#x3D;6 HZ&#x3D;100<br>| stack&#x3D;0x7fefba3000-0x7fefba5000 stackSize&#x3D;8MB<br>| held mutexes&#x3D;<br>&#x2F;&#x2F; java 堆栈调用信息(这里可查看导致ANR的代码调用流程)(<em>分析ANR最重要的信息</em>)<br>at java.lang.Thread.sleep!(Native method)  </p><ul><li>sleeping on &lt;0x0c60f3c7&gt; (a java.lang.Object)<br>at java.lang.Thread.sleep(Thread.java:1031)  </li><li><em>locked</em> &lt;0x0c60f3c7&gt; (a java.lang.Object) &#x2F;&#x2F; <em>锁住对象0x0c60f3c7</em><br>at java.lang.Thread.sleep(Thread.java:985)<br>at android.os.SystemClock.sleep(SystemClock.java:120)<br>at org.code.ipc.MessengerService.onCreate(MessengerService.java:63) &#x2F;&#x2F;<em>导致ANR的代码</em><br>at android.app.ActivityThread.handleCreateService(ActivityThread.java:2877)<br>at android.app.ActivityThread.access$1900(ActivityThread.java:150)<br>at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1427)<br>at android.os.Handler.dispatchMessage(Handler.java:102)<br>at android.os.Looper.loop(Looper.java:148)<br>at android.app.ActivityThread.main(ActivityThread.java:5417)<br>at java.lang.reflect.Method.invoke!(Native method)<br>at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)<br>at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</li></ul><p>查看系统耗时关键字: binder_sample、dvm_lock_sample、am_lifecycle_sample、binder thread<br>结合源码和以上的信息进行分析</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p><a href="https://www.jianshu.com/p/bacd320b36b3">Android造成ANR的常见原因及示例分析 - 简书</a></p><ol><li>主线程获取播放器总时长</li><li>主线程上执行复杂的布局计算，例如嵌套的布局层次、动态布局调整或复杂的测量和布局过程，主线程可能会花费过长的时间来计算布局，recycleview 嵌套，csharpReason: Input dispatching timed out </li><li>读一个大文件</li><li>主线程中执行长时间的动画操作，可以启动硬件加速、或者如果动画操作涉及到后台任务，例如加载和处理大量图像数据，可以考虑使用异步任务来在后台线程上执行这些操作，并在完成后在主线程上更新动画。</li><li>调 h5方法太频繁或耗时</li><li>在主线程上执行大量的图像处理操作，例如图片压缩、滤镜处理或大型图像的加载和显示，大图优化。内存紧张导致 ANR</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>不要在主线程 (UI 线程) 里面做繁重的操作, 增大 VM 内存, 使用 largeHeap 属性, 排查内存泄露</li><li>Thread + Handler + Message ，Thread + Handler + post，AsyncTask，intentservice、runOnUiThread (Runnable) 在子线程中直接使用该方法，可以更新 UI，记得注意内存泄露</li></ol><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>比较少，大部分是做了耗时操作</p><h4 id="主线程处于阻塞状态，等待获取锁"><a href="#主线程处于阻塞状态，等待获取锁" class="headerlink" title="主线程处于阻塞状态，等待获取锁"></a>主线程处于阻塞状态，等待获取锁</h4><p>先让后台线程获取锁，做耗时操作，然后主线程再尝试获取锁。然后多次点击返回键，制造ANR。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-string">&quot;main&quot;</span> prio=<span class="hljs-number">5</span> tid=<span class="hljs-number">1</span> Blocked<br>  | <span class="hljs-keyword">group</span>=<span class="hljs-string">&quot;main&quot;</span> sCount=<span class="hljs-number">1</span> dsCount=<span class="hljs-number">0</span> obj=<span class="hljs-number">0x77d21af8</span> self=<span class="hljs-number">0x7fa2ea2a00</span><br>  | sysTid=<span class="hljs-number">20008</span> nice=<span class="hljs-number">-10</span> cgrp=<span class="hljs-literal">default</span> sched=<span class="hljs-number">0</span>/<span class="hljs-number">0</span> handle=<span class="hljs-number">0x7fa6f4ba98</span><br>  | state=S schedstat=( <span class="hljs-number">278831875</span> <span class="hljs-number">7233747</span> <span class="hljs-number">156</span> ) utm=<span class="hljs-number">22</span> stm=<span class="hljs-number">5</span> core=<span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span><br>  | stack=<span class="hljs-number">0x7fd42e0000</span><span class="hljs-number">-0x7fd42e2000</span> stackSize=<span class="hljs-number">8</span>MB<br>  | held mutexes=<br>  at com.example.android.jetpackdemo.StartActivity.onClick(StartActivity.kt:<span class="hljs-number">61</span>)<br>  - <span class="hljs-function">waiting to <span class="hljs-title">lock</span> &lt;0x0f8c80b0&gt; (<span class="hljs-params">a java.lang.Object</span>) held <span class="hljs-keyword">by</span> thread 16</span><br></code></pre></td></tr></table></figure><p>在等待一个锁对象 <code>&lt;0x0f8c80b0&gt;</code>，该对象是一个 <code>Object</code> 对象(a java.lang.Object)，这个锁对象正在被线程id为16的线程持有。那么我们下面在traces.txt文件中搜索一下这个锁对象 <code>&lt;0x0f8c80b0&gt;</code>，然后找到对应代码</p><h4 id="主线程与其他线程之间发生死锁"><a href="#主线程与其他线程之间发生死锁" class="headerlink" title="主线程与其他线程之间发生死锁"></a>主线程与其他线程之间发生死锁</h4><p><strong>traces.txt部分信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">----- pid 13626 at 2020-06-04 15:07:37 -----<br>Cmd line: com.example.android.jetpackdemo<br>Build fingerprint: <span class="hljs-string">&#x27;HUAWEI/MLA-AL10/HWMLA:7.0/HUAWEIMLA-AL10/C00B364:user/release-keys&#x27;</span><br></code></pre></td></tr></table></figure><p>通过进程号pid 13626搜索</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-string">&quot;main&quot;</span> prio=<span class="hljs-number">5</span> tid=<span class="hljs-number">1</span> Blocked<br>  | <span class="hljs-keyword">group</span>=<span class="hljs-string">&quot;main&quot;</span> sCount=<span class="hljs-number">1</span> dsCount=<span class="hljs-number">0</span> obj=<span class="hljs-number">0x77d21af8</span> self=<span class="hljs-number">0x7fa2ea2a00</span><br>  | sysTid=<span class="hljs-number">13626</span> nice=<span class="hljs-number">-10</span> cgrp=<span class="hljs-literal">default</span> sched=<span class="hljs-number">0</span>/<span class="hljs-number">0</span> handle=<span class="hljs-number">0x7fa6f4ba98</span><br>  | state=S schedstat=( <span class="hljs-number">288564792</span> <span class="hljs-number">6939269</span> <span class="hljs-number">224</span> ) utm=<span class="hljs-number">23</span> stm=<span class="hljs-number">5</span> core=<span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span><br>  | stack=<span class="hljs-number">0x7fd42e0000</span><span class="hljs-number">-0x7fd42e2000</span> stackSize=<span class="hljs-number">8</span>MB<br>  | held mutexes=<br>  at com.example.android.jetpackdemo.StartActivity.mockDeadLock(StartActivity.kt:<span class="hljs-number">142</span>)<br>  - <span class="hljs-function">waiting to <span class="hljs-title">lock</span> &lt;0x0a43b5c8&gt; (<span class="hljs-params">a java.lang.String</span>) held <span class="hljs-keyword">by</span> thread 17</span><br></code></pre></td></tr></table></figure><p>主线程状态是线程状态是Blocked，说明正在等待获取锁对象，等待获取的锁对象<code>&lt;0x0a43b5c8&gt;</code>是一个String对象(a java.lang.String)，该对象被线程id为17的线程持有。然后我们搜索这个锁对象。</p><h2 id="traces关注点"><a href="#traces关注点" class="headerlink" title="traces关注点"></a>traces关注点</h2><p><strong>traces.txt 里的主要关注点</strong></p><p>ANR 发生时，系统会把当时所有进程的线程堆栈 dump 到 <code>/data/anr/traces.txt</code>。常看这些：</p><ul><li><p><strong>main 线程堆栈（UI线程）</strong></p><ul><li><code>state</code>（状态：Running &#x2F; Sleeping &#x2F; Blocked）</li><li>是否在等待锁（<code>- locked</code>、<code>- waiting to lock</code>）</li><li>是否在 Binder 调用（跨进程阻塞）</li><li>是否有耗时操作（IO、sleep、数据库、循环计算等）</li></ul></li><li><p><strong>Binder 线程池（Binder_xxx）</strong></p><ul><li>否卡在某个系统服务 &#x2F; 应用 Service 调用上</li><li>常见问题：binder 死锁 &#x2F; binder 队列阻塞</li></ul></li><li><p><strong>GC &#x2F; FinalizerDaemon &#x2F; ReferenceQueueDaemon</strong></p><ul><li>是否 GC 卡顿</li><li>是否对象回收线程停滞，拖慢主线程</li></ul></li><li><p><strong>系统服务进程（system_server）</strong></p><ul><li><code>ActivityManager</code>、<code>InputDispatcher</code>、<code>WindowManager</code> 的堆栈</li><li>重点：system_server 如果被卡住，所有 app 都可能 ANR</li></ul></li></ul><p><strong>traces.txt 里的关键 tag（系统打的日志点）</strong></p><p>你提到的几个关键字，其实是 <strong>systrace&#x2F;atrace 打点 + ANR 打印扩展</strong>，能辅助定位卡点：</p><ul><li><p><strong>binder_sample</strong></p><ul><li>说明 <strong>Binder 调用超时</strong>，可能是调用方 &#x2F; 被调用方处理过慢。</li><li>binder thread 堆栈能看到调用的接口。</li></ul></li><li><p><strong>dvm_lock_sample &#x2F; art_lock_sample</strong></p><ul><li>表示 <strong>Java 锁竞争严重</strong>，有线程长时间持有锁。</li><li>常见场景：主线程 <code>synchronized</code> 锁住，子线程要获取；或者数据库锁未释放。</li></ul></li><li><p><strong>am_lifecycle_sample</strong></p><ul><li>ActivityManager 监控到某个 <strong>生命周期回调耗时</strong>。</li><li>比如 <code>onCreate()</code>、<code>onResume()</code>、<code>onStart()</code> 超时。</li></ul></li><li><p><strong>binder thread</strong></p><ul><li>binder 线程池的堆栈信息，可以看到是否卡在等待 &#x2F; 处理事务。<br>这些信息配合 <code>system_server</code> 和 app 主线程堆栈一起看，能快速定位卡因。</li></ul></li></ul><h2 id="线上问题排查"><a href="#线上问题排查" class="headerlink" title="线上问题排查"></a>线上问题排查</h2><p>adb bugreport<br>生成的 log 位于 &#x2F;data&#x2F;user_de&#x2F;0&#x2F;com. android. shell&#x2F;files&#x2F;bugreports&#x2F; 目录下<br>如何查看 FC：</p><ol><li>搜索关键字 system_app_crash   am_crash </li><li>关键字 AndroidRuntime  </li><li>F DEBUG ,native 崩溃会用到</li></ol><ul><li>日志打点怕打太多也怕太少，担心出现问题没有足够丰富的信息去定位分析问题。应该打多少日志，如何去打日志并没有一个非常严格的准则，这需要整个团队在长期实践中慢慢去摸索。在最开始的时候，可能大家都不重视也不愿意去增加关键代码的日志，但是当我们通过日志平台解决了一些疑难问题以后，团队内部的成功案例越来越多的时候，这种习惯也就慢慢建立起来了。</li><li>使用 Mars 的 xlog，Java 实现写日志，GC 频繁，而 C 实现并不会出现这种情况，因为它不会占用 Java 的堆内存。</li><li>使用阿里云日志采集服务</li><li>俩种方式上报日志：push 上报，主动上报（在用户出现奔溃，反馈问题时主动上报日志（可以重启了上报））</li><li>正因为反复“痛过”，才会有了微信的用户日志和点击流平台，才会有美团的 <strong>Logan</strong> 和 <strong>Homles</strong>（看看） 统一日志系统。所谓团队的“提质增效”，就是寻找团队中这些痛点，思考如何去改进。无论是流程的自动化，还是开发新的工具、新的平台，都是朝着这个目标前进。</li></ul><p><strong>Android 混淆后还怎么看错误</strong></p><p>保留关键信息：在混淆配置文件（通常是 <code>proguard-rules.pro</code>）中，您可以添加规则来保留某些类、方法或字段的名称，以便在混淆后的应用程序中仍然能够识别它们。例如：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>-keep <span class="hljs-keyword">class</span> <span class="hljs-title class_">android</span>.** &#123; *; &#125; <span class="hljs-comment">// 保留 android 包及其子包下的所有类和成员</span><br>-keep <span class="hljs-keyword">class</span> <span class="hljs-title class_">androidx</span>.** &#123; *; &#125; <span class="hljs-comment">// 保留 androidx 包及其子包下的所有类和成员</span><br><br>-keep <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.example.MyClass &#123; *; &#125; <span class="hljs-comment">// 保留 MyClass 及其成员</span><br>-keepclassmembers <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.example.MyClass &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> myMethod(); <span class="hljs-comment">// 保留 MyClass 中的 myMethod 方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注解混淆</strong></p><p>不想混淆的类需要一个个添加到 proguard-rules. pro (或 proguard. cfg) 中吗？这样会导致 proguard 配置文件变得杂乱无章，同时需要团队所有成员对其语法有所了解。<br>解决方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新建表示统一标识的注解 NotProguard</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.FIELD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NotProguard &#123;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><p>NotProguard 是个编译时注解，不会对运行时性能有任何影响。可修饰类、方法、构造函数、属性。<br>然后在 Proguard 配置文件中过滤被这个注解修饰的元素，表示不混淆被 NotProguard 修饰的类、属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"># Keep annotated by NotProguard<br>-keep <span class="hljs-meta">@cn</span>.trinea.android.lib.annotation.NotProguard class * &#123;*;&#125;<br>-keep,allowobfuscation <span class="hljs-meta">@interface</span> cn.trinea.android.lib.annotation.NotProguard<br>-keepclassmembers class * &#123;<br>    <span class="hljs-meta">@cn</span>.trinea.android.lib.annotation.NotProguard *;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">## keep 不想要混淆的类<br>-keep <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.utils.ProguardKeep &#123;*;&#125;<br>-keep class * <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.utils.ProguardKeep &#123;*;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现这个接口的类不会进行混淆</span><br><span class="hljs-comment"> *  proguard keep</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProguardKeep</span>  &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="问题不是自己-app，怎么解决"><a href="#问题不是自己-app，怎么解决" class="headerlink" title="问题不是自己 app，怎么解决"></a>问题不是自己 app，怎么解决</h3><p>bugly 报的很多问题不是自己 app 的类，怎么解决</p><ol><li><p>第三方库或依赖项：Bugly 可以报告与您的应用程序相关的第三方库或依赖项中出现的问题。这可能是由于库本身的 bug、版本不兼容或配置错误等原因引起的。在这种情况下，您可以尝试更新相关的库版本，查看是否已经发布了修复此问题的更新版本。另外，您还可以尝试搜索相关问题的解决方案或在开发者社区中提问以获得帮助。</p></li><li><p>系统组件或操作系统问题：有时 Bugly 报告的问题可能涉及到 Android 系统组件或操作系统本身的问题。这可能是由于特定设备、Android 版本或其他环境因素导致的。在这种情况下，您可以尝试查看 Bugly 提供的详细信息，例如堆栈跟踪、设备信息等，以了解问题发生的背景。然后，您可以尝试在 Bugly 或其他社区中搜索相关问题，看是否有其他开发者遇到过类似问题，并找到解决方案或工作回避方法。</p></li><li><p>混淆和符号化：如果您在应用程序中使用了代码混淆（如 ProGuard）并启用了符号化配置，Bugly 报告的问题可能显示的是混淆后的类名或方法名。在这种情况下，您可以尝试使用<em>符号化映射文件</em>（mapping file）将混淆后的类名还原为原始的类名，以便更好地理解问题出现的位置和上下文。您可以通过在 Bugly 控制台中上传符号化映射文件来实现这一点。</p></li></ol><h3 id="符号化映射文件"><a href="#符号化映射文件" class="headerlink" title="符号化映射文件"></a>符号化映射文件</h3><p>将应用程序的崩溃堆栈信息转换为可读形式的文件。它包含了应用程序的符号表（Symbol Table）信息，将编译后的函数和变量名映射回原始的源代码符号，使得崩溃日志更易于理解和分析。</p><p>符号化映射文件通常在应用程序构建过程中生成，并与应用程序的发布版本一起打包。在 Android 开发中，常用的构建工具如 ProGuard 或 R8 可以生成符号化映射文件。该文件通常具有 “.mapping” 或 “.txt” 的扩展名。</p><p>需要注意的是，符号化映射文件包含敏感信息，<em>如函数名和行号</em>等。因此，为了保护应用程序的安全，符号化映射文件应妥善管理，并不应该随意公开或共享。</p><p>Mapping 文件的默认位置为 <code>app/build/outputs/mapping/release/mapping.txt</code></p><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><p>卡顿的原因<br>频繁 GC 造成卡顿、物理内存不足时系统会触发 low memory killer 机制，系统负载过高是造成卡顿的俩个原因。<em>用时分配，及时释放</em></p><p>大部分的卡顿问题都比较好定位，例如<em>主线程执行一个耗时任务、读一个非常大的文件或者是执行网络请求</em>等。</p><p>Android 端采用 Matrix 来整理和汇总数据, 同步到实时监控日志</p><p>Traceview、systrace 以及 AS 自带的 Profiler 工具。</p><p>[[7.优化工具使用#卡顿监测]]</p><p>[[第三方框架源码#BlockCanary原理]]</p><p>导致卡顿的原因有很多，比如函数非常耗时、I&#x2F;O 非常慢、线程间的竞争或者锁等，其实很多时候卡顿问题并不难解决，相较解决来说，更困难的是如何快速发现这些卡顿点，以及通过更多的辅助信息找到真正的卡顿原因。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.Android内存优化</title>
    <link href="/2025/12/860d5e680c4f.html"/>
    <url>/2025/12/860d5e680c4f.html</url>
    
    <content type="html"><![CDATA[<p>在实践操作当中，可以从三个方面着手减小内存使用，首先是减小对象的内存占用，其次是内存对象的重复利用，最后是避免对象的内存泄露。<br>也可以从从设备分级、Bitmap 优化和内存泄露这三个方面入手。</p><h2 id="减小内存占用"><a href="#减小内存占用" class="headerlink" title="减小内存占用"></a>减小内存占用</h2><h3 id="Bitmap-优化"><a href="#Bitmap-优化" class="headerlink" title="Bitmap 优化"></a>Bitmap 优化</h3><p>[[4.图片、glide优化]]</p><ol><li>资源和图片压缩，对于低端机用户可以关闭复杂的动画、或者某些功能；使用 565 格式的图片</li><li>一个空进程也会占用 10M 的内存，减少应用启动的进程数，减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li><li>Serializable全部改成 Parcelable（&#x2F;ˈpɑːrsl&#x2F;）[[Serializable 与 Parcelable]]</li><li>arraymap，sarparray 代替 hashmap [[SparseArray 和 ArrayMap]]</li></ol><h2 id="内存对象的重复利用"><a href="#内存对象的重复利用" class="headerlink" title="内存对象的重复利用"></a>内存对象的重复利用</h2><ol><li>使用线程池（对象池）</li><li>避免创建不必要的对象，单例</li><li>合理的使用缓存，使用lrucache，比如图片是很耗内存</li><li>内存抖动</li></ol><h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><p>内存抖动是指在短时间内有大量的对象被创建或者被回收的现象，内存抖动出现原因主要是频繁（在循环里）创建对象（短时间内产生大量对象，需要大量内存，就可能会需要回收内存以用于产生对象，垃圾回收机制就自然会频繁运行了）。频繁内存抖动会导致垃圾回收频繁运行。解决的方法：</p><ol><li>尽量避免在循环体内创建对象，应该把对象创建移到循环体外。</li><li>注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。</li><li>当需要大量使用Bitmap的时候，把它们缓存在数组中实现复用。</li><li>对于能够复用的对象，可以使用对象池将它们缓存起来。</li><li>允许复用的情况下，使用对象池进行缓存，如：Handler的Message单链表(obtain);</li></ol><ul><li><p><strong>RecyclerView滚动优化</strong></p><ul><li>问题：<code>onBindViewHolder</code>中创建Bitmap&#x2F;Paint</li><li>现象：快速滚动时明显卡顿</li><li>方案：ViewHolder复用+对象池</li></ul></li><li><p><strong>动画资源泄漏</strong>    </p><ul><li>问题：未复用<code>ValueAnimator</code>&#x2F;<code>ObjectAnimator</code></li><li>现象：连续触发动画时内存锯齿状波动</li><li>方案：使用<code>AnimatorSet</code>复用动画对象<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (mShowSearchContainerAnimatorSet == <span class="hljs-literal">null</span>) &#123;  <br>    AnimatorSetBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-type">AnimatorSetBuilder</span>();  <br>    PropertySetter.AnimatedPropertySetter setter = <span class="hljs-keyword">new</span> <span class="hljs-type">PropertySetter</span>.AnimatedPropertySetter(<span class="hljs-number">300</span>, builder);  <br>    setter.setViewAlpha(mCategoryContainer, <span class="hljs-number">0</span>, Interpolators.LINEAR);  <br>    setter.setViewAlpha(mSearchContainer, <span class="hljs-number">1</span>, Interpolators.LINEAR);  <br>    mShowSearchContainerAnimatorSet = builder.build();  <br>&#125;  <br>mShowSearchContainerAnimatorSet.start();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>[[3.内存泄漏简单问]]</p><p>Handler 都不能算是罪魁祸首，罪魁祸首（根本原因）都是他们的头头——线程。内部类引用就引用吧，无所谓，但是这个内部类是长期存在的就不行</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-43-7a03ecb64c07e5a1600c55194e5cf24c-unknown_filename.2-63fa83.png" alt="unknown_filename.2"></p><p>handle. post<br>view 中使用的 Context 就是当前的 Activity，而这个 runnable 一旦被 post，就会一直存在于队列里面，直到时间到了，被执行。<br>主线程 —&gt; threadlocal —&gt; Looper —&gt; MessageQueue —&gt; Message —&gt; Handler-&gt;view —&gt; Activity</p><h3 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h3><h4 id="非静态内部类持有外部类的引用"><a href="#非静态内部类持有外部类的引用" class="headerlink" title="非静态内部类持有外部类的引用"></a>非静态内部类持有外部类的引用</h4><p>内部类的构造函数中会传入外部类的实例，然后就可以通过 this$0访问外部类的成员<br><em>this$0</em>的意思就是所说的隐式持有外部 Activity 引用, 内部类可以访问外部类的成员变量, 靠的就是 this$0, 这个东西是编译器自动加上的, 不需要手动定义, 在反编译的 smali 文件中很容易看到~(当然如果有多层内部类的嵌套, 会有 this$1, this$2)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SdkDialogFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DialogFragment</span> </span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Dialog</span> mDialog;  <br>  <br>    public <span class="hljs-type">SdkDialogFragment</span>(<span class="hljs-type">Dialog</span> dialog) &#123;  <br>        mDialog = dialog;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>非静态内部类改为静态内部类,如使用Application Context</p><h4 id="匿名内部类持有外部类的引用"><a href="#匿名内部类持有外部类的引用" class="headerlink" title="匿名内部类持有外部类的引用"></a>匿名内部类持有外部类的引用</h4><p>在 Activity 中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有 Activity 的引用，会导致 Activity 长期得不到回收，例如 handler（使用静态内部类加上弱引用的方式实现），或者 mHandler.removeCallbacksAndMessages(null);</p><p>匿名内部类，例如：AsyncTask 和 Runnable ，那么它们将持有其所在 Activity 的隐式引用。如果任务在 Activity 销毁之前还未完成，那么将导致 Activity 的内存资源无法被回收，从而造成内存泄漏。（将 AsyncTask 和 Runnable 类独立出来或者使用静态内部类）</p><p>解决方法：<strong>静态+弱引用</strong></p><ul><li>内部类 Handler 对象会隐式地持有一个外部类对象（通常是一个 Activity）的引用（不然你怎么可能通过 Handler 来操作 Activity 中的 View？）</li><li>PS: 在 Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。静态类不持有外部类的对象，所以你的 Activity 可以随意被回收。</li><li>由于 Handler 不再持有外部类对象的引用，导致程序不允许你在 Handler 中操作 Activity 中的对象了。所以你需要在 Handler 中增加一个对 Activity 的弱引用（WeakReference）。</li><li><em>使用弱引用注意判空</em></li></ul><p>泄漏例子：在 ondestory 里 ref1没问题，ref2就内存泄漏, ref2是匿名内部类<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-43-dd496c41d503d49dec142e2022f176a2-unknown_filename.1-35efb0.jpeg" alt="unknown_filename.1"></p><p>在反编译的时候经常会看到 xxxxx$1. class, xxxxxx$2. class, 这些就是匿名内部类, 经常的书写格式一般是 new xxxxxx () {    类的成员变量, 成员方法     }. xxxxx ();<br>其实我们经常用</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">leak_single.setOnClickListener (<span class="hljs-keyword">new</span> View.OnClickListener () &#123;<br>    <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span> <span class="hljs-params">(View view)</span> </span>&#123;<br>        Intent intent = <span class="hljs-keyword">new</span> Intent (MainActivity. <span class="hljs-keyword">this</span>, LeakSingleTestActivity. <span class="hljs-class"><span class="hljs-keyword">class</span>)</span>;<br>        startActivity (intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="HandlerThread-泄露"><a href="#HandlerThread-泄露" class="headerlink" title="HandlerThread 泄露"></a>HandlerThread 泄露</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">HandlerThread thread = <span class="hljs-built_in">new</span> HandlerThread(&quot;xxx&quot;);<br>thread.<span class="hljs-keyword">start</span>();<br><span class="hljs-keyword">Handler</span> <span class="hljs-keyword">handler</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Handler</span>(thread.getLooper());<br><span class="hljs-keyword">handler</span>.postDelayed(<span class="hljs-built_in">new</span> Runnable() &#123;<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> run() &#123;<br>       <span class="hljs-keyword">view</span>.setVisibility(<span class="hljs-keyword">View</span>.GONE);<br>    &#125;<br>&#125;, <span class="hljs-number">10000</span>);<br><br>thread.quit();<br></code></pre></td></tr></table></figure><p>在 HandlerThread 中还有一个方法: quitSafely, 简单提一下, 实际执行的是 removeAllFutureMessageLocked 方法, 只会清空 MessageQueue 消息池中所有的延迟消息, 并将所有非延迟消息派发出去让 Handler 处理, 相比于 quit, 更安全一些, 这个看需求吧, 一般 Activity 都退出了, 消息派不派发都没有实际意义了</p><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。（使用 Application 的 context）</p><h4 id="资源未关闭造成"><a href="#资源未关闭造成" class="headerlink" title="资源未关闭造成"></a>资源未关闭造成</h4><p>BraodcastReceiver，ContentObserver，数据库Cursor，IO，Bitmap（close 或取消注册）、线程池 shutdown、handlerThread quick. 属性动画当设置成无限循环时，需要 cancel</p><p>listener 也要置为 null（getViewTreeObserver）</p><p><em>注册和取消注册成对出现</em>，在对象合适的生命周期进行监听的注销</p><p>WebView 造成的泄露（当我们不要使用 WebView 对象时，应该调用它的 destory ()函数来销毁它，并释放其占用的内存，否则其长期占用的内存也不能被回收，从而造成内存泄露）。在客户端刚启动时，就初始化一个全局的 WebView 待用，并隐藏；当用户访问了 WebView 时，直接使用这个 WebView 加载对应网页，并展示。这种方法可以比较有效的减少初始化 WebView 的时间。</p><p><em>不要多余的成员变量或临时变量</em>。成员变量（全局变量）。activity 持有成员变量的引用，比如说 arraylist，集合容器中的内存泄露（在退出程序之前，将集合里的东西 clear，然后置为 null，再退出程序。或者创建成局部变量 (短内存泄漏)在堆上，多了也占内存</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><em>尽量不要用一个生命周期长于 Activity 的对象来持有 Activity 的引用</em></p><h6 id="三种静态"><a href="#三种静态" class="headerlink" title="三种静态"></a>三种静态</h6><ol><li>静态内部类：尽量不要用一个生命周期长于Activity的对象来持有Activity的引用。声明handler为static，这样内部类就不再持有外部类的引用了，就不会阻塞Activity的释放。在<strong>Activity中尽量避免使用生命周期不受控制的非静态类型的内部类</strong>，可以使用<strong>静态内部类</strong>加上弱引用的方式实现。</li><li><em>静态变量</em>：不要直接或者间接引用Activity、Service等。这会使用Activity以及它所引用的所有对象无法释放，然后，用户操作时间一长，内存就会狂升。</li><li>静态引用：应该避免 static 成员变量引用资源耗费过多的实例，比如 Context。尽量使用 getApplicationContext，因为 Application 的 Context 的生命周期比较长，引用它不会出现内存泄露的问题，而不是用 activity 的 context。可以通过调用 Context.getApplicationContext () or Activity.getApplication ()来获得</li></ol><p>当某个 View 初始化时耗费大量资源, 而且要求 Activity 生命周期内保持不变, 这个时候很多业务组可能会吧 view 变成 static,加载到视图树上 (View Hierachy)，像这样, 当 <code>Activity</code> 被销毁时，应当释放资源。但很可能会带来泄露问题, View 是跟 Context 紧密关联, 使用不当就会出现泄露问题, 需要特别注意.<br>我在使用 View 的时候没操作 Context? 怎么会有 Activity 的引用呢?</p><p>其实 View 的代码中是默认有 Context<br>Context 是什么时候给到 View 的呢? View 创建的时候, new View, 有的时候是我们写代码时自己 new, 更多的时候是 setContentView 时将 Activity 作为 context 传给 View</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Override</span>  <br>protected void onCreate(Bundle savedInstanceState) &#123;  <br>    super<span class="hljs-selector-class">.onCreate</span>(savedInstanceState);  <br>    <span class="hljs-built_in">setContentView</span>(R.layout.activity_main);<br></code></pre></td></tr></table></figure><p><strong>解决办法:</strong><br><strong>1: 通过设计改变 static 为普通变量, 不要在 Android 中使用 static 修饰 View, 完全避免此种可能, 推荐</strong><br>2: 在 onDestroy 时将 static view 置为 null</p><h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p><strong>静态对象实例存在于堆中<br>静态方法在 stack，运行完就出栈了<br>静态成员变量在方法区<br>局部变量是不能静态的</strong></p><p><em>类的静态成员变量（static成员变量）存储在方法区（Method Area）中</em>，而非堆内存。静态成员变量独立于对象而存在，它们属于类本身而不是对象的一部分。</p><p><strong>为什么 Java 静态方法引用的属性也必须是静态的</strong></p><ul><li>静态方法不需要 new 对象，只要 class 文件被 ClassLoader   load 进入<strong>JVM 的 stack</strong>，该静态方法即可被调用。当然此时静态方法是存取不到 heap 中的对象属性的。  </li><li>非静态方法执行前，要先new对象，在heap中分配数据，并把stack中的地址指针交给非静态方法，这样程序技术器依次执行指令，而指令代码此时能够访问到heap数据区了。</li></ul><p><strong>和静态方法没关系，主要是静态变量持有activity的引用</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fragment <span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(ArrayList&lt;SpeakKey&gt; data, int parentIndex) &#123;<br>    LearnSpeakScoreFragment fragment = <span class="hljs-keyword">new</span> <span class="hljs-type">LearnSpeakScoreFragment</span>();<br>    Bundle bundle = <span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>();<br>    bundle.putInt(<span class="hljs-string">&quot;parentIndex&quot;</span>, parentIndex);<br>    fragment.setArguments(bundle);<br>    <span class="hljs-keyword">return</span> fragment;<br>&#125;<br></code></pre></td></tr></table></figure><p>不会内存泄漏，因为LearnSpeakScoreFragment又没持有activity的引用。方法运行完了就出栈了</p><h3 id="标准的-handler-写法"><a href="#标准的-handler-写法" class="headerlink" title="标准的 handler 写法"></a>标准的 handler 写法</h3><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">private</span> WeakReference&lt;Context&gt; reference;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHandler</span><span class="hljs-params">(Context context)</span> &#123;<br>            reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(context);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> (MainActivity) reference.get();<br>            <span class="hljs-keyword">if</span>(activity != <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-comment">//                activity.mTextView.setText(&quot;&quot;);</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//标准的单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AppManager instance;<br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">AppManager</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context = context.getApplicationContext();<span class="hljs-comment">// 使用Application 的context</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AppManager <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppManager</span>(context);<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>（特别对于 Context,View,Fragmet,Activity 对象），如果要将其放进类内部的容器对象或者静态类中引用，请一直用 WeakReference 包装！比如在 TabLayout 的源码中，在 TabLayoutOnPageChangeListener 中，就为 TabLayout 做了 WeakReference wrap。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.resources/2023/09/15/18-49-43-92a4462c3b07dfc7942c3fcc6d160dc4-unknown_filename-5b6b3f.jpeg" alt="unknown_filename"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对象的引用分为四种级别，从而使程序更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><ol><li>强引用是Java的默认引用实现, 它会尽可能长时间的存活于 JVM（虚拟机） 内， 当没有任何对象指向它时（显式地将引用赋值为nul）才会在合适的时间，进行垃圾回收。</li><li>软引用 如果内存空间不足了，就会回收这些对象的内存。</li><li>弱引用 WeakReference  弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间充足与否，都会回收它的内存。</li><li>虚引用 PhantomReference  虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>Android 系统中 GC 内存泄漏的原因</strong></p><p>主动回收内存System.gc();、getruntime.runtime.gc<br>导致内存泄漏主要的原因是，<em>申请了内存空间而忘记了释放</em>。如果程序中存在对象的引用，这个对象就被定义为”有效的活动（引用可达）”，无法让垃圾回收器GC验证这些对象是否不再需要，这些对象就会驻留内存，消耗内存。典型的做法就是把对象数据成员设为null或者从集合中移除该对象。但当局部变量不需要时，不需明显的设为null，因为一个方法执行完毕时，这些引用会自动被清理。</p><p><strong>什么是 GC</strong></p><p>GC垃圾收集器，它让创建的对象不需要像c&#x2F;c++那样delete、free掉，GC的时间系统自身决定，时间不可预测。 对超出作用域的对象或引用置为空的对象进行清理，删除不使用的对象，腾出内存空间。</p><p><strong>内存溢出和内存泄漏</strong></p><p>内存泄露 memory leak，是指程序在申请内存后，忘了释放，就出现了内存泄漏，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！</p><p>内存溢出是要求分配的内存超出了系统能给的，系统不能满足需求，于是产生溢出。</p><p>Java 带垃圾回收的机制,为什么还会内存泄露呢?</p><p>举个例子 当你堆里某个对象没有被引用时，然后再过一段时间，垃圾回收机制才会回收，那么</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">while</span>（<span class="hljs-literal">true</span>）&#123;<span class="hljs-built_in">String</span> str=<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;ni hao ni hao &quot;</span>);&#125;<br></code></pre></td></tr></table></figure><p>一直循环创建 String对象。。。你觉得堆不会溢出嘛。。。</p><p><strong>内存泄露的根本原因就是保存了不可能再被访问的变量类型的引用和回收的不确定性</strong></p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>GC Roots算法<em>判定一个对象需要被回收</em>，GC Roots一般在JVM的栈区域里产生。<br>![[6.JVM#GC Roots]]</p><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>不使用 application 作为 context。当 context 为 application 时，会把 imageView 是生命周期延长到整个运行过程中，imageView 不能被回收，从而造成 OOM 异常。</p><p>((App) getApplication ()). leakviews.add (view);</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br>    public <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Object</span>&gt; leakviews = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在子线程调了其他类的方法，而其他类里用到了 context，是 activity 的 context，从而导致内存泄露</p><p>eventbus、webview（h5接口）、多进程<br>[[多进程Binder#内存泄露]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>( mWebView!=<span class="hljs-literal">null</span>) &#123;<br><br>        <span class="hljs-comment">// 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再</span><br>        <span class="hljs-comment">// destory()</span><br>        <span class="hljs-type">ViewParent</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> mWebView.getParent();<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>            ((ViewGroup) parent).removeView(mWebView);<br>        &#125;<br><br>        mWebView.stopLoading();<br>        <span class="hljs-comment">// 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span><br>        mWebView.getSettings().setJavaScriptEnabled(<span class="hljs-literal">false</span>);<br>        mWebView.clearHistory();<br>        mWebView.clearView();<br>        mWebView.removeAllViews();<br>        mWebView.destroy();<br><br>    &#125;<br>    <span class="hljs-built_in">super</span>.on <span class="hljs-title function_">Destroy</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postDelayed,几分钟之后打点统计、或者做其他操作,都是不合理的~或者在Message中处理非常耗时的操作,最后造成消息堆积,无法得到及时处理,最后造成内存泄露<br>Runnable(Thread)泄露相对更容易理解,主要是异步线程持有外部Activity 的引用,而回调Activity onDestroy方法时,线程没有执行完成,导致内存泄露</p><p>handler. removeCallbacksAndMessages (null);<br>removeCallbacks (Runnable r) 和 removeMessages (int what)</p><p><strong>1:在Activity的onDestroy执行时,Handler泄露可手动调用Handler的removeCallbacksAndMessages,清除异步消息,Runnable(Thread)泄露则可通过终止线程(控制逻辑需要自己写),切断引用链~推荐</strong><br><strong>2:将Handler,Runnable(Thread)定义为静态内部类,推荐</strong>，通过此方式,不会隐式持有外部Activity的引用<br>3:如果确实需要使用Activity做相关操作,建议使用弱引用,或者使用ApplicationContext,推荐<br>4:如果确实有耗时操作,建议使用jobschedule去做,推荐</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NestedScrollingParent</title>
    <link href="/2025/12/fc4a00731331.html"/>
    <url>/2025/12/fc4a00731331.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/8f412c6cb0ef">一篇文章让你轻松弄懂NestedScrollingParent &amp; NestedScrollingChild</a></p><p><a href="https://juejin.cn/post/7084926146675998756">NestedScrollView 从源码到实战..</a></p><p><a href="https://juejin.cn/post/6844904065567031303#heading-4">手把手实现ScrollView+ViewPager+RecyclerView常规嵌套首页布局</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/18/2024-02-27-17-57-d1297e898f9b0a591dada5f4864cfe97-09-58-18-d1297e898f9b0a591dada5f4864cfe97-unknown_filename.6-76ace0-fcbc50.png" alt="unknown_filename.6|600"></p><h2 id="谁实现-NestedScrollingChild，谁实现-NestedScrollingParent-？"><a href="#谁实现-NestedScrollingChild，谁实现-NestedScrollingParent-？" class="headerlink" title="谁实现 NestedScrollingChild，谁实现 NestedScrollingParent ？"></a>谁实现 NestedScrollingChild，谁实现 NestedScrollingParent ？</h2><p>在实际项目中，我们往往会遇到这样一种需求，当 <code>ViewA</code> 还显示的时候，往上滑动到 <code>viewA</code> 不可见时，才开始滑动 <code>viewB</code>，又或者向下滑动到 <code>viewB</code> 不能滑动时，才开始向上滑动 <code>viewC</code>. 如果列表滑动、上拉加载和下拉刷新的 <code>view</code> 都封装成一个组件的话，那滑动逻辑就是刚刚这样。</p><p>而这其中列表就要实现 <code>nestedScrollingChild</code>, 最外层的 <code>Container</code> 实现 <code>nestedScrollingParent</code>. 如果最外层的 <code>Container</code> 希望在其它布局中仍然能够将滑动事件继续往上冒泡，那么 <code>container</code> 在实现 <code>nestedScrollingParent</code> 的同时也要实现 <code>nestedScrollingChild</code>。如下示意图所示。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-07-11-19-48f904a7ccd705c205a4379eb9fc21db-20231107111903-69f33e.png" alt="image.png"><br>所以这个问题的答案：</p><p>触发滑动的组件或者接受到滑动事件且需要继续往上传递的是<code>nestedScrollingChild</code>.</p><p>是<code>nestedScrollingChild</code>的父布局，且需要消费传递的滑动事件就是<code>nestedScrollingParent</code>.</p><h2 id="滑动事件如何在二者之间传递和消费的？"><a href="#滑动事件如何在二者之间传递和消费的？" class="headerlink" title="滑动事件如何在二者之间传递和消费的？"></a>滑动事件如何在二者之间传递和消费的？</h2><h3 id="分辨API"><a href="#分辨API" class="headerlink" title="分辨API"></a>分辨API</h3><p>一个分辨是<code>child</code>和<code>parent</code>的<code>api</code>的一个小诀窍，因为<code>child</code>是产生滑动的造势者，所以它的<code>api</code>都是以直接的动词开头，而<code>parent</code>的滑动响应是<code>child</code>通知<code>parent</code>的，所以都是以监听<code>on</code>开头，这样就记住了。<br><code>parent</code> —-&gt; <code>onXXXX()</code><br><code>child</code> —–&gt; <code>verbXXXX()</code></p><h3 id="方法执行流程规范"><a href="#方法执行流程规范" class="headerlink" title="方法执行流程规范"></a>方法执行流程规范</h3><p><em>滑动产生时，由child主动通知，parent被动接收判断处理</em>。这里的child和parent不必是直接父子关系，child会向上遍历parent。<br>child.startNestedScroll -&gt; parent.onStartNestedScroll -&gt; parent.onNestedScrollAccepted -&gt;<br>child.dispatchNestedPreScroll -&gt; parent.onNestedPreScroll -&gt; child.dispatchNestedScroll -&gt;<br>parent.onNestedScroll -&gt; child.stopNestedScroll -&gt;parent.onStopNestedScroll</p><p>在onTouchEvent方法中，首先在DOWN时通过通知parent对滑动进行判断响应。之后在ACTION_MOVE过程中，计算滑动偏移量，优先交由parent进行消耗处理，若有parent接收处理，则在parent滑动后，减去parent消耗的偏移量，在交给自身或子view进行剩余偏移量的滑动。若自身或子view滑动后还有剩余的偏移量，则再交由parent处理。最后在UP&#x2F;CANCEL通知parent滑动结束。</p><h3 id="NestedScrollingChild"><a href="#NestedScrollingChild" class="headerlink" title="NestedScrollingChild"></a>NestedScrollingChild</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通知开始滑动，会回调父容器的onStartNestedScroll方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@ScrollAxis</span> <span class="hljs-type">int</span> axes, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通知停止滑动，会回调父容器的onStopNestedScroll方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">stopNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询是否有父容器支持指定类型的嵌套滑动。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNestedScrollingParent</span><span class="hljs-params">(<span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在子视图处理滑动前，先将滚动偏移量传递给父容器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchNestedPreScroll</span><span class="hljs-params">(<span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">int</span>[] consumed, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">int</span>[] offsetInWindow, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子视图处理滑动后，再将剩余的滚动偏移量传递给父容器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchNestedScroll</span><span class="hljs-params">(<span class="hljs-type">int</span> dxConsumed, <span class="hljs-type">int</span> dyConsumed, <span class="hljs-type">int</span> dxUnconsumed, <span class="hljs-type">int</span> dyUnconsumed, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">int</span>[] offsetInWindow, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br></code></pre></td></tr></table></figure><p><strong>NestedScrollingChild 和 NestedScrollingChild2的区别:</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-07-11-33-7c0ab2d9a1be28e46fb7ec344cee31bf-20231107113357-f91fa5.png" alt="image.png"></p><ul><li>NestedScrollType.TYPE_TOUCH 表示正常的滑动</li><li>NestedScrollType.TYPE_NON_TOUCH 表示在滑动过程中迅速点击屏幕,终止滑动</li></ul><p> <strong>NestedScrollingChild3 和 NestedScrollingChild2 的区别：</strong><br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-07-11-34-f29c7b459881f303bb33a2adcf3fd65a-20231107113454-f40ad2.png" alt="image.png"></p><h3 id="NestedScrollingParent"><a href="#NestedScrollingParent" class="headerlink" title="NestedScrollingParent"></a>NestedScrollingParent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子视图触发滑动时会回调该方法，父容器在该方法中根据子view、滑动方向、触摸类型等判断自己是否支持接收，</span><br><span class="hljs-comment"> * 若接收返回true，否则返回false。（可由NestedScrollingChild2的startNestedScroll方法触发）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">onStartNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-meta">@NonNull</span> View target, <span class="hljs-meta">@ScrollAxis</span> <span class="hljs-type">int</span> axes, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * onStartNestedScroll返回true后会回调该方法，可在此方法中做一些初始配置操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedScrollAccepted</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-meta">@NonNull</span> View target, <span class="hljs-meta">@ScrollAxis</span> <span class="hljs-type">int</span> axes, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始滑动时，子视图会优先回调该方法。父容器可以处理自己的滚动操作，之后将剩余的滚动偏移量</span><br><span class="hljs-comment"> * 传回给子视图。（可由NestedScrollingChild2的dispatchNestedPreScroll方法触发）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedPreScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy, <span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>[] consumed, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子视图处理完剩余的滚动偏移量后，若还有剩余，则将剩余的滚动偏移量再通过该回调传给</span><br><span class="hljs-comment"> * 父容器处理。（可由NestedScrollingChild2的dispatchNestedScroll方法触发）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-type">int</span> dxConsumed, <span class="hljs-type">int</span> dyConsumed, <span class="hljs-type">int</span> dxUnconsumed, <span class="hljs-type">int</span> dyUnconsumed, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当滑动结束时，回调该方法。（可由NestedScrollingChild2的stopNestedScroll方法触发）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onStopNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>tips: NestedScrollingParent2 和 NestedScrollingParent3 改动和 NestedScrollingChlid2&#x2F;NestedScrollingChlid3 一样</p></blockquote><h2 id="部分参数含义说明"><a href="#部分参数含义说明" class="headerlink" title="部分参数含义说明"></a>部分参数含义说明</h2><ul><li>child：表示包含target的当前容器的直接子view。</li><li>target：表示调用startNestedScroll触发onStartNestedScroll回调的那个子view。</li><li>axes：表示即将滑动的坐标轴方向，通过位运算求出方向。</li><li>type：表示触摸类型，有TYPE_TOUCH（用户触摸）、TYPE_NON_TOUCH（惯性滑动）两种类型。</li><li>dx：水平滑动偏移量。&lt;0表示手指向右划，&gt;0则相反。</li><li>dy：垂直滑动偏移量。&lt;0表示手指向下划，&gt;0则相反。</li><li>consumed：保存父容器滑动消耗的偏移量（索引0存x轴偏移，1存y轴偏移）。在父容器滑动后，子view会将原偏移量减去consumed中的值得到剩余偏移量，再进行自身的滚动处理。</li><li>dxConsumed：子view消耗的水平偏移量。</li><li>dyConsumed：子view消耗的垂直偏移量。</li><li>dxUnconsumed：子view滑动后还剩下的水平偏移量。</li><li>dyUnconsumed：子view滑动后还剩下的垂直偏移量。<br><strong>注意：若有用户触摸滑动到惯性滑动，会走两遍方法执行流程，即不同type各触发一次流程。</strong></li></ul><h2 id="NestedScrollView源码分析"><a href="#NestedScrollView源码分析" class="headerlink" title="NestedScrollView源码分析"></a>NestedScrollView源码分析</h2><h3 id="为什么-NestedScrollView-只能添加-1个-ChildView"><a href="#为什么-NestedScrollView-只能添加-1个-ChildView" class="headerlink" title="为什么 NestedScrollView 只能添加 1个 ChildView"></a>为什么 NestedScrollView 只能添加 1个 ChildView</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-07-11-45-1462b890b289dbbb5c43c3cc2659c9e5-20231107114539-558ed7.png" alt="image.png"></p><p>可以从 NestedScrollView#<code>addView(View child, ViewGroup.LayoutParams params)</code> 中看出,在添加第二个 View 的时候,直接就报错了,报错信息为:<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-07-11-48-ba0977cb732248690429e4603a14369c-20231107114800-163083.png" alt="image.png"></p><h3 id="NestedScrollView的事件分发流程"><a href="#NestedScrollView的事件分发流程" class="headerlink" title="NestedScrollView的事件分发流程"></a>NestedScrollView的事件分发流程</h3><p>事件分发主要分为:</p><ul><li>onInterceptTouchEvent</li><li>onTouchEvent<ul><li>ACTION_DOWM</li><li>ACTION_MOVE</li><li>ACTION_UP &#x2F; ACTION_CANCEL</li></ul></li></ul><h2 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h2><p>&#x3D;&#x3D;事件都是从子view开始的&#x3D;&#x3D;</p><h4 id="onTouchEvent-ACTION-DOWN事件"><a href="#onTouchEvent-ACTION-DOWN事件" class="headerlink" title="onTouchEvent#ACTION_DOWN事件"></a>onTouchEvent#ACTION_DOWN事件</h4><p>在 TouchEvent.DOWN 事件中通过<code>NestedScrollingChildHelper</code>调用 <code>NestedScrollingChild#startNestedScroll()</code>方法,那么<code>NestedScrollingChildHelper</code>就会通过么<code>ViewParentCompat</code>调用到 <code>NestedScrollingParent#onStartNestedScroll()</code>上,<code>parentView</code> 用来判断是否需要嵌套滚动,如果需要的话,返回 true,则立即调用到<code>NestedScrollingParent#onNestedScrollAccepted</code>上 完成最初的事件传递<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-07-14-04-d6ac7ab12bf9ab1b8d7cb764e475c6bf-20231107140440-b54cff.png" alt="image.png"></p><h4 id="onTouchEvent-ACTION-MOVE事件"><a href="#onTouchEvent-ACTION-MOVE事件" class="headerlink" title="onTouchEvent#ACTION_MOVE事件"></a>onTouchEvent#ACTION_MOVE事件</h4><p><code>ACTION_MOVE</code> : 小手指滑动位移为：<code>dy</code><br>–&gt; <code>childHelper.dispatchNestedPreScroll</code>(dy)<br>–&gt; <code>parent.onNestedPreScroll(dy)</code>, <code>consumedY = parent.onNestedPreScroll(dy)</code><br>–&gt; <code>dy&#39; = dy - consumeY</code> <code>recyclerView.scrollByInternal(dy&#39;)</code> <code>unconsumeY = dy&#39; - recyclerView.scrollByInternal(dy&#39;)</code><br>–&gt; <code>parent.startNestedScroll(unconsumeY)</code> 将未消耗的滑动位移继续移交给自己的<code>parent</code></p><h4 id="onTouchEvent-ACTION-UP事件"><a href="#onTouchEvent-ACTION-UP事件" class="headerlink" title="onTouchEvent#ACTION_UP事件"></a>onTouchEvent#ACTION_UP事件</h4><p>先是<code>child</code>执行<code>fling</code>方法，也就是当手松开时仍然有速度，那么会执行一段惯性滑动，而在这惯性滑动中， 这里就很奇妙了，先是通过<code>dispatchNestedPreFling()</code>将滑动速度传递给<code>parent</code>， 如果<code>parent</code>不消耗的话，再次通过<code>dispatchNestedFling</code>向<code>parent</code>传递，只是这次的传递会带上<code>child</code>自己是否有能力消费惯性滑动，最后不管<code>parent</code>有没有消费，<code>child</code>也就是<code>recyclerview</code>都会执行自己的<code>fling</code>.也就是:</p><p><code>mViewFlinger.fling(velocityX, velocityY);</code></p><p><code>ACTION_UP</code></p><p>–&gt; <code>childHelper.dispatchNestedPreFling</code><br>–&gt; <code>parent.onNestedPreFling</code><br>–&gt; <code>childHelper.dispatchNestedFling</code><br>–&gt; <code>parent.onNestedFling</code><br>–&gt; <code>child.fling</code><br>–&gt; <code>childHelper.stopNestedScroll</code><br>–&gt; <code>parent.onStopNestedScroll</code></p><p>这样，我们整个<code>nestedScrollingChild</code>和<code>nestedScrollingParent</code>之间的丝丝缕缕都讲解完了。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>view</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.Android屏幕适配</title>
    <link href="/2025/12/8def896b4756.html"/>
    <url>/2025/12/8def896b4756.html</url>
    
    <content type="html"><![CDATA[<h1 id="Android屏幕适配"><a href="#Android屏幕适配" class="headerlink" title="Android屏幕适配"></a>Android屏幕适配</h1><h3 id="dp的问题"><a href="#dp的问题" class="headerlink" title="dp的问题"></a>dp的问题</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D.resources/2023/09/15/18-49-51-e3094e900dccacb9d9e72063ca3084ce-unknown_filename-445de4.png" alt="unknown_filename"><br>px &#x3D; dp(dpi&#x2F;160)</p><ul><li>dpi是像素密度，指的是在系统软件上指定的单位尺寸的像素数量，它往往是写在系统出厂配置文件的一个固定值。</li><li>ppi参数，这个在手机屏幕中指的也是像素密度，但是这个是物理上的概念，它是客观存在的不会改变。dpi是软件参考了物理像素密度后，人为指定的一个值，这样保证了某一个区间内的物理像素密度在软件上都使用同一个值。这样会有利于我们的UI适配。</li><li>比如，几部相同分辨率不同尺寸的手机的ppi可能分别是430,440,450,那么在Android系统中，可能dpi会全部指定为480。这样的话，dpi&#x2F;160就会是一个相对固定的数值，这样就能保证相同分辨率下不同尺寸的手机表现一致。</li><li>而在不同分辨率下，dpi将会不同，比如：720P中，1dp&#x3D;2px，1080P中1dp&#x3D;3px</li></ul><table><thead><tr><th>…</th><th>1080*720</th><th>1920*1080</th></tr></thead><tbody><tr><td>dpi</td><td>320</td><td>480</td></tr><tr><td>dpi&#x2F;160</td><td>2</td><td>3</td></tr></tbody></table><p>autosize是头条方案，通过反射修改系统的density值</p><p><strong>通过dp加上自适应布局和weight比例布局可以基本解决不同手机上适配的问题，这基本是最原始的Android适配方案。</strong></p><p>有两个问题：</p><ol><li>只能保证我们写出来的界面适配绝大部分手机，部分手机仍然需要单独适配，为什么dp只解决了90%的适配问题，因为并不是所有的1080P的手机dpi都是480，比如Google 的Pixel2（1920* 1080）的dpi是420，也就是说，在Pixel2中，1dp&#x3D;2.625px,这样会导致相同分辨率的手机中，这样，一个100dp* 100dp的控件，在一般的1080P手机上，可能都是300px,而Pixel 2 中 ，就只有262.5px,这样控件的实际大小会有所不同。</li><li>开发麻烦，设计稿的宽高往往和Android的手机真实宽高差别极大，以我们的设计稿为例，设计稿的宽高是375px* 750px，而真实手机可能普遍是1080* 1920</li></ol><hr><h3 id="适配方法"><a href="#适配方法" class="headerlink" title="适配方法"></a>适配方法</h3><ol><li>宽高限定符适配<br> 设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens（第没审）文件。<br> 但是这个方案有一个致命的缺陷，那就是需要精准命中才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。</li><li>smallestWidth适配，或者叫sw限定符适配。</li></ol><ul><li>Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。<br>  和宽高限定符适配最大的区别在于，前者有很好的容错机制，<em>如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp</em>文件夹下面的资源文件。</li><li>从开发效率上，它不逊色于上述任意一种方案。根据固定的放缩比例，我们基本可以按照UI设计的尺寸不假思索的填写对应的dimens引用。</li><li>我们还有以375个像素宽度的设计稿为例，在values-sw360dp文件夹下的dimens文件应该怎么编写呢？<br>  这个文件夹下，意味着手机的最小宽度的dp值是360，我们把360dp等分成375等份，每一个设计稿中的像素，大概代表smallestWidth值为360dp的手机中的0.96dp，那么接下来的事情就很简单了，假如设计稿上出现了一个10px * 10px的ImageView,那么，我们就可以不假思索的在layout文件中写下对应的尺寸。<br>  原生的dp适配可能会碰到Pixel 2这种有些特别的手机需要单独适配，但是在smallestWidth适配中，通过计算Pixel 2手机的的smallestWidth的值是411，我们只需要生成一个values-sw411dp(或者取整生成values-sw410dp也没问题)就能解决问题。</li></ul><h4 id="AndroidAutoSize"><a href="#AndroidAutoSize" class="headerlink" title="AndroidAutoSize"></a>AndroidAutoSize</h4><p>![[Pasted image 20250703144144.png]]<br>AndroidAutoSize 的核心是通过<strong>动态重计算 density 值</strong>，使不同尺寸的设备都能按照设计图的比例进行缩放</p><p>系统默认：density &#x3D; dpi &#x2F; 160f<br>&#x2F;&#x2F; 基于设计图尺寸重新计算density<br>targetDensity &#x3D; screenWidthInPx &#x2F; designWidthInDp<br>当前设备屏幕总宽度（单位为像素）&#x2F; 设计图总宽度（单位为 dp) &#x3D; density （动态），意思就是 <em>1 dp 占当前设备多少像素</em></p><p>适配流程源码解析</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs abnf">public class AutoSize &#123;<br>    public static void init(...) &#123;<br>        // <span class="hljs-number">1</span>. 获取设备屏幕尺寸<br>        DisplayMetrics displayMetrics <span class="hljs-operator">=</span> appContext.getResources().getDisplayMetrics()<span class="hljs-comment">;</span><br>        <br>        // <span class="hljs-number">2</span>. 计算目标density<br>        float targetDensity <span class="hljs-operator">=</span> displayMetrics.widthPixels / designWidthInDp<span class="hljs-comment">;</span><br>        <br>        // <span class="hljs-number">3</span>. 修改系统DisplayMetrics<br>        displayMetrics.density <span class="hljs-operator">=</span> targetDensity<span class="hljs-comment">;</span><br>        displayMetrics.densityDpi <span class="hljs-operator">=</span> (int)(targetDensity * <span class="hljs-number">160</span>)<span class="hljs-comment">;</span><br>        displayMetrics.scaledDensity <span class="hljs-operator">=</span> targetDensity * (displayMetrics.scaledDensity / displayMetrics.density)<span class="hljs-comment">;</span><br>        <br>        // <span class="hljs-number">4</span>. 修改Activity DisplayMetrics<br>        DisplayMetrics activityMetrics <span class="hljs-operator">=</span> activity.getResources().getDisplayMetrics()<span class="hljs-comment">;</span><br>        activityMetrics.density <span class="hljs-operator">=</span> targetDensity<span class="hljs-comment">;</span><br>        activityMetrics.densityDpi <span class="hljs-operator">=</span> (int)(targetDensity * <span class="hljs-number">160</span>)<span class="hljs-comment">;</span><br>        activityMetrics.scaledDensity <span class="hljs-operator">=</span> targetDensity * (activityMetrics.scaledDensity / activityMetrics.density)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>![[Pasted image 20250703144520.png]]</p><hr><h3 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h3><ul><li>开发时选取主流屏幕 1280* 720，用相对布局和线性布局</li><li>用dp sp不用px，dp单位动态匹配开发后期在不同的分辨率上测试，没有太大问题可以上线</li><li>权重适配:weight 只有线性布局有</li><li>使用minWidth、minHeight、lines等属性</li><li>代码适配:getWindowManager().getDefaultDisplay().getWidth();</li><li>如果屏幕的宽高如果屏幕放不下了，可以使用 ScrollView（可以上下拖动）</li><li>布局适配:layout-800x180 针对某一种屏幕 工作量大</li><li>尺寸适配:dp&#x3D;px&#x2F;设备密度&#x3D;getResource().getDisplayMetrice().dsnsity;根据不同分辨率的屏幕建立不同的valuse，比如valuse-1280x720,values里的dimens里算出dp，最后引用系统会自动匹配。(约等于)320* 240（0.5） 480* 320（1） 480* 800（1.5） 1280* 720（2）就不用布局适配了</li><li>在进行开发的时候，我们需要把合适大小的图片放在合适的文件夹里面。大分辨率图片（单维度超过 1000）大分辨率图片建议统一放在 xxhdpi 目录下管理，否则将导致占用内存成倍数增加。根据当前的设备屏幕尺寸和密度，将会寻找最匹配的资源，如果将高分辨率图片放入低密度目录，将会造成低端机加载过大图片资源，又可能造成 OOM，同时也是资源浪费，没有必要在低端机使用大。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">DisplayMetrics metric = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DisplayMetrics</span>();<br><span class="hljs-built_in">getWindowManager</span>().<span class="hljs-built_in">getDefaultDisplay</span>().<span class="hljs-built_in">getMetrics</span>(metric);<br><span class="hljs-type">int</span> width = metric.widthPixels;  <span class="hljs-comment">// 屏幕宽度（像素）</span><br><span class="hljs-type">int</span> height = metric.heightPixels;  <span class="hljs-comment">// 屏幕高度（像素）</span><br><span class="hljs-type">float</span> density = metric.density;  <span class="hljs-comment">// 屏幕密度（0.75 / 1.0 / 1.5）</span><br><span class="hljs-type">int</span> densityDpi = metric.densityDpi;  <span class="hljs-comment">// 屏幕密度DPI（120 / 160 / 240）</span><br><span class="hljs-comment">//        px=dp(dpi/160)</span><br><span class="hljs-type">float</span> dp = width / (densityDpi / <span class="hljs-number">160</span>);<span class="hljs-comment">//最大宽度dp</span><br>Log.<span class="hljs-built_in">d</span>(<span class="hljs-string">&quot;HomeActivity&quot;</span>, width + <span class="hljs-string">&quot;---&quot;</span> + dp + <span class="hljs-string">&quot;----&quot;</span> + density + <span class="hljs-string">&quot;---&quot;</span> + densityDpi);<br><span class="hljs-comment">// 375</span><br><span class="hljs-comment">//768---384.0----2.0---320</span><br><span class="hljs-comment">//1080---540.0----2.75---440</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>view</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.Android动画</title>
    <link href="/2025/12/b6a0fdf8c755.html"/>
    <url>/2025/12/b6a0fdf8c755.html</url>
    
    <content type="html"><![CDATA[<h1 id="Android动画"><a href="#Android动画" class="headerlink" title="Android动画"></a>Android动画</h1><p>原理：不停修改view的不同属性，刷新</p><h3 id="动画实现方式"><a href="#动画实现方式" class="headerlink" title="动画实现方式"></a>动画实现方式</h3><h4 id="GIf"><a href="#GIf" class="headerlink" title="GIf"></a>GIf</h4><p>一般Gif或者帧动画 的性能差是由于图过多，每秒种几十帧，每一帧都是一张图。一个小动画往往需要几十张图。如果变成资源下载，资源包体积难以控制。</p><h4 id="原生"><a href="#原生" class="headerlink" title="原生"></a>原生</h4><p>Native 动画是属性动画或者补间动画。性能相比较gif而言性能比较好，但是有大量动画的需求时，往往生产力是不够的，一开始手动码动画，一个动画最多时写了3000多行code。<br>Native 动画优缺点：<br>开发成本高<br>必须发版<br>不能完全100%还原复杂动画，调参数比较繁<br>图片资源大,影响apk包大小</p><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>SVG图片格式，一种矢量图形。另一个角度来讲一张图或者一个动画，是由很多上下层级的图层构成。比如当前的简单的图，看到的是一张图，但在设计工具中是三个图层构成，有着不同的上下层级顺序。<br>原理：通过设置帧率，来生成一个配置文件，使得每一帧都有一个配置，每一帧都是关键帧，通过帧率去刷每一帧的画面，这个思路跟gif很像，但是通过配置使得动画过程中图片都可以得到复用。性能就提升上来了。</p><h4 id="Lottie"><a href="#Lottie" class="headerlink" title="Lottie"></a>Lottie</h4><p>完全按照设计工具的设计思路来进行还原，将动画脚本导出并解析。动画脚本非常的轻量。将所有的动画拆成多个层级,每个层级layer都有一个动画配置，播放时解析多个layer的配置，并给每个layer做相应的动画。也达到了图片可以复用。当需要解析高阶插值（二次线性方程，贝塞尔曲线方程）时，性能相对而言差一点。</p><p><strong>Lottie使用注意</strong><br>都是canvas 画布操作<br>lottie动画很卡顿，不流畅&#x2F;&#x2F;硬件加速，开启之后瞬间丝滑<br>遮罩或者蒙版，性能将会受到影响。<br>如果你在一个列表中使用动画, 我们建议你配置 LottieAnimationView.setAnimation(String, CacheStrategy) 的第二个参数——缓存策略，这样动画就不必每次都反序列化。</p><h3 id="Android中的动画"><a href="#Android中的动画" class="headerlink" title="Android中的动画"></a>Android中的动画</h3><p>三种：补间动画、帧动画、属性动画。<br>补间动画是放置到res&#x2F;anim&#x2F;下面<br>帧动画是放置到res&#x2F;drawable&#x2F;下面，子节点为animation-list，在这里定义要显示的图片和每张图片的显示时长</p><p>上下左右浮动效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectAnimator</span> <span class="hljs-variable">objectAnimator</span> <span class="hljs-operator">=</span> ObjectAnimator.ofFloat(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;translationY&quot;</span>, -<span class="hljs-number">6.0f</span>,<span class="hljs-number">6.0f</span>,-<span class="hljs-number">6.0f</span>);<br>   objectAnimator.setRepeatCount(ValueAnimator.INFINITE);<br>   objectAnimator.setDuration(<span class="hljs-number">800</span>);<br>   objectAnimator.start();<br>   <br>          animator2 = ObjectAnimator.ofFloat(ivHand2, <span class="hljs-string">&quot;translationY&quot;</span>, -<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,-<span class="hljs-number">20</span>);<br>        animator2.setRepeatMode(ValueAnimator.RESTART);<br>           animator2.setRepeatCount(-<span class="hljs-number">1</span>);<br>           animator2.setDuration(<span class="hljs-number">1000</span>);<br>           animator2.start();<br>   <br>    <br></code></pre></td></tr></table></figure><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影，一张张图片不断的切换，形成动画效果，要自己指定每一帧。</p><ul><li><p>帧动画使用xml定义<br>  在drawable目录下定义xml文件，子节点为animation-list，在这里定义要显示的图片和每张图片的显示时长</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span> <span class="hljs-attr">xmlns:androandroid:oneshot</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/g1&quot;</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;200&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/g2&quot;</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;200&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/g3&quot;</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;200&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在屏幕上播放帧动画</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ImageView</span> <span class="hljs-variable">iv</span> <span class="hljs-operator">=</span> (ImageView) findViewById(R.id.iv);<br>    <span class="hljs-comment">//把动画文件设置为imageView的背景</span><br>    iv.setBackgroundResource(R.drawable.animations);<br>    <span class="hljs-type">AnimationDrawable</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> (AnimationDrawable) iv.getBackground();<br>    <span class="hljs-comment">//播放动画</span><br>    ad.start();<br></code></pre></td></tr></table></figure></li></ul><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><ol><li>如果动画中的图像变换比较有规律时，例如图像的移动（TranslateAnimation）、旋转（RotateAnimation）、缩放（ScaleAnimation）、透明度渐变（AlphaAnimation），这些图像变化过程中的图像都可以根据一定的算法自动生成，我们只需要指定动画的第一帧和最后一帧图像即可，这种自动生成中间图像的动画就是补间动画。</li><li>补间动画，只是一个动画效果，组件其实还在原来的位置上，xy没有改变</li></ol><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><ol><li>补间动画改变了View的显示效果而已，而不会真正去改变View的属性，比如说，屏幕的左上角有一个按钮，然后通过补间动画将它移动到了屏幕的右下角，现在去尝试点击这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</li><li>动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了。</li></ol><h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><p>使⽤ View.animate() 创建对象，以及使⽤ViewPropertyAnimator.translationX() 等⽅法来设置动画；<br>可以连续调⽤来设置多个动画；<br>可以⽤ setDuration() 来设置持续时间；<br>可以⽤ setStartDelay() 来设置开始延时；<br>以及其他⼀些便捷⽅法。</p><p>view.animate().translationX(500);<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%8A%A8%E7%94%BB.resources/2023/09/15/18-47-55-522340c178b8984a99995fb222c6c7b4-unknown_filename-1e6462.png" alt="unknown_filename"></p><h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator是整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，是一个非常重要的类。<br>可以在动画多的时候用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">anim</span> <span class="hljs-operator">=</span> ValueAnimator.ofFloat(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);  <br>anim.setDuration(<span class="hljs-number">300</span>);  <br>anim.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123; <br>        <span class="hljs-type">float</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) animation.getAnimatedValue();  <br>        Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;cuurent value is &quot;</span> + currentValue);  <br>    &#125;  <br>&#125;);  <br>anim.start();  <br></code></pre></td></tr></table></figure><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡。而ObjectAnimator则就不同了，<strong>它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。</strong> 它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ObjectAnimator</span> oa = ObjectAnimator.ofFloat(bt, <span class="hljs-string">&quot;translationX&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) ;//位移<br><span class="hljs-attribute">ObjectAnimator</span> oa = ObjectAnimator.ofFloat(bt, <span class="hljs-string">&quot;scaleY&quot;</span>, <span class="hljs-number">0</span>.<span class="hljs-number">1</span>f, <span class="hljs-number">2</span>);//缩放<br><span class="hljs-attribute">ObjectAnimator</span> oa = ObjectAnimator.ofFloat(bt, <span class="hljs-string">&quot;alpha&quot;</span>, <span class="hljs-number">0</span>.<span class="hljs-number">1</span>f, <span class="hljs-number">1</span>);//透明<br> <span class="hljs-attribute">ObjectAnimator</span> oa = ObjectAnimator.ofFloat(bt, <span class="hljs-string">&quot;rotation&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">270</span>);//旋转<br> <span class="hljs-attribute">oa</span>.start();<br></code></pre></td></tr></table></figure><p>属性动画的优势在于，可以为⾃定义属性设置动画。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ObjectAnimator</span> animator = ObjectAnimator.ofObject(view,<span class="hljs-string">&quot;radius&quot;</span>, Utils.dp2px(<span class="hljs-number">200</span>));<br></code></pre></td></tr></table></figure><p>另外，⾃定义属性需要设置 getter 和 setter ⽅法，并且 setter ⽅法⾥需要调⽤invalidate() 来触发重绘：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> <span class="hljs-title">getRadius</span>()</span> &#123;<br><span class="hljs-keyword">return</span> radius;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> radius</span>)</span> &#123;<br><span class="hljs-keyword">this</span>.radius = radius;<br>invalidate();<br>&#125;<br></code></pre></td></tr></table></figure><p>设置旋转起点</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">mArrowImageView.<span class="hljs-built_in">set</span>PivotX(mArrowImageView.getMeasureWidth() / <span class="hljs-number">2</span>);<br>mArrowImageView.<span class="hljs-built_in">set</span>PivotY(mArrowImageView.getMeasureHeight() / <span class="hljs-number">2</span>);<br>ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(<br>                mArrowImageView, <span class="hljs-string">&quot;rotate&quot;</span>, <span class="hljs-keyword">from</span>D<span class="hljs-literal">egress</span>, <span class="hljs-keyword">to</span>D<span class="hljs-literal">egress</span>);<br>objectAnimator.<span class="hljs-built_in">set</span>Duration(<span class="hljs-number">100</span>);<br>objectAnimator.start();<br></code></pre></td></tr></table></figure><p>可以使用reverse，就不需要重新创建个动画了</p><h3 id="Interpolator"><a href="#Interpolator" class="headerlink" title="Interpolator"></a>Interpolator</h3><p>插值器，⽤于设置时间完成度到动画完成度的计算公式，直⽩地说即设置动画的速度曲线，通过 setInterpolator(Interpolator) ⽅法来设置。常⽤的有 AccelerateDecelerateInterpolator、<br>AccelerateInterpolator、DecelerateInterpolator、LinearInterpolator 。</p><p><em>差值器和估值器是什么?</em><br>Interpolator 负责控制动画变化的速率，使得基本动画能够以匀速、加速、减速、抛物线速率等各种速率变化。<br>TypeEvaluator 设置属性值，从初始值过度到结束值的变化具体数值。</p><h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>⽤于设置更加详细的动画，例如多个属性应⽤于同⼀个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PropertyValuesHolder</span> <span class="hljs-variable">holder1</span> <span class="hljs-operator">=</span> PropertyValuesHolder.ofFloat(<span class="hljs-string">&quot;radius&quot;</span>, <br>Utils.dp2px(<span class="hljs-number">200</span>));<br><span class="hljs-type">PropertyValuesHolder</span> <span class="hljs-variable">holder2</span> <span class="hljs-operator">=</span> PropertyValuesHolder.ofFloat(<span class="hljs-string">&quot;offset&quot;</span>, Utils.dp2px(<span class="hljs-number">100</span>));<br><span class="hljs-type">ObjectAnimator</span> <span class="hljs-variable">animator</span> <span class="hljs-operator">=</span> PropertyValuesHolder.ofPropertyValuesHolder(view, holder1, holder2);<br></code></pre></td></tr></table></figure><p>或者，配合使⽤ Keyframe ，对⼀个属性分多个段：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Keyframe</span> keyframe1 = Keyframe.ofFloat(<span class="hljs-number">0</span>,Utils.dpToPixel(<span class="hljs-number">100</span>));<br><span class="hljs-attribute">Keyframe</span> keyframe2 = Keyframe.ofFloat(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>f,Utils.dpToPixel(<span class="hljs-number">250</span>));<br><span class="hljs-attribute">Keyframe</span> keyframe3 = Keyframe.ofFloat(<span class="hljs-number">1</span>,Utils.dpToPixel(<span class="hljs-number">200</span>));<br><span class="hljs-attribute">PropertyValuesHolder</span> holder =PropertyValuesHolder.ofKeyframe(<span class="hljs-string">&quot;radius&quot;</span>, keyframe1,<br><span class="hljs-attribute">keyframe2</span>, keyframe3);<br><span class="hljs-attribute">ObjectAnimator</span> animator =ObjectAnimator.ofPropertyValuesHolder(view, holder);<br></code></pre></td></tr></table></figure><h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><p>将多个 Animator 合并在⼀起使⽤，先后顺序或并列顺序都可以：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">AnimatorSet animatorSet = <span class="hljs-keyword">new</span> <span class="hljs-type">AnimatorSet</span>();<br>animatorSet.playTogether(animator1, animator2);<br>animatorSet.start();<br></code></pre></td></tr></table></figure><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a>TypeEvaluator</h3><p>⽤于设置动画完成度到属性具体值的计算公式。默认的 ofInt() ofFloat() 已经有了⾃带的 IntEvaluator FloatEvaluator ，但有的时候需要⾃⼰设置Evaluator。例如，对于颜⾊，需要为 int 类型的颜⾊设置 ArgbEvaluator，⽽不是让它们使⽤ IntEvaluator</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">animator.setEvaluator(<span class="hljs-keyword">new</span> <span class="hljs-type">ArgbEvaluator</span>());<br></code></pre></td></tr></table></figure><p>如果你对 ArgbEvaluator 的效果不满意，也可以⾃⼰写⼀个 HsvEvaluator ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HsvEvaluator</span> <span class="hljs-keyword">implements</span><br><span class="hljs-title class_">TypeEvaluator</span>&lt;<span class="hljs-title class_">Integer</span>&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">float fraction, <span class="hljs-built_in">Object</span></span><br><span class="hljs-params">startValue, <span class="hljs-built_in">Object</span> endValue</span>) &#123;<br>...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，对于不⽀持的类型，也可以使⽤ ofObject() 来在创建 Animator 的同时就设置上 Evaluator，⽐如 NameEvaluator ：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">NameEvaluator</span> <span class="hljs-title">implements</span>        </span><br><span class="hljs-title class_"><span class="hljs-title">TypeEvaluator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;   <br>List&lt;<span class="hljs-keyword">String</span>&gt; names = ...;   <br><span class="hljs-meta">@Override    </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> evaluate(float fraction, <span class="hljs-keyword">String</span>  startValue, <span class="hljs-keyword">String</span> endValue) &#123;       <br><span class="hljs-keyword">if</span> (!names.contains(startValue)) &#123;            <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Start value not existed&quot;</span>);       <br>&#125;       <br><span class="hljs-keyword">if</span> (!names.contains(endValue)) &#123;            <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Endvalue not existed&quot;</span>);       <br>&#125;       <br>int index = (int) ((names.indexOf(endValue) - names.indexOf(startValue)) * fraction);        <br><span class="hljs-keyword">return</span> names.<span class="hljs-keyword">get</span>(index);    <br>&#125;<br>&#125;<br>ObjectAnimator animator = ObjectAnimator.ofObject(view, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-keyword">new</span>  <span class="hljs-type">NameEvaluator</span>(), <span class="hljs-string">&quot;Jack&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3><p><strong>硬件加速是什么</strong><br>使⽤ CPU 绘制到 Bitmap，然后把 Bitmap 贴到屏幕，就是软件绘制；<br>使⽤ CPU 把绘制内容转换成 GPU 操作，交给 GPU，由 GPU 负责真正的绘制，就叫硬件绘制；<br>使⽤ GPU 绘制就叫做硬件加速<br><strong>怎么就加速了？</strong><br>GPU 分摊了⼯作<br>GPU 绘制简单图形（例如⽅形、圆形、直线）在硬件设计上具有先天优势，会更快流程得到优化（重绘流程涉及的内容更少）<br><strong>硬件加速的缺陷：</strong><br>兼容性。由于使⽤ GPU 的绘制（暂时）⽆法完成某些绘制，因此对于⼀些特定的API，需要关闭硬件加速来转回到使⽤ CPU 进⾏绘制。</p><h3 id="view动画的特殊使用场景"><a href="#view动画的特殊使用场景" class="headerlink" title="view动画的特殊使用场景"></a>view动画的特殊使用场景</h3><p>activity overridePendingTransition，可以是补间（下面的），也可以是熟悉动画<br>FragmentTransaction中的 setCustomAnimations 方法（不能是属性动画）</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%8A%A8%E7%94%BB.resources/2023/09/15/18-47-55-1406b168996cde1f32fda877b18e5ec1-Image-161916.jpg" alt="Image"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%E5%8A%A8%E7%94%BB.resources/2023/09/15/18-47-55-6a8855482bd0b0799c0207a8793380d8-Image.1-c0e21b.jpg" alt="Image.1"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>view</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.requestLayout</title>
    <link href="/2025/12/d170891dd6f9.html"/>
    <url>/2025/12/d170891dd6f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>其一：锁屏后，调用 View.requestLayout ()，会往上层层调用 requestLayout () 吗？<br>其二：锁屏后，调用 View.requestLayout ()，会触发 View 的测量和布局操作吗？</p><h2 id="第一层-往上，层层遍历"><a href="#第一层-往上，层层遍历" class="headerlink" title="第一层(往上，层层遍历)"></a>第一层(往上，层层遍历)</h2><p>假设调用I.requestLayout ()，会触发哪些 View 的 requestLayout 方法？<br>答：会依次触发I.requestLayout () -&gt; C.requestLayout () -&gt; A.requestLayout () -&gt; … 省略一些 View -&gt; ViewRootImpl.requestLayout ()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//View.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span>()</span> &#123;<br>    <span class="hljs-comment">// 1. 清除测量记录</span><br>    <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-literal">null</span>) mMeasureCache.clear();<br><br>    <span class="hljs-comment">// 2. 增加PFLAG_FORCE_LAYOUT给mPrivateFlags</span><br>    mPrivateFlags |= PFLAG_FORCE_LAYOUT;<br>    mPrivateFlags |= PFLAG_INVALIDATED;<br><br>    <span class="hljs-comment">// 3. 如果mParent没有调用过requestLayout，则调用之。换句话说，如果调用过，则不会继续调用</span><br>    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-literal">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;<br>        mParent.requestLayout();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法作用如下：</p><ol><li><strong>清除测量记录</strong></li><li><strong>增加PFLAG_FORCE_LAYOUT给mPrivateFlags</strong></li><li><strong>如果mParent没有调用过requestLayout，则调用之。换句话说，如果调用过，则不会继续调用</strong></li></ol><p>重点看下mParent.isLayoutRequested()方法，它在View.java中有具体实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//View.java</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isLayoutRequested</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (mPrivateFlags &amp; <span class="hljs-variable constant_">PFLAG_FORCE_LAYOUT</span>) == <span class="hljs-variable constant_">PFLAG_FORCE_LAYOUT</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在View调用完layout方法，会将PFLAG_FORCE_LAYOUT标志位清除掉。当View下次再调用requestLayout方法时，依旧能往上层层调用。但是<em>如果当layout()方法没有执行时</em>，下次再调用requestLayout方法时，就不会往上层层调用了。</p><p>其一：锁屏后，调用 View.requestLayout ()，会往上层层调用 requestLayout () 吗？<br>答：锁屏后，除了第一次调用会往上层层调用，其它的都不会<br>为什么，只有第一次调用会呢？那必定是因为 layout 方法没有得到执行，导致 PFLAG_FORCE_LAYOUT 无法被清除</p><h2 id="第二层-ViewRootImpl-requestLayout"><a href="#第二层-ViewRootImpl-requestLayout" class="headerlink" title="第二层(ViewRootImpl.requestLayout)"></a>第二层(ViewRootImpl.requestLayout)</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//ViewRootImpl.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">requestLayout</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;<br>        <span class="hljs-title function_">checkThread</span>();<br>        mLayoutRequested = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">scheduleTraversals</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">scheduleTraversals</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//1. 往主线程的Handler对应的MessageQueue发送一个同步屏障消息</span><br>        mTraversalBarrier = mHandler.<span class="hljs-title function_">getLooper</span>().<span class="hljs-title function_">getQueue</span>().<span class="hljs-title function_">postSyncBarrier</span>();<br>        <span class="hljs-comment">//2. 将mTraversalRunnable保存到Choreographer中</span><br>        mChoreographer.<span class="hljs-title function_">postCallback</span>(<span class="hljs-title class_">Choreographer</span>.<span class="hljs-property">CALLBACK_TRAVERSAL</span>, mTraversalRunnable, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;<br>            <span class="hljs-title function_">scheduleConsumeBatchedInput</span>();<br>        &#125;<br>        <span class="hljs-title function_">notifyRendererOfFramePending</span>();<br>        <span class="hljs-title function_">pokeDrawLockIfNeeded</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法主要作用如下：</p><ol><li><strong>往主线程的Handler对应的MessageQueue发送一个同步屏障消息</strong></li><li><strong>将mTraversalRunnable保存到Choreographer中</strong></li></ol><p>此处有三个特别重要的知识点：</p><ol><li><strong>mTraversalRunnable</strong></li><li><strong>MessageQueue的同步屏障</strong></li><li><strong>Choreographer机制</strong>  [[2.Handler 里的各种消息#Choreographer]]</li></ol><p>mTraversalRunnable相对比较简单，它的作用就是从ViewRootImpl 从上往下执行performMeasure、performLayout、performDraw。<br>它的执行时机是当Vsync信号来到时，会往主线程的Handler对应的MessageQueue中发送一条异步消息，由于在scheduleTraversals()中给MessageQueue中发送过一条同步屏障消息，那么当执行到同步屏障消息时，会将异步消息取出执行</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;<br>      <span class="hljs-built_in">performMeasure</span>()<br>    &#125;<br><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>    <span class="hljs-keyword">if</span> (didLayout) &#123;<br>      <span class="hljs-built_in">performLayout</span>(lp, mWidth, mHeight);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.<span class="hljs-built_in">dispatchOnPreDraw</span>() || !isViewVisible;<br><br>    <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<br>        <span class="hljs-built_in">performDraw</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的作用：</p><ol><li><strong>满足条件的情况下调用performMeasure()</strong></li><li><strong>满足条件的情况下调用performLayout()</strong></li><li><strong>满足条件的情况下调用performDraw()</strong></li></ol><p>mStopped表示Activity是否处于stopped状态。如果<em>Activity调用了onStop方法，performLayout方法是不会调用的</em>。</p><p>其二：锁屏后，调用 View.requestLayout ()，会触发 View 的测量和布局操作吗？<br>答：不会，因为当前 Activity 处于 stopped 状态了,<strong>因为不会执行View.layout()方法，所以PFLAG_FORCE_LAYOUT不会被清除，导致接下来的requestLayout方法不会层层往上调用。</strong></p><p>其三：既然 Activity 的 onStop 会导致 requestLayout layout 方法得不到执行，那么 onResume 方法会不会让上一次的 requestLayout 没有执行的 layout 方法执行一次呢？<br>亮屏调用了performTraversals方法时，会执行Measure、Layout、Draw等操作<br>![[Pasted image 20250820154352.png]]</p><h1 id="requestLayout-后没有-onMearsu"><a href="#requestLayout-后没有-onMearsu" class="headerlink" title="requestLayout 后没有 onMearsu"></a>requestLayout 后没有 onMearsu</h1><p> requestLayout 后没有 onMearsure<br>getItem 的实际堆栈<br>![[Pasted image 20250714102910.png]]</p><p><strong>onMeasure ()</strong> → populate () → addNewItem () → adapter.instantiateItem () → getItem ()<br>其实 viewpager setAdapter 里会调用 requestlayout 但是没有执行 onMeasure，原因是<strong>因为 view 测量的时候若 View 的可见性为 View. GONE，系统会跳过其测量流程</strong>。而 viewpager 的父 view 抽屉 view 第一次设置的就是 gone，所以没有调用 onMeasure<br>![[Pasted image 20250714102944.png]]<br>修改：第一次切换抽屉模式后设置抽屉 view 为 INVISIBLE</p><h1 id="requestLayout-后没传到父-view"><a href="#requestLayout-后没传到父-view" class="headerlink" title="requestLayout 后没传到父 view"></a>requestLayout 后没传到父 view</h1><p>将所有应用分为3个文件夹放置 dock 栏，切换布局规则，文件夹大小无变化，长按后更新大小<br>按理来说：<em>requestLayout 是向上传递</em>，调用子 View 的 requestLayout () 会递归向上传递到父 View，这是因为 dock  子 view requestLayout 了，<em>但是没有传到 dock</em>，然后  onMeasure 没有执行。</p><p>通过分析源码 requestLayout 方法：mParent.isLayoutRequested () 是 false 才能执行父 view requestLayout。<br>通过查找是 dock 在桌面加载的时候调用了 forceLayout，这个方法会导致 isLayoutRequested 成 true，但是没有 <code>measure</code>，所以这个标志位一直是 true，然后子 view <code>requestLayout</code> 就不会刷新父 view<br>最后修改，取消了 forcelayout ，直接修改 view 的属性 setBlur</p><ul><li><code>requestLayout()</code> 需要逐层向上触发父布局的 <code>requestLayout()</code>，最终到达 <code>ViewRootImpl</code>。</li></ul><p><strong>FolderIcon1x1</strong> isLayoutRequested 是 true，如下面源码所示，所以父 view requestLayout 没有执行，而 hotset 的 <em>isLayoutRequested 是 false</em><br>![[Pasted image 20250619155726.png]]<br>为什么 FolderIcon1x1 isLayoutRequested 是 true？</p><p>  <em>PFLAG_FORCE_LAYOUT 就是防止重复调用的，如果调用过，则不会继续调用</em>，测量布局后会清掉</p><p><code>isLayoutRequested</code> 源码</p><p><strong>请求布局阶段：</strong></p><ul><li><strong>调用</strong><code>requestLayout()</code> 或 <code>forceLayout()</code></li><li><strong>操作</strong>：设置 <code>PFLAG_FORCE_LAYOUT</code> 标志，<strong>强制下一次 measure 一定要重新执行</strong>。</li><li><strong>结果</strong>：<code>isLayoutRequested()</code> 返回 true，系统知道该 View 需要重新布局</li></ul><p><strong>布局处理阶段：</strong></p><ul><li><strong>进入</strong><code>measure()</code> 或 <code>layout()</code> 方法</li><li><strong>操作</strong>：这个标志位会在 <strong>真正执行 <code>measure()</code> 过程中清掉</strong>。</li><li><strong>结果</strong>：完成测量和布局之后，<code>isLayoutRequested()</code> 返回 false</li></ul><p>![[Pasted image 20250619155934.png]]<br>[BugFix][Launcher]开启深色模式，文件夹拖拽到 dock 栏，文件夹显示黑色，开启浅色模式，dock 栏的文件夹黑色没有变化<br>[RootCause]: 从设置更改深色浅色模式的时候 dock 栏的子 view 不会 onlayout<br>[Modify]: 在 hotseats 执行 onlayout 的时候对子 view 遍历执行 layout</p><p>最后修改，取消了 forcelayout ，直接修改 setBlur<br><a href="https://gerrit.pt.mioffice.cn/c/platform/packages/apps/MiuiHome/+/5278057">https://gerrit.pt.mioffice.cn/c/platform/packages/apps/MiuiHome/+/5278057</a></p><p>dock 在桌面加载的时候 forceLayout，导致 isLayoutRequested 成 true，但是没有 <code>measure</code>，所以这个标志位一直是 true，然后子 view <code>requestLayout</code> 就不会刷新父 view</p><h1 id="子-view-是否需要调用-requestLayout"><a href="#子-view-是否需要调用-requestLayout" class="headerlink" title="子 view 是否需要调用 requestLayout"></a>子 view 是否需要调用 requestLayout</h1><p>mPreviewContainer.requestLayout ()<br>mImageView.requestLayout ()<br>mFolderCover.requestLayout ()</p><p><strong>如果自己 requestLayout 后，子 view 是否需要调用 requestLayout？</strong><br>需要，因为需要子 view requestLayout，会设置标记位，有这个标记位，父 view 的 onMeasure 才会调用子 view 的 onMeasure</p><p>![[Pasted image 20250619155456.png]]</p><ol><li>3个子 view requestLayout 都完了，父 view requestLayout 才会执行，只调一次，系统合并优化</li><li><em>子 view 大小改变</em>，然后导致父 view requestLayout 才会执行</li><li>父 View 的 MeasureSpec 未变化，导致子 View 的 onMeasure () 未被调用。所以调用子 view requestLayout，子 view onMeasure 没执行</li><li><em>requestLayout 是向上传递。不会向下传递</em>，调用子 View 的 requestLayout () 会递归向上传递到父 View，直到根 View<br><a href="https://wayawbott0.f.mioffice.cn/docx/doxk4JoJmzat1c2edpyF5CvdFcJ">https://wayawbott0.f.mioffice.cn/docx/doxk4JoJmzat1c2edpyF5CvdFcJ</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.RecycleView 嵌套卡顿</title>
    <link href="/2025/12/a0bad8cfa7a3.html"/>
    <url>/2025/12/a0bad8cfa7a3.html</url>
    
    <content type="html"><![CDATA[<h2 id="RecycleView-嵌套卡顿"><a href="#RecycleView-嵌套卡顿" class="headerlink" title="RecycleView 嵌套卡顿"></a>RecycleView 嵌套卡顿</h2><p><a href="https://blog.csdn.net/qq_30983519/article/details/81280274">https://blog.csdn.net/qq_30983519/article/details/81280274</a></p><ol><li>共用 RecycledViewPool，holder. innerRecyclerView. setRecycledViewPool (viewPool)<br>2. <em>setInitialPrefetchItemCount</em> (int) 来优化嵌套时预加载性能</li><li>设置 recycleview 的子项缓存 rv. setItemViewCacheSize (200);</li><li>rv. setHasFixedSize (true);</li><li>recyclerview 嵌套 recyclerview 的时候, adapter 全局变量</li></ol><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>setInitialPrefetchItemCount</strong></p><p>位置：LinearLayoutManager、GridLayoutManager<br>作用：控制预取 (prefetch) 的数量。<br>当 RecyclerView 嵌套 RecyclerView（比如外层是列表，内层是横向的 banner&#x2F;卡片列表）时，外层滑到某个 item，系统会提前帮你把内层 RecyclerView 的子 item 创建&#x2F;绑定好，避免用户滑动到时才加载导致卡顿。<br>默认值一般是 2（也就是提前加载 2 个子项）。</p><p>👉 优化点：<br>减少「卡顿感」，让用户滑动到新区域时内容已经准备好。<br>（主要是滑动流畅度）</p><p><strong>setItemViewCacheSize</strong></p><p>位置：RecyclerView 本身<br>作用：设置 RecyclerView 缓存区 (cache) 能保留多少个离屏的 ViewHolder。<br>默认是 2，也就是说屏幕外的 2 个 item 不会立刻回收，而是放到缓存里，滑回来时可以直接复用，减少重新绑定数据和创建 ViewHolder 的开销。</p><p>👉 优化点：<br>减少频繁的创建和绑定 ViewHolder，在来回滚动时更高效。<br>（主要是 CPU 开销和回收&#x2F;复用性能）</p><p><strong>对比总结</strong></p><p>![[Pasted image 20250909141809.png]]</p><p><strong>使用建议</strong><br>嵌套场景（横向列表 inside 纵向列表）：调大 setInitialPrefetchItemCount，<em>一般设成横向列表一屏能展示的数量</em>。<br>单层长列表：可以根据内存情况调大 setItemViewCacheSize，比如设成 10，减少频繁回收。</p><h2 id="NestedScrollView-嵌套-recyclerView"><a href="#NestedScrollView-嵌套-recyclerView" class="headerlink" title="NestedScrollView 嵌套 recyclerView"></a>NestedScrollView 嵌套 recyclerView</h2><p><strong>NestedScrollview 和 recycler View 嵌套的时候, recyclerview 的缓存机制失效了, 这种情况有没有什么好的解决办法呢?</strong><br><em>NestedScrollView 传递给子 View 的测量模式为 UNSPECIFIED</em>，RecyclerView 在 UNSPECIFIED 的测量模式下，会不限制自身的高度，即 RecyclerView 的窗口高度将会变成所有 item 高度累加后加上 paddding 的高度。因此，表现出来就是 item 一次性全部加载完成。<br>这样做在 RecyclerView 的 item 数量较少的时候可能没什么问题，但是如果 item 数量比较多，随之带来的性能问题就会很严重。</p><p>推荐使用 RecyclerView 的多样式布局实现，毕竟 RecyclerView 自带滑动，没必要外层套一个 ScrollerView 或者 NestedScrollView</p><p>必须嵌套，解决方案：<br><a href="https://www.jianshu.com/p/f3f18db711ce">懒饭详情页嵌套效果仿写（View&#x2F;Compose 实现） - 简书</a><br>问题本质上其实就是因为高度不确定导致复用失效了，那其实指定 RecyclerView 的高度即可，例如屏幕的高。</p><ul><li><p><strong>在未到达临界高度之前</strong></p><ul><li>所有滚动（scroll &#x2F; fling）都由外层 <code>NestedScrollView</code> 消费</li></ul></li><li><p><strong>到达临界高度之后</strong></p><ul><li>外层不再滚动</li><li>剩余的滚动和 fling 交由内部 <code>RecyclerView</code> 处理</li></ul></li></ul><p>![[Pasted image 20250703145905.png]]</p><p>[[NestedScrollingParent]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始滑动时，子视图会优先回调该方法。父容器可以处理自己的滚动操作，之后将剩余的滚动偏移量传回给子视图。</span><br><span class="hljs-comment">   （可由 NestedScrollingChild2的 dispatchNestedPreScroll 方法触发）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedPreScroll</span> <span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy, <span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>[] consumed, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子视图处理完剩余的滚动偏移量后，若还有剩余，则将剩余的滚动偏移量再通过该回调传给父容器处理。</span><br><span class="hljs-comment">   （可由 NestedScrollingChild2的 dispatchNestedScroll 方法触发）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-type">int</span> dxConsumed, <span class="hljs-type">int</span> dyConsumed, <span class="hljs-type">int</span> dxUnconsumed, <span class="hljs-type">int</span> dyUnconsumed, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type)</span>;<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>scrollViewHeadHeight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">override fun <span class="hljs-title function_">onNestedPreScroll</span><span class="hljs-params">(target: View, dx: Int, dy: Int, consumed: IntArray, type: Int)</span> &#123;<br><span class="hljs-keyword">if</span> (scrollY &lt; scrollViewHeadHeight) &#123;<br>            <span class="hljs-keyword">if</span> (scrollY + dy &lt; scrollViewHeadHeight) &#123;<br>                scrollBy(<span class="hljs-number">0</span>, dy)<br>                consumed[<span class="hljs-number">1</span>] = dy<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scrollY + dy &gt; scrollViewHeadHeight) &#123;<br>                <span class="hljs-type">val</span> <span class="hljs-variable">scrollViewNeedScrollY</span> <span class="hljs-operator">=</span> scrollViewHeadHeight - scrollY<br>                <span class="hljs-title function_">scrollBy</span><span class="hljs-params">(<span class="hljs-number">0</span>, scrollViewNeedScrollY)</span><br>                consumed[<span class="hljs-number">1</span>] = scrollViewNeedScrollY<br>            &#125;<br>    &#125;<br>&#125;<br><br>override fun <span class="hljs-title function_">fling</span><span class="hljs-params">(velocityY: Int)</span> &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> FlingUtil.getDistanceByVelocity(context, velocityY)<br>    <span class="hljs-keyword">if</span> (scrollY &lt; scrollViewHeadHeight) &#123;<br>        <span class="hljs-keyword">if</span> (scrollY + dy &lt;= scrollViewHeadHeight) &#123;<br>            <span class="hljs-built_in">super</span>.fling(velocityY)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scrollY + dy &gt; scrollViewHeadHeight) &#123;<br>            <span class="hljs-type">val</span> <span class="hljs-variable">scrollViewNeedScrollY</span> <span class="hljs-operator">=</span> scrollViewHeadHeight - scrollY<br>            <span class="hljs-comment">//让NestedScrollView先处理所有的滚动事件</span><br>            <span class="hljs-type">val</span> <span class="hljs-variable">scrollViewNeedVelocity</span> <span class="hljs-operator">=</span> FlingUtil.getVelocityByDistance(context, scrollViewNeedScrollY.toDouble())<br>            <span class="hljs-keyword">if</span> (velocityY &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">super</span>.fling(scrollViewNeedVelocity)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">super</span>.fling(-scrollViewNeedVelocity)<br>            &#125;<br>            <span class="hljs-comment">//把剩余的滚动事件交给RecyclerView处理</span><br>            <span class="hljs-type">val</span> <span class="hljs-variable">recyclerViewScrollY</span> <span class="hljs-operator">=</span> dy - scrollViewNeedScrollY<br>            <span class="hljs-type">val</span> <span class="hljs-variable">recyclerViewNeedVelocity</span> <span class="hljs-operator">=</span> FlingUtil.getVelocityByDistance(context, recyclerViewScrollY)<br>            <span class="hljs-keyword">if</span> (velocityY &gt; <span class="hljs-number">0</span>) &#123;<br>                getChildRecyclerView(<span class="hljs-built_in">this</span>)?.fling(<span class="hljs-number">0</span>, recyclerViewNeedVelocity)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                getChildRecyclerView(<span class="hljs-built_in">this</span>)?.fling(<span class="hljs-number">0</span>, -recyclerViewNeedVelocity)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>上面的代码是针对嵌套滚动的情况进行处理的。根据代码的逻辑，可以理解如下：</p><ol><li><p><code>onNestedPreScroll()</code> 方法用于处理嵌套滚动前的预处理。当嵌套滚动发生时，会调用该方法。参数说明如下：</p><ul><li><code>target</code>: 嵌套滚动的目标视图。</li><li><code>dx</code>: 水平方向上的滚动距离。</li><li><code>dy</code>: 垂直方向上的滚动距离。</li><li><code>consumed</code>: 用于传递消耗的滚动距离的数组。</li><li><code>type</code>: 滚动事件类型。</li></ul><p>在代码中，首先判断当前滚动的位置 <code>scrollY</code> 是否小于 <code>scrollViewHeadHeight</code>（一个预设的阈值）。如果小于该阈值，表示需要对滚动进行处理。</p><ul><li>如果 <code>scrollY + dy</code> 小于 <code>scrollViewHeadHeight</code>，直接进行滚动并消耗全部的垂直滚动距离 <code>dy</code>，将其存入 <code>consumed</code> 数组中。</li><li>如果 <code>scrollY + dy</code> 大于 <code>scrollViewHeadHeight</code>，则需要将滚动限制在 <code>scrollViewHeadHeight</code> 的位置，即将滚动距离限制为 <code>scrollViewHeadHeight - scrollY</code>，<em>并将此消耗的滚动距离存入 <code>consumed</code> 数组中</em>。</li></ul></li><li><p><code>fling()</code> 方法用于处理滑动手势的快速滚动。当手指快速滑动屏幕时，会调用该方法。参数说明如下：</p><ul><li><code>velocityY</code>: 垂直方向上的滑动速度。</li></ul><p>在代码中，首先判断当前滚动的位置 <code>scrollY</code> 是否小于 <code>scrollViewHeadHeight</code>。</p><ul><li>如果小于该阈值，表示需要对滚动进行处理。</li><li>如果 <code>scrollY + dy</code> 小于等于 <code>scrollViewHeadHeight</code>，直接调用父类的 <code>super.fling(velocityY)</code> 方法进行滚动。</li><li>如果 <code>scrollY + dy</code> 大于 <code>scrollViewHeadHeight</code>，则需要将滚动限制在 <code>scrollViewHeadHeight</code> 的位置，即将滚动距离限制为 <code>scrollViewHeadHeight - scrollY</code>，并将此消耗的滚动距离存入 <code>scrollViewNeedScrollY</code>。</li><li>接下来，根据滚动速度 <code>velocityY</code> 计算出 <code>scrollViewNeedScrollY</code> 所对应的速度 <code>scrollViewNeedVelocity</code>。</li><li>如果 <code>velocityY</code> 大于 0，表示向上滑动，调用父类的 <code>super.fling(scrollViewNeedVelocity)</code> 方法进行滚动。</li><li>如果 <code>velocityY</code> 小于等于 0，表示向下滑动，调用父类的 <code>super.fling(-scrollViewNeedVelocity)</code> 方法进行滚动。</li><li>然后，剩余的滚动距离为 <code>dy - scrollViewNeedScrollY</code>，根据剩余距离计算出对应的速度 <code>recyclerViewNeedVelocity</code>。</li><li>最后，通过 <code>getChildRecyclerView(this)?.fling(0, recyclerViewNeedVelocity)</code> 将剩余的滚动事件交给嵌套的 RecyclerView 处理。</li></ul></li></ol><p>这段代码的目的是在特定的条件下对滚动和快速滑动进行限制和分发，以实现特定的滚动效果和交互行为。具体的实现细节和逻辑可能还需要结合其他代码来全面理解其功能和效果。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.RecycleView_ ListView原理</title>
    <link href="/2025/12/28af756907fe.html"/>
    <url>/2025/12/28af756907fe.html</url>
    
    <content type="html"><![CDATA[<h2 id="ListView-原理"><a href="#ListView-原理" class="headerlink" title="ListView 原理"></a>ListView 原理</h2><p>ListView 实现成百上千条数据都不会 OOM 的原因<br>因为 getview 的第二个参数 convertView 就是之前用过的 VIew 对象，当 view 对象完全移除屏幕后，会存入 RecycleBin 对象里，当 listview 的屏幕外下面的 view 滑出来的时候，会从 RecycleBin 里取出复用。ListView 中的子 View 其实来来回回就那么几个，移出屏幕的子 View 会很快被移入屏幕的数据重新利用起来，所以不会 OOM<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-a51d0b105e9fa241970be6aa5b1e900c-unknown_filename.3-fd9a6c.png" alt="unknown_filename.3"></p><p><strong>coverview 原理</strong><br>这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用，在 getView ()方法中进行了判断，如果 convertView 为空，则使用 LayoutInflater 去加载布局，如果不为空则直接对 convertView 进行重用</p><h2 id="RecycleView-和-ListView-对比"><a href="#RecycleView-和-ListView-对比" class="headerlink" title="RecycleView 和 ListView 对比"></a>RecycleView 和 ListView 对比</h2><p>RecycleView 是 ListView 的升级版，和 ListView 一样，RecyclerView 是用来显示大量数据的容器，并通过复用有限数量的 View，来提高滚动时的性能。与 ListView 不同的是 RecyclerView<em>不负责布局，只专注于复用机制</em>，布局交由 LayoutManager 来管理。</p><p>ListView 的局限</p><ul><li>只有纵向列表一种布局</li><li>没有支持动画的 API</li><li>没有强制实现 ViewHolder</li></ul><p>RecyclerView 的优势</p><ul><li>默认支持 Linear, Grid, Staggered Grid 三种布局</li><li>友好的 ItemAnimator 动画 API</li><li>强制实现 ViewHolder</li><li>解耦的架构设计（adapter、layoutManager、item animator）</li><li>局部刷新</li><li>缓存有区别</li></ul><h2 id="RecycleView-原理"><a href="#RecycleView-原理" class="headerlink" title="RecycleView 原理"></a>RecycleView 原理</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.Adapter&lt;MyAdapter.ViewHolder&gt; &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; dataList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAdapter</span><span class="hljs-params">(List&lt;String&gt; dataList)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dataList = dataList;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-type">int</span> viewType)</span> &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(parent.getContext()).inflate(R.layout.item_layout, parent, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewHolder</span>(view);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBindViewHolder</span><span class="hljs-params">(ViewHolder holder, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> dataList.get(position);<br>        holder.textView.setText(item);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getItemCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dataList.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.ViewHolder &#123;<br>        TextView textView;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewHolder</span><span class="hljs-params">(View itemView)</span> &#123;<br>            <span class="hljs-built_in">super</span>(itemView);<br>            textView = itemView.findViewById(R.id.textView);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><a href="https://juejin.cn/post/7173816645511544840?searchId=20230802143652E62B1DA3FEB2DE9CAA23">这10张图拿去，别再说学不会RecyclerView的缓存复用机制了！</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-5abea9a05ceac40a8c4396cf6395f485-unknown_filename.1-3fb93d.png" alt="unknown_filename.1"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-b071917fe2a29429411a9b47b94247fe-unknown_filename.2-c9fe14.png" alt="unknown_filename.2"></p><p>RecyclerView 缓存分层：</p><h4 id="第一层缓存-Scrap"><a href="#第一层缓存-Scrap" class="headerlink" title="第一层缓存 Scrap"></a>第一层缓存 Scrap</h4><p>（&#x2F;skræp&#x2F; 碎片、小块）（mAttachedScrap）屏幕内缓存，可直接复用，无需重新绑定，且用 position 寻找缓存，这个缓存结构实际上更多是为了<em>避免出现像局部刷新这一类的操作，导致所有的列表项都需要重绘的情形</em>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ArrayList&lt;ViewHolder&gt; mAttachedScrap <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-83038e2480407a3e787289fb8c93933a-unknown_filename.7-c00cca.png" alt="unknown_filename.7|700"></p><h4 id="第二层缓存-mCachedViews"><a href="#第二层缓存-mCachedViews" class="headerlink" title="第二层缓存 mCachedViews"></a>第二层缓存 mCachedViews</h4><p>mCachedViews 主要用于<em>存放已被移出屏幕、但有可能很快重新进入屏幕的列表项，它的默认大小是2</em>。可直接复用，无需重新绑定，且用 position 寻找缓存，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ViewHolder&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">mViewCacheMax</span> <span class="hljs-operator">=</span> DEFAULT_CACHE_SIZE;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CACHE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-492d953a17df01be18d97cbaab063a27-unknown_filename.8-5ab42b.png" alt="unknown_filename.8|700"></p><h4 id="第三层-ViewCacheExtension"><a href="#第三层-ViewCacheExtension" class="headerlink" title="第三层 ViewCacheExtension"></a>第三层 ViewCacheExtension</h4><p>开发者自定义控制的 View 缓存帮助类。一般而言，我们不会自定义缓存实现，使用 Recycler 提供的3级缓存足够。</p><h4 id="第四层-RecycledViewPoll"><a href="#第四层-RecycledViewPoll" class="headerlink" title="第四层 RecycledViewPoll"></a>第四层 RecycledViewPoll</h4><p>所有被废弃的 ItemView 的池（没有废弃使用）</p><p>mRecyclerPool 主要用于<em>按不同的 itemType 分别存放超出 mCachedViews 限制的、被移出屏幕的列表项</em>，其会先以 SparseArray 区分不同的 itemType，然后每种 itemType 对应的值又以 ArrayList 的形式持有着每个列表项的 ViewHolder 对象，每种 itemType 的 ArrayList 大小限制<em>默认为5</em>。</p><p>由于 mCachedViews 默认的大小限制仅为2，因此，当滑出屏幕的列表项超过2个后，就会按照先进先出的顺序，依次将 ViewHolder 对象从 mCachedViews 移出，<strong>并按 itemType 放入 RecycledViewPool 中的不同 ArrayList。</strong></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>Scrap 与 Cache 是通过 position 来找到缓存的，并且他的数据是肯定的，所以不需要重新绑定数据</li><li>RecycledViewPool 是通过 viewType 来找到缓存的，并且他的数据是脏数据，找到缓存的话，需要重新绑定数据</li><li>RecycleView.setItemViewCacheSize (size) 加大 RecyclerView 缓存空间, 利用空间换时间策阅来提高流畅性。</li><li>多个 RecyclerView 共用 RecycledViewPool，比如 RecyclerView 里又有多类似的 RecyclerView，竖向里有横向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">RecyclerView. <span class="hljs-type">RecycledViewPool</span> <span class="hljs-variable">recycledViewPool</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">RecyclerView</span>. RecycledView <span class="hljs-title function_">Pool</span> <span class="hljs-params">( )</span> ;<br>recyclerView1. setRecycledViewPool ( recycledViewPool) ;<br>recyclerView2. setRecycledViewPool ( recycledViewPool) ;<br>recyclerView3. setRecycledViewPool ( recycledViewPool) ;<br></code></pre></td></tr></table></figure><h3 id="ListView、RecycleView-的优化"><a href="#ListView、RecycleView-的优化" class="headerlink" title="ListView、RecycleView 的优化"></a>ListView、RecycleView 的优化</h3><ul><li>Item 的布局层次结构尽量简单，避免布局太深或者不必要的重绘</li><li>Item 高度固定, 设置 RecyclerView.<em>setHasFixedSize (true), 避免不停的测量</em>。requeLayout 资源浪费，</li><li>recycleview 加载1000条数据也没问题，因为会只加载一屏的数据，但是添加了 scroview 就会出现卡顿。如果是 listview，还需要指定他的高度， nested scroll view 会导致 recycleview 把数据全部加载出来</li><li><strong>如果不要求动画</strong>, 可用通过 ((SimpleItemAnimator) rv.getItemAnimator ()). setSupportsChangeAnimations (false); 把默认动画关闭来提高性能</li><li>避免在 getView 方法中做耗时的操作，例如加载大量图片，当用户不停的滑动时，由于 ui 在主线程操作的，会出现卡顿，可以在滑动的时候停止加载 (setOnscrollerListener)，在 getView 方法里只有静止才加载图片</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (view.getContext () != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (scrollState) &#123;<br>            <span class="hljs-keyword">case</span> SCROLL_STATE_IDLE:<br>                Glide.<span class="hljs-keyword">with</span> (view.getContext ()). resumeRequests ()<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>            <span class="hljs-keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:<br>            <span class="hljs-keyword">case</span> SCROLL_STATE_FLING:<br>                Glide.<span class="hljs-keyword">with</span> (view.getContext ()). pauseRequests ()<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>在一些场景中，<strong>ScollView 内会包含多个 ListView，可以把 listview 的高度写死固定下来</strong>。ScollView 在快速滑动过程中需要大量计算每一个 listview 的高度，阻塞了 UI 线程导致卡顿现象出现，如果我们每一个 item 的高度都是均匀的，可以通过计算把 listview 的高度确定下来，避免卡顿现象出现</li><li>使用 RecycleView 代替 listview：每个 item 内容的变动，listview 都需要去调用 notifyDataSetChanged 来更新全部的 item，太浪费性能了。RecycleView 可以实现当个 item 的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</li><li>ListView 中元素避免半透明：半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</li><li>复用历史的 view 对象 convertview</li><li>减少 item 查询的次数 viewholder</li><li>异步加载数据（把图片缓存）</li></ul><h3 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h3><p>列表中 item&#x2F;广告的 impression 统计<br>    ListView getView<br>    RecyclerView 通过 onBindViewHolder () 统计? 可能错误!<br>    通过 <em>onViewAttachedToWindow</em> ()统计</p><p>点击监听器的设置用户不停的滑动就会不停的创建监听器，每次绑定一个新的。这样写会造成内存抖动。点击监听器只是一个观察者模式<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-1ed8301ce26cf4ab884252f97a9a8d98-unknown_filename-257440.png" alt="unknown_filename"></p><ol><li>用户滑动到横向滑动的 item RecyclerView 的时候, 由于需要创建更复杂的<br> RecyclerView 以及多个子 view, 可能会导致页面卡顿</li><li>由于 RenderThread 的存在, RecyclerView 会进行 prefetch<ul><li>只有 LinearLayoutManager API</li><li>只有嵌套在内部的 RecyclerView 才会生效</li></ul></li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/RecycleView__ListView%E5%8E%9F%E7%90%86.resources/2023/09/18/09-58-18-66d4414642ec9017e653d08451dffe07-unknown_filename.4-4bebad.png" alt="unknown_filename.4"></p><h3 id="DiffUtil-提高列表性能的方法"><a href="#DiffUtil-提高列表性能的方法" class="headerlink" title="DiffUtil 提高列表性能的方法"></a>DiffUtil 提高列表性能的方法</h3><p>它会自动计算新老数据集的差异，并根据差异情况，自动调用以下四个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">adapter.notifyItemRangeInserted (position, count);<br>adapter.notifyItemRangeRemoved (position, count);<br>adapter.notifyItemMoved (fromPosition, toPosition);<br>adapter.notifyItemRangeChanged (position, count, payload);<br></code></pre></td></tr></table></figure><ol><li>局部更新方法 notifyltemXXX () 不适用于所有情况</li><li>notifyDataSetChange () 会导致整个布局重绘, 重新绑定所有 ViewHolder, 而<br> 且会失去可能的动画效果</li><li>DiffUtil 适用于整个页面需要刷新, 但是有部分数据可能相同的情况</li></ol><p>DiffUtil 在使用起来，主要需要关注几个类：</p><p>DiffUtil. Callback：具体用于限定数据集比对规则。<br>DiffUtil. DiffResult：比对数据集之后，返回的差异结果。<br>1、DiffUtil. Callback<br>DiffUtil. Callback 主要就是为了限定两个数据集中子项的比对规则。毕竟开发者面对的数据结构多种多样，既然没法做一套通用的内容比对方式，那么就将比对的规则，交还给开发者来实现即可。</p><p>它拥有 4 个抽象方法和 1 个非抽象方法的抽象类。我们需要继承并实现它的所有方法：在自定义的 Callback 中，其实需要实现 4 个方法：</p><p>getOldListSize ()：旧数据集的长度。<br>getNewListSize ()：新数据集的长度<br>areItemsTheSame ()：判断是否是同一个 Item。<br>areContentsTheSame ()：如果是通一个 Item（即 areItemsTheSame 返回 true），此方法用于判断是否同一个 Item 的内容也相同。<br>如我们有两个 Object，它们可能拥有很多属性，但是其中只有两个属性需要被显示出来，那只要这两个属性一致我们这个方法就要返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areContentsTheSame</span> <span class="hljs-params">(<span class="hljs-type">int</span> oldItemPosition, <span class="hljs-type">int</span> newItemPosition)</span> &#123;<br>       <span class="hljs-type">TestBean</span> <span class="hljs-variable">beanOld</span> <span class="hljs-operator">=</span> mOldDatas.get (oldItemPosition);<br>       <span class="hljs-type">TestBean</span> <span class="hljs-variable">beanNew</span> <span class="hljs-operator">=</span> mNewDatas.get (newItemPosition);<br>       <span class="hljs-keyword">if</span> (! beanOld.getDesc (). equals (beanNew.getDesc ())) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果有内容不同，就返回 false</span><br>       &#125;<br>       <span class="hljs-keyword">if</span> (beanOld.getPic () != beanNew.getPic ()) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果有内容不同，就返回 false</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//默认两个 data 内容是相同的</span><br>   &#125;<br>    <br><br>      DiffUtil. <span class="hljs-type">DiffResult</span> <span class="hljs-variable">diffResult</span> <span class="hljs-operator">=</span> DiffUtil.calculateDiff (<span class="hljs-keyword">new</span> <span class="hljs-title class_">DiffCallBack</span> (mOldList, mList), <span class="hljs-literal">true</span>);<br>       diffResult.dispatchUpdatesTo (myAdapter);<br>       mOldList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(mList);<br>       myAdapter.setDatas (mList);<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/60a41bb5cd7f">更高效地刷新 RecyclerView | DiffUtil二次封装 - 简书</a></p><pre><code class="java">    val oldList = ... // 老列表    val newList = ... // 新列表    val adapter：RecyclerView. Adapter = ...        // 1. 定义比对方法    val callback = object : DiffUtil.Callback () &#123;        override fun getOldListSize (): Int = oldList. size        override fun getNewListSize (): Int = newList. size        override fun areItemsTheSame (oldItemPosition: Int, newItemPosition: Int): Boolean &#123;            // 分别获取新老列表中对应位置的元素            val oldItem = oldList[oldItemPosition]            val newItem = newList[newItemPosition]            return ... // 定义什么情况下新老元素是同一个对象（通常是业务 id）        &#125;        override fun areContentsTheSame (oldItemPosition: Int, newItemPosition: Int): Boolean &#123;            val oldItem = oldList[oldItemPosition]            val newItem = newList[newItemPosition]            return ... // 定义什么情况下同一对象内容是否相同 (由业务逻辑决定)        &#125;        override fun getChangePayload (oldItemPosition: Int, newItemPosition: Int): Any? &#123;            val oldItem = oldList[oldItemPosition]            val newItem = newList[newItemPosition]            return ... // 具体定义同一对象内容是如何地不同 (返回值会作为 payloads 传入 onBindViewHoder())        &#125;    &#125;    // 2. 进行比对并输出结果    val diffResult = DiffUtil.calculateDiff (callback)    // 3\. 将比对结果应用到 adapter    diffResult.dispatchUpdatesTo (adapter)</code></pre>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.约束布局ConstraintLayout</title>
    <link href="/2025/12/be54c5ef8b71.html"/>
    <url>/2025/12/be54c5ef8b71.html</url>
    
    <content type="html"><![CDATA[<h2 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p><strong>用 RelativeLayout 可以解决问题，为什么还要使用 ConstraintLayout 呢？</strong><br>因为 ConstraintLayout 使用起来比 RelativeLayout 更灵活，性能更出色！<br>还有一点就是 ConstraintLayout 可以<em>按照比例约束控件位置和尺寸，能够更好地适配屏幕大小不同的机型</em>。可以角度、距离定位</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/53122387">拖动写UI</a></p><p><a href="https://juejin.cn/post/7101491983494938655">使用场景</a></p><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul><li>找准布局基准元素，一般是界面的固定不变的业务元素，其它组件，根据其约束来进行布局</li><li>使用 Group 等虚拟布局组件来简化布局代码</li><li>还是有缺点的，因为控件相互依赖很强，牵一发而动全身，后期修改 UI，维护起来很麻烦<br>  答：<strong>多实用辅助线 guideline</strong> 把这样相对来说会很好点。</li><li>这个布局不存在谁先写；</li><li>如何居中: 底部和顶部都和另一个控件平齐就是居中</li><li>如果不好写，可以考虑 Guideline、Barrier 等等，在辅助线左右</li><li>app: layout_constraintHorizontal_weight 类似：LinearLayout 和 weight</li><li>goneMargin 主要用于约束的控件可见性被设置为 gone 的时候使用的 margin 值</li><li>layout_constraintHorizontal_bias 水平偏移，假如赋值为0，则 TextView1在布局的最左侧，假如赋值为1，则 TextView1在布局的最右侧，假如假如赋值为0.5，则水平居中</li><li>使用 0dp (MATCH_CONSTRAINT)<br>  官方不推荐在 ConstraintLayout 中使用 match_parent，可以设置 0dp (MATCH_CONSTRAINT) 配合约束代替 match_parent。<br>  因为 ConstraintLayout 的一大特点就是为了解决布局嵌套，既然没有了布局嵌套，那么 match parent 也就没有多大意义了。</li><li>当宽或高至少有一个尺寸被设置为0dp 时，可以通过属性 layout_constraintDimensionRatio 设置宽高比。app: layout_constraintDimensionRatio&#x3D;”1:1”</li></ul><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><h4 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h4><p>避免布局嵌套<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&_ConstraintLayout.resources/2023/09/18/09-58-10-cde50056a2bacdc66d0e5014299ed451-unknown_filename.3-03ada7.png" alt="unknown_filename.3"></p><h4 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h4><p>android: orientation 垂直 vertical，水平 horizontal<br>layout_constraintGuide_begin 开始位置<br>layout_constraintGuide_end 结束位置<br>layout_constraintGuide_percent 距离顶部的百分比 (orientation &#x3D; horizontal 时则为距离左边)。</p><p>不会显示再界面上，和 Barrier 区别：Barrier 作用于几个控件，设置屏障。 Guideline 直接就是比例或距离</p><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>Group 可以把多个控件归为一组，方便隐藏或显示一组控件<br>app: constraint_referenced_ids</p><h4 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h4><p>Placeholder 指的是占位符。在 Placeholder 中可使用 setContent () 设置另一个控件的 id，使这个控件移动到占位符的位置。改变 view 位置。</p><h4 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h4><h4 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h4><p><strong>android. widget. Space</strong><br>在 ConstraintLayout 中，虽然不能使用负-margin 的方式来完成传统布局中的一些错位的效果，但是可以借助 Space 来实现类似的功能，例如借助 Space 来实现左边 TextView 在右边 TextView 某一百分比（或者是 dp）对齐的场景。<br>android:translationX&#x3D;”-20dp”  <!-- 向左偏移20dp --><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&_ConstraintLayout.resources/2023/09/18/09-58-10-63bcbfce2c66b2bc0a7630056bbf82ae-unknown_filename.6-570ecc.png" alt="unknown_filename.6"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:androxmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;32dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;32dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#bebebe&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;TextView&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Space</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;@+id/textView2&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.2&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;@+id/textView2&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;68dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;TextView&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/space&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;92dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br>```  <br><br>由于 ConstraintLayout 不支持负-Margin，所以很多场景下，我们都可以借助 Space 等辅助元素来实现中转，完成传统布局下通过-Margin 实现的效果。<br><br>#### Layer (Added in 2.0)<br><br>Layer 可以看作是它引用的 view 的边界（可以理解为包含这些 view 的一个 ViewGroup，但是 Layer 并不是 ViewGroup，Layer 并不会增加 view 的层级）。另外 Layer 支持对里面的 view 一起做变换。<br>考虑这么一个场景，*如果一个页面里面有部分 view 需要加个背景，使用 Layer 引用这几个 view，然后给 Layer 设置背景就可以了*。如果不用 Layer，只能另外加个 ViewGroup 包住这几个 View 了，这样会增加 view 的层级，不利于性能。避免布局嵌套，*可以为一组控件统一设置旋转/缩放/位移*<br><br>![QQ截图20191026153932](https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&amp;_ConstraintLayout.resources/2023/09/18/09-58-10-f7365e8b25cdf59e435d4f52f1189910-QQ%E6%88%AA%E5%9B%BE20191026153932-81acb8.png)<br><br>![unknown_filename](https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&amp;_ConstraintLayout.resources/2023/09/18/09-58-10-8bcf558119843ef1f0bfb0f8afdfd45b-unknown_filename-a03917.png)<br><br>### 示例<br>```xml<br>    <span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:androxmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.Group</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;visible&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:constraint_referenced_ids</span>=<span class="hljs-string">&quot;iv_back,tv_title,iv_more&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.Barrier</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:barrierDirection</span>=<span class="hljs-string">&quot;bottom&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:constraint_referenced_ids</span>=<span class="hljs-string">&quot;iv_back&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">android.widget.Space</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@+id/iv_back&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@android:color/black&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@+id/space&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;标题&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;20sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@id/iv_back&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;@id/iv_back&quot;</span> /&gt;</span><br>    <br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginRight</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;火影忍者&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;30sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@id/space&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@id/tv_star_title&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:ellipsize</span>=<span class="hljs-string">&quot;end&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:lines</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;名字反反复复反反复复反反复复反反复复反反复复反反复复反反复复反反复复反反复复分&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;18sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toRightOf</span>=<span class="hljs-string">&quot;@id/iv_icon&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintRight_toLeftOf</span>=<span class="hljs-string">&quot;@+id/iv_right&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;@+id/iv_icon&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;吧名&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;18sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@+id/iv_icon&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;@+id/tv_name&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!--这个布局不存在谁先写；如何居中；</span><br><span class="hljs-comment">        如果不好写，可以考虑Guideline、Barrier等等</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;12dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginRight</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintDimensionRatio</span>=<span class="hljs-string">&quot;h,4:2&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintLeft_toRightOf</span>=<span class="hljs-string">&quot;@+id/tv_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;@+id/tv_name&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintDimensionRatio</span>=<span class="hljs-string">&quot;h,1:1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@id/iv_icon&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;内容哈哈哈哈哈哈哈&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;20sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@id/guideline&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;内容哈哈哈哈哈哈哈&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;20sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toTopOf</span>=<span class="hljs-string">&quot;@id/guideline&quot;</span> /&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.Guideline</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintGuide_percent</span>=<span class="hljs-string">&quot;0.5&quot;</span> /&gt;</span><br>    <br>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>自动添加约束</p><p>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&_ConstraintLayout.resources/2023/09/18/09-58-10-0df5c84f604e535d1b95327da083b294-unknown_filename.4-b55b96.png" alt="unknown_filename.4"></p></li><li><p>在当控件有自己设置的宽度，例如 warp_content、固定值时，我们为控件添加的都是约束“Constraint”，这个约束有点像橡皮筋一样会拉这个控件，但是并不会改变控件的尺寸<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&_ConstraintLayout.resources/2023/09/18/09-58-10-4590717f2cef02318b473528ace3f4db-unknown_filename.5-0a12c2.png" alt="unknown_filename.5"></p></li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&_ConstraintLayout.resources/2023/09/18/09-58-10-f96ed6aa92450fb1a461c5f1352e23b3-unknown_filename.1-87d986.png" alt="unknown_filename.1"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/CoordinatorLayout_&_ConstraintLayout.resources/2023/09/18/09-58-10-7c340e0b7554930c2eec01aa7739712f-unknown_filename.2-77be8e.png" alt="unknown_filename.2"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.自定义View总结</title>
    <link href="/2025/12/618995c41398.html"/>
    <url>/2025/12/618995c41398.html</url>
    
    <content type="html"><![CDATA[<p>[[自写动画自定义View]]</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>明确需求，确定你想实现的效果。</li><li>确定是使用组合控件的形式还是全新自定义的形式，组合控件即使用多个系统控件来合成一个新控件，你比如 titilebar，这种形式相对简单。</li><li>如果是完全自定义一个 view 的话，你首先需要考虑继承哪个类，是 View 呢，还是 ImageView 等子类。</li><li>根据需要去复写 View 的 onDraw 、onMeasure 、onLayout 方法。</li><li>根据需要去复写 dispatchTouchEvent、onTouchEvent 方法。</li><li>根据需要为你的自定义 view 提供自定义属性，即编写 attr. xml, 然后在代码中通过 TypedArray 等类获取到自定义属性值。</li><li>需要处理滑动冲突、像素转换等问题。</li><li>在要在 onDraw 或是 onLayout  中去创建对象，因为 onDraw 方法可能会被频繁调用，可以在 view 的构造函数中进行创建对象</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>父 View 调用了子 View 的 measure () &#x2F; layout ()，而子 View 自己重写了 onMeasure () &#x2F; onLayout ()，到底哪个为准？</p><p>onMeasure：谁决定大小？<br>流程：<br>父 View 调用 child.measure (widthSpec, heightSpec)。<br>子 View 内部调用 onMeasure () → 计算出自己的 measuredWidth &#x2F; measuredHeight。<br>系统最终会保存结果到 child.getMeasuredWidth ()&#x2F;getMeasuredHeight ()。</p><p>结论：<br>父 View 只能提供约束（MeasureSpec），比如 AT_MOST、EXACTLY、UNSPECIFIED。<br>子 View 的 onMeasure () 负责决定实际的测量值。<br>所以<em>最终大小取决于子 View 的 onMeasure 实现，但必须在父 View 提供的约束范围内</em>。</p><p>onLayout：谁决定位置？<br>流程：<br>父 View 调用 child.layout (l, t, r, b)。<br>系统会触发 child.onLayout (changed, l, t, r, b)。<br><em>子 View 的 onLayout 里一般不会改变自己的位置</em>（因为位置由父 View 决定），它更多是用来安放子 View（孙子级）。</p><p>结论：<br>父 View 决定子 View 的位置（left&#x2F;top&#x2F;right&#x2F;bottom）。<br>子 View 的 onLayout 只能决定自己的子 View 的位置，不能改变自己在父 View 里的位置。</p><p>谁说了算总结：<br>大小（width&#x2F;height） → 子 View 的 onMeasure 为准（父只能限制，子决定最终值）。<br>位置（left&#x2F;top&#x2F;right&#x2F;bottom） → 父 View 的 layout 为准（子不能改）。</p><h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2><ul><li>onMeasure 测量 view 的大小，设置自己显示在屏幕上的宽高。</li><li>onLayout 确定 view 的位置，父 view 会根据子 view 的需求，和自身的情况，来综合确定子 view 的位置 (确定他的大小)。</li><li>onDraw (Canvas)绘制 view 的内容。</li><li>在主线程中拿到 view 调用 Invalide ()方法，刷新当前视图，导致执行 onDraw 执行，如果是在子线程用 postinvalidate，或者不需要一直刷新用 postinvalidateDelayed (300)，每隔300毫秒刷新一次。</li><li>如果希望视图的绘制流程 (三步)可以完完整整地重新走一遍，就不能使用 invalidate ()方法，而应该调用 requestLayout ()了。</li></ul><p><strong>Invalidate 和 postInvalidate  的区别及使用</strong><br>View invalidate : 层层上传到父级，直到传递到 ViewRootImpl 后触发了 scheduleTraversals 0)然后整个 View 树开始重新按照 View 绘制流程进行重绘任务。<br>Invalidate: 在 ui 线程刷新 view<br>PostInvalidate: 在工作线程刷新 view (底层还是 handler) 其实它的原理就是 invalidate+handler</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p><strong>onMeasure 测量 view 的大小。设置自己显示在屏幕上的宽高。</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-1d4b35cdd071a53970be316c73f1a667-5edce9c0581e4ecf7e5a0565e2d788c8-7404c3.png" alt="5edce9c0581e4ecf7e5a0565e2d788c8"></p><p>MeasureSpec 有 SpecMode 和 SpecSize 俩个属性。</p><h3 id="SpecMode"><a href="#SpecMode" class="headerlink" title="SpecMode"></a>SpecMode</h3><ol><li>unspecified: 父 View 不对子 View 做任何限制，需要多大给多大，一般不关心这个模式</li><li>exactly: view 的大小就是 SpecSize（父 view 的大小）指定的大小。相当于<strong>mach_parents</strong>，就是根据这个获取的测量模式</li><li>at_most: 父容器指定了一个 specsize，view 不能大于这个值。具体的值看 view, 相当于<strong>wrap_content</strong></li></ol><ul><li>常开发中我们接触最多的不是 MeasureSpec 而是 LayoutParams，在 View 测量的时候，LayoutParams 会和父 View 的 MeasureSpec 相结合被换算成 View 的 MeasureSpec，进而决定 View 的大小。</li></ul><ul><li>LayoutParams 类是用于子 view 向父 view 传达自己的意愿的一个东西（孩子想变成什么样向其父亲说明）</li></ul><p>测量流程：从根 View 递归调用每一级子 View 的 measure () 方法，对它们进行测量<br>布局流程：从根 View 递归调用每一级子 View 的 layout () 方法，把测量过程得出的子 View 的位置和尺寸传给子 View，子 View 保存</p><ul><li><code>onMeasure</code> &#x3D; 算法（你来计算宽高逻辑）</li><li><code>setMeasuredDimension</code> &#x3D; 存储（告诉系统最终大小）</li><li>setMeasuredDimension(int measuredWidth, int measuredHeight) 是真正保存测量结果的唯一方法。所有 onMeasure 的计算结果，最终必须调用它才能生效。</li></ul><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>对自定义 View 完全进行自定义尺寸计算：重写 onMeasure ()：CircleView</p><ol><li>重写 onMeasure ()</li><li>计算出自⼰的尺⼨</li><li>用 <strong>resolveSize</strong>() 或者 resolveSizeAndState () 修正结果<br> (根据自己的尺寸和父 view 的模式和尺寸，综合计算自己的大小)<br> <strong>size 是自己的</strong><br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-8babb7778fa73ecc910b893b7ea362b2-unknown_filename.1-5b2033.png" alt="unknown_filename.1"></li></ol><ul><li>⾸先用 MeasureSpec.getMode (measureSpec) 和 MeasureSpec.getSize (measureSpec)<strong>取出父对自己的尺寸</strong> 限制类型和具体限制尺⼨；</li><li>如果 MeasureSpec 的 mode 是 EXACTLY，表示⽗ View 对子 View 的尺⼨寸做出了精确限制，所以就放弃计算出的 size，直接选用 MeasureSpec 的 size；</li><li>如果 MeasureSpec 的 mode 是 UNSPECIFIED，表示父 View 对子 View 没有任何尺寸限制，所以直接选用计算出的 size，忽略 spec 中的 size。</li><li>at_most，最大不能超过父</li></ul><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><ul><li>如果写的自定义 View 是继承现有控件的，而且写了 super.measure ()，则会默认使用那个现有控件的测量宽高，你可以在这个已经测量好的宽高上做修改，当然也可以全部重新测过再改掉。</li><li>如果我们的 View 直接继承 ImageView，ImageView 已经运行了一大堆已经写好的代码测出了相应的宽高。我们可以在它基础上更改即可。比如我们的 Image2View 是一个自定义的正方形的 ImageView：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">onMeasure</span> <span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> </span>&#123;<br><br>    <span class="hljs-comment">//这里已经帮我们测好了 ImageView 的规则下的宽高，并且通过了 setMeasuredDimension 方法赋值进去了。</span><br>    super.<span class="hljs-built_in">onMeasure</span> (widthMeasureSpec, heightMeasureSpec);<br><br>     <span class="hljs-type">int</span> measuredWidth = <span class="hljs-built_in">getMeasuredWidth</span> ();<br>        <span class="hljs-type">int</span> measuredHeight = <span class="hljs-built_in">getMeasuredHeight</span> ();<br>        <span class="hljs-type">int</span> size = Math.<span class="hljs-built_in">min</span> (measuredWidth, measuredHeight);<br>        <span class="hljs-built_in">setMeasuredDimension</span> (size, size);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>setMeasuredDimension 后才能 getmeasure 宽高，super 里做了这步，因为这方法是用来设置 view 测量的宽和高。</li><li>完全自定义 view：<em>重写 onMeasure 方法的目的是为了能够给 view 一个 warp_content 属性下的默认大小</em>，因为不重写 onMeasure，那么系统就不知道该使用默认多大的尺寸。如果不处理，那 wrap_content 就相当于 match_parent。所以自定义控件需要支持 warp_content 属性就重写 onMeasure。</li><li>可以自己尝试一下自定义一个 View，然后不重写 onMeasure ()方法，你会发现只有设置 match_parent 和 wrap_content 效果是一样的，事实上 TextView、ImageView 等系统组件都在 wrap_content 上有自己的处理。</li></ul><h3 id="getMeasuredHeight"><a href="#getMeasuredHeight" class="headerlink" title="getMeasuredHeight"></a>getMeasuredHeight</h3><p><strong>getHeight ()和 getMeasuredHeight ()的区别</strong><br>有俩种方法可以获得控件的宽高</p><ol><li>getMeasuredHeight (): 控件实际的大小。获取测量完的高度，只要在 onMeasure 方法执行完，就可以用它获取到宽高，在自定义 view 内使用 view. measure (0,0)方法可以主动通知系统去测量，然后就可以直接使用它获取宽高。measure 里调用的 onmeasure。</li><li>getHeight ()：控件显示的大小, 必须<em>在 onLayout 方法执行完后</em>，才能获得宽高。</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">view.getViewTreeObserver (). addOnGlobalLayoutListener (<span class="hljs-keyword">new</span> OnGlobalLayoutListener () &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onGlobalLayout</span> <span class="hljs-params">()</span> </span>&#123;<br>headerView.getViewTreeObserver (). removeGlobalOnLayoutListener (<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">int</span> headerViewHeight = headerView.getHeight ();<br><span class="hljs-comment">//直接可以获取宽高</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>getMeasuredHeight()</code> view 的实际高度，<code>getHeight()</code> 反映父容器允许的高度，它是 View 在父布局中<strong>实际分配到的显示区域高度</strong><br>getMeasuredHeight() &gt;&#x3D; getHeight()  &#x2F;&#x2F; 当父容器限制高度时成立<br>![[Pasted image 20250702195530.png]]</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><ul><li>onLayout 设置自己显示在屏幕上的位置 (只有在自定义 ViewGroup 中才用到)，这个坐标是相对于当前视图的父视图而言的。view 自身有一些建议权，决定权在父 view 手中。</li><li>调用场景：在 view <em>需要给其孩子设置尺寸和位置时被调用</em>。子 view，包括孩子在内，必须重写 onLayout (boolean, int, int, int, int)方法，并且调用各自的 layout (int, int, int, int)方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span> <span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; getChildCount (); i++) &#123;<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> getChildAt (i);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 父 view 会根据子 view 的需求，和自身的情况，来综合确定子 view 的位置, (确定他的大小)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//指定子 view 的位置  ,  左，上，右，下，是指在 viewGround 坐标系中的位置</span><br>view.layout (<span class="hljs-number">0</span>+i*getWidth (), <span class="hljs-number">0</span>, getWidth ()+i*getWidth (), getHeight ());<br>&#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a><strong>onDraw</strong></h2><p>onDraw (Canvas)绘制 view 的内容。控制显示在屏幕上的样子 (自定义 viewgroup 时不需要这个)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">/*<br><span class="hljs-bullet">* </span>backgroundBitmap 要绘制的图片<br><span class="hljs-bullet">* </span>left 图片的左边界<br><span class="hljs-bullet">* </span>top 图片的上边界<br><span class="hljs-bullet">* </span>paint 绘制图片要使用的画笔<br>*/<br>canvas.drawBitmap (backgroundBitmap, 0, 0, paint);<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在 Android 中，给 <code>View</code> 设置圆角通常涉及以下几个步骤：</p><ol><li>**设置 <code>outlineProvider</code>**：为 <code>View</code> 设置一个 <code>Outline</code>，它定义了 <code>View</code> 的形状和圆角。</li><li>**调用 <code>invalidateOutline()</code>**：通知系统 <code>View</code> 的轮廓已经改变，需要重新绘制。</li><li>**设置 <code>clipToOutline</code>**：决定是否根据 <code>View</code> 的 <code>Outline</code> 裁剪其内容。</li></ol><p><strong>View 和 ViewGroup 的区别</strong></p><ul><li>ViewGroup 需要控制子 view 如何摆放的时候需要实现 onLayout。</li><li>View 没有子 view，所以不需要 onLayout 方法，需要的话实现 onDraw</li><li>继承系统已有控件或容器, 比如 FrameLayou，它会帮我们去实现 onMeasure 方法中，不需要去实现 onMeasure, 如果继承 View 或者 ViewGroup 的话需要 warp_content 属性的话，需要实现 onMeasure 方法</li><li>自定义 ViewGroup 大多时候是控制子 view 如何摆放，并且做相应的变化（滑动页面、切换页面等）。</li><li>自定义 view 主要是通过 onDraw 画出一些形状，然后通过触摸事件去决定如何变化</li></ul><p><strong>scrollTo ()和 scrollBy ()</strong></p><ul><li>scrollTo 将当前视图的基准点移动到某个点（坐标点）；</li><li>ScrollBy 移动当前 view 内容移动一段距离。</li><li>为正时，图片向左移动，为负时，图片向右移动 （跟下面的坐标轴是反的）</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-b73202fc1ce8e4c16fe67942b082bb7a-722549-43d324.png" alt="722549|700"></p><p>三⻆函数的计算横向的位移是 cos，纵向的位移是 sin</p><h4 id="drawChild"><a href="#drawChild" class="headerlink" title="drawChild"></a>drawChild</h4><p>![[Pasted image 20250702163133.png]]</p><ul><li><strong>触发条件</strong>：<ul><li>View 首次附加到窗口时</li><li>View 的可见性发生变化时</li><li>调用 <code>invalidate()</code> 或 <code>postInvalidate()</code> 时</li><li>视图布局发生变化时（调用 <code>requestLayout()</code></li><li>动画执行期间（每帧重绘）</li></ul></li></ul><h4 id="dispatchDraw"><a href="#dispatchDraw" class="headerlink" title="dispatchDraw"></a>dispatchDraw</h4><p>dispatchDraw (Canvas canvas) 方法是 ViewGroup 类的一个受保护的方法，用于处理视图组的绘制流程。它会在以下几种情况下被调用：</p><ol><li>当视图树中的某个视图或视图组需要重新绘制时。</li><li>当视图树的布局发生变化时。<br>当调用了 invalidate () 或 requestLayout () 方法后，导致视图需要重新布局和绘制时。</li></ol><p>dispatchDraw (Canvas canvas) 的主要作用是将绘制任务分发给它的子视图。当 dispatchDraw 被调用时，它会间接导致子视图的 onDraw (Canvas canvas) 方法被调用。这是通过以下步骤完成的：</p><ol><li>dispatchDraw 通常会调用 drawChild (Canvas canvas, View child, long drawingTime) 方法来绘制每个子视图。</li><li>drawChild 方法内部会调用子视图的 draw (Canvas canvas) 方法。<br>子视图的 draw (Canvas canvas) 方法会进一步调用 onDraw (Canvas canvas) 方法来进行实际的绘制工作。因此，dispatchDraw 通过一系列调用链最终导致子视图的 onDraw 方法被执行，从而完成子视图的绘制</li></ol><h3 id="onFinishInflate-获取子View"><a href="#onFinishInflate-获取子View" class="headerlink" title="onFinishInflate 获取子View"></a>onFinishInflate 获取子View</h3><p>当 xml 被填充完毕时调用，在自定义 viewgroup 中，可以通过这个方法获得子 view 对象</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFinishInflate</span> <span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">super</span>.onFinishInflate ();<br><span class="hljs-comment">// 容错性检查 (至少有俩子 View, 子 View 必须是 ViewGroup 的子类)</span><br><span class="hljs-keyword">if</span> (getChildCount () &lt; <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException (<span class="hljs-string">&quot;布局至少有俩孩子. Your ViewGroup must have 2 children at least.&quot;</span>);<br>&#125;<br><br>mLeftContent = (ViewGroup) getChildAt (<span class="hljs-number">0</span>);<br>mMainContent = (ViewGroup) getChildAt (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得-View-宽高的几种方式"><a href="#获得-View-宽高的几种方式" class="headerlink" title="获得 View 宽高的几种方式"></a>获得 View 宽高的几种方式</h3><p><strong>获取 View 宽高的几种方法</strong></p><ol><li>OnGlobalLayoutListener 获取 </li><li>OnPreDrawListener 获取</li><li>OnLayoutChangeListener 获取 </li><li>重写 View 的 onSizeChanged </li><li>使用 View.post 方法</li></ol><ul><li>onWindowFocusChanged：View 已经初始化完毕，宽高已经有了，需要注意 onWindowFocusChanged 会被调用多次，Activity 得到焦点和失去焦点都会执行这个回调</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onWindowFocusChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasFocus)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onWindowFocusChanged(hasFocus);<br>    <span class="hljs-keyword">if</span> (hasFocus) &#123;<br>        <span class="hljs-comment">//获得宽度</span><br>        <span class="hljs-keyword">int</span> width = view.getMeasuredWidth();<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><ul><li>view.post (runnable)<br>  通过 post 可以将一个 runnable 投递到消息队列的尾部，等待 Looper 调用此 runnable 的时候，View 也已经初始化好了</li><li>ViewTreeObserver</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Overrideprotected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onStart</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onStart</span>();<br>    <span class="hljs-title class_">ViewTreeObserver</span> observer=view.<span class="hljs-title function_">getViewTreeObserver</span>();<br>    observer.<span class="hljs-title function_">addOnGlobalLayoutListener</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewTreeObserver</span>.<span class="hljs-title class_">OnGlobalLayoutListener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onGlobalLayout</span>(<span class="hljs-params"></span>) &#123;<br>            view.<span class="hljs-title function_">getViewTreeObserver</span>().<span class="hljs-title function_">removeOnGlobalLayoutListener</span>(<span class="hljs-variable language_">this</span>);<br>            int width=view.<span class="hljs-title function_">getMeasuredWidth</span>();<br>        &#125;<br>    &#125;);&#125;<br></code></pre></td></tr></table></figure><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>padding 是属于本 View 的属性，不同于 margin (不需要自定义时做处理系统就能很好的使用 margin)，所以要在测量绘图时考虑它<br>测量时, desireSize&#x3D;实际所需 size+相应方向的 padding。</p><h3 id="View-的绘制过程"><a href="#View-的绘制过程" class="headerlink" title="View 的绘制过程"></a>View 的绘制过程</h3><p>a.绘制背景 background.draw (canvas)<br>b.绘制自己 (onDraw)<br>c.绘制 children (dispatchDraw)<br>d.绘制装饰 (onDrawScrollBars)</p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-0c49e249319654f268cc47bcd208e651-6ffa7e36-0587-450e-946f-3f0cd60c6b82-ce8293.jpg" alt="6ffa7e36-0587-450e-946f-3f0cd60c6b82"></p><ul><li>view 的位置参数有 left、right、top、bottom（可以 getXX 获得），3.0后又增加了几个参数：x、y、translationX 和 translationY，其中 x 和 y 是 view 左上角的坐标，而<strong>translationX 和 translationY 是 view 左上角相对于父容器的偏移量</strong>。这些参数都是相对于父容器的坐标，并且 translationX 和 translationY 的默认值是0，他们的换算关系是：x&#x3D;left+translationX   y&#x3D;top+ translationY。需要注意的是，view 在平移的过程中，top 和 left 表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是 x、y、translationX 和 translationY 这四个参数</li><li>touchslop 是系统所能识别出的被认为是滑动的最小距离，比如当俩次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值</li><li><strong>Rect 成员变量为 int 类型，RectF 为 float 类型</strong></li></ul><p><strong>MotionEvent 中 getRawX、getRawY 与 getX、getY 以及 View 中的 getScrollX、getScrollY</strong></p><ul><li>getRawX ()、getRawY ()返回的是触摸点相对于屏幕的位置，而 getX ()、getY ()返回的则是触摸点相对于 View 的位置。</li><li>getScrollX ()与 getScrollY ()的值由调用 View 的 scrollTo (int x, int y)或者 scrollBy (int x, int y)产生，其中 scrollTo 是将 View 中的内容移动到指定的坐标 x、y 处，此 x、y 是相对于 View 的左上角，而不是屏幕的左上角。scrollBy (int x, int y)则是改变 View 中的相对位置，参数 x、y 为距离上一次的相对位置。</li><li>当 View 中的内容向右移动时，getScrollX ()的值为负数，同理，向 scrollTo 与 scrollBy 的 x 中传入负数，view 中的内容向右移动，反之向左。</li><li>当 View 中的内容向下移动时，getScrollY ()的值为负数，同理，向 scrollTo 与 scrollBy 的 y 中传入负数，view 中的内容向下移动，反之向上。</li><li>把 getScrollx 的值看成坐标。比如 view 向右边移动20px。那么得到的值就是 view. getScrollx ()的值就是-20</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/09/15/2024-02-21-17-47-816b6ba1ef98f6a08e1fe1911ccc9175-18-48-24-816b6ba1ef98f6a08e1fe1911ccc9175-c82ecb89-00f7-476b-bbe9-fba0ac818be1-cc14ef-3b2099.png" alt="c82ecb89-00f7-476b-bbe9-fba0ac818be1|600"></p><h3 id="四种滑动的方法"><a href="#四种滑动的方法" class="headerlink" title="四种滑动的方法"></a>四种滑动的方法</h3><ol><li>使用 scrollTo ()或 scrollBy ()，坐标是反的</li><li>动画</li><li>实时改变 layoutparams，重新布局</li><li>layout（）方法</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouchEvent</span> (<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>        <span class="hljs-comment">//获取到手指处的横坐标和纵坐标</span><br>        <span class="hljs-built_in">int</span> x = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">event</span>.getX ();<br>        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">event</span>.getY ();<br><br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">event</span>.getAction ()) &#123;<br>            <span class="hljs-keyword">case</span> MotionEvent. ACTION_DOWN:<br>                lastX = x;<br>                lastY = y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MotionEvent. ACTION_MOVE:<br>                <span class="hljs-comment">//计算移动的距离</span><br>                <span class="hljs-built_in">int</span> offX = x - lastX;<br>                <span class="hljs-built_in">int</span> offY = y - lastY;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 第一种</span><br><span class="hljs-comment">                 * 调用 layout 方法来重新放置它的位置</span><br><span class="hljs-comment">                 */</span><br>                layout (getLeft () + offX, getTop () + offY,<br>                        getRight () + offX, getBottom () + offY);<br><span class="hljs-comment">//                /**</span><br><span class="hljs-comment">//                 * 第二种</span><br><span class="hljs-comment">//                 * 这两个方法分别是对左右移动和上下移动的封装，传入的就是偏移量</span><br><span class="hljs-comment">//                 */</span><br><span class="hljs-comment">//                offsetLeftAndRight (offX);</span><br><span class="hljs-comment">//                offsetTopAndBottom (offY);</span><br><span class="hljs-comment">//                /**</span><br><span class="hljs-comment">//                 * 第三种</span><br><span class="hljs-comment">//                 */</span><br><span class="hljs-comment">//                ViewGroup. MarginLayoutParams mlp =</span><br><span class="hljs-comment">//                        (ViewGroup. MarginLayoutParams) getLayoutParams ();</span><br><span class="hljs-comment">//                mlp. leftMargin = getLeft () + offX;</span><br><span class="hljs-comment">//                mlp. topMargin = getTop () + offY;</span><br><span class="hljs-comment">//                setLayoutParams (mlp);</span><br><span class="hljs-comment">//                /**</span><br><span class="hljs-comment">//                 * 第四种</span><br><span class="hljs-comment">//                 * sceollTo (x, y)传入的应该是移动的终点坐标</span><br><span class="hljs-comment">//                 * scrollBy (dx, dy)传入的是移动的增量。</span><br><span class="hljs-comment">//                 * 通过 scrollBy 传入的值应该是你需要的那个增量的相反数</span><br><span class="hljs-comment">//                 */</span><br><span class="hljs-comment">//                ((View) getParent ()). scrollBy (-offX, -offY);</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果让 view 在一段时间内移动到某个位置 (不是快速滑动，弹性，有动画)方法：</p><ol><li>使用自定义动画 (让 view 在一段时间内做某件事），extends Animation，<br> 总要修改的是 translationx. y 这俩个值 (相对于父容器移动的距离)</li><li>使用 Scoller，OverScroller。用于自动计算滑动的偏移<br> 模板 (固定代码):</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"> * <span class="hljs-variable">@param</span> startX开始时的 X 坐标<br> * <span class="hljs-variable">@param</span> startY开始时的 Y 坐标<br> * <span class="hljs-variable">@param</span> disXX 方向要移动的距离<br> * <span class="hljs-variable">@param</span> disYY 方向要移动的距离<br>myScroller.startScroll (getScrollX (), <span class="hljs-number">0</span>,distance,<span class="hljs-number">0</span>,Math.abs (distance));<span class="hljs-comment">//持续的时间</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Scroller 不主动去调用这个方法</span><br><span class="hljs-comment"> * 而 invalidate ()可以掉这个方法</span><br><span class="hljs-comment"> * invalidate-&gt;draw-&gt;computeScroll</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@Override</span><br>public void computeScroll () &#123;<br><span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.computeScroll</span> ();<br><span class="hljs-selector-tag">if</span> (scroller.computeScrollOffset ())&#123;<span class="hljs-comment">//返回 true, 表示动画没结束</span><br><span class="hljs-selector-tag">scrollTo</span> (scroller.getCurrX (), <span class="hljs-number">0</span>);<br><span class="hljs-selector-tag">invalidate</span> ();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="scroller、OverScroller"><a href="#scroller、OverScroller" class="headerlink" title="scroller、OverScroller"></a>scroller、OverScroller</h3><p>scroller 本身并不能实现 view 的滑动，它需要配合<code>view 的的 computeScroll 方法才能完成弹性滑动的效果</code>，它不断的让 view 重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔 srcoller 就可以得出 view 当前的滑动位置，知道了滑动位置就可以通过 scrollTo 方法来完成 view 的滑动，就这样，view 的每一次重绘就会导致 view 进行小幅度的滑动，而多次的小幅度滑动就组成了弹性动画。</p><p>scrollTo () 是瞬时方法，不会自动使用动画。如果要用动画，需要配合 View.computeScroll () 方法<br>computeScroll () 在 View 重绘时被自动调用，使用方式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// onTouchEvent () 中：例如滑动等等</span><br>overScroller<span class="hljs-selector-class">.startScroll</span> (startX, startY, dx, dy);<br>postInvalidateOnAnimation ();<br>......<br><span class="hljs-comment">// onTouchEvent () 外：</span><br><span class="hljs-keyword">@Override</span><br>public void computeScroll () &#123;<br>  if (overScroller.computeScrollOffset ()) &#123; <span class="hljs-comment">//</span><br>   计算实时位置<br>   scrollTo (overScroller.getCurrX (),<br>    overScroller<span class="hljs-selector-class">.getCurrY</span> ()); <span class="hljs-comment">// 更新⾯面</span><br>   postInvalidateOnAnimation (); <span class="hljs-comment">// 下一帧继续</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a><strong>VelocityTracker</strong></h3><p>如果 GestureDetector 不能满⾜足需求，或者觉得 GestureDetector 过于复杂，可以自己处理 onTouchEvent () 的事件。但需要使用 VelocityTracker 来计算手指移动速度。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-e2f21bc194187a5f7fce4ec4b7bea389-unknown_filename.2-63c4be.png" alt="unknown_filename.2"></p><h2 id="Canvas-使用"><a href="#Canvas-使用" class="headerlink" title="Canvas 使用"></a>Canvas 使用</h2><ul><li>save：用来保存 Canvas 的状态。save 之后，可以调用 Canvas 的平移、放缩、旋转、错切、裁剪等操作。</li><li>restore：用来恢复 Canvas 之前保存的状态。防止 save 后对 Canvas 执行的操作对后续的绘制有影响。</li><li>save 和 restore 要配对使用 ( restore 可以比 save 少，但不能多)，如果 restore 调用次数比 save 多，会引发 Error 。save 和 restore 之间，往往夹杂的是对 Canvas 的特殊操作。</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-f7592775deae25107cfe75ab882b5768-unknown_filename.5-0fe60d.png" alt="unknown_filename.5"></p><p>Canvas 还提供了一系列位置转换的方法：rorate、scale、translate、skew (扭曲)等</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-81deb6acb507bf858387fbfeb6b370ee-unknown_filename.4-d22638.png" alt="unknown_filename.4"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-0cb6ab3258a144f14a5ec83708167dd2-unknown_filename.6-1c8b01.png" alt="unknown_filename.6"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-b6c011951dffbd24d8a1520b4cd4c420-unknown_filename.7-df640a.png" alt="unknown_filename.7"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93.resources/2023/09/15/18-48-24-fe76544d8d5d7e04760bfe8205f085dc-unknown_filename.8-18c4ec.png" alt="unknown_filename.8"></p><h2 id="inflate-方法"><a href="#inflate-方法" class="headerlink" title="inflate 方法"></a>inflate 方法</h2><p><strong>View.inflate () 和 LayoutInflator.from (). inflate () 有啥区别？</strong><br>调用 inflate () 方法的时候有时候传 null，有时候传 parent 是为啥？</p><p>View inflate 只是个简易的包装方法，实际上还是调用的 LayoutInflater  inflate ;<br>当 root 传空时，会直接返回要加载的 layoutId，<strong>返回的 View 没有父布局且没有 LayoutParams</strong>；<br>当 root 不传空时，又分为 attachToRoot 为真或者为假：</p><p>attachToRoot &#x3D; true 会为传入的 layoutId 直接设置参数，并将其添加到 root 中，<strong>然后将传入的 root 返回</strong>；<br>attachToRoot &#x3D; false 会为传入的 layoutId 设置参数，但是不会添加到 root ，然后返回 layoutId 对应的 View；</p><p>当我们不为子 View 的展示负责时，attachToRoot 必须为 false；否则就会出现对应的负责人，比如上面说的 Rv 或者 FragmentManager，已经把布局 id 添加到 ViewGroup 了，我们还继续设置 attachToRoot 为 true，想要手动 addView，那必然会发生 <strong>child already has parent</strong>的错误。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> ViewHolder onCreateViewHolder(ViewGroup parent, <span class="hljs-type">int</span> viewType) &#123;  <br>      LayoutInflater inflater = LayoutInflater.<span class="hljs-keyword">from</span>(getActivity());  <br>      <span class="hljs-keyword">View</span> <span class="hljs-keyword">view</span> = inflater.inflate(R.layout.item, parent, <span class="hljs-keyword">false</span>);  <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ViewHolder(<span class="hljs-keyword">view</span>);  <br>&#125;<br><br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">View</span> onCreateView(LayoutInflater inflater, ViewGroup container, <br>                         Bundle savedInstanceState) &#123;<br>    <span class="hljs-keyword">return</span> inflater.inflate(R.layout.fragment_layout, parentViewGroup, <span class="hljs-keyword">false</span>); <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>view</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gradle插件</title>
    <link href="/2025/12/bbf498878f13.html"/>
    <url>/2025/12/bbf498878f13.html</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-Gradle"><a href="#什么是-Gradle" class="headerlink" title="什么是 Gradle"></a>什么是 Gradle</h3><p>Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化构建工具。Gradle 就是<strong>工程的管理，帮我们做了依赖、打包、部署、发布、各种渠道</strong>的差异管理等工作。<br>Gradle 脚本是基于 Groovy 语言来编译执行的，Java、Groovy、Kotlin 等都是基于 JVM 运行的，所以他们在语法上共性很多，熟悉 Java 的同学应该对 Groovy 上手很快</p><h4 id="gradle插件"><a href="#gradle插件" class="headerlink" title="gradle插件"></a>gradle插件</h4><p>gradle插件修改代码是在最后一步<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8F%92%E4%BB%B6.resources/2023/09/15/18-48-10-1243f403caedbbb3673f06080749f3db-unknown_filename.5-53eb19.png" alt="unknown_filename.5"></p><h3 id="编写方法"><a href="#编写方法" class="headerlink" title="编写方法"></a>编写方法</h3><p>在 Android 下的 gradle 插件共分为 两大类：</p><ul><li>脚本插件：同普通的 gradle 脚本编写形式一样，可以直接写在build.gradle文件中，也可以自己新建一个 gradle 脚本文件中写</li><li>对象插件：通过插件全路径类名或 id 引用，它主要有 三种编写形式，如下所示：<br>  1）在当前构建脚本下直接编写。<br>  2）在 buildSrc 目录下编写。<br>  加载自定义插件 group + module + version<br>  3）在完全独立的项目中编写。</li></ul><h4 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h4><p>由于buildSrc目录是gradle默认的目录之一，该目录下的代码会在构建是自动编译打包，并被添加到buildScript中的classpath下，所以不需要任何额外的配置，就可以直接被其他模块的构建脚本所引用。<br>这就是：buildScript</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8F%92%E4%BB%B6.resources/2023/09/15/18-48-10-2ee54d0a19d35714ebe766ca2fd4fce9-unknown_filename-7c7987.png" alt="unknown_filename"></p><p>在buildSrc&#x2F;src&#x2F;main目录下，再分别创建groovy、resources文件夹。</p><p>随便定义的需要自己写classpath:<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8F%92%E4%BB%B6.resources/2023/09/15/18-48-10-767409b5145505004c2dbce3852de167-unknown_filename.1-6ec2ed.png" alt="unknown_filename.1"></p><p>优点：</p><ul><li>项目构建时，Gradle 会自动编译项目目录下的 buildSrc 文件夹下的构建脚本和源码，并将其添加到项目构建脚本的 classpath 中，因此在<strong>使用 buildSrc 中创建的插件时，无需再手动指定 classpath（依赖的名字）</strong>（当然也可以自己创建id）</li><li>buildSrc 文件夹中构建脚本和 Gradle 插件同一项目均可见，因此同一项目中的其他模块也可以使用 buildSrc 中创建的插件</li><li>不需要 uploadArchives task</li></ul><p><strong>缺点：</strong><br>此处创建的插件对外部项目不可见，无法在其他项目中复用</p><p><strong>id引入</strong><br>引用的方式可以是通过类名引用，也可以通过给插件映射一个id，然后通过id引用。<br>通过类名引用插件的需要使用全限定名，也就是需要带上包名，或者可以先导入这个插件类，如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 在app模块下的build.gradle文件中引用</span><br>apply plugin:com<span class="hljs-selector-class">.wings</span><span class="hljs-selector-class">.gradle</span>.CustomBuildSrcPlugin<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 在app模块下的build.gradle文件中引用</span><br>import com<span class="hljs-selector-class">.wings</span><span class="hljs-selector-class">.gradle</span><span class="hljs-selector-class">.CustomBuildSrcPlugin</span><br>apply plugin: CustomBuildSrcPlugin<br></code></pre></td></tr></table></figure><blockquote><p>通过简单的id的方式，我们可以隐藏类名等细节，使的引用更加容易。映射的方式很简单，在buildSrc目录下创建resources&#x2F;META-INF&#x2F;gradle-plugins&#x2F;xxx.properties,这里的xxx也就是所映射的id，这里我们假设取名CustomPlugin。具体结构可参考上文buildSrc目录结构。</p></blockquote><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h4><p><strong>作用</strong></p><ul><li>一般自定义Plugin就是入口</li><li>模块化构建脚本的功能</li><li>公共的功能可以抽取出来成为插件，可以供多个 build.gradle 使用，增加复用性。</li></ul><p><strong>和task的关系</strong><br>如果有个你想要在好几个项目中重用的Gradle task集合，把这些task提取到一个自定义的plugin中是有意义的。这使得重用你自己的build逻辑和与他人共享该逻辑都是可能的。</p><h4 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h4><p>为了能让 App 传入相关的版本信息和生成的版本信息文件路径，我们需要一个用于配置版本信息的 Extension，其实质就是一个实体类</p><p>与创建扩展属性一样，扩展Task也需要在project中创建注入。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project<span class="hljs-selector-class">.extensions</span><span class="hljs-selector-class">.create</span>(<span class="hljs-string">&quot;releaseInfo&quot;</span>, ReleaseInfoExtension)<br></code></pre></td></tr></table></figure><h4 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h4><p>右边就都是task</p><ul><li>使用自定义扩展属性 <strong>Extension</strong> 仅仅是为了让使用插件者有配置插件的能力。而插件还得借助自定义 Task 来实现相应的功能</li><li>创建扩展属性一样，扩展Task也需要在project中创建注入</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 创建Task</span><br>project<span class="hljs-selector-class">.tasks</span><span class="hljs-selector-class">.create</span>(<span class="hljs-string">&quot;updateReleaseInfo&quot;</span>, ReleaseInfoTask)<br></code></pre></td></tr></table></figure><ul><li>task 的作用就是通过实现自定义的 Extension，可以在 Gradle 脚本中增加类似 android 这样命名空间的配置，Gradle 可以识别这种配置，并读取里面的配置内容。。</li><li>一个Task表示一个逻辑上较为独立的执行过程，比如编译Java源代码，拷贝文件，打包Jar文件，甚至可以是执行一个系统命令或者调用Ant。另外，一个Task可以读取和设置Project的Property以完成特定的操作。</li><li><strong>一个Task是由一序列Action</strong>组成的，当运行一个Task的时候，这个Task里的Action序列会按照顺序执行</li></ul><p><strong>构建生命周期</strong><br>每次构建的本质其实就是执行一系列的Task，某些Task可能依赖其他Task，那些没有依赖的Task总会被最先执行，而且每个Task只会被执行一遍，每次构建的依赖关系是在构建的配置阶段确定的，在gradle构建中，构建的生命周期主要包括以下三个阶段：<br>初始化（Initialization)<br>构建工具会根据每个build.gradle文件创建出一个Project实例，初始化阶段会执行项目根目录下的Settings.gradle文件，来分析哪些项目参与构建。<br>include ‘:app’<br>配置（Configuration）<br>执行（Execution）</p><p>有关于命令行调用的信息，只需要使用 exec {} 闭包<br>exec 闭包中的几个参数提及下——</p><ul><li>workingDir：工作环境，参数为 File 格式。默认为当前 project 目录。</li><li>commandLine：需要命令行执行的命令，参数为 List 格式。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">task</span> RunBatfile &#123;<br>         exec &#123;<br>             workingDir <span class="hljs-string">&quot;D:/Bat&quot;</span><br>             commandLine <span class="hljs-string">&#x27;cmd&#x27;</span>, <span class="hljs-string">&#x27;/c&#x27;</span>, <span class="hljs-string">&#x27;&lt;your_bat_file_name&gt;.bat&#x27;</span><br>         &#125;<br>     &#125;<br>    <br><br> <span class="hljs-comment">// 统计build执行时长</span><br> <span class="hljs-keyword">def</span> startBuildTime, endBuildTime<br> <span class="hljs-comment">//doFirst、doLast可以对gradle中提供的已有的task进行扩展。</span><br> <span class="hljs-keyword">this</span>.afterEvaluate &#123; <span class="hljs-keyword">Project</span> <span class="hljs-keyword">project</span> -&gt;<br>     <span class="hljs-comment">// 保证要找的task已经配置完毕</span><br>     <span class="hljs-keyword">def</span> preBuildTask = <span class="hljs-keyword">project</span>.tasks.getByName(<span class="hljs-string">&#x27;preBuild&#x27;</span>) <span class="hljs-comment">// 执行build任务时，第一个被执行的Task</span><br>     preBuildTask.<span class="hljs-keyword">doFirst</span> &#123;<br>         startBuildTime = System.currentTimeMillis()<br>     &#125;<br>     <span class="hljs-keyword">def</span> buildTask = <span class="hljs-keyword">project</span>.tasks.getByName(<span class="hljs-string">&#x27;build&#x27;</span>) <span class="hljs-comment">// 执行build任务时，最后一个被执行的Task</span><br>     buildTask.<span class="hljs-keyword">doLast</span> &#123;<br>         endBuildTime = System.currentTimeMillis()<br>         <span class="hljs-keyword">println</span> <span class="hljs-string">&quot;the build time is: $&#123;endBuildTime - startBuildTime&#125;&quot;</span><br>     &#125;<br> &#125;<br>    <br></code></pre></td></tr></table></figure><p>task taskZ(dependsOn: [taskX, taskY]) {<br>&#x2F;&#x2F; 依赖多个task，需要用数组[]表示<br>doLast { println ‘taskZ’ } }<br>taskZ依赖了taskX与taskY，所以在执行taskZ时，会先执行taskX、taskY。</p><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><ul><li>Transform 可以被看作是Gradle 在编译项目时的一个 task，<strong>在 .class 文件转换成 .dex 的流程中会执行这些 task</strong>，对所有的 .class 文件（可包括第三方库的 .class）进行转换，转换的逻辑定义在 Transform 的 transform 方法中。实际上平时我们在 build.gradle 中常用的功能都是通过 Transform 实现的，比如混淆（proguard）、分包（multi-dex）、jar 包合并（jarMerge）</li><li>在 Booster 中，跟字节码相关的操作都是通过 Transformer 来完成，它是对字节码转换的简单抽象，以字节码的二进制做为输入，经过转换后，输出字节码二进制，它与具体使用哪种字节码操作框架无关，开发者可以自己选择跟字节码操作框架相关的特定实现， Booster 提供了两种实现：<br>  基于 ASM 的实现：AsmTransformer<br>  基于 Javassist 的实现：JavassistTransformer</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> AddCodePlugin <span class="hljs-keyword">implements</span> Plugin&lt;<span class="hljs-keyword">Project</span>&gt; &#123;<br>    <span class="hljs-keyword">void</span> apply(<span class="hljs-keyword">Project</span> <span class="hljs-keyword">project</span>) &#123;<br>        <span class="hljs-keyword">project</span>.android.registerTransform(<span class="hljs-keyword">new</span> AddCodeTransform(<span class="hljs-keyword">project</span>))<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>写法</strong><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8F%92%E4%BB%B6.resources/2023/09/15/18-48-10-ee036b402c47ad14ccfe61ff4a879e9b-unknown_filename.2-cf2a9a.png" alt="unknown_filename.2"><br>其实就是：<strong>把输入内容写入到作为输出内容</strong></p><p>输出地址不是由你任意指定的。而是根据输入的内容、作用范围等由TransformOutputProvider生成，比如，你要获取输出路径：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> String dest = outputProvider<span class="hljs-selector-class">.getContentLocation</span>(directoryInput<span class="hljs-selector-class">.name</span>,<br>                        directoryInput<span class="hljs-selector-class">.contentTypes</span>, directoryInput<span class="hljs-selector-class">.scopes</span>, Format.DIRECTORY)<br>                        <br>FileUtils<span class="hljs-selector-class">.copyDirectory</span>(directoryInput<span class="hljs-selector-class">.file</span>, dest)<br></code></pre></td></tr></table></figure><p>Transform的inputs有两种类型，一种是目录，一种是jar包，要分开遍历<br>一旦注册了transform，就要处理输入和输出（默认实现是没有处理的），否则编译失败。</p><p><strong>字节码操作框架</strong><br>ASM vs Javassist  &#x2F;əˈsɪst&#x2F;</p><p><a href="https://www.jianshu.com/p/f2a4c7d3745d">https://www.jianshu.com/p/f2a4c7d3745d</a><br>Javassist简单，asm性能好</p><p><strong>Transform API 起因</strong><br>从 Android Gradle Plugin 1.5.0-beta1 开始，为了简化注入自定义 class 的操作，Android 提供了 Transform API，允许第三方插件在 class 文件被转换成 dex 之前对其进行修改，在此之前，如果要实现同样的操作，只能通过 Hook Task 的方式才能做到</p><p><strong>参数说明</strong><br>具体看代码<br>解释说明：Transform 主要作用是检索项目编译过程中的所有文件。通过这几个方法，我们可以对自定义 Transform 设置一些遍历规则，具体如下：</p><p>getName：<br>设置我们自定义的 Transform 对应的 Task 名称。Gradle 在编译的时候，会将这个名称显示在控制台上。比如：<br>Task :app:transformClassesWithXXXForDebug。</p><p>getInputType：<br>在项目中会有各种各样格式的文件，通过 getInputType 可以设置 LifeCycleTransform 接收的文件类型，此方法返回的类型是 Set&lt;QualifiedContent.ContentType&gt; 集合。</p><h4 id="Gradle脚本的执行时序"><a href="#Gradle脚本的执行时序" class="headerlink" title="Gradle脚本的执行时序"></a>Gradle脚本的执行时序</h4><ol><li>首先解析settings.gradle来获取模块信息，这是初始化阶段；</li><li>然后配置每个模块，配置的时候并不会执行task；</li><li>配置完了以后，有一个重要的回调<strong>project.afterEvaluate</strong>，它表示所有的模块都已经配置完了，可以准备执行task了；</li><li>执行指定的task。</li></ol><p>备注：如果注册了多个project.afterEvaluate回调，那么执行顺序等同于注册顺序。在上面的例子中，由于buildSrc中的回调注册较早，所以它也先执行。</p><p>gradle提供了对project状态配置监听的接口回调,以方便我们来配置一些Project的配置属性,监听主要分为两大类,一种是通过project进行 回调，一种是通过gradle进行回调,作用域也有不同 ,project是只针对当前project实现进行的监听,gradle监听是针对于所有的project而言的。接下来就其方式和具体的实现进行介绍说明。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8F%92%E4%BB%B6.resources/2023/09/15/18-48-10-fcc17e324260c1d843f6e169906597f0-unknown_filename.4-e70436.png" alt="unknown_filename.4"></p><p>&#x2F;&#x2F;在 Project 进行配置前调用<br>void beforeEvaluate(Closure closure)<br>&#x2F;&#x2F;在 Project 配置结束后调用，一般用这个<br>void afterEvaluate(Closure closure)<br>beforeEvaluate 必须在父模块的 build.gradle 对子模块进行配置才能生效，因为在当前模块的 build.gradle 中配置，它自己本身都没配置好，所以不会监听到。<br>什么是配置</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">//凡是project中可以配置的都可以进行配置</span><br>  <span class="hljs-comment">//比如添加依赖</span><br>  <span class="hljs-keyword">dependencies</span>&#123;<br>    <br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="Gradle用处"><a href="#Gradle用处" class="headerlink" title="Gradle用处"></a>Gradle用处</h3><p>gradle插件修改第三方代码</p><p>1、我们知道在打包过程中，可以通过动态修改字节码，来进行插桩，实现埋点等业务，那么，在什么时机插入呢？；<br>2、随着项目越来越大，编译项目的时间会越来越长，我们需要统计各个任务的执行时间，来优化我们的打包编译速度，那么，如何统计呢？；<br>3、在我们的项目、第三方库和系统遇到一些bug的时候，我们有没有什么比较好的hook方法，对我们的代码做到无侵入？<br>4、多想想使用场景，例如打包完成发送钉钉机器人等</p><h3 id="好文章"><a href="#好文章" class="headerlink" title="好文章"></a>好文章</h3><p><a href="https://github.com/didi/booster">各种插件</a></p><p><a href="https://blog.bihe0832.com/gradle_plugin_debug.html">调试gradle</a><br>最后需要执行 gradle assembleDebug</p><p><a href="https://www.jianshu.com/p/6bbe9352f75d">https://www.jianshu.com/p/6bbe9352f75d</a> 也可以</p><p>或者右侧：APP —— build —— assemble(可以停止)<br>下一次直接点bugbug就可以调试了<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8F%92%E4%BB%B6.resources/2023/09/15/18-48-10-d6b9e63e3a27a0ab0cf27a0e48d63ed6-unknown_filename.3-ddf14d.png" alt="unknown_filename.3"></p><p><a href="https://www.jianshu.com/p/80a14bc35000">如何debug自定义AbstractProcessor</a> 好用</p><p><a href="https://www.jianshu.com/p/4fef2ad51f5a">Android APT 编译期进入debug模式</a></p><p><a href="https://blog.bihe0832.com/gradle_plugin_publish.html">gradle插件发布</a></p><p><a href="https://www.jianshu.com/p/417589a561da">通过自定义Gradle插件修改编译后的class文件</a></p><p><a href="https://blog.csdn.net/ZYJWR/article/details/113091371">Gradle插件实战之编译期修改代码</a></p><ul><li>开源库和自己写的插入代码注意不要混淆</li><li>buildSrc中build.gradle的AGP版本要和app模块中一致</li><li>插入代码引用的类要使用全路径</li><li>插入代码中用到的类需要将类路径添加到classPool中，否则会编译不过<br>  buildSrc不要在settings.gradle中配置</li><li>不管我们有没有修改jar的操作，也要拷贝到目标路径</li></ul><p><a href="https://juejin.cn/post/6844904013998243847">Android ASM框架详解</a></p><p><a href="https://www.cnblogs.com/sunfie/p/5154246.html">Java学习之 javassist</a></p><p><a href="https://juejin.cn/post/6844904047728656398">自定义Gradle插件+ASM 实战</a></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>Could not find implementation class ‘xxx’ 的话</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">implementation-class=com<span class="hljs-selector-class">.lqr</span><span class="hljs-selector-class">.gradle</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.GradleStudyPlugin</span><br><span class="hljs-comment">// 如果报错 Could not find implementation class &#x27;xxx&#x27; 的话，一般是类全路径有问题，默认包不需要写包路径，修改如下即可：</span><br><span class="hljs-comment">// implementation-class=GradleStudyPlugin</span><br></code></pre></td></tr></table></figure></li><li><p>重新部署插件时，需要先在 app module 的 build.gradle 中将插件依赖注释，否则报错。</p></li><li><p>不生效时，可以先注释，编译，再打开试试</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gradle技巧和遇到的问题</title>
    <link href="/2025/12/88e5d1a55ae0.html"/>
    <url>/2025/12/88e5d1a55ae0.html</url>
    
    <content type="html"><![CDATA[<h2 id="Gradle-是什么"><a href="#Gradle-是什么" class="headerlink" title="Gradle 是什么"></a>Gradle 是什么</h2><p>是构建工具，不是语言<br>它用了 Groovy 这个语言，创造了一种 DSL，但它本身不是语⾔</p><p>packagingOptions</p><p>packagingOptions常见的设置项有exclude、pickFirst、doNotStrip、merge。</p><p>1. exclude，过滤掉某些文件或者目录不添加到APK中，作用于APK，不能过滤aar和jar中的内容。</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">packagingOptions</span> &#123;<br>    <span class="hljs-literal">exclude</span> <span class="hljs-string">&#x27;META-INF/**&#x27;</span><br>    <span class="hljs-literal">exclude</span> <span class="hljs-string">&#x27;lib/arm64-v8a/libmediaplayer.so&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2. pickFirst，匹配到多个相同文件，只提取第一个。只作用于APK，不能过滤aar和jar中的文件。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">packagingOptions</span> &#123;<br>   pickFirst <span class="hljs-string">&quot;lib/armeabi-v7a/libaaa.so&quot;</span><br>   pickFirst <span class="hljs-string">&quot;lib/armeabi-v7a/libbbb.so&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>3. doNotStrip，可以设置某些动态库不被优化压缩。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">packagingOptions</span>&#123;<br>   doNotStrip <span class="hljs-string">&quot;*/armeabi/*.so&quot;</span><br>   doNotStrip <span class="hljs-string">&quot;*/armeabi-v7a/*.so&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4. merge，将匹配的文件都添加到APK中，和pickFirst有些相反，会合并所有文件。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">packagingOptions &#123;<br>    <span class="hljs-keyword">merge</span> <span class="hljs-string">&#x27;**/LICENSE.txt&#x27;</span><br>    <span class="hljs-keyword">merge</span> <span class="hljs-string">&#x27;**/NOTICE.txt&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="compile-implementation-和-api"><a href="#compile-implementation-和-api" class="headerlink" title="compile, implementation 和 api"></a>compile, implementation 和 api</h4><p>implementation：不会传递依赖<br>compile &#x2F; api：会传递依赖；<br>从 Gradle 3.0 版本开始，compile 废弃</p><p>二级依赖 0 级项目<br>当依赖被传递时，<em>二级依赖的改动会导致 0 级项目重新编译；</em><br>当依赖不传递时，二级依赖的改动不会导致 0 级项目重新编译</p><p>gralde.wrapper 所有项目的gradle的下载地址，就不用把gradle上传上去了<br>我们可以把 compile 替换为 provided 关键字 provided 的意思是<em>只在编译时会用到相应的 jar 包，打包成 apk 后 jar 包并不会在 apk 中存在</em>（旧版 Android 插件用 <code>provided</code>，新版统一用 <code>compileOnly</code>）</p><h4 id="compileOnly"><a href="#compileOnly" class="headerlink" title="compileOnly"></a>compileOnly</h4><p>父组件实现 implementation，子组件 compileOnly，这样组件可以编译期有，运行时没有（可以用到父组件的）<br>声明仅需在编译期间使用的依赖库，但<strong>不会打包到最终 APK</strong> 中</p><p>只要确保有一个 module 中该依赖能参与到打包即可。</p><p>编译时仅需要其 API，但具体实现由别的 module 1实现<br>所以 <em>compileOnly 经常用于解决依赖冲突等问题</em>，一般第三方库中，比较常用的依赖，如 support、gson、Eventbus 等等。</p><p> <code>compileOnly</code> 可显著<em>优化 APK 体积和构建速度</em></p><h4 id="Gradle-常用命令"><a href="#Gradle-常用命令" class="headerlink" title="Gradle 常用命令"></a>Gradle 常用命令</h4><p><a href="http://wuxiaolong.me/2017/07/19/mac-adb-gradlew/">Mac 配置 adb 环境、gradlew：command not found</a><br>.&#x2F;gradlew build –stacktrace &gt; logs.txt 2&gt;logErrors.txt<br>输出错误日志</p><p>gradlew assembleDebug<br>gradlew tinkerPatchDebug</p><p>.&#x2F;gradlew build –refresh-dependencies</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 查看构建版本</span><br><span class="hljs-string">./gradlew</span> -v<br><span class="hljs-comment"># 清除build文件夹</span><br><span class="hljs-string">./gradlew</span> clean<br><span class="hljs-comment"># 检查依赖并编译打包</span><br><span class="hljs-string">./gradlew</span> build<br><span class="hljs-comment"># 编译并安装debug包</span><br><span class="hljs-string">./gradlew</span> installDebug<br><span class="hljs-comment"># 编译并打印日志</span><br><span class="hljs-string">./gradlew</span> build <span class="hljs-params">--info</span><br><span class="hljs-comment"># 译并输出性能报告，性能报告一般在 构建工程根目录 build/reports/profile</span><br><span class="hljs-string">./gradlew</span> build <span class="hljs-params">--profile</span><br><span class="hljs-comment"># 调试模式构建并打印堆栈日志</span><br><span class="hljs-string">./gradlew</span> build <span class="hljs-params">--info</span> <span class="hljs-params">--debug</span> <span class="hljs-params">--stacktrace</span><br><span class="hljs-comment"># 强制更新最新依赖，清除构建并构建</span><br><span class="hljs-string">./gradlew</span> clean build <span class="hljs-params">--refresh-dependencies</span><br><br><br><span class="hljs-comment"># 编译并打Debug包</span><br><span class="hljs-string">./gradlew</span> assembleDebug<br><span class="hljs-comment"># 这个是简写 assembleDebug</span><br><span class="hljs-string">./gradlew</span> aD<br><span class="hljs-comment"># 编译并打Release的包</span><br><span class="hljs-string">./gradlew</span> assembleRelease<br><span class="hljs-comment"># 这个是简写 assembleRelease</span><br><span class="hljs-string">./gradlew</span> aR<br><br><span class="hljs-string">./gradlew</span> app<span class="hljs-function">:dependencies</span>       去除重复依赖库优化<br></code></pre></td></tr></table></figure><p><strong>混淆恢复</strong><br>android-sdk&#x2F;tools&#x2F;proguard&#x2F;bin&#x2F;proguardgui.bat</p><p><strong>减少apk体积</strong></p><ul><li><p>Android Studio 3.0 推出了新 Dex 编译器 D8 与新混淆工具 R8，目前 D8 已经正式 Release，大约可以减少 3% 的 Dex 体积。<br>  Android Studio 使用 R8（它使用 ProGuard 规则文件）来压缩代码，<br>  排查 R8 问题：<br>  <a href="https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn#shrink-code">https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn#shrink-code</a></p></li><li><p>MultiDex.install(this);分多个dex包</p></li><li><p>使用andresguard，路径变成了r&#x2F;d&#x2F;a，还有Android 编译过程中，下面这些格式的文件会指定不压缩；在 AndResGuard 中，我们支持针对 resources.arsc、PNG、JPG 以及 GIF 等文件的强制压缩。</p></li><li><p>移出无用的资源</p></li></ul><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;<br>    <span class="hljs-operator">...</span><br>    <span class="hljs-keyword">buildTypes</span> &#123;<br>        <span class="hljs-keyword">release</span> &#123;<br>            shrinkResources <span class="hljs-literal">true</span><br>            minifyEnabled <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>minifyEnabled 会对代码进行混淆和压缩，shrinkResources 会对比R文件对无用资源进行删除</li><li>minifyEnabled 设置为true时shrinkResources 的设置才会生效</li></ol><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p>添加 @Nullable 和 @NonNull 注释，以检查给定变量、参数或返回值的 null 性<br>public abstract void setTitle(@StringRes int resId)<br>其他资源类型的注释（例如 @DrawableRes、@DimenRes、@ColorRes 和 @InterpolatorRes<br>@MainThread@UiThread@WorkerThread<br> @IntRange、@FloatRange 和 @Size <br> @RequiresPermission</p><p><strong>id可以不同，装两个类似应用</strong></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;       <br><span class="hljs-keyword">defaultConfig</span> &#123;            <br>applicationId <span class="hljs-string">&quot;com.example.myapp&quot;</span>       <br>&#125;       <br><span class="hljs-keyword">productFlavors</span> &#123;          <br><span class="hljs-keyword">free</span> &#123;                applicationIdSuffix <span class="hljs-string">&quot;.free&quot;</span>            &#125;           <br><span class="hljs-keyword">pro</span> &#123;                applicationIdSuffix <span class="hljs-string">&quot;.pro&quot;</span>            &#125;      <br>&#125;    <br>&#125;      <br><br></code></pre></td></tr></table></figure><p>配置动态版本代码 ：不用自己手改了</p><p><strong>优化构建速度</strong><br><a href="https://developer.android.google.cn/studio/build/optimize-your-build?hl=zh-cn">https://developer.android.google.cn/studio/build/optimize-your-build?hl=zh-cn</a></p><h4 id="Gradle-自动化构建"><a href="#Gradle-自动化构建" class="headerlink" title="Gradle 自动化构建"></a>Gradle 自动化构建</h4><p><strong>BuildTypes、Flavors、BuildVariants</strong><br>BuildTypes：<strong>构建类型</strong>，AndroidStudio的Gradle组件默认提供给了“debug”“release”两个默认配置，此处用于配置是否需要混淆、是否可调试等<br>productFlavors：<strong>产品渠道</strong>，默认不提供任何默认配置，在实际发布中，根据不同渠道，我们可能需要用不同的包名，服务器地址、收费或付费等<br>BuildVariants：每个buildtype和flavor组成一个buildvariant</p><p>Build-&gt;Generate Signed APK，补充好签名信息，可以看到Flavors多了两个我们添加的渠道，这时候选择一个然后开始构建，看效果吧！</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">buildTypes</span> &#123;<br>  <span class="hljs-keyword">release</span> &#123;<br>    debuggable <span class="hljs-literal">true</span><br>    minifyEnabled <span class="hljs-literal">true</span> <span class="hljs-comment">//启用Proguard</span><br>    shrinkResources <span class="hljs-literal">true</span> <span class="hljs-comment">//是否清理无用资源,依赖于minifyEnabled</span><br>    zipAlignEnabled <span class="hljs-literal">true</span> <span class="hljs-comment">//是否启用zipAlign压缩</span><br>    signingConfig signingConfigs.release<br>    proguardFiles getDefaultProguardFile(<span class="hljs-symbol">&#x27;proguard</span><span class="hljs-operator">-</span>android.txt&#x27;), <span class="hljs-symbol">&#x27;proguard</span><span class="hljs-operator">-</span>rules.txt&#x27;<br>  &#125;<br>  <span class="hljs-keyword">debug</span> &#123;<br>    debuggable <span class="hljs-literal">true</span><br>    minifyEnabled <span class="hljs-literal">false</span>  <span class="hljs-comment">//不启用Proguard</span><br>    shrinkResources <span class="hljs-literal">false</span> <span class="hljs-comment">//是否清理无用资源,依赖于minifyEnabled</span><br>    zipAlignEnabled <span class="hljs-literal">false</span> <span class="hljs-comment">//是否启用zipAlign压缩</span><br>    signingConfig signingConfigs.debug<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>技巧：可以创建个debug、debug文件夹，写个工具类，不同包BuildTypes就会执行不同的逻辑，会和默认的合并。比如，debug的设置图标蓝色，其他红色</p></blockquote><h4 id="升级3-0引起的问题（butterknife）"><a href="#升级3-0引起的问题（butterknife）" class="headerlink" title="升级3.0引起的问题（butterknife）"></a>升级3.0引起的问题（butterknife）</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Error:Cannot choose between the following configurations of project :XXX:<br><span class="hljs-bullet">  -</span> debugApiElements<br><span class="hljs-bullet">  -</span> debugRuntimeElements<br><span class="hljs-bullet">  -</span> releaseApiElements<br><span class="hljs-bullet">  -</span> releaseRuntimeElements<br></code></pre></td></tr></table></figure><p>解决办法：<br>1、project的build.gradle文件，删除“apt”配置：<br><code>classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39; //删除</code><br>2、module的build.gradle文件，删除“android-apt”引用：<br><code>apply plugin: &#39;android-apt&#39; //删除</code><br>3、module的build.gradle文件，修改“dependencies”中的“apt”方式 为“annotationProcessor”方式：<br><code>apt &quot;引用项&quot; //老方式，删除 annotationProcessor &quot;引用项&quot; //新方式</code></p><h4 id="Android项目目录"><a href="#Android项目目录" class="headerlink" title="Android项目目录"></a>Android项目目录</h4><p>（我觉的挺好，就拿别人的放到这里来了<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8A%80%E5%B7%A7%E5%92%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.resources/2023/09/18/09-56-56-9d9503b5893f61a640fbbb2a5fb3e47c-70d88bd0-fd3f-491a-b998-922b636717b1-f213b6.png" alt="70d88bd0-fd3f-491a-b998-922b636717b1"></p><h4 id="gralde缓存目录"><a href="#gralde缓存目录" class="headerlink" title="gralde缓存目录"></a>gralde缓存目录</h4><p>Windows用户 C:\Users(用户)\username.gradle\caches\modules-2\files-2.1<br>linux／mac用户 ~&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1</p><h4 id="全局变量的使用"><a href="#全局变量的使用" class="headerlink" title="全局变量的使用"></a>全局变量的使用</h4><p>在多个module的情况下，不同module的build.gradle文件中有部分配置项类似，或者依赖的类库，有部分是相同的，在维护上不是很方便，这个时候就可以考虑统一配置。在项目根目录的build.gradle文件中添加以下代码和android{}同级</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">ext &#123;<br>    <span class="hljs-regexp">//</span>全局变量控制，可在<span class="hljs-keyword">module</span>中的build.gradle文件通过rootProject.ext.xxx开头来使用<br>    compileSdkVersion = <span class="hljs-number">24</span><br>    buildToolsVersion = <span class="hljs-string">&#x27;24.0.3&#x27;</span><br>    supportVersion = <span class="hljs-string">&#x27;24.2.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置打包用的签名"><a href="#配置打包用的签名" class="headerlink" title="配置打包用的签名"></a>配置打包用的签名</h4><p>主要有接过分享或者授权登录功能的都应该知道，像微信或者微博的分享和授权登录提供sdk，只有在指定的签名下才能生效，而我们平时开发都习惯使用默认的androidkeystore打包签名，这个时候想要测试分享或者登录功能就需要手动去打包指定keystore的签名。非常影响开发效率，这个时候可以通过配置gradle，根据release或者是debug打包指定的签名。<br>项目根目录新建一个签名用到的密码管理文件signing.properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">signing.alias</span>=dou361            <span class="hljs-comment">#release</span><br><span class="hljs-attr">signing.password</span>=dou361            <span class="hljs-comment">#release</span><br><span class="hljs-attr">signing.jjdxm_alias</span>=dou361        <span class="hljs-comment">#debug</span><br><span class="hljs-attr">signing.jjdxm_password</span>=dou361    <span class="hljs-comment">#debug</span><br></code></pre></td></tr></table></figure><p>在主程序build.gradle的apply plugin: ‘com.android.application’下面添加</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Properties</span> <span class="hljs-variable">props</span> = <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">Properties</span>()</span><br><span class="hljs-variable">props.load</span>(<span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">FileInputStream</span>(<span class="hljs-title">file</span>(<span class="hljs-variable">rootProject.file</span>(<span class="hljs-string">&quot;signing.properties&quot;</span>))))</span><br></code></pre></td></tr></table></figure><p>在android{}节点里面添加</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs stylus">signingConfigs &#123;<br>    release &#123;<br>        keyAlias props<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;signing.alias&#x27;</span>]</span><br>        keyPassword props<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;signing.password&#x27;</span>]</span><br>        storeFile <span class="hljs-built_in">file</span>(rootProject<span class="hljs-selector-class">.file</span>(<span class="hljs-string">&quot;debug.keystore&quot;</span>))<br>        storePassword props<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;signing.password&#x27;</span>]</span><br>    &#125;<br><br>    debug &#123;<br>        keyAlias props<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;signing.jjdxm_alias&#x27;</span>]</span><br>        keyPassword props<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;signing.jjdxm_password&#x27;</span>]</span><br>        storeFile <span class="hljs-built_in">file</span>(rootProject<span class="hljs-selector-class">.file</span>(<span class="hljs-string">&quot;debug.keystore&quot;</span>))<br>        storePassword props<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;signing.jjdxm_password&#x27;</span>]</span><br>    &#125;<br>&#125;<br>buildTypes &#123;<br>    debug &#123;<br>        signingConfig signingConfigs<span class="hljs-selector-class">.debug</span><br>        minifyEnabled false<br>        proguardFiles <span class="hljs-built_in">getDefaultProguardFile</span>(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>    &#125;<br><br>    release &#123;<br>        signingConfig signingConfigs<span class="hljs-selector-class">.release</span><br>        minifyEnabled false<br>        proguardFiles <span class="hljs-built_in">getDefaultProguardFile</span>(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行不同的接口环境的apk"><a href="#运行不同的接口环境的apk" class="headerlink" title="运行不同的接口环境的apk"></a>运行不同的接口环境的apk</h4><p>项目可以通过定义多个不同的productFlavors来实现应用的不同定制版本，每一个Flavor与buildTypes配合产出对应的一种输出类型的apk文件，新建的项目初始化只有一个默认的Flavor：defaultConfig</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">productFlavors</span> &#123;<br>     <span class="hljs-comment">//接口正式环境还是测试环境</span><br>     <span class="hljs-keyword">env_public</span> &#123;<br>         buildConfigField <span class="hljs-string">&quot;boolean&quot;</span>, <span class="hljs-string">&quot;isTestEnv&quot;</span>, <span class="hljs-string">&quot;false&quot;</span><br>     &#125;<br>    <br>     <span class="hljs-keyword">env_test</span> &#123;<br>         buildConfigField <span class="hljs-string">&quot;boolean&quot;</span>, <span class="hljs-string">&quot;isTestEnv&quot;</span>, <span class="hljs-string">&quot;true&quot;</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>跟buildTypes结合就有四种Build Variants（构建变种）。可以不修改代码直接运行相应的apk<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8A%80%E5%B7%A7%E5%92%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.resources/2023/09/18/09-56-56-73e3d4185fccb7569b32ea9eb4fd0a34-8b9f9a3f-7382-4781-a829-cf0294777d38-c80968.png" alt="8b9f9a3f-7382-4781-a829-cf0294777d38"></p><p>会自动运行到BuildConfig里，可以判断不同的值去加载不同的接口环境</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否测试环境</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isTest</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> BuildConfig.isTestEnv;<br>    &#125;<br><br>ServiceInfoManager.<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">setEnv</span>(IqbConfig.<span class="hljs-built_in">isTest</span>() ? ServiceInfoManager.Environment.TestEnv : ServiceInfoManager.Environment.PublicEnv);<br></code></pre></td></tr></table></figure><h4 id="为什么-BuildConfig-DEBUG-始终为-false"><a href="#为什么-BuildConfig-DEBUG-始终为-false" class="headerlink" title="为什么 BuildConfig.DEBUG 始终为 false"></a>为什么 BuildConfig.DEBUG 始终为 false</h4><ul><li>BuildConfig.java 是编译时自动生成的，并且每个 Module 都会生成一份，以该 Module 的 packageName 为 BuildConfig.java 的 packageName。所以如果你的应用有多个 Module 就会有多个 BuildConfig.java 生成，编译时被依赖的 Module 默认会提供 Release 版给其他 Module 或工程使用，这就导致该 BuildConfig.DEBUG 会始终为 false。</li><li>AndroidManifest.xml 中 application 节点的 android:debuggable 值是不同的。Debug 包值为 true，Release 包值为 false，这是编译自动修改的。可以通过 ApplicationInfo 的这个属性去判断是否是 Debug 版本。</li></ul><p><a href="http://www.trinea.cn/android/android-whether-debug-mode-why-buildconfig-debug-always-false/">http://www.trinea.cn/android/android-whether-debug-mode-why-buildconfig-debug-always-false/</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppUtils</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Boolean</span> isDebug = <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isDebug</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> isDebug == <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : isDebug.<span class="hljs-title function_">booleanValue</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">syncIsDebug</span>(<span class="hljs-params">Context context</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isDebug == <span class="hljs-literal">null</span>) &#123;<br>            isDebug = context.<span class="hljs-title function_">getApplicationInfo</span>() != <span class="hljs-literal">null</span> &amp;&amp;<br>                    (context.<span class="hljs-title function_">getApplicationInfo</span>().<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ApplicationInfo</span>.<span class="hljs-property">FLAG_DEBUGGABLE</span>) != <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在自己的 Application 内调用进行初始化</span><br><span class="hljs-title class_">AppUtils</span>.<span class="hljs-title function_">syncIsDebug</span>(<span class="hljs-title function_">getApplicationContext</span>());<br></code></pre></td></tr></table></figure><h4 id="找不到so新建jniLibs，将so放进来"><a href="#找不到so新建jniLibs，将so放进来" class="headerlink" title="找不到so新建jniLibs，将so放进来"></a>找不到so新建jniLibs，将so放进来</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>sourceSets &#123;<br>    <span class="hljs-selector-tag">main</span> &#123;<br>        jniLibs<span class="hljs-selector-class">.srcDir</span> <span class="hljs-string">&#x27;jniLibs&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置gradle离线工作"><a href="#配置gradle离线工作" class="headerlink" title="配置gradle离线工作"></a>配置gradle离线工作</h4><p>在gradle中引用第三方模块时采用maven方式依赖，每次打开Android Studio或者点击sync按钮时，都会去maven中央仓库去取第三方的库文件,一般是jar或者aar文件。如果下载完可以配置gradle离线工作 ，勾选gradle会使得速度更快，但同时存在一个问题，如果需要从网上加载第三方库，会无法下载，所以酌情使用。所以需要没有的第三方模块记得把这个关了。<br>external libraries下的库在C:\Users\用户名.gradle\caches\modules-2\files-2.1下，或者右击某个库下面的某个类，点击file path就可以查</p><h4 id="在-debug-模式下产生-release-版本"><a href="#在-debug-模式下产生-release-版本" class="headerlink" title="在 debug 模式下产生 release 版本"></a>在 debug 模式下产生 release 版本</h4><p>有时候调试SDK必须要用release版本，例如地图、登录，但是每次打包混淆太麻烦，在debug模式下产生release版本</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">//配置keystore签名</span><br><span class="hljs-keyword">signingConfigs</span> &#123;<br>        <span class="hljs-keyword">release</span> &#123;<br>            storeFile file(<span class="hljs-string">&quot;KeyStore&quot;</span>)<br>            storePassword <span class="hljs-string">&quot;98765432&quot;</span><br>            keyAlias <span class="hljs-string">&quot;lyly&quot;</span><br>            keyPassword <span class="hljs-string">&quot;98765432&quot;</span><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">appbuildTypes</span> &#123;<br>        <span class="hljs-keyword">debug</span> &#123;<br>            signingConfig signingConfigs.release<br>        &#125;<br>        <span class="hljs-keyword">release</span> &#123;<br>            signingConfig signingConfigs.release<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这样编译出来的debug版本直接用的是正式签名。</p><h4 id="依赖包重复的问题"><a href="#依赖包重复的问题" class="headerlink" title="依赖包重复的问题"></a>依赖包重复的问题</h4><p>遇到这样的一个错误：com.android.dex.DexException: Multiple dex files define XXXX，一般情况下，是我们项目中引用了重复的库或者jar包引起的，我们找到去掉即可解决<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8A%80%E5%B7%A7%E5%92%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.resources/2023/09/18/09-56-56-d72e8a58eda66c518538854c09bbe580-294fb60f-e597-4a1e-b8e6-cf4dc8572c56-484cd4.jpg" alt="294fb60f-e597-4a1e-b8e6-cf4dc8572c56"></p><p>com.loonggg.saoyisao.lib:1.1.0 这个依赖里引用了第三方zxing。com.timmy.qrcode.lib:1.4.1这个依赖里也引用了zxing这个库，在com.timmy.qrcode.lib:1.4.1的依赖里添加语句 exclude group: ‘com.google.zxing’，意思是编译的时候将group为com.google.zxing的所有library都去除在外，这样com.timmy.qrcode.lib:1.4.1就会自动去引用com.loonggg.saoyisao.lib:1.1.0项目里的zxing依赖了。这样问题就解决了。</p><h4 id="过滤日志"><a href="#过滤日志" class="headerlink" title="过滤日志"></a>过滤日志</h4><p>^(?!.* (你要过滤掉的tag)).* $<br>^(?!.* (UserConnection|BroadcastConnection)).*<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Gradle%E6%8A%80%E5%B7%A7%E5%92%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.resources/2023/09/18/09-56-56-a7b45ea4fd4d347ee2da6a037096820c-logcat-644803.png" alt="logcat"></p><h4 id="判断不同机型-Rom"><a href="#判断不同机型-Rom" class="headerlink" title="判断不同机型 Rom"></a>判断不同机型 Rom</h4><p>根据Build.BRAND 字段判断不同机型Rom</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rom</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Rom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//no instance</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是Oppo</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> IS_OPPO;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是Vivo</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> IS_VIVO;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是华为，注意不包括华为荣耀</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> IS_HUAWEI;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是华为荣耀</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> IS_HUAWEI_HONOR;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是三星</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> IS_SAMSUNG;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是努比亚</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> IS_NUBIA;<br><br>    <span class="hljs-type">static</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> brand = Build.BRAND.<span class="hljs-built_in">toUpperCase</span>();<br><br>        IS_OPPO = brand.<span class="hljs-built_in">equalsIgnoreCase</span>(<span class="hljs-string">&quot;OPPO&quot;</span>);<br>        IS_VIVO = brand.<span class="hljs-built_in">equalsIgnoreCase</span>(<span class="hljs-string">&quot;VIVO&quot;</span>);<br>        IS_HUAWEI = brand.<span class="hljs-built_in">equalsIgnoreCase</span>(<span class="hljs-string">&quot;HUAWEI&quot;</span>);<br><br>        IS_HUAWEI_HONOR = brand.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;HONOR&quot;</span>);<br>        IS_SAMSUNG = brand.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;SAMSUNG&quot;</span>);<br><br>        IS_NUBIA = brand.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;NUBIA&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="isRunAlone"><a href="#isRunAlone" class="headerlink" title="isRunAlone"></a>isRunAlone</h4><p>通过在组件工程下的gradle.properties文件中设置一个isRunAlone的变量来区分不同的场景，在组件的build.gradle开头这样写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(isRunAlone.toBoolean()</span></span>)&#123;    <br>  apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<span class="hljs-keyword">else</span>&#123;  <br>  apply plugin: <span class="hljs-string">&#x27;com.android.library&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>极客时间总结</title>
    <link href="/2025/12/cc65cff2c76d.html"/>
    <url>/2025/12/cc65cff2c76d.html</url>
    
    <content type="html"><![CDATA[<h1 id="极客时间总结"><a href="#极客时间总结" class="headerlink" title="极客时间总结"></a>极客时间总结</h1><p>学到的知识：</p><ol><li>Bitmap都在Java堆内存，经常会oom，8.0以后有个硬件位图 Hardware Bitmap，它可以减少图片内存并提升绘制效率。像素数据放到 Native 内存中的。最大的 Java 堆限制也才到 512MB，可能我的物理内存还有 5GB</li></ol><ul><li>SharedPreferences跨进程会导致数据丢失</li><li>网络数据压缩，有个库压缩比默认gzip算法更厉害，节约大量的带宽成本</li><li>xml x2c</li><li>异步的textview。，把 measure 和 layout 都放到了后台线程，只留下了必须要在主线程完成的 draw，这大大降低了 UI 线程的负载。</li><li>谷歌有个 Protocol Buffers，比json数据更小，是二进制格式</li><li>一个 100MB 的文件裁剪后一般只剩下 30MB 左右，使用 7zip 压缩最后小于 10MB，增加了文件上传的成功率。</li></ul><p><a href="https://time.geekbang.org/column/intro/142">Android开发高手课</a></p><p><strong>内存优化</strong></p><p>Android 3.0～Android 7.0 将 Bitmap 对象和像素数据统一放到 Java 堆中，这样就算我们不调用 recycle，Bitmap 内存也会随着对象一起被回收。不过 Bitmap 是内存消耗的大户，把它的内存放到 Java 堆中似乎不是那么美妙。即使是最新的华为 Mate 20，最大的 Java 堆限制也才到 512MB，可能我的物理内存还有 5GB，但是应用还是会因为 Java 堆内存不足导致 OOM。Bitmap 放到 Java 堆的另外一个问题会引起大量的 GC，对系统内存也没有完全利用起来。</p><p>将 Bitmap 内存放到 Native 中，也可以做到和对象一起快速释放，同时 GC 的时候也能考虑这些内存防止被滥用。NativeAllocationRegistry 可以一次满足你这三个要求，Android 8.0 正是使用这个辅助回收 Native 内存的机制，来实现像素数据放到 Native 内存中。Android 8.0 还新增了硬件位图 Hardware Bitmap，它可以减少图片内存并提升绘制效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 步骤一：申请一张空的 Native Bitmap</span><br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">nativeBitmap</span> <span class="hljs-operator">=</span> nativeCreateBitmap(dstWidth, dstHeight, nativeConfig, <span class="hljs-number">22</span>);<br><br><span class="hljs-comment">// 步骤二：申请一张普通的 Java Bitmap</span><br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">srcBitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeResource(res, id);<br><br><span class="hljs-comment">// 步骤三：使用 Java Bitmap 将内容绘制到 Native Bitmap 中</span><br>mNativeCanvas.setBitmap(nativeBitmap);<br>mNativeCanvas.drawBitmap(srcBitmap, mSrcRect, mDstRect, mPaint);<br><br><span class="hljs-comment">// 步骤四：释放 Java Bitmap 内存</span><br>srcBitmap.recycle();<br>srcBitmap = <span class="hljs-literal">null</span>；<br><br></code></pre></td></tr></table></figure><p>Protocol Buffers</p><p>文件遍历在 API level 26 之后建议使用FileVisitor，替代 ListFiles，整体的性能会好很多。</p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93.resources/2023/09/15/18-23-45-ec4efbcad6a976425731ebcfdf4917ef-ec4efbcad6a976425731ebcfdf4917ef-96ab24.png" alt="ec4efbcad6a976425731ebcfdf4917ef"><br>Mars的好处就是跨平台、长链接，看情况</p><p>网络数据压缩<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93.resources/2023/09/15/18-23-45-5c68b454db0f7c4d86c74a29dda2ac6f-QQ%E6%88%AA%E5%9B%BE20190509231931-679456.png" alt="QQ截图20190509231931"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93.resources/2023/09/15/18-23-45-ceec93b272ef5c9a3087144536a51659-QQ%E6%88%AA%E5%9B%BE20190509231800-6a063d.png" alt="QQ截图20190509231800"></p><p><strong>电量</strong></p><p>Android 是基于 Linux 内核，而 Linux 大部分使用在服务器中，它对功耗并没有做非常严格苛刻的优化。特别是国内会有各种各样的“保活黑科技”，大量的应用在后台活动简直就是“电量黑洞”。</p><p>耗电量这块， 因为要维持推送的实时到达， 只能追求黑科技， 要不然人家就会问，为啥苹果可以收到推送，android就不行~ 但是保活就会加大耗电</p><p>耗电优化的第一个方向是优化应用的后台耗电。因为用户最容易感知这个，我明明没有怎么打开，为什么耗这么多？在后台不要做这些：长时间获取 WakeLock(及时释放)、WiFi 和蓝牙的扫描、GPS、video、audio</p><blockquote><p>WakeLock 用来阻止 CPU、屏幕甚至是键盘的休眠。类似 Alarm、JobService 也会申请 WakeLock 来完成后台 CPU 操作.<br>Alarm 用来做一些定时的重复任务</p></blockquote><p>通过 Hook，我们可以在申请资源的时候将堆栈信息保存起来。当我们触发某个规则上报问题的时候，可以将收集到的堆栈信息、电池是否充电、CPU 信息、应用前后台时间等辅助信息也一起带上。</p><p><strong>UI优化</strong></p><p>对于硬件绘制，我们通过调用 OpenGL ES 接口利用 GPU 完成绘制。opengl是一个跨平台的图形 API，它为 2D&#x2F;3D 图形处理硬件指定了标准软件接口。而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。</p><p>使用 XML 进行 UI 编写可以说是十分方便，可以在 Android Studio 中实时预览到界面。如果我们要对一个界面进行极致优化，就可以使用代码进行编写界面。</p><p>xml缺点<br>读取xml很耗时<br>递归解析xml较耗时<br>反射生成对象的耗时是new的3倍以上</p><p><a href="https://github.com/iReaderAndroid/X2C/blob/master/README_CN.md">x2c：在编译的时候，通过注解的方式，将xml转换成Java代码</a></p><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93.resources/2023/09/15/18-23-45-9ecf73e145aa5fc20be0a8b8079a8e01-QQ%E6%88%AA%E5%9B%BE20190511135645-de5438.png" alt="QQ截图20190511135645"></p><p>measure&#x2F;layout 优化</p><ul><li>减少布局的嵌套（viewstub、merge、include）</li><li>尽量不使用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大。这里我推荐使用 ConstraintLayout （约束布局，只有一个层级）替代 RelativeLayout 或者 weighted LinearLayout。</li><li>减少多余的background</li><li>PrecomputedText（研究下），异步的textview。<br>  Litho （研究下）如我前面提到的 PrecomputedText 一样，把 measure 和 layout 都放到了后台线程，只留下了必须要在主线程完成的 draw，这大大降低了 UI 线程的负载。<br>  如果你没有计划完全迁移到 Litho，我建议可以优先使用 Litho 中的 RecyclerCollectionComponent 和 Sections 来优化自己的 RecyelerView 的性能。</li></ul><p><strong>h5优化</strong></p><p>分为前端优化和本地优化<br>前端优化：看看ssr<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93.resources/2023/09/15/18-23-45-eb35420f98c472de0731046974001d02-QQ%E6%88%AA%E5%9B%BE20190512234706-95c58f.png" alt="QQ截图20190512234706"></p><p>本地：</p><ul><li>webview预创建。提前创建和初始化 WebView，以及实现 WebView 的复用，这块大约可以节省 100～200 毫秒。</li><li>缓存。提前把网页需要的资源请求下来。</li></ul><p>React Native 和 Weex 性能差。 JS 是解释性的动态语言，它的执行效率相比 AOT 编译后的 Java，性能依然会在几倍以上的差距。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>断点技巧</title>
    <link href="/2025/12/bbd7df3b8a30.html"/>
    <url>/2025/12/bbd7df3b8a30.html</url>
    
    <content type="html"><![CDATA[<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>循环中经常用到这个技巧，比如：遍历1个大List的过程中，想让断点停在某个特定值。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-09-15-38-bf15665c4a4e7d375c12b189fc70ba1f-20231109153806-50aa9c.png" alt="image.png"></p><h2 id="回到”上一步”"><a href="#回到”上一步”" class="headerlink" title="回到”上一步”"></a>回到”上一步”</h2><p>Drop Frame：JVM内部以栈帧为单位保存线程的运行状态，drop frame即扔掉当前运行的栈帧，这样当前“指针”的位置，就自然到了上一帧的位置。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-09-15-39-1cd8a64382e46e20aa4fb331b89b2000-20231109153914-74a128.png" alt="image.png"></p><h2 id="临时执行表达式-修改变量的运行值"><a href="#临时执行表达式-修改变量的运行值" class="headerlink" title="临时执行表达式&#x2F;修改变量的运行值"></a>临时执行表达式&#x2F;修改变量的运行值</h2><p>调试时，可以临时执行一些表达式，参考下图：点击这二个图标中的任何1个都可以<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-09-15-42-1c72b9b06d14b4a7100def3b12a342bc-20231109154243-c95de8.png" alt="image.png"></p><p>如果调试时，想动态修改变量的值，也很容易，在变量上右击，然后选择Set Value，剩下的事，地球人都知道。<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-09-15-43-7b91a75e061e8b605bcadef56785825c-20231109154312-c2a456.png" alt="image.png"></p><h2 id="方法断点"><a href="#方法断点" class="headerlink" title="方法断点"></a>方法断点</h2><p>通常我们会对方法里的代码添加断点调试，很少对方法本身调试。其实，如果只是为了看到方法的参数和返回结果，我们可以在定义方法的第一行打断点，直接对方法本身调试，此时断点的展示图标样式也会与众不同：<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/picgo/picgo-clipboard-images/2023-11-09-15-45-b18c3a6d41edca6abf68d8d8f0b62c10-20231109154505-e0d008.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Rxjava</title>
    <link href="/2025/12/5ee9edc8d405.html"/>
    <url>/2025/12/5ee9edc8d405.html</url>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://blog.csdn.net/TellH/article/details/71534704">揭秘RxJava的实现原理</a><br>RxJava是响应式编程，基于观察者模式，事件流将从上往下，从订阅源传递到观察者。<br>Rx框架的优点，它可以避免回调嵌套，更优雅地切换线程实现异步处理数据。配合一些操作符，可以让处理事件流的代码更加简洁，逻辑更加清晰。</p><p>Subscriber（观察者、订阅者） 和 Observable（订阅<strong>源</strong>，被观察者） 显著的；觉察得到的；看得见的<br>subscribeOn 用于指定被观察者（Observable）执行的线程环境，只能指定一次，多次指定以第一次为准<br>observeOn 用于指定观察者（Subscriber）执行的线程环境，每次指定完都在下一步生效。<br><strong>正好相反</strong></p><p>每个 Observable 里面有一个 OnSubscribe 对象，只有一个方法（void call(Subscriber&lt;? super T&gt; subscriber);），用来产生数据流，这是典型的命令模式。<br>Flowable，retrofit返回。</p><p><strong>原理</strong><br>RxJava是响应式编程，基于观察者模式，事件流将从上往下，从订阅源传递到观察者，源码思路就是写个接口（OnSubscribe的call），然后在数据源里调用这个接口的方法。订阅者去监听这个接口的回调。<br>每调用一次操作符的方法，就相当于在上层数据源和下层观察者之间桥接了一个新的Observable。他去传给下面的订阅者数据<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Rxjava.resources/2023/09/15/17-54-30-db3229cab38c995a35621dd903959946-unknown_filename-2b6d14.png" alt="unknown_filename"></p><p><strong>Scheduler（调度器）</strong><br>调用的 Executors 的线程池，请求完数据通过handler设置到主线程。<br>SchedulerPoolFactory</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> ScheduledExecutorService <span class="hljs-title">create</span><span class="hljs-params">(ThreadFactory factory)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ScheduledExecutorService exec = Executors.<span class="hljs-built_in">newScheduledThreadPool</span>(<span class="hljs-number">1</span>, factory);<br>        <span class="hljs-built_in">tryPutIntoPool</span>(PURGE_ENABLED, exec);<br>        <span class="hljs-keyword">return</span> exec;<br>    &#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-built_in">Scheduler</span> <span class="hljs-title">mainThread</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">getInstance</span>().mainThreadScheduler; &#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>自动取消</strong><br>AutoDispose<br>.<code>as</code>(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(this)))<br>在Activity销毁时自己onDispose<br>不需要Disposable</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> &#123;<br>    <br>  <span class="hljs-keyword">var</span> mDisposable: Disposable? = <span class="hljs-literal">null</span><br>    <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">var</span> disposable = Observable.subscribeWith(aObserver)<br>      mDisposable?.add(disposable)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>      mDisposable?.dispose()<br>  &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Rxjava.resources/2023/09/15/17-54-30-181200cab7782c883ddeacc28b03eed1-rxjava-8cf75c.png" alt="rxjava"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理数组集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">just</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">//        Observable observable=Observable.just(&quot;一二三四五&quot;,&quot;上山打老虎&quot;,&quot;老虎一发威&quot;,&quot;武松就发怵&quot;);</span><br>        <span class="hljs-title class_">Integer</span>[] items1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-title class_">Integer</span>[] items2 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>&#125;;<br>        <span class="hljs-title class_">Observable</span> observable = <span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">just</span>(items1, items2);<span class="hljs-comment">//俩个数组变成一个了</span><br>        observable.<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Subscriber</span>&lt;<span class="hljs-title class_">Integer</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onCompleted</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">i</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">&quot;onCompleted&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) &#123;<br>                <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">i</span>(<span class="hljs-variable constant_">TAG</span>, e.<span class="hljs-title function_">getMessage</span>());<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params">Integer[] o</span>) &#123;<br>                <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;o.<span class="hljs-property">length</span>;i++)&#123;<br>                    <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">i</span>(<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">&quot;next:&quot;</span>+o[i]);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>Subscriber 对 Observer 接口进行了一些扩展， Subscriber 有 onStart()（ 事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置 ）、可以返回一个Subscription，取消订阅unsubscribe()</p></li><li><p>创建被观察者create，from(数组)，just（不变参数&#x2F;俩个数组合并）等</p></li><li><p>创建观察者：new Subscriber ()，也可以new Action()（相当于onnext）rxjava2是 Consumer（肯书妹儿，消费者 ），最后的简化</p></li></ul><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="map和flatmap"><a href="#map和flatmap" class="headerlink" title="map和flatmap"></a>map和flatmap</h4><p><strong>map</strong><br>对集合或数据进行转化；<br>map只能单一转换，单一只的是只能一对一进行转换，指一个对象可以转化为另一个对象但是不能转换成对象数组（map返回结果集不能直接使用from&#x2F;just再次进行事件分发，一旦转换成对象数组的话，再处理集合&#x2F;数组的结果时需要利用for一一遍历取出（看下面例子），而使用RxJava就是为了剔除这样的嵌套结构，使得整体的逻辑性更强。）</p><p><strong>flatmap</strong><br>适用于嵌套结构(list,数组)<br>可以单一转换也可以一对多&#x2F;多对多转换，<strong>flatmap 要求返回 Observable</strong>，因此可以再内部进行from&#x2F;just的再次事件分发，一一取出单一对象（转换对象的能力不同）</p><p><strong>举例说明</strong><br>一个Student类中只有一个name，而一个Student却有多门课程（Course）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">List</span>&lt;<span class="hljs-type">Student</span>&gt; students <span class="hljs-operator">=</span> new <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">Student</span>&gt;();<br>students.add<span class="hljs-operator">...</span><br><span class="hljs-operator">...</span><br>    <br><span class="hljs-type">Action1</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Course</span>&gt;&gt; action1 <span class="hljs-operator">=</span> new <span class="hljs-type">Action1</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Course</span>&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void call(<span class="hljs-type">List</span>&lt;<span class="hljs-type">Course</span>&gt; courses) &#123;<br>        <span class="hljs-comment">//遍历courses，输出cuouses的name</span><br>         <span class="hljs-keyword">for</span> (int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> courses.size(); i<span class="hljs-operator">++</span>)&#123;<br>            <span class="hljs-type">Log</span>.i(<span class="hljs-type">TAG</span>, courses.get(i).getName());<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-type">Observable</span>.from(students)<br>        .map(new <span class="hljs-type">Func1</span>&lt;<span class="hljs-type">Student</span>, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Course</span>&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">Course</span>&gt; call(<span class="hljs-type">Student</span> student) &#123;<br>                <span class="hljs-comment">//返回coursesList</span><br>                <span class="hljs-keyword">return</span> student.getCoursesList();<br>            &#125;<br>        &#125;)<br>        .subscribe(action1);<br></code></pre></td></tr></table></figure><p>使用flatMap</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>students.<span class="hljs-keyword">add</span>...<br>...<br>    <br>Observable.<span class="hljs-keyword">from</span>(students)<br>        .flatMap(<span class="hljs-keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">Course</span>&gt; <span class="hljs-title">call</span>(<span class="hljs-params">Student student</span>)</span> &#123;<br>                <span class="hljs-keyword">return</span> Observable.<span class="hljs-keyword">from</span>(student.getCoursesList());<br>            &#125;<br>        &#125;)<br>        .subscribe(<span class="hljs-keyword">new</span> Action1&lt;Course&gt;() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(<span class="hljs-params">Course course</span>)</span> &#123;<br>                Log.i(TAG, course.getName());<br>            &#125;<br>        &#125;);<br>    <br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>merge：合并俩个任务；<br>filter:对集合或数据进行过滤；<br>toSortedList() :为事件中的数据排序<br>interval(1, TimeUnit.SECONDS) 创建一个每隔一秒发送一次事件的对象<br>timestamp() :为每个事件加上一个时间戳<br>take：取出集合中的前几个<br>skip：跳过前几个元素<br>each：遍历集合</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">       Observable.from(integers)<br>                    .filter(<span class="hljs-literal">new</span> Func1&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Boolean</span>&gt;() &#123;<br>                        <span class="hljs-comment">//泛型第一个是传入的参数，第二个是返回的参数</span><br>                        @Override<br>                        <span class="hljs-keyword">public</span> <span class="hljs-built_in">Boolean</span> call(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>;<br>                        &#125;   <br>                    <span class="hljs-comment">//取前四个,从1开始</span><br>                    .<span class="hljs-keyword">take</span>(<span class="hljs-number">4</span>)<br>                    <span class="hljs-comment">//取前四个中的后两个</span><br>                    .takeLast(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>concat操作符处理多数据源<br>concat会三个数据源都会请求的。如何使得哪层有数据就用哪层的，之后就不走后面的逻辑了。 <br>可以配合first()操作符来实现这样的效果。例如 对缓存进行检查，如：内存缓存、本地缓存、网络，哪一层有数据立即返回。<br>注意：Observable.concat只接受相同泛型的参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">concat</span>(memorySource, diskSource, networkSource)<br>                        .<span class="hljs-title function_">first</span>()<br>                        .<span class="hljs-title function_">observeOn</span>(<span class="hljs-title class_">AndroidSchedulers</span>.<span class="hljs-title function_">mainThread</span>())<br>                        .<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Action1</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">call</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>                                <span class="hljs-title function_">printLog</span>(tvLogs, <span class="hljs-string">&quot;Getting data from &quot;</span>, s);<br>                            &#125;<br>                        &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Action1</span>&lt;<span class="hljs-title class_">Throwable</span>&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">Throwable throwable</span>) &#123;<br>                                throwable.<span class="hljs-title function_">printStackTrace</span>();<br>                                <span class="hljs-title function_">printLog</span>(tvLogs, <span class="hljs-string">&quot;Error: &quot;</span>, throwable.<span class="hljs-title function_">getMessage</span>());<br>                            &#125;<br>                        &#125;);<br></code></pre></td></tr></table></figure><p><strong>compose</strong><br>减少一些相同的操作</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.subscribeOn</span>(Schedulers<span class="hljs-selector-class">.io</span>())<br><span class="hljs-selector-class">.observeOn</span>(AndroidSchedulers<span class="hljs-selector-class">.mainThread</span>())<br><span class="hljs-selector-class">.subscribe</span>(consumer)<br></code></pre></td></tr></table></figure><p><strong>zip 操作符</strong><br>可以将多个 Observable （多个网络请求）的数据结合为一个数据源再发射出去。</p><p><strong>flatMap 和 concatMap</strong></p><ul><li>concatMap是有序的，flatMap是无序的，concatMap最终输出的顺序与原序列保持一致，而flatMap则不一定，有可能出现交错。</li><li>concatMap和flatMap的功能是一样的， 将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据放进一个单独的Observable。只不过最后合并Observables flatMap采用的merge，而concatMap采用的是连接(concat)。</li><li>flatMap一般用来链式调用接口，请求完一个接口又请求另一个接口</li></ul><p><strong>subscribe和subscribeWith</strong><br>一般subscribeWith用到使用Rx请求接口的这种情况,订阅后把请求参数返回回去,可以添加到CompositeDisposable中方便绑定Activity生命周期取消<br>subscribe返回值是void所以在请求接口时，最好还是使用subscribeWith,添加订阅关系更方便了</p><p><strong>single没有继续</strong></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>Schedulers.newThread() 代表一个常规的新线程；通过内部的 Handler 把任务放到主线程去做。</li><li>AndroidSchedulers.mainThread() 代表Android的主线程</li><li>Schedulers.io(): I&#x2F;O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li><li>Schedulers.computation(): 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用</li><li>Schedulers.io())；默认线程数等于处理器的数量</li></ul><p>比如传统的创建线程：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// TODO &#125; &#125;).start();</span><br></code></pre></td></tr></table></figure><p>在RxJava中，我们可以这样实现，这样的好处是我们可以直接使用RxJava的线程调度逻辑。还可以在合适的时机终止线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Scheduler.<span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> Schedulers.io().createWorker();<br>worker.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Action0</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br>&#125;);<br>worker.unsubscribe();<br></code></pre></td></tr></table></figure><p>还有个好处是更容易的实现延迟执行和周期执行：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 延迟</span><br><span class="hljs-selector-tag">Schedulers</span><span class="hljs-selector-class">.computation</span>()<span class="hljs-selector-class">.createWorker</span>()<span class="hljs-selector-class">.schedule</span>(new <span class="hljs-built_in">Action0</span>() &#123;<br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">call</span>() &#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;&#125;, <span class="hljs-number">500</span>, TimeUnit.MILLISECONDS);<br><br><br><span class="hljs-comment">// 周期</span><br><span class="hljs-selector-tag">Schedulers</span><span class="hljs-selector-class">.computation</span>()<span class="hljs-selector-class">.createWorker</span>()<span class="hljs-selector-class">.schedulePeriodically</span>(new <span class="hljs-built_in">Action0</span>() &#123;<br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">call</span>() &#123;<br>        <span class="hljs-comment">// TODO</span><br>    &#125;&#125;, <span class="hljs-number">500</span>, <span class="hljs-number">250</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><h3 id="处理Activity的生命周期"><a href="#处理Activity的生命周期" class="headerlink" title="处理Activity的生命周期"></a>处理Activity的生命周期</h3><p>1.在configuration改变（比如转屏）之后继续之前的Subscription。<br>比如你使用Retrofit发出了一个REST请求，接着想在listview中展示结果。如果在网络请求的时候用户旋转了屏幕怎么办？你当然想继续刚才的请求，但是怎么搞？<br>2.Observable持有Context导致的内存泄露<br>这个问题是因为创建subscription的时候，以某种方式持有了context的引用，尤其是当你和view交互的时候，这太容易发生！如果Observable没有及时结束，内存占用就会越来越大。<br>解决方案<br>在生命周期的某个时刻取消订阅。一个很常见的模式就是使用 CompositeDisposable 来持有所有的Subscriptions，然后在onDestroy()或者onDestroyView()里取消所有的订阅。mDisposable.dispose();</p><h3 id="真实项目运用"><a href="#真实项目运用" class="headerlink" title="真实项目运用"></a>真实项目运用</h3><p>链式调用，就不用调完一个回调再调另一个这样子了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript">      <span class="hljs-title class_">Subscription</span> subscription = <span class="hljs-title class_">LoginNetManager</span>.<span class="hljs-title function_">getIP</span>()<br>                    .<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Func1</span>&lt;<span class="hljs-title class_">RspIqbDefault</span>&lt;<span class="hljs-title class_">IPModel</span>&gt;, <span class="hljs-title class_">Boolean</span>&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-title class_">Boolean</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">RspIqbDefault&lt;IPModel&gt; rsp</span>) &#123;<br>                            <span class="hljs-keyword">return</span> rsp != <span class="hljs-literal">null</span> &amp;&amp; rsp.<span class="hljs-property">isSuccess</span> &amp;&amp; rsp.<span class="hljs-title function_">getResultEntity</span>() != <span class="hljs-literal">null</span>;<br>                        &#125;<br>                    &#125;)<br>                    .<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Func1</span>&lt;<span class="hljs-title class_">RspIqbDefault</span>&lt;<span class="hljs-title class_">IPModel</span>&gt;, <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">RspIqbDefault</span>&lt;<span class="hljs-title class_">SmsCodeLoginModel</span>&gt;&gt;&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">RspIqbDefault</span>&lt;<span class="hljs-title class_">SmsCodeLoginModel</span>&gt;&gt; <span class="hljs-title function_">call</span>(<span class="hljs-params">RspIqbDefault&lt;IPModel&gt; rsp</span>) &#123;<br>                            <span class="hljs-title class_">IPModel</span> entity = rsp.<span class="hljs-title function_">getResultEntity</span>();<br>                            <span class="hljs-keyword">return</span> <span class="hljs-title class_">VerifySmsNetManager</span>.<span class="hljs-title function_">smsCodeLogin</span>(entity.<span class="hljs-property">ip</span>, code, phone_number, sms_id, action);<br>                        &#125;<br>                    &#125;)<br>                    .<span class="hljs-title function_">observeOn</span>(<span class="hljs-title class_">AndroidSchedulers</span>.<span class="hljs-title function_">mainThread</span>())<br>                    .<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Subscriber</span>&lt;<span class="hljs-title class_">RspIqbDefault</span>&lt;<span class="hljs-title class_">SmsCodeLoginModel</span>&gt;&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onCompleted</span>(<span class="hljs-params"></span>) &#123;<br>                        &#125;<br>    <br>    <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (mView != <span class="hljs-literal">null</span>) &#123;<br>                                mView.<span class="hljs-title function_">smsCodeLogin</span>(<span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>);<br>                            &#125;<br>                        &#125;<br>    <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params">RspIqbDefault&lt;SmsCodeLoginModel&gt; rsp</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (rsp != <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (mView != <span class="hljs-literal">null</span>) &#123;<br>                                    mView.<span class="hljs-title function_">smsCodeLogin</span>(rsp.<span class="hljs-title function_">getResultEntity</span>(), rsp.<span class="hljs-title function_">getErrorCode</span>(), rsp.<span class="hljs-title function_">getErrorMessage</span>());<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> (mView != <span class="hljs-literal">null</span>) &#123;<br>                                    mView.<span class="hljs-title function_">smsCodeLogin</span>(<span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>);<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>            compositeSubscription.<span class="hljs-title function_">add</span>(subscription);<br>    <br></code></pre></td></tr></table></figure><p><strong>RxBinding</strong><br>基于RxJava的对于Android原生组件的绑定，是RxJava风格的，相当于代替了OnClick,Listener这些东西</p><p><strong>doOnNext</strong><br>doOnNext()函数执行的地方跟subcribe()中的onNext()执行的地方没有必然联系。 doOnNext()的执行在onNext()之前，可以对数据进行相关处理。例如网络解析返回来的数据先进行处理。也可以直接代替Subscriber</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">   userInfoEntityObservable.doOnNext(<span class="hljs-built_in">new</span> Action1&lt;UserInfoEntity&gt;() &#123;<br>                    @Override<br>                    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">call</span>(UserInfoEntity userInfoEntity) &#123;<br>                        PublicMessage publicMsg = <span class="hljs-built_in">new</span> PublicMessage(roomId);<br>                        EventBus.getDefault().post(event);<br>                    &#125;<br>                &#125;).subscribe();//doOnNext后面可以直接subscribe，不需要参数<br>//输出[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]中第三个和第四个奇数，take(i) 取前i个事件 takeLast(i) 取后i个事件 doOnNext(Action1) 每次观察者中的onNext调用之前调用，输出<span class="hljs-keyword">before</span> onNext（），<span class="hljs-number">5</span>，<span class="hljs-keyword">before</span> onNext（），<span class="hljs-number">7</span><br>Observable.<span class="hljs-keyword">from</span>(number<br>                .<span class="hljs-keyword">filter</span>(<span class="hljs-built_in">new</span> Func1&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Boolean</span>&gt;() &#123;<br>                    @Override<br>                    <span class="hljs-built_in">public</span> <span class="hljs-type">Boolean</span> <span class="hljs-keyword">call</span>(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;)<br>                //取前四个,从<span class="hljs-number">1</span>开始<br>                .take(<span class="hljs-number">4</span>)<br>                //取前四个中的后两个<br>                .takeLast(<span class="hljs-number">2</span>)<br>                .doOnNext(<span class="hljs-built_in">new</span> Action1&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>                    @Override<br>                    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">call</span>(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) &#123;<br>                        mText.append(&quot;before onNext（）\n&quot;);<br>                    &#125;<br>                &#125;)<br>                .subscribe(<span class="hljs-built_in">new</span> Action1&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>                    @Override<br>                    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">call</span>(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) &#123;<br>                        mText.append(&quot;onNext()---&gt;&quot; + <span class="hljs-type">integer</span> + &quot;\n&quot;);<br>                    &#125;<br>                &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><p>PublishSubject比较容易理解，相对比其他Subject常用，它的Observer只会接收到PublishSubject被订阅之后发送的数据。示例代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">PublishSubject</span> publishSubject = <span class="hljs-title class_">PublishSubject</span>.<span class="hljs-title function_">create</span>();<br>  publishSubject.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">&quot;publishSubject1&quot;</span>);<br>  publishSubject.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">&quot;publishSubject2&quot;</span>);<br>  publishSubject.<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onCompleted</span>(<span class="hljs-params"></span>) &#123;<br>          &#125;<br><br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) &#123;<br>          &#125;<br><br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>              <span class="hljs-title class_">LogUtil</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;publishSubject observer1:&quot;</span>+s);<br>          &#125;<br>      &#125;);<br>  publishSubject.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">&quot;publishSubject3&quot;</span>);<br>  publishSubject.<span class="hljs-title function_">onNext</span>(<span class="hljs-string">&quot;publishSubject4&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码，Observer只会接收到”behaviorSubject3”、”behaviorSubject4”。</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>将一个 Observable&#x2F;Flowable&#x2F;Single&#x2F;Completable&#x2F;Maybe 对象转换成另一个 Observable&#x2F;Flowable&#x2F;Single&#x2F;Completable&#x2F;Maybe 对象，和调用一系列的内联操作符是一模一样的。<br>举个简单的例子，写一个transformer()方法将一个发射整数的Observable转换为发射字符串的Observable。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;<span class="hljs-keyword">String</span>&gt; ObservableTransformer&lt;Integer, java.lang.<span class="hljs-keyword">String</span>&gt; transformer() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ObservableTransformer</span>&lt;Integer, java.lang.<span class="hljs-keyword">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ObservableSource&lt;java.lang.<span class="hljs-keyword">String</span>&gt; apply(<span class="hljs-meta">@NonNull Observable&lt;Integer&gt; upstream) &#123;</span><br>                <span class="hljs-keyword">return</span> upstream.map(<span class="hljs-keyword">new</span> <span class="hljs-type">Function</span>&lt;Integer, java.lang.<span class="hljs-keyword">String</span>&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> java.lang.<span class="hljs-keyword">String</span> apply(<span class="hljs-meta">@NonNull Integer integer) throws Exception &#123;</span><br>                        <span class="hljs-keyword">return</span> java.lang.<span class="hljs-keyword">String</span>.valueOf(integer);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>Observable.just(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>)<br>       .compose(transformer())<br>       .subscribe(<span class="hljs-keyword">new</span> <span class="hljs-type">Consumer</span>&lt;<span class="hljs-keyword">String</span>&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> void accept(<span class="hljs-meta">@io.reactivex.annotations.NonNull String s) throws Exception &#123;</span><br>                   System.out.println(<span class="hljs-string">&quot;s=&quot;</span>+s);<br>                    &#125;<br>                &#125;);<br></code></pre></td></tr></table></figure><p><strong>RxJava全局错误处理</strong><br>在RxJava中rx.pluginsRxJavaPlugins这个类是用来处理发生的错误的，在RxJava的源码中用RxJavaPlugins.getInstance().getErrorHandler().handleError(e);这句来处理错误，这个默认是没有对错误进行任何处理的，我们需要自己来实现这个，<br> RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() { @Override public void handleError(Throwable e) { &#x2F;&#x2F;在这里处理错误 } });</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Countly 日志</title>
    <link href="/2025/12/7db93f300422.html"/>
    <url>/2025/12/7db93f300422.html</url>
    
    <content type="html"><![CDATA[<p>结论先说：<br><strong>Countly 后台目前不支持：通过 “用户 ID + tag” 直接搜索 Log（recordLog）日志。</strong><br>但可以通过以下方式实现“间接查询”或“可检索日志结构”。</p><p>下面给你最清晰的说明👇</p><hr><h1 id="✅-Countly-官方能力总结"><a href="#✅-Countly-官方能力总结" class="headerlink" title="✅ Countly 官方能力总结"></a>✅ <strong>Countly 官方能力总结</strong></h1><table><thead><tr><th>能力</th><th>支持？</th><th>说明</th></tr></thead><tbody><tr><td>通过 <strong>用户 ID</strong> 查看事件 &#x2F; 会话</td><td>✔ 支持</td><td>在 <strong>User Profiles</strong> 页面可查看该用户的事件，但 <strong>不包含 recordLog 日志</strong></td></tr><tr><td>通过 <strong>用户 ID</strong> 查看日志（recordLog）</td><td>❌ 不支持</td><td>recordLog 不会出现在 User Profiles</td></tr><tr><td>按 <strong>tag 搜索日志</strong></td><td>❌ 不支持</td><td>Logs 插件没有搜索功能</td></tr><tr><td>查看所有日志</td><td>✔ 支持</td><td>Utilities → Incoming Data Logs</td></tr><tr><td>在日志中包含自定义字段（tag&#x2F;uid）</td><td>✔ 可以</td><td>你可以把 tag、uid 放到 JSON 里，日志会出现在 log 表中</td></tr></tbody></table><hr><h1 id="⭐-想做到-“按用户ID-tag-查日志”，推荐方案"><a href="#⭐-想做到-“按用户ID-tag-查日志”，推荐方案" class="headerlink" title="⭐ 想做到 “按用户ID + tag 查日志”，推荐方案"></a>⭐ 想做到 “按用户ID + tag 查日志”，推荐方案</h1><p>要实现这个功能你必须 <strong>自己在 recordLog 内容里加入 uid + tag</strong><br>然后到后台 <strong>Incoming Data Logs</strong> 按内容搜索。</p><hr><h1 id="📌-推荐的日志结构（Android-Kotlin）"><a href="#📌-推荐的日志结构（Android-Kotlin）" class="headerlink" title="📌 推荐的日志结构（Android Kotlin）"></a>📌 <strong>推荐的日志结构（Android Kotlin）</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> logObj = JSONObject().apply &#123;<br>    put(<span class="hljs-string">&quot;uid&quot;</span>, Countly.sharedInstance().deviceId)   <span class="hljs-comment">// 用户唯一标识</span><br>    put(<span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-string">&quot;NETWORK&quot;</span>)<br>    put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;调用登录接口失败&quot;</span>)<br>    put(<span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>)<br>&#125;<br><br>Countly.sharedInstance().recordLog(logObj)<br></code></pre></td></tr></table></figure><p>Countly 后台会收到类似内容（在 incoming data logs → logs{appId}）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;logs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;user_12345&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;tag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NETWORK&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;调用登录接口失败&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;error&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="🔍-怎么在后台查？（你问的关键）"><a href="#🔍-怎么在后台查？（你问的关键）" class="headerlink" title="🔍 怎么在后台查？（你问的关键）"></a>🔍 <strong>怎么在后台查？（你问的关键）</strong></h1><h2 id="方式-1：Incoming-Data-Logs（可搜索内容）"><a href="#方式-1：Incoming-Data-Logs（可搜索内容）" class="headerlink" title="方式 1：Incoming Data Logs（可搜索内容）"></a><strong>方式 1：Incoming Data Logs（可搜索内容）</strong></h2><p>路径：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Utilities</span> → Incoming <span class="hljs-meta">Data</span> Logs<br></code></pre></td></tr></table></figure><p>在这里你可以用页面的搜索框：</p><ul><li><p>输入用户 ID（如 <code>user_12345</code>）</p></li><li><p>输入 tag（如 <code>NETWORK</code>）</p></li></ul><p>即可找到包含这段内容的日志。</p><p>👉 _这是唯一能查到 recordLog 的地方_。</p><hr><h2 id="方式-2：直接查数据库（self-host-使用-MongoDB）"><a href="#方式-2：直接查数据库（self-host-使用-MongoDB）" class="headerlink" title="方式 2：直接查数据库（self-host 使用 MongoDB）"></a><strong>方式 2：直接查数据库（self-host 使用 MongoDB）</strong></h2><p>表名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">log_<span class="hljs-tag">&lt;<span class="hljs-name">appId</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你可以使用 Mongo 查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-property">log_XXXXXX</span>.<span class="hljs-title function_">find</span>(&#123;<br>  <span class="hljs-attr">logs</span>: &#123;<br>    <span class="hljs-attr">$elemMatch</span>: &#123;<br>      <span class="hljs-attr">uid</span>: <span class="hljs-string">&quot;user_12345&quot;</span>,<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;NETWORK&quot;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>即可查出所有匹配记录。</p><hr><h1 id="🎯-结论总结（最实用）"><a href="#🎯-结论总结（最实用）" class="headerlink" title="🎯 结论总结（最实用）"></a>🎯 结论总结（最实用）</h1><ul><li><p>Countly 不支持按用户 ID 或 tag 直接查 recordLog。</p></li><li><p>你 <strong>必须把 uid 和 tag 写进日志内容中</strong>。</p></li><li><p>然后到：</p><ul><li><p><strong>Incoming Data Logs</strong> 搜索内容（Cloud 和 Self-host 均可）</p></li><li><p>或用 MongoDB 查询（Self-host）</p></li></ul></li></ul><hr><p>如果你愿意，我可以帮你写一个：</p><h3 id="🔧-Android-Kotlin-CountlyLogger-工具类"><a href="#🔧-Android-Kotlin-CountlyLogger-工具类" class="headerlink" title="🔧 Android Kotlin CountlyLogger 工具类"></a>🔧 Android Kotlin CountlyLogger 工具类</h3><p>支持：</p><ul><li><p>自动加入用户 ID</p></li><li><p>自动加入 tag</p></li><li><p>自动加入等级（INFO、ERROR）</p></li><li><p>自动加入时间</p></li><li><p>可开关本地 Logcat 输出</p></li></ul><p>需要吗？</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android（二）</title>
    <link href="/2025/12/8a805a2fd5e9.html"/>
    <url>/2025/12/8a805a2fd5e9.html</url>
    
    <content type="html"><![CDATA[<h3 id="So-库架构选择"><a href="#So-库架构选择" class="headerlink" title="So 库架构选择"></a>So 库架构选择</h3><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-bdd37727b06e16d5b65e8b59b3726793-unknown_filename.3-dd8cc1.png" alt="unknown_filename.3"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-7993cd4f8311dd2e9f49cc48f4ade8e9-unknown_filename.4-edc322.png" alt="unknown_filename.4"><br> <em>连微信也只有：abiFilters “arm64-v8a”</em></p><p>arm64-v8a: 64位支持，目前主流的版本，虽然网上很多博客都说 v7是主流版本，但是我亲自试验了很多手机，都是 arm64-v8a 的架构，测试机型包括小米5-小米9，华为 P30，华为 mate10，魅蓝2等均是 v8架构查询手机 cpu 命令行</p><p><a href="https://segmentfault.com/a/1190000023517574">文章</a></p><p>结论：<em>用 arm64-v8a 处理速度快</em><br>250M 减到 88M</p><h3 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h3><p><a href="https://cs.android.com/">https://cs.android.com/</a><br><a href="http://androidxref.com/">http://androidxref.com/</a><br>带 stub 就是 class 文件，反编译的，看不了</p><h3 id="buildToolsVersion-和-TargetSdkVersion"><a href="#buildToolsVersion-和-TargetSdkVersion" class="headerlink" title="buildToolsVersion 和 TargetSdkVersion"></a>buildToolsVersion 和 TargetSdkVersion</h3><p>compileSdkVersion：应用程序编译时使用的 Android SDK 版本<br>minSdkVersion ：应用程序所支持的最低Android平台版本</p><p>targetSdkVersion 的作用：<em>应用的兼容模式</em>。它表明你的应用程序是<em>针对该版本进行开发和测试的</em>，并且遵循该版本的行为和特性。通过指定 <code>targetSdkVersion</code>，你向系统表明你的应用程序是为目标平台版本进行优化的，系统会根据该版本来确定应用程序的运行环境和默认行为，以提供最佳的兼容性和体验。</p><p>TargetSdkVersion 设为23那么是按6.0设置的（运行时权限），小于23是按6.0以前的方式</p><p>目前项目：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compileSdkVersion</span>: <span class="hljs-number">31</span>,  <br><span class="hljs-attribute">minSdkVersion</span> : <span class="hljs-number">21</span>,  <br><span class="hljs-attribute">targetSdkVersion</span> : <span class="hljs-number">31</span>,<br></code></pre></td></tr></table></figure><p>31：android12</p><h3 id="Android-6-0-23适配"><a href="#Android-6-0-23适配" class="headerlink" title="Android 6.0 23适配"></a>Android 6.0 23适配</h3><h4 id="使用FileProvider"><a href="#使用FileProvider" class="headerlink" title="使用FileProvider"></a>使用FileProvider</h4><p>存储的变化<br>Android 不再允许在 app 中把 file:&#x2F;&#x2F;Uri 暴露给其他 app，包括但不局限于通过 Intent 或 ClipData 等方法。</p><p>Uri photoOutputUri &#x3D; Uri.fromFile (photoOutputFile);<br>原因在于使用 &#x2F;file:&#x2F;&#x2F;Uri 会有一些风险，比如：文件是私有的，接收&#x2F;file:&#x2F;&#x2F;Uri 的 app 无法访问该文件。<br>在 Android6.0之后引入运行时权限，如果接收file:&#x2F;&#x2F;Uri的app没有申请READ_EXTERNAL_STORAGE权限，在读取文件时会引发崩溃。<br>因此，google 提供了 FileProvider，<em>使用它可以生成 content:&#x2F;&#x2F;Uri 来替代 file:&#x2F;&#x2F;Uri</em>。</p><p><a href="https://juejin.cn/post/6987569764407181349">聊一聊Android存储行为的变化</a></p><ol><li>在 res 目录下新建 xml 目录，在 xml 目录下新建 filepaths. xml 文件</li><li>在 AndroidManifest. xml 中申明：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;androidx.core.content.FileProvider&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.alexlu.androidstorage.fileProvider&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/filepaths&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用的时候注意与配置文件中注册的包名一致：</li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">context</span>.getExternalFilesDir(<span class="hljs-keyword">null</span>);<br>// val <span class="hljs-keyword">file</span> = <span class="hljs-keyword">File</span>(xxpath)<br>val uri = FileProvider.getUriForFile(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;com.alexlu.androidstorage.fileProvider&quot;</span>, <span class="hljs-keyword">file</span>);<br></code></pre></td></tr></table></figure><p>文件不能随便访问了，新增了 READ_MEDIA_IMAGES, READ_MEDIA_VIDEO, READ_MEDIA_AUDIO</p><h4 id="动态申请权限"><a href="#动态申请权限" class="headerlink" title="动态申请权限"></a>动态申请权限</h4><ol><li>在 android 6.0 Marshmallow 版本之后，系统不会在软件安装的时候就赋予该 app 所有其申请的权限，对于一些危险级别的权限，app 需要在运行时一个一个询问用户授予权限。</li><li>只有那些 targetSdkVersion 设置为23和23以上的应用才会出现异常，在使用危险权限的时候系统必须要获得用户的同意才能使用，要不然应用就会崩溃。</li><li>targetSdkVersion 如果没有设置为23版本或者以上，系统还是会使用旧规则：在安装的时候赋予该 app 所申请的所有权限。所以 app 当然可以和以前一样正常使用了，但是还有一点需要注意的是6.0的系统里面，用户可以手动将该 app 的权限关闭。</li><li>经试验：<em>点拒绝没有奔溃，不过点不在提示后就一直不提示，也打不开那个页面，所以需要动态申请引导去设置页打开系统架</em></li></ol><h3 id="Android-13-32适配"><a href="#Android-13-32适配" class="headerlink" title="Android 13  32适配"></a>Android 13  32适配</h3><p><a href="https://juejin.cn/post/7099762078977622053">Android 13 适配指南 - 掘金</a></p><h4 id="相册权限"><a href="#相册权限" class="headerlink" title="相册权限"></a>相册权限</h4><p><strong>通过申请新的<code>android.permission.READ_MEDIA_IMAGES</code> 权限，就可以用以前的代码继续访问到以前的相册信息</strong>，因为对于目标版本为 Android 13 的情况，现在 <code>READ_EXTERNAL_STORAGE</code>权限被细化了，开发者需要使用<code>READ_MEDIA_IMAGE</code>、<code>READ_MEDIA_VIDEO</code>、<code>READ_MEDIA_AUDIO</code> 来替代适配；</p><p>在申请完权限之后，就可以正常读取相册等信息；</p><p><strong>所以如果是 TargetSDK 在 Android 13 以下，不需要处理，如果在 Android 13 以及以上 ，需要增加申请权限</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_MEDIA_IMAGES&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_MEDIA_AUDIO&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_MEDIA_VIDEO&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p><strong>Android 13 里增加了通知的运行时权限</strong>，其中 Android 13 (33) 的通知会根据正在运行的应用程序的目标 API 级别进行不同的处理，<strong>不过不管应用程序的目标API级别如何，Android 13 都会提示用户授予应用程序发送通知的权限</strong>。</p><ul><li>如果是 TargetSDK 在 Android 12L (32) 以下，只要用户同意才能发送通知，一般是在应用启动的时候，比如用户点击了不允许，就无法发出通知，需要等到下次 App 再启动，才会再次询问，或者去设置通知中心打开；</li><li>如果是 TargetSDK 在 Android 13 (33) 以上，就一定需要手动添加 <code>android.permission.POST_NOTIFICATIONS</code> 和<em>代码调用申请，不然可能设置中心都无法打开</em>；</li></ul><h3 id="Android-虚拟机"><a href="#Android-虚拟机" class="headerlink" title="Android 虚拟机"></a>Android 虚拟机</h3><p>Dalvik 和 <em>ART（5.0以后）</em><br><strong>Dalvik 运行 dex 文件，而 JVM 运行 java 字节码</strong></p><p>ART 的机制与 Dalvik 不同。在 Dalvik 下，应用每次运行的时候，字节码都需要通过<strong>即时编译器</strong>（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，<br>在 ART 环境中，应用在第一次安装的时候，字节码就会<strong>预先编译成机器码</strong>，使其成为真正的本地应用。这个过程叫做预编译（AOT, Ahead-Of-Time）。这样的话，应用的启动 (首次) 和执行都会变得更加快速。</p><p>ART 有什么优缺点呢？<br>优点：<br>1、系统性能的显著提升。<br>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。<br>3、更长的电池续航能力。<br>4、支持更低的硬件。<br>缺点：</p><ol><li>机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%（不过在应用包中，可执行的代码常常只是一部分。比如最新的 Google+ APK 是 28.3 MB，但是代码只有 6.9 MB。）</li><li>应用的安装时间会变长。</li></ol><p><strong>机器码（Machine Code）</strong> 是CPU能够直接理解和执行的指令集。不同的CPU架构（如ARM、x86）有不同的机器码指令集。</p><ul><li>在计算机系统中，所有程序最终都要转换成机器码才能被CPU执行。</li><li>在Android中，机器码就是针对设备CPU架构（如ARMv7、ARMv8-A、x86等）的本地指令。</li></ul><p>ART 的演进优化<br>现代 Android 系统已采用混合编译策略：JIT + AOT 混合模式 (Android 7.0+)：<br>安装时：<em>仅编译关键代码</em><br>运行时：JIT 编译热点代码<br>空闲时：AOT 编译剩余代码<br>安装速度将比目前的安卓6.0提升最多75％</p><h3 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h3><ol><li>Service 设置成 START_STICKY，kill 后会被重启（等待5秒左右），重传 Intent，保持与重启前一样</li><li>通过 startForeground 将进程设置为<strong>前台进程，做前台服务</strong>，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill</li><li>双进程 Service：让2个进程互相保护，其中一个 Service 被清理后，另外没被清理的进程可以立即重启进程</li><li>QQ 黑科技: 在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死</li><li>利用系统广播拉活</li><li>多进程：用 C 编写守护进程 (即子进程)</li><li>引导用户调到自启动管理界面，参考请启动</li></ol><h3 id="Android-逆向反编译"><a href="#Android-逆向反编译" class="headerlink" title="Android 逆向反编译"></a>Android 逆向反编译</h3><p>Android 逆向工程主要是指反编译和二次打包，通过反编译可以破解一些有用信息，而通过二次打包则可以产生一些山寨应用。Android 逆向工程是一个很有意思的话题，如果开发者对其感兴趣的话，推荐大家阅读下逆向相关的书籍，比如《Android 软件安全与逆向分析》</p><p>Jar 和 Aar 的区别<br>    Jar 包里面只有代码，aar 里面不光有代码还包括代码还包括资源文件，比如 drawable 文件，xml 资源文件。对于一些不常变动的 Android Library，我们可以直接引用 aar，加快编译速度</p><p><strong>APK 反编译</strong></p><p>拿到需要加密的 Apk 和自己的壳程序 Apk，然后用加密算法对源 Apk 进行加密；再与壳 Apk 的 Dex 进行合并得到新的 Dex 文件；然后替换原壳程序中的 dex 文件即可，得到新的 Apk。那么这个新的 Apk 我们也叫作脱壳程序 Apk，他已经不是一个完整意义上的 Apk 程序了，他的主要工作是：负责解密源 Apk，然后加载 Apk，让其正常运行起来。</p><p>通过反射和 classloader</p><ol><li>dex2jar：将 dex 文件转化成 jar，原理也是一样的，只要知道 Dex 文件的格式，能够解析出 dex 文件中的类信息就可以了</li><li>jd-gui：可以查看 jar 中的类，其实他就是解析 class 文件，只要了解 class 文件的格式就可以，class 反编译成 Java</li></ol><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><ul><li>LinerLayout 跟 RelativeLayout 的绘制原理<br>  LinearLayout 需要测量一次，而 RelativeLayout 需要测量2次（对子 view 测量，横向纵向分别进行一次），然后如果只嵌套一层首选 LinearLayout，如果多层需要使用 RelativeLayout<br>  FrameLayout 和 LinearLayout 差不多</li></ul><ol><li>RelativeLayout 会<em>让子 View 调用2次 onMeasure</em>，LinearLayout 在有 weight 时。也会调用子 View2次 onMeasure</li><li>RelativeLayout 的子 View 假设高度和 RelativeLayout 不同，则会引发效率问题，当子 View 非常复杂时，这个问题会更加严重。</li><li>假设能够，尽量使用 padding 取代 margin。</li></ol><ul><li>CoordinatorLayout</li></ul><p><a href="https://juejin.cn/post/6976443779762880549?utm_source=gold_browser_extension#comment">自定义Behavior，好文章</a></p><p><strong>参考：fragment_task</strong></p><p>CoordinatorLayout 是一个“加强版”的 FrameLayout，它主要有两个用途：</p><ol><li>用作应用的顶层布局管理器</li><li>通过为子 View 指定 behavior 实现自定义的交互行为。<br>在我们做 Material Design 风格的 app 时通常都使用 CoordinatorLayout 作为布局的根节点，以便实现特定的 UI 交互行为。很常见的一种模式是 TabLayout 放在 ToolBar 布局中与其一起置顶在界面上方，在滑动的时候将 ToolBar 隐藏而 TabLayout 一直置顶在界面上方。</li></ol><ul><li>CollapsingToolbarLayout<br>  顾名思义就是可折叠的 toolbar 布局。CollapsingToolbarLayout 可以包裹 Toolbar , 当其显示完收缩动画时使 Toolbar 显示在顶端。可以再加入浸入式的效果让 CollapsingToolbarLayout 的背景图突破系统的状态栏使界面更加美观同时也不影响 Toolbar 的显示效果。</li></ul><p>Padding 和 Margin 有什么区别？</p><p>Padding 是控件内容的距离，margin 是控件和控件间的距离<br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%BA%8C%EF%BC%89.resources/2023/09/15/18-48-56-c33d027aa1e7247c246d672be4156849-wpsF24B-7a8e9f.jpg" alt="wpsF24B"></p><p>实现侧边栏、和指示器效果、页面滑动有几种方式<br>侧边栏：自定义、slidingmenu、DrawerLayout 、SlidingDrawer<br>指示器效果：自定义、viewpager 里面的 PagerTabStrip、ActionBar Tab 标签、viewpagerindicate、FragmentTabHost、TabActivity、radiobutton、tablayout<br>页面滑动：自定义、viewpager、手势识别器，其实就是 onTouchEvent 提供的简单工具类，onTouchEvent 将触摸事件委托给了手势识别器</p><p>layout_weight<br>屏幕适配经常用等分的长度“先各自分配各自控件的长度，然后将剩余的长度按照权重的比例 layout_weight 的大小进行设置。</p><h3 id="抓包的原理"><a href="#抓包的原理" class="headerlink" title="抓包的原理"></a>抓包的原理</h3><p>代理。客户端请求-&gt;经过代理-&gt;到达服务端服务端返回-&gt;经过代理-&gt;到达客户端<br>任何 Https 的 app 都能抓的到吗？<br>7.0以下是可以的，<em>只要手机里安装对应 CA 证书，比如用 charles 抓包，手机要安装 charles 提供的证书就行</em>。<br>Android 7.0 之后，Google 推出更加严格的安全机制，应用默认不信任用户证书（手机里自己安装证书），自己的 app 可以通过配置解决，但是抓其它 app 的 https 请求就行不通。<br>okhtttp 禁止代理，就可以了 builder.proxy (Proxy. NO_PROXY);<br>charles 抓包显示乱码解决方法：</p><ol><li>工具栏–&gt;Proxy–&gt;SSL Proxying Settings</li><li>添加需求抓包的请求的域名和端口号0<br>HTTPS 能调试是因为你安装了调试工具给你的根证书，相当于你主动被中间人入侵</li></ol><h3 id="Intent-传输数据的大小有限制吗"><a href="#Intent-传输数据的大小有限制吗" class="headerlink" title="Intent 传输数据的大小有限制吗"></a>Intent 传输数据的大小有限制吗</h3><p>Intent 中的 Bundle 是使用 Binder 机制进行数据传送的, <em>数据会写到内核空间，Binder 缓冲区域</em>。<br>Binder 的缓冲区是有大小限制的, 有些 ROM 是 1M, 有些 ROM 是 2M;<br>这个限制定义在 frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;processState. cpp 类中, 如果超过这个限制, 系统就会报错<br>因为 Binder 本身就是为了进程间频繁-灵活的通信所设计的, 并不是为了拷贝大量数据;</p><p>如果非 ipc 就很简单了, static 变量, eventBus 之类的都可以;<br>如果是 ipc, 一定要一次性传大文件, 可以用 file 或者 socket;</p><h3 id="没有给权限如何定位，特定机型定位失败，如何解决"><a href="#没有给权限如何定位，特定机型定位失败，如何解决" class="headerlink" title="没有给权限如何定位，特定机型定位失败，如何解决"></a>没有给权限如何定位，特定机型定位失败，如何解决</h3><p>GPS 就是精准定位！<br>蓝牙、移动信号、wifi 都是能定位的。就是基于网络定位，但是不太准，没有 GPS 定位那么准。<br>android 的定位权限就是 GPS 定位，但是只要你有网络请求，就能得到你的大概范围。</p><h3 id="Android-各个版本"><a href="#Android-各个版本" class="headerlink" title="Android 各个版本"></a>Android 各个版本</h3><p>Android 3.0系统这个系统是为了平板电脑设计的，加入了 fragment</p><ul><li>4.0版本，这个版本对于不在对手机和平板进行区别对待, actionbar 在这个版本加的</li><li>5.0系统，使用了 ART 运行环境代替了 Dalvik 虚拟机大大提升了运行速度之外，还提出了 Material Design 的设计语言来优化应用的界面，新增了很多控件。Material Design 主题，设置阴影、ToolBar (就相当于一个控件，更加灵活)、DrawerLayout、CardView，google 发布的新的 Android Support Design 库，里面也包含了几个新的控件，那么 TabLayout 就是其中一个。RecyclerView</li><li>6.0系统加入了运行时权限，加入指纹识别，能提供原生指纹识别 API，这不但降低了厂商开发指纹识别模块的成本。大量漂亮流畅的动画</li><li>7.0系统加入了多窗口模式功能，引入了 JIT 编译器，APP 的安装速度将比目前的安卓6.0提升最多75％，支持了 Java8语言模式，夜间模式<br>  获取文件需要使用 fileprovider</li><li>8.0对隐式广播、后台服务和位置更新等进行了后台自动限制，以此来增加手机电池寿命。<br>  后台启动服务 startService 会报错，需要使用 startForgand ()<br>  通知栏需要使用新的 API，旧的不生效了，需要指定个 channelID</li><li>9.0：全面屏的全面支持</li><li>AndroidQ：5G 网络、通知中的智能回复、黑暗主题、设置面板、分享快捷方式、用户隐私</li></ul><h3 id="缓存数据，如何保证和服务器的数据统一？"><a href="#缓存数据，如何保证和服务器的数据统一？" class="headerlink" title="缓存数据，如何保证和服务器的数据统一？"></a>缓存数据，如何保证和服务器的数据统一？</h3><ol><li>比如有个网络更新的功能, activity 可以每隔半小时开启 service 去访问服务器，获取最新的数据。</li><li>在缓存文件里面加入时间戳，根据实际情况在一定的时间差内再次访问网络数据、判断 URL 在缓存的第一行写一个上当前时间，读的时候判断是不是过期，根据需求看需要多久跟新</li></ol><h3 id="系统分层"><a href="#系统分层" class="headerlink" title="系统分层"></a>系统分层</h3><p>（由下向上） 【如图】</p><ul><li>安卓系统分为四层，分别是 Linux 内核层、Libraries 层、FrameWork 层，以及 Applications 层</li></ul><ol><li>Linux 内核层：包含 Linux 内核和驱动模块（比如 USB、Camera、蓝牙等）</li><li>Libraries 层：这一层提供动态库（也叫共享库） 、android 运行时库、Dalvik、apengl、虚拟机等，编程语言主要为 C 或 C++，所以可以简单的看成 Native 层。</li><li>FrameWork 层：这一层大部分用 java 语言编写，有 activityManager、windowManager 等，它是 android 平台上 Java 世界的基石。</li><li>Applications 层：应用层，桌面、联系人、拨号等软件<br> FrameWork 层 ——– Java 世界<br> Libraries 层 ——– Native 世界<br> Linux 内核层 ——– Linux OS<br> Java 世界和 Native 世界间的通信是通过 JNI 层, JNI 层和 Native 世界都可以直接调用系统底层</li><li>Dalvik VM 和传统 JVM 的区别：<br> 传统的 JVM：编写. java 文件→编译为. class 文件 → 打包成. jar 文件<br> Dalvik VM： 编写. java 文件 → 编译为. class 文件 → 打包成. dex 文件 → 打包成. apk 文件 (通过 dx 工具) 将所有的类整合到一个文件中，提高了效率。更适合在手机上运行<br> <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%BA%8C%EF%BC%89.resources/2023/09/15/18-48-56-1caf5f3bacc6666699ca9a86d39e5323-8f054a15-c276-48b1-948e-e69044b554d0-bbe90e.jpg" alt="8f054a15-c276-48b1-948e-e69044b554d0"></li></ol><h3 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h3><p>应用程序二进制接口 ABI（Application Binary Interface）定义了二进制文件（尤其是. so 文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在 Android 系统上，每一个 CPU 架构对应一个 ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。</p><p><strong>SO 文件</strong><br>如果程序中使用到了 NDK，它将会生成. so 文件。c++的类库</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理单元（CPU）主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出 CPU 每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。<br>CPU 需要执行数以百万计的指示，才能使它向我们期待的方向运行</p><p>Intel 和 ARM 处理器的第一个区别是，前者使用复杂指令集（超高性能的台式机和服务器处理器），而后者使用精简指令集（低功耗处理器）。</p><h3 id="ARGB"><a href="#ARGB" class="headerlink" title="ARGB"></a>ARGB</h3><p>色彩模式，也就是 RGB 色彩模式附加上 Alpha（透明度）通道，常见于32位位图的存储结构。<br>透明度是个 0~255的值，为0的时候，完全不可见；为 255的时候完全可见，#(0-f) 00设置透明，f 全黑色 Color.FromArgb () 有一个构造函数有4个参数，<br>Color.FromArgb (int alpha, int red, int green, int blue). 这个用来控制颜色的透明度。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android（一）</title>
    <link href="/2025/12/2a4c1471c008.html"/>
    <url>/2025/12/2a4c1471c008.html</url>
    
    <content type="html"><![CDATA[<h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>四大组件之一,一个和用户交的互界面就是一个 activity，是所有 View 的容器</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期描述的是一个类从创建(new出来)到死亡(垃圾回收)的过程中会执行的方法，在这个过程中会针对不同的生命阶段会调用不同的方法。这些回调方法包括：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">oncreate:Activity对象创建完毕，但此时不可见<br>onstart:Activity在屏幕可见，但是此时没有焦点<br><span class="hljs-keyword">on</span>Resume：Activity在屏幕可见，并且获得焦点<br><span class="hljs-keyword">on</span>Pause：Activity此时在屏幕依然可见，但是已经没有焦点<br><span class="hljs-keyword">on</span>Stop：Activity已经不可见了，但此时Activity的对象还在内存中<br><span class="hljs-keyword">on</span>Destroy：Activity对象被销毁<br></code></pre></td></tr></table></figure><p>其实这些方法都是两两对应的：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">on</span>Create创建与<span class="hljs-keyword">on</span>Destroy销毁；<br><span class="hljs-keyword">on</span>Start可见与<span class="hljs-keyword">on</span>Stop不可见；<br><span class="hljs-keyword">on</span>Resume可编辑（即焦点）与<span class="hljs-keyword">on</span>Pause；<br></code></pre></td></tr></table></figure><p> onRestart 方法：在 Activity 被 onStop 后，但是没有被 onDestroy，在再次启动此 Activity 时就调用 onRestart（而不再调用 onCreate）方法；如果被 onDestroy 了，则是调用 onCreate 方法。当一个 Activity 启动另一个 Activity，然后按返回键返回到前一个 Activity 时。</p><ul><li><p>两个Activity之间跳转时必然会执行的是哪几个方法<br>一般情况比如说有两个activity,分别叫A,B ,当在A里面激活B组件的时候, A 会调用 onPause()方法,!<br>然后B 调用onCreate() ,onStart(), OnResume() ,这个时候B覆盖了窗体, A会调用onStop()方法.  如果B是个透明的,或者是对话框的样式, 就不会调用onStop()方法。</p></li><li><p>横竖屏切换时候Activity的生命周期<br>这个生命周期跟清单文件里的配置有关系<br>设置Activity的android:configChanges&#x3D;”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法，游戏开发中, 屏幕的朝向都是写死的</p></li><li><p>如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？<br>  <img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-0eb8e744012c77533eae8818ffef5b50-wpsF22B-1e1cb4.jpg" alt="wpsF22B"></p></li></ul><p>除了在栈顶的activity,其他的activity都有可能在内存不足的时候被系统回收,一个activity越处于栈底,被回收的可能性越大.如果有多个后台进程，在选择杀死的目标时，采用最近最少使用算法（LRU）。</p><ol><li>Activity中提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用， 可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</li><li>通过onRestoreInstanceState来存储和恢复数据，区别是不需要判断空了，onRestoreInstanceState调用一定是有值的</li></ol><p>Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们并不一定会被触发。<br>当应用遇到意外情况，由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。<br>除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态</p><blockquote><p>当用户按下 HOME 键时<br>长按 HOME 键，选择运行其他的程序时<br>锁屏时<br>从 activity A 中启动一个新的 activity 时<br>屏幕方向切换时</p></blockquote><ul><li>发送特定广播：&#x2F;&#x2F;在baseactivity里注册广播   registerReceiver(receiver, filter)&#x2F;&#x2F;想退出的时候就在onRecriver方法里finish()。</li><li>可以通过 intent的flag 来实现， intent.setFlag(FLAG_ACTIVITY_CLEAR_TOP)激活一个新的activity,然后在新的activity的oncreate方法里面就可以finish掉.</li></ul><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-21777d9b65be1ecb685fb6f191aa8dc7-unknown_filename-ad563c.png" alt="unknown_filename"></p><ul><li>如何返回数据基本流程<br>  使用 startActivityForResult(Intent intent, int requestCode) 方法打开 Activity；<br>  新 Activity 中调用 setResult(int resultCode, Intent data) 设置返回数据之后，关闭 Activity 就会调用onActivityResult 方法；在原来的activity里重写 onActivityResult(int requestCode, int resultCode, Intent data) 方法；</li></ul><blockquote><p>注意：新的 Activity 的启动模式不能设置成 singleTask（如果已创建，会使用以前创建的）与 singleInstance（单独的任务栈），不能被摧毁（执行不到 finish 方法） ，父 Activity 中的 onActivityResult 方法将不会执行；</p></blockquote><p>PendingIntent简单地理解为延迟执行的 Intent。</p><ol><li>任务栈的概念问：一个手机里面有多少个任务栈？<br>答：一般情况下，有多少个应用正在运行，就对应开启多少个任务栈；每开启一个应用程序就会创建一个与之对应的任务栈；栈：后进先出，最先进栈，就会最后出栈。Activity的启动模式就是修改任务栈的排列情况</li><li>任务栈的作用：它是存放 Activity 的引用的，Activity不同的启动模式，对应不同的任务栈的存放；可通过 getTaskId()来获取任务栈的 ID，如果前面的任务栈已经清空，新开的任务栈 ID+1，是自动增长的；</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-1c78f67c55317123cc1a587eb7227d29-unknown_filename.1-a61bc7.png" alt="unknown_filename.1"></p><h4 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h4><ol><li>standard 标准启动模式</li><li>singleTop 单一顶部模式如果任务栈的栈顶存在这个要开启的activity，不会重新的创建activity，而是复用已经存在的activity,会调用 onNewInstance()，复用已经存在的实例。如果栈顶没有或者不在栈顶，会重新创建。应用场景：singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很耗内存的。</li><li>singeTask 单一任务栈，在当前任务栈里面只能有一个实例存在当开启activity的时候，就去检查在任务栈里面是否有实例已经存在，如果有实例存在就复用这个已经存在的activity，并且把这个activity上面的所有的别的activity都清空，复用这个已经存在的activity。<strong>保证整个任务栈里面只有自己的一个实例存在</strong>。会调用 onNewInstance()，复用已经存在的实例。应用场景：singleTask适合作为程序入口点，例如应用中的主页（Home页）。假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用SingleTask模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。</li><li>singleInstance：activity会运行在自己的任务栈里面，并且这个任务栈里面只有一个实例存在如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance应用场景： 电话拨打界面。singleInstance适合需要与程序分离开的页面。例如我们有个需求，需要打开别的应用，这个时候如果不设置singleInstance的话，这个新打开的应用在我们程序的任务栈里，用户想要按任务键切换的话没法切换。</li></ol><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-568c23259949a12e0533083690a74e75-unknown_filename.2-00df06.png" alt="unknown_filename.2"></p><p><a href="https://rengwuxian.com/dang-wo-an-xia-home-jian-zai-qie-hui-lai-hui-fa-sheng-shen-me/">https://rengwuxian.com/dang-wo-an-xia-home-jian-zai-qie-hui-lai-hui-fa-sheng-shen-me/</a></p><p>singleInstance 和 singleTask 的区别：singleTask 强调的只是唯一性：我只会在一个 Task 里出现；而且这个 Task 里也只会有一个我的实例。而 singleInstance 除了唯一性，还要求独占性：我要独自霸占一个完整的 Task。</p><p>使用 singleTask 模式的场景主要包括：</p><ol><li><strong>任务的入口点</strong>：适用于任务的入口点，例如应用的主界面，确保整个应用只有一个实例。</li><li><strong>处理特定动作的Activity</strong>：比如一个音乐播放器的播放界面，通过设置为singleTask，可以确保只有一个播放界面存在。<br>值得注意的是，使用 singleTask 要小心处理 Activity 的生命周期，尤其是在 onNewIntent 方法中接收新的 Intent，并进行相应的处理。</li></ol><p><strong>问题</strong>：如何使用 LaunchMode 来实现单实例 Activity？<br>可以使用 singleTask 或 singleInstance 模式来实现单实例 Activity。</p><p><strong>问题</strong>：如何在不同的任务栈中启动 Activity？<br>要在不同的任务栈中启动 Activity，可以通过设置 Intent 的 FLAG_ACTIVITY_NEW_TASK 标志位，然后调用 startActivity()方法。例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Intent</span> <span class="hljs-keyword">intent</span> = new <span class="hljs-keyword">Intent</span>(this, TargetActivity.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">intent</span>.setFlags(<span class="hljs-keyword">Intent</span>.FLAG_ACTIVITY_NEW_TASK);<br>startActivity(<span class="hljs-keyword">intent</span>);<br></code></pre></td></tr></table></figure><p>这样，TargetActivity 就会在一个新的任务栈中启动。需要注意的是，<em>如果目标 Activity 已经存在于其他任务栈中，系统会将其移动到新的任务栈</em></p><h5 id="Affinity"><a href="#Affinity" class="headerlink" title="Affinity"></a>Affinity</h5><p>在 Android 里，<em>一个 App 默认只能有一个 Task 显示在最近任务列表里</em>。但其实用来甄别这份唯一性的并不是 App，而是一个叫做 taskAffinity 的东西。Affinity 就是相似、有关联的的意思，在 Android 里，每个 Activity 都有一个 taskAffinity，它就相当于是对每个 Activity 预先进行的分组。它的值默认取自它所在的 Application 的 taskAffinity，而 Application 的 taskAffinity 默认是 App 的包名。</p><h5 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h5><p>简单理解： onResume 前面多了 onNewIntent（）方法</p><p>第一种情况：activity launchMode为singleTask或者singleInstance<br>1、activitya start activityb<br>2、activityb start activitya<br>在第二步被执行后，activitya就会顺序执行 onNewIntent onRestart onStart onResume</p><p>第二种情况：（一般情况）<br>大概意思是当Activity被设以singleTop模式启动，当需要再次响应此Activity启动需求时，会复用栈顶的已有Activity，还会调用onNewIntent方法。并且，再接受新发送来的intent(onNewIntent方法）之前，一定会先执行onPause方法<br><strong>onPause onNewIntent onResume</strong></p><p>第二种情况：如果ActivityA在栈顶,且现在要再启动ActivityA，这时会调用onNewIntent()方法，生命周期顺序为：onCreate—&gt;onStart—&gt;onResume—onPause&gt; onNewIntent—&gt;onResume</p><blockquote><p>在内存吃紧的情况下，系统可能会 kill 掉后台运行的 Activity ，如果不巧要启动的那个 activity 实例被系统 kill 了，那么系统就会调用 onCreate 方法，而不调用 onNewIntent 方法。这里有个解决方法就是在 onCreate 和 onNewIntent 方法中调用同一个处理数据的方法</p></blockquote><ul><li>​<strong>​<code>standard</code>（默认模式）​</strong>​：每次启动都会创建新实例，​<strong>​会调用 <code>onCreate()</code>​</strong>​，无论是否已存在。</li><li>​<strong>​ <code>singleTop</code> ​</strong>、<code>singleTask</code> &#x2F; <code>singleInstance</code> ​<strong>​​：若目标 Activity 已在栈顶，则复用实例并调用 <code>onNewIntent()</code>，​</strong>​不会触发 <code>onCreate()</code> ​**​；否则行为同 <code>standard</code>。</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>一个应用有 4 个 Activity, ABCD, 他们的启动模式分别为 standard, singleTop，singleTask, singlelnstance, 现在 A&gt;B&gt;C&gt;D&gt;A&gt;B&gt;C&gt;D<br>A 启动 B，B 启动 C, C 启动 D, D 启动 A, A 启动 B，B 启动 C, C 启动 D。现在这个应用 ABCDAcvity 实例各几个????有几个 Acvity 栈?? ?</p><p>1)当 CActivity 的 taskAfFinity 和大家一样时启动流程是这样的:<br>A 启动 B 没有任何波澜，他们都是在一个堆栈，取名栈 1，启动 C，c 寻找 taskAffnity 一样的栈，发现栈 1，而栈 1 中没有 C 实例，所有创建 C 实例。启动 D 时<br>D 为 singlelnstance，所有会另开一个栈，存放 D。一轮启动过后! 目前栈为2个<br>栈 1 里面的实例是 ABC<br>栈 2 里面的实例是 D</p><p>D 启动 A&#x3D;》A 会在栈 1中创建<br>栈 1 里面的实例是 ABCA 栈 2 里面的实例是 D<br>A 启动 b&#x3D;》B 会在栈 1中创建<br>栈 1 里面的实例是 ABCAB<br>栈 2 里面的实例是 D</p><p>B 启动 C&#x3D;》由于但是由于栈 1 有 c，所有 singleTask 的特性会将 c 上的实例通通清除<br>栈 1 里面的实例是 ABC<br>栈 2 里面的实例是 D</p><p>C 启动 D&#x3D;》D 为 singleInstance, 而现在 D <em>又有实例，所有不会创建新的，复用原本的 D 实例栈</em> 1 里面的实例是 ABC<br>栈 2 里面的实例是 D<br>最终结果是: ABCD 实例各一个，栈 2 个</p><p>2)当 CActivity 的 taskAffinity 和大家不一样时启动流程是这样的:<br>A 启动 B 没有任何波澜，他们都是在一个栈取名栈 1，启动 c 时。由于 C 的 <em>taskAffinity</em> 和 A 不一样，也就是栈 1 不一样，所有会单独创建个栈 2，存放 C。<br>C 启动 D，D 为 singleInstance 所有会另开一个栈 3，存放 d。一轮启动过后目前栈为3个<br>栈 1 里面的实例是 AB<br>栈 2 里面的实例是 C<br>栈 3 里面的实例是 D  </p><p>D 启动 A&#x3D;》A 会在栈 1 中创建栈 1 里面的实例是 ABA 栈 2 里面的实例是 C   栈 3 里面的实例是 D<br>A 启动 b&#x3D;》B 会在栈 1 中创建栈 1 里面的实例是 ABAB 栈 2 里面的实例是 C   栈 3 里面的实例是 D<br>B 启动 C&#x3D;》C 会去找 taskAffinity 相同的栈，也就是栈 2，栈 2 的 c 在最上面所有复用 C 实例<br>栈 1 里面的实例是 ABAB<br>栈2里面的实例是 C<br>栈 3 里面的实例是 D</p><p>C 启动 D&#x3D;》D 为 singleInstance, 而现在 D 又有实例，所有不会创建新的，复用原本的 D 实例<br>栈 1 里面的实例是 ABAB<br>栈 2 里面的实例是 C<br>栈 3 里面的实例是 D<br>最终结果是: AB 实例各 2 个，CD 实例各 1 个  栈3个</p><ul><li>Android下的进程进程是被系统创建的，当内存不足的时候，又会被系统回收内存管理<br>  Android 系统在运行多个进程时，如果系统资源不足，会强制结束一些进程,优先选择哪个进程来结束是有优先级的。会按照以下顺序杀死(进程级别)：<br>  ①、空： 进程中没有任何组件（无组件启动，做进程缓存使用，恢复速度快），任务栈清空，意味着程序退出了，但进程留着，这个就是空进程，容易被系统回收；<br>  ②、后台：进程中只有停止状态(onStop)的 Activity；<br>  ③、服务：进程中有正在运行的服务；<br>  ④、可见：进程中有一个暂停状态(onPause)的 Activity；<br>  ⑤、前台：进程中正在运行一个 Activity；Activity 在退出的时候进程不会销毁, 会保留一个空进程方便以后启动. 但在内存不足时进程会被销毁；<br>  不要在 Activity 做耗时的操作, 因为 Activity 切换到后台之后（Activity 停止了）, 内存不足时, 也容易被销毁；热启动：退出后在进入应用不会执行application里的代码了。</li></ul><p><strong>横竖屏切换生命周期</strong></p><ol><li>、不设置 Activity 的 Android: configChanges 时，切屏会重新调用生命周期，切横屏会调用一次，切竖屏会调用两次。<br>2)、设置 Activity 的 Android:configChanges&#x3D;”orientation”时，切开还是会重新调用生命周期，切横竖屏都只调用次生命周期。<br>3)、设置 Activity 的 Android: configChanges “orientation keyboardHidden: 切屏不会重新调用冬个生命周期，只会调用 onConfigurationChanged 方法</li></ol><hr><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><strong>什么时候使用 Service？</strong><br>    1、Service 的特点可以让他在后台一直运行, 可以在 service 里面创建线程去完成耗时的操作.<br>    2、Broadcast receiver 捕获到一个事件之后, 可以起一个 service 来完成一个耗时的操作.</p><p>Service的生命周期。Service有哪些启动方法，有什么区别，怎样停用Service?<br>    在Service的生命周期有onCreate, onStartCommand, onDestroy,onBind和onUnbind。<br>    一旦在项目的任何位置调用了Context的startService()方法，相应的服务就会启动起来，并回调onStartCommand()方法。如果这个服务之前还没有创建过，onCreate()方法会先于onStartCommand()方法执行。<br>    通常有两种方式启动一个Service,他们对Service生命周期的影响是不一样的。</p><ol><li>通过startService    <br> Service会经历 onCreate 到onStartCommand，然后处于运行状态，stopService的时候调用onDestroy方法。 如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。</li><li>通过bindService      <br> Service会运行onCreate，然后是调用onBind， 这个时候调用者和Service绑定在一起。调用者退出了，Srevice就会调用onUnbind-&gt;onDestroyed方法。所谓绑定在一起就共存亡了。调用者也可以通过调用unbindService方法来停止服务，这时候Srevice就会调用onUnbind-&gt;onDestroyed方法。</li></ol><p>音乐播放：<br>增加StartService，来增加后台播放功能 startService(intent);<br>StartService后，onUnbind不会停服务，会解除绑定</p><ul><li>service如何杀不死</li></ul><ol><li>onStartCommand方法，返回START_STICKY（粘性）当service因内存不足被kill，当内存又有的时候，service又被重新创建</li><li>设置优先级</li><li>在服务里的ondestory里发送广播，在广播里再次开启这个服务,双进程守护</li></ol><p><strong>service是否在main thread中执行, service里面是否能执行耗时的操作?</strong><br>    Service和Activity是运行在当前app所在进程的main thread(UI主线程)里面service里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )，需要在子线程中执行 new Thread(){}.start()</p><p><strong>service里面可以弹土司吗</strong> <br>    由于没有关联的界面，土司会无法显示出来，创建一个Handler，并将其与主线程的Looper关联起来。然后，在需要弹出土司的地方，通过Handler来发送弹出土司的消息</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>&#123;  <br>       <span class="hljs-keyword">handler</span> = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());                          <br>       System.out.println(<span class="hljs-string">&quot;service started&quot;</span>);  <br>       <span class="hljs-keyword">handler</span>.post(<span class="hljs-keyword">new</span> Runnable() &#123;    <br>            <span class="hljs-meta">@Override</span>    <br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <br>               Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;Test&quot;</span>,Toast.LENGTH_SHORT).show();<br>    &#125;);<br></code></pre></td></tr></table></figure><ul><li>什么是IntentService？有何优点？<br>  普通的service ,默认运行在ui main 主线程，Sdk给我们提供的方便的,带有异步处理的service类<strong>OnHandleIntent()</strong> 处理耗时的操作，不需要开启子线程，这个方法已经在子线程中运行了Intentservice，<strong>若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务</strong>，等任务完成后再次调用stopService()</li></ul><p><strong>startForeground(id, notification)</strong><br>拥有service的进程具有较高的优先级。当内存不足时，拥有service的进程具有较高的优先级。将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed</p><hr><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>请描述一下 Broadcast Receiver。</p><p>Android 中：系统在运行过程中，会产生会多事件，那么某些事件产生时，比如：电量改变、收发短信、拨打电话、屏幕解锁、开机，系统会发送广播，只要应用程序接收到这条广播，就知道系统发生了相应的事件，从而执行相应的代码。使用广播接收者，就可以收听广播广播分三种：有序广播、无序广播、本地广播</p><ol><li>无序广播（标准广播）：无序广播不可中断，不能互相传递数据；所有与广播中的 action 匹配的广播接收者都可以收到这条广播，并且是没有先后顺序，视为同时收到</li><li>有序广播：一个接一个的传递，广播可中断，通过调用 abortBroadcast()方法；接收者之间可以传递数据（intent）所有与广播中的action匹配的广播接收者都可以收到这条广播，但是是有先后顺序的，按照广播接收者的优先级排序优先级的定义</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">&quot;100&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.broadcasttest.MY_BROADCAST&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>最终接收者：所有广播接收者都接收到广播之后，它才接收，并且一定会接收abortBroadCast：阻止其他接收者接收这条广播，类似拦截，只有有序广播可以被拦截发送有序广播：sendOrderedBroadcast(intent)</p><p>本地广播</p><ul><li>与全局广播相比，LocalBroadcast 更加高效和安全，因为它只在应用内部传递消息，不会被其他应用接收到，也不需要进行权限检查。</li><li>需要注意的是，在 Android 10 及以上版本中，LocalBroadcast 机制已经被废弃，<em>建议使用其他方式进行应用内部通信，如使用 ViewModel 或 LiveData。</em></li></ul><h4 id="如何注册广播"><a href="#如何注册广播" class="headerlink" title="如何注册广播"></a>如何注册广播</h4><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-fd81ff34823cb6edf47b2425f2369899-05a8c7a67e7b5a582ec85bade979cad2-c23cce.png" alt="05a8c7a67e7b5a582ec85bade979cad2"></p><p>广播的方式一般有两种，在代码中注册和在 AndroidManifest.xml中注册，其中前者也被称为动态注册，后者也被称为静态注册<br>动态注册：安卓中有一些广播接收者，必须使用代码注册，清单文件注册是无效的，屏幕锁屏和解锁电量改变</p><p>静态注册：可以使用清单文件注册，广播一旦发出，系统就会去所有清单文件中寻找，哪个广播接收者的 action 和广播的 action 是匹配的，如果找到了，就把该广播接收者的进程启动起来</p><p>【强制】 避免使用隐式 Intent 广播（静态、动态注册）敏感信息，信息可能被其他注册了对应 BroadcastReceiver 的 App 接收如果广播仅限于应用内，则可以使用 <em>LocalBroadcastManager</em> 的 sendBroadcast ()实现，避免敏感信息外泄和 Intent 拦截的风险。 （效率更高，使用的 handler，静态是 pms）</p><p>正例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-type">Intent</span>(<span class="hljs-string">&quot;my-sensitive-event&quot;</span>);<br>intent.putExtra(<span class="hljs-string">&quot;event&quot;</span>, <span class="hljs-string">&quot;this is a test event&quot;</span>);<br>LocalBroadcastManager.getInstance(<span class="hljs-built_in">this</span>).sendBroadcast(intent); <br></code></pre></td></tr></table></figure><p>LocalBroadcastReceiver 是应用内广播，利用 Handler 实现，利用了 IntentFilter 的 match 功能提供消息的发布与接收功能，实现应用内通信，效率和安全性比较高，仅支持动态注册<br>4大组件其中比较特殊的是广播接收者，可以不在清单文件中配置，可以通过代码进行注册。其他组件全部在清单文件中注册</p><h4 id="广播的生命周期"><a href="#广播的生命周期" class="headerlink" title="广播的生命周期"></a>广播的生命周期</h4><ol><li>广播接收者的生命周期非常短暂的，<em>在接收到广播的时候创建，onReceive()方法结束之后销毁；</em></li><li>广播接收者中不要做一些耗时的工作，否则会弹出 Application No Response错误对话框；</li><li>最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉；</li><li>耗时的较长的工作最好放在服务中完成；</li></ol><p><strong>广播产生的问题</strong></p><p>广播的最大问题就是被滥用，各种全家桶app的相互唤醒，以及保活措施导致设备占用内存增多，性能下降。</p><p><strong>google 是如何处理这些问题的</strong></p><p>在新版本api中去除了影响较大的全局跨进程广播，比如网络状态变化，新图片或新视频的添加等 。<br>即使你在app中对这些广播进行了静态注册，依然不会被唤醒 ；如果需要监听网络环境改变，谷歌建议使用JobScheduler（系统服务）来监听；而图片和视频的广播在api24中被完全禁用了。</p><hr><h3 id="内容提供者"><a href="#内容提供者" class="headerlink" title="内容提供者"></a>内容提供者</h3><p>Android 设计 ContentProvider 主要是<em>为了实现跨进程通信</em>。</p><p><em>调用系统功能，拍照、裁剪、查联系人、短信、系统文件、音乐的时候用到</em></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>ContentResolver cr = getContentResolver();<br>Cursor c = cr.query(<span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://sms&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br><br></code></pre></td></tr></table></figure><ul><li>提供一种统一的数据访问格式。调用者无需关心数据源于何处（如DB、XML文件和网络等），只需获取到对应的ContentResolver来进行增删查改即可。</li><li><strong>四大组件之一，主要用于在不同的应用程序之间实现数据共享的功能</strong>，不同于sharepreference和文件存储中的两种全局可读写操作模式，<strong>内容提供其可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险通常</strong>，是把私有数据库的数据暴露给其他应用在清单文件中定义内容提供者的标签。</li><li>注意必须要有authorities属性，这是内容提供者的主机名，功能类似地址 ，可以自己定义。若需提供数据给其他应用，则 exported 要设为true</li></ul><p>scheme前缀是固定的： content:&#x2F;&#x2F;<br>授权host：此例中为 com.xxx.yyy.provide<br>r路径与参数：此例中为 test_path&#x2F;1</p><blockquote><p>原理：packmanagerservice里注册，在使用ContentResolver来进行查询操作时，query 方法层层调用到 ActivityThread 的 acquireExistingProvider 方法，根据URI字符串当中的授权host（即 authority ）和当前所在用户的 userId 来获取对应的Provider实例。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.itheima.contentprovider.PersonProvider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.itheima.person&quot;</span>  </span><br><span class="hljs-tag">     <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br>    <br></code></pre></td></tr></table></figure><p>把自己的数据通过uri的形式共享出去，android 系统下不同程序，数据默认是不能共享访问 需要去实现一个类去继承ContentProvider。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonContentProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ContentProvider</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">onCreate</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">//实例化UriMatcher对象</span><br>        uriMatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UriMatcher</span>(<span class="hljs-title class_">UriMatcher</span>.<span class="hljs-property">NO_MATCH</span>);<br>        <span class="hljs-comment">//可以实现匹配URI的功能</span><br>        <span class="hljs-comment">//参数1：authority 参数2：路径 参数3：自定义代码</span><br>        uriMatcher.<span class="hljs-title function_">addURI</span>(<span class="hljs-variable constant_">AUTHORITY</span>, <span class="hljs-string">&quot;userdemo&quot;</span>, <span class="hljs-variable constant_">USER_DIR</span>);<br>        uriMatcher.<span class="hljs-title function_">addURI</span>(<span class="hljs-variable constant_">AUTHORITY</span>, <span class="hljs-string">&quot;userdemo/#&quot;</span>, <span class="hljs-variable constant_">USER_ITEM</span>);<br>&#125;<br><span class="hljs-title function_">query</span>(<span class="hljs-title class_">Uri</span>, <span class="hljs-title class_">String</span>[], <span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>[], <span class="hljs-title class_">String</span>)<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Uri</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">Uri uri, ContentValues values</span>) &#123;<br> <span class="hljs-keyword">switch</span> (uriMatcher.<span class="hljs-title function_">match</span>(uri)) &#123; <br>  <span class="hljs-keyword">case</span> <span class="hljs-attr">USER_DIR</span>:<br>db.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-literal">null</span>, values);<br><span class="hljs-keyword">return</span> uri;<br>&#125;<br><br><span class="hljs-title function_">update</span>(<span class="hljs-title class_">Uri</span>, <span class="hljs-title class_">ContentValues</span>, <span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>[])<br><span class="hljs-title function_">delete</span>(<span class="hljs-title class_">Uri</span>, <span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>[])<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">View v</span>)&#123;<br><span class="hljs-comment">//得到内容分解器对象</span><br><span class="hljs-title class_">ContentResolver</span> cr = <span class="hljs-title function_">getContentResolver</span>();<br><span class="hljs-title class_">ContentValues</span> cv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>cv.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小方&quot;</span>);<br>cv.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-number">138856</span>);<br>cv.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;money&quot;</span>, <span class="hljs-number">3000</span>);<br><span class="hljs-comment">//url:内容提供者的主机名</span><br>cr.<span class="hljs-title function_">insert</span>(<span class="hljs-title class_">Uri</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;content://com.itheima.person&quot;</span>), cv);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么要用ContentProvider？它和sql的实现上有什么差别？<br>屏蔽数据存储的细节,对用户透明,用户只需要关心操作数据的uri就可以了不同app之间共享,操作数据Sql也有增删改查的方法，但是contentprovider 还可以去增删改查本地文件. xml文件的读取,更改，网络数据读取更改</p><p>请介绍下Android的数据存储方式</p><ol><li>文件储存，在内部文件和SD卡getCacheDir()，在data&#x2F;data&#x2F;包名&#x2F;cachegetFilesDir(),在data&#x2F;data&#x2F;包名&#x2F;filesSD卡：首先通过File file &#x3D; new File(Environment.getExternalStorageDirectory(), “info.txt”)，然后通过io存储</li><li>SharedPreference</li><li>SQLite数据库：当应用程序需要处理的数据量比较大时，为了更加合理地存储、管理、查询数据，往往使用关系数据库来存储数据。</li><li>ContentProvider</li></ol><p>通知图库更新</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMediaDtore</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> fileName</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-title class_">MediaStore</span>.<span class="hljs-property">Images</span>.<span class="hljs-property">Media</span>.<span class="hljs-title function_">insertImage</span>(context.<span class="hljs-title function_">getContentResolver</span>(),<br>                  currentFile.<span class="hljs-title function_">getAbsolutePath</span>(), fileName, <span class="hljs-literal">null</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>          e.<span class="hljs-title function_">printStackTrace</span>();<br>      &#125;<br>  &#125;<br>    <br></code></pre></td></tr></table></figure><hr><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><ul><li>简单说说Fragment？<br>  用途：在一个Activity里切换界面，切换界面时只切换Fragment里面的内容生命周期方法跟Activity一致，可以理解把其为就是一个Activity，与Activity同存亡，Activity的XX方法调用，Fragment的XX方法就调用</li></ul><p><strong>fragment懒加载</strong><br>懒加载就是页面对用户可见时再去加载数据使用add hide() show()方法切换fragment ，不会走任何的生命周期，无法通过生命周期进行刷新，而是使用onHiddenChanged()<br>当fragment结合viewpager使用的时候，显示隐藏调用的是setUserVisibleHint()所以需要在这两个方法都判断下，让fragment显示再去加载数据（loadData），当然要先判断是否初始化完成</p><ul><li>他们是怎么进行传递数据的?</li></ul><ol><li>活动传递给Fragment:为了方便碎片和活动之间进行通信， FragmentManager提供了一个findFragmentById的方法，专门用于从布局文件中获取碎片的实例，前提是自己在布局文件中定义fragment这个标签，还有findViewByTag，在replace 的时候设置tag或者在fragment里声明接口，然后activity获得fragment对象调用接口里的方法</li><li>fragment数据传递给活动，直接getActivity就可以调用活动里的方法了</li><li>activity给fragment传递数据一般不通过fragment的构造方法来传递，会通过<em>setArguments</em>来传递，因为当横竖屏会调用fragment的空参构造函数，数据丢失。</li><li>fragment和fragment数据传递首先在一个fragment可以得到与它相关联的活动，然后再通过这个活动去获取另外一个fragment的实例，这样也就实现了不同fragment之间的通信功能FragmentManager</li></ol><ul><li>add 和 replace 有什么区别?<br>  用add方式实现fragment的效果就是：切换fragment时不会重新创建，是什么样子切换回来还是什么样子；<br>  用replace的效果就是：切换fragment时每次都会重新创建初始化</li></ul><ol start="3"><li>使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。</li><li>当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。</li><li>而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。replace()方法会将被替换掉的那个Fragment彻底地移除掉，因此最好的解决方案就是使用hide()和show()方法来隐藏和显示Fragment，这就不会让Fragment的生命周期重走一遍了。</li></ol><ul><li>Fragment和view的区别</li></ul><ol><li>Fragment可以有效的对 view进行管理（增删和替换）而且结构更加清晰，有模块化的实现思想。用view 很多逻辑代码可能都需要写在Activity里，如果view很多， 耦合度会很高。用Fragment则可以各自管理，起了解耦的作用。一般软件简单的话直接view，复杂的用Fragment。</li><li>viewpager是一个滑动切换的控件，Fragment是一个轻量级的Activity，这个Fragment可以放到这个Viewpager里面去运行。例如QQ或微信那样,可以来回切换不同的选项卡,即切换了不同的Fragment。</li><li>通常Viewpager 会放 fargment或者view。</li><li>在一个Activity里切换界面，切换界面时只切换Fragment里面的内容。Fragment通常用来作为一个activity界面的一部分。</li><li>fragment有生命周期</li></ol><ul><li>回退栈<br>  Activity切换是通过栈的形式，不断压栈出栈，在Fragment的时候，如果不是手动开启回退栈，它是直接销毁再重建，但如果将Fragment任务添加到回退栈，情况就会不一样了，它就有了类似Activity的栈管理方式。</li></ul><p><strong>popBackStack()</strong> 弹出堆栈中的一个并且显示，类似按下返回键的操作；<br><strong>popBackStack(String tag,int flags)</strong><br>tag可以为null或者相对应的tag，flags只有0和1(POP_BACK_STACK_INCLUSIVE)两种情况</p><p>如果tag为null，flags为0时，弹出回退栈中最上层的那个fragment。</p><p>如果tag为null ，flags为1时，弹出回退栈中所有fragment。</p><p>如果tag不为null，那就会找到这个tag所对应的fragment，flags为0时，弹出该</p><p>fragment以上的Fragment，如果是1，弹出该fragment（包括该fragment）以上的fragment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">Fragment2</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fragment2</span>();<br><span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> getFragmentManager();<br><span class="hljs-type">FragmentTransaction</span> <span class="hljs-variable">tx</span> <span class="hljs-operator">=</span> fm.beginTransaction();<br>tx.replace(R.id.fl, f2);<br><span class="hljs-comment">//将当前的事务添加到了回退栈</span><br>tx.addToBackStack(<span class="hljs-literal">null</span>);<br>tx.commit();<br><br><span class="hljs-comment">//返回，回退到Fragment2，Fragment2不回执行onDestory</span><br><span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> getFragmentManager();<br>fm.popBackStack();<br><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-92a9400996ef48c827b4c4d65700440f-fragment-life-faebc4.png" alt="fragment-life"><br><img src="https://obsidian-yupic.oss-cn-beijing.aliyuncs.com/_resources/Android%EF%BC%88%E4%B8%80%EF%BC%89.resources/2023/09/15/18-48-41-6659d319ca25cd2b6b698bad507a3119-f770be1f-7024-41dd-907b-02eccb007a97-83103a.jpg" alt="f770be1f-7024-41dd-907b-02eccb007a97"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 机型适配问题整理</title>
    <link href="/2025/12/c5ce6a779cad.html"/>
    <url>/2025/12/c5ce6a779cad.html</url>
    
    <content type="html"><![CDATA[<h3 id="覆盖安装"><a href="#覆盖安装" class="headerlink" title="覆盖安装"></a>覆盖安装</h3><p>长时间在后台 APP 重启的处理</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> APP_STATUS_KILLED = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示应用是被杀死后再启动的  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> APP_STATUS_NORMAL = <span class="hljs-number">1</span>; <span class="hljs-comment">//表示应用是正常启动的  </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> APP_STATUS = APP_STATUS_KILLED; <span class="hljs-comment">//记录App的启动状态</span><br><br><span class="hljs-keyword">if</span> (Constants.APP_STATUS != Constants.APP_STATUS_NORMAL) &#123;<br>            BookLogger.<span class="hljs-built_in">e</span>(TAG, <span class="hljs-string">&quot;非正常启动流程，直接重新初始化应用界面&quot;</span>)<br>            CommonUtil.<span class="hljs-built_in">reInitApp</span>()<br>            <span class="hljs-built_in">finish</span>()<br>            <span class="hljs-keyword">return</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h3><p>Android 8.0 行为变更：后台执行限制<br>Android 8.0 还对特定函数做出了以下变更：如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException。<br>新的 Context.startForegroundService() 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 Context.startForegroundService()。不过，应用必须在创建服务后的五秒内调用该服务的 startForeground() 函数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> static void start(Context context) &#123;    <br><span class="hljs-keyword">Intent</span> <span class="hljs-keyword">intent</span> = new <span class="hljs-keyword">Intent</span>(context, InitializeService.<span class="hljs-keyword">class</span>);    <span class="hljs-keyword">intent</span>.setAction(ACTION_INIT);   <br><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#123;        <br>  context.startForegroundService(<span class="hljs-keyword">intent</span>);    <br>&#125; <span class="hljs-keyword">else</span>&#123;        <br>   context.startService(<span class="hljs-keyword">intent</span>);   <br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="小米手机适配"><a href="#小米手机适配" class="headerlink" title="小米手机适配"></a>小米手机适配</h3><p>可以说小米手机对android系统定制得让人头痛，好好的应用跑在小米手机上多多少少会点问题。</p><ul><li><p>短信发送失败无回调 <br>  在发送短信时候，若系统拦截之后，若用户点击拒绝发送短信，这个时候发现一直收不到系统发送短信失败的广播回调，就会出现无回调不知道短信是否发送成功，这对于需要监听短信发送结果的要求是一个打击，用户往往很可能拒绝发送短信。<br>  解决方案：使用安卓系统的权限管理进行权限，既能接受说明发送短信意图也能收到回调。这个时候系统在有权限申请之后，不会再默认拦截了。</p></li><li><p>隐藏显示刘海会使当前activity重建，会造成数据不正确的问题，强制让应用回到首页</p></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> force_black_v2 = <br>Settings.<span class="hljs-keyword">Global</span>.getInt(mContext.getContentResolver(), &quot;force_black_v2&quot;, <br><span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> <span class="hljs-keyword">local</span> = (<span class="hljs-type">int</span>) SharePrefUtil.<span class="hljs-keyword">get</span>(&quot;force_black_v2&quot;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (AppStatusManager.getInstance().getAppStatus() == <br>AppStatus.STATUS_RECYCLE || <span class="hljs-keyword">local</span> != force_black_v2) &#123;    SharePrefUtil.put(&quot;force_black_v2&quot;, force_black_v2);   <br>//跳到MainActivity,让MainActivity也finish掉   <br>Intent intent = <span class="hljs-built_in">new</span> Intent(this, SplashActivity.<span class="hljs-keyword">class</span>);    startActivity(intent);    <br>finish();   <br><span class="hljs-keyword">return</span>;<br><br></code></pre></td></tr></table></figure><ul><li>应用安装完成后打开应用出现初始化两次 <br>  是指在调用系统安装应用程序完成安装之后，若用户直接通过这个程序打开应用进入之后，用户按home键退出回到桌面应用程序列表，又点击该应用的icon重新进入该应用，却发现应用是重新打开，而不是继续上次离开的界面，按道理应用不应该重新初始化，后面经搜索发现这是个系统bug。 <br>  解决方案：在启动Activity onCreate方法中进行判断是否重复启动</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>   protected void <span class="hljs-built_in">onCreate</span>(Bundle savedInstanceState) &#123;<br>       <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.onCreate</span>(savedInstanceState);<br>    <br>       <span class="hljs-comment">//防止重复创建的问题，第一次安装完成启动，和home键退出点击launcher icon启动会重复</span><br>       <span class="hljs-selector-tag">if</span> (!<span class="hljs-built_in">isTaskRoot</span>()<br>               &amp;&amp; <span class="hljs-built_in">getIntent</span>().<span class="hljs-built_in">hasCategory</span>(Intent.CATEGORY_LAUNCHER)<br>               &amp;&amp; <span class="hljs-built_in">getIntent</span>().<span class="hljs-built_in">getAction</span>() != null<br>               &amp;&amp; <span class="hljs-built_in">getIntent</span>().<span class="hljs-built_in">getAction</span>().<span class="hljs-built_in">equals</span>(Intent.ACTION_MAIN)) &#123;<br>    <br>           <span class="hljs-selector-tag">finish</span>();<br>           <span class="hljs-selector-tag">return</span>;<br>       &#125;<br>       &#125;<br>    <br></code></pre></td></tr></table></figure><ul><li>静态注册广播收不到广播 <br>  在注册系统广播之后，收到广播是有条件，并不是每次都能够收到，在该品牌机型中要求：Receiver注册不能配置运行在非该应用包名下的进程中，否则收不到广播，广播只给不配置android:process的Receiver。同时要求是在当前进程应用没有退出的前提下，否则也收不到。 <br>  暂没有找到解决方案</li><li>悬浮窗适配<br>  开启悬浮窗之前，检查如果是否有悬浮窗权限,如果系统没有赋予 APP 弹出悬浮窗的权限，就先跳转到权限授权界面，等用户打开该权限之后，再去弹出悬浮窗，比如 QQ 等一些主流应用就是这么做得</li></ul><h3 id="华为机型"><a href="#华为机型" class="headerlink" title="华为机型"></a>华为机型</h3><ul><li><p>Toast不显示 （荣耀手机）<br>  也是偶然发现在荣耀8机型上后台应用的toast不会被显示出来，只能当前在前台的应用TOAST提示。 <br>  解决方案：替换toast显示，改用其他方式，如dialog或者弹出activity界面。</p></li><li><p>多网络下指定网络不成功 <br>  简单讲就是指wifi和移动网络同时开着的情况下，不能指定移动网络访问，详见接受说明移步到我的另一篇文章：<a href="http://blog.csdn.net/u010019468/article/details/72886859">http://blog.csdn.net/u010019468/article/details/72886859</a></p>  <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE"/>  </li><li><p>这个权限是普通权限，在华为6.0手机上，一旦targerSdk》23就没有权限，也不能申请。只能把targetSdk降低到23以下，目前在华为p8电信版手机发现</p></li><li><p>华为手机：因为某些机型是虚拟按键的,所以要加上以下设置防止挡住按键.        setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);</p></li><li><p>空字符串AES解密崩溃 <br>  在华为c8817d手机上出现了这个问题，虽然不怎么规范，却反应了这个问题。</p></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>5.0以上的手机，如果禁止了权限，那么toast也会被禁止，建议通过弹窗的形式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HqToastUtils.showToast(GlobalContext.getString(R.string.main_open_notification))<span class="hljs-comment">;</span><br>     if (Build.VERSION.SDK_INT &gt;<span class="hljs-operator">=</span> Build.VERSION_CODES.BASE) &#123;<br>         // 进入设置系统应用权限界面<br>         Intent intent <span class="hljs-operator">=</span> new Intent(Settings.ACTION_SETTINGS)<span class="hljs-comment">;</span><br>         mContext.startActivity(intent)<span class="hljs-comment">;</span><br>         return<span class="hljs-comment">;</span><br>     &#125; else if (Build.VERSION.SDK_INT &gt;<span class="hljs-operator">=</span> Build.VERSION_CODES.LOLLIPOP) &#123;// 运行系统在<span class="hljs-number">5</span>.x环境使用<br>         // 进入设置系统应用权限界面<br>         Intent intent <span class="hljs-operator">=</span> new Intent(Settings.ACTION_SETTINGS)<span class="hljs-comment">;</span><br>         mContext.startActivity(intent)<span class="hljs-comment">;</span><br>         return<span class="hljs-comment">;</span><br>     &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
